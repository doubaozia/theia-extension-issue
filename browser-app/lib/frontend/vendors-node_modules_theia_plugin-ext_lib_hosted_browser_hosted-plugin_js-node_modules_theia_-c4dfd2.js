(self["webpackChunkbrowser_app"] = self["webpackChunkbrowser_app"] || []).push([["vendors-node_modules_theia_plugin-ext_lib_hosted_browser_hosted-plugin_js-node_modules_theia_-c4dfd2"],{

/***/ "../node_modules/@babel/runtime/helpers/esm/extends.js":
/*!*************************************************************!*\
  !*** ../node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ "../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-contribution.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-contribution.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyContribution = exports.CallHierarchyCommands = exports.CALL_HIERARCHY_TOGGLE_COMMAND_ID = exports.CALL_HIERARCHY_LABEL = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const callhierarchy_1 = __webpack_require__(/*! ./callhierarchy */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js");
Object.defineProperty(exports, "CALL_HIERARCHY_LABEL", ({ enumerable: true, get: function () { return callhierarchy_1.CALL_HIERARCHY_LABEL; } }));
Object.defineProperty(exports, "CALL_HIERARCHY_TOGGLE_COMMAND_ID", ({ enumerable: true, get: function () { return callhierarchy_1.CALL_HIERARCHY_TOGGLE_COMMAND_ID; } }));
const callhierarchy_service_1 = __webpack_require__(/*! ./callhierarchy-service */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
var CallHierarchyCommands;
(function (CallHierarchyCommands) {
    CallHierarchyCommands.OPEN = common_1.Command.toLocalizedCommand({
        id: 'callhierarchy:open',
        label: 'Open Call Hierarchy'
    }, 'theia/callhierarchy/open');
})(CallHierarchyCommands || (exports.CallHierarchyCommands = CallHierarchyCommands = {}));
let CallHierarchyContribution = class CallHierarchyContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: callhierarchy_1.CALLHIERARCHY_ID,
            widgetName: callhierarchy_1.CALL_HIERARCHY_LABEL,
            defaultWidgetOptions: {
                area: 'bottom'
            },
            toggleCommandId: callhierarchy_1.CALL_HIERARCHY_TOGGLE_COMMAND_ID,
            toggleKeybinding: 'ctrlcmd+shift+f1'
        });
    }
    init() {
        this.editorHasCallHierarchyProvider = this.contextKeyService.createKey('editorHasCallHierarchyProvider', false);
        this.editorManager.onCurrentEditorChanged(() => this.editorHasCallHierarchyProvider.set(this.isCallHierarchyAvailable()));
        this.callHierarchyServiceProvider.onDidChange(() => this.editorHasCallHierarchyProvider.set(this.isCallHierarchyAvailable()));
    }
    isCallHierarchyAvailable() {
        const { selection, languageId } = this.editorAccess;
        return !!selection && !!languageId && !!this.callHierarchyServiceProvider.get(languageId, new uri_1.default(selection.uri));
    }
    async openView(args) {
        const widget = await super.openView(args);
        const { selection, languageId } = this.editorAccess;
        widget.initializeModel(selection, languageId);
        return widget;
    }
    registerCommands(commands) {
        commands.registerCommand(CallHierarchyCommands.OPEN, {
            execute: () => this.openView({
                toggle: false,
                activate: true
            }),
            isEnabled: this.isCallHierarchyAvailable.bind(this)
        });
        super.registerCommands(commands);
    }
    registerMenus(menus) {
        const menuPath = [...browser_2.EDITOR_CONTEXT_MENU, 'navigation'];
        menus.registerMenuAction(menuPath, {
            commandId: CallHierarchyCommands.OPEN.id,
            label: callhierarchy_1.CALL_HIERARCHY_LABEL
        });
        super.registerMenus(menus);
    }
    registerKeybindings(keybindings) {
        super.registerKeybindings(keybindings);
        keybindings.registerKeybinding({
            command: CallHierarchyCommands.OPEN.id,
            keybinding: 'ctrlcmd+f1'
        });
    }
};
exports.CallHierarchyContribution = CallHierarchyContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.CurrentEditorAccess),
    tslib_1.__metadata("design:type", browser_2.CurrentEditorAccess)
], CallHierarchyContribution.prototype, "editorAccess", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], CallHierarchyContribution.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(callhierarchy_service_1.CallHierarchyServiceProvider),
    tslib_1.__metadata("design:type", callhierarchy_service_1.CallHierarchyServiceProvider)
], CallHierarchyContribution.prototype, "callHierarchyServiceProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CallHierarchyContribution.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CallHierarchyContribution.prototype, "init", null);
exports.CallHierarchyContribution = CallHierarchyContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], CallHierarchyContribution);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-frontend-module.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-frontend-module.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const callhierarchy_contribution_1 = __webpack_require__(/*! ./callhierarchy-contribution */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-contribution.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const callhierarchy_service_1 = __webpack_require__(/*! ./callhierarchy-service */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const callhierarchy_1 = __webpack_require__(/*! ./callhierarchy */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js");
const callhierarchy_tree_1 = __webpack_require__(/*! ./callhierarchy-tree */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
__webpack_require__(/*! ../../src/browser/style/index.css */ "../node_modules/@theia/callhierarchy/src/browser/style/index.css");
exports["default"] = new inversify_1.ContainerModule(bind => {
    (0, common_1.bindContributionProvider)(bind, callhierarchy_service_1.CallHierarchyService);
    bind(callhierarchy_service_1.CallHierarchyServiceProvider).to(callhierarchy_service_1.CallHierarchyServiceProvider).inSingletonScope();
    (0, browser_1.bindViewContribution)(bind, callhierarchy_contribution_1.CallHierarchyContribution);
    bind(browser_1.WidgetFactory).toDynamicValue(context => ({
        id: callhierarchy_1.CALLHIERARCHY_ID,
        createWidget: () => (0, callhierarchy_tree_1.createHierarchyTreeWidget)(context.container)
    }));
});


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyServiceProvider = exports.CallHierarchyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const language_selector_1 = __webpack_require__(/*! @theia/editor/lib/common/language-selector */ "../node_modules/@theia/editor/lib/common/language-selector.js");
exports.CallHierarchyService = Symbol('CallHierarchyService');
let CallHierarchyServiceProvider = class CallHierarchyServiceProvider {
    constructor() {
        this.onDidChangeEmitter = new common_1.Emitter();
        this.services = [];
    }
    get onDidChange() {
        return this.onDidChangeEmitter.event;
    }
    init() {
        this.services = this.services.concat(this.contributions.getContributions());
    }
    get(languageId, uri) {
        return this.services
            .filter(service => this.score(service, languageId, uri) > 0)
            .sort((left, right) => this.score(right, languageId, uri) - this.score(left, languageId, uri))[0];
    }
    score(service, languageId, uri) {
        return (0, language_selector_1.score)(service.selector, uri.scheme, uri.path.toString(), languageId, true);
    }
    add(service) {
        this.services.push(service);
        const that = this;
        this.onDidChangeEmitter.fire();
        return {
            dispose: () => {
                that.remove(service);
            }
        };
    }
    remove(service) {
        const length = this.services.length;
        this.services = this.services.filter(value => value !== service);
        const serviceWasRemoved = length !== this.services.length;
        if (serviceWasRemoved) {
            this.onDidChangeEmitter.fire();
        }
        return serviceWasRemoved;
    }
};
exports.CallHierarchyServiceProvider = CallHierarchyServiceProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.ContributionProvider),
    (0, inversify_1.named)(exports.CallHierarchyService),
    tslib_1.__metadata("design:type", Object)
], CallHierarchyServiceProvider.prototype, "contributions", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CallHierarchyServiceProvider.prototype, "init", null);
exports.CallHierarchyServiceProvider = CallHierarchyServiceProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CallHierarchyServiceProvider);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-container.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-container.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHierarchyTreeWidget = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const callhierarchy_tree_1 = __webpack_require__(/*! ./callhierarchy-tree */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js");
const callhierarchy_tree_model_1 = __webpack_require__(/*! ./callhierarchy-tree-model */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-model.js");
const callhierarchy_tree_widget_1 = __webpack_require__(/*! ./callhierarchy-tree-widget */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-widget.js");
function createHierarchyTreeContainer(parent) {
    const child = (0, browser_1.createTreeContainer)(parent, {
        tree: callhierarchy_tree_1.CallHierarchyTree,
        model: callhierarchy_tree_model_1.CallHierarchyTreeModel,
        widget: callhierarchy_tree_widget_1.CallHierarchyTreeWidget,
    });
    return child;
}
function createHierarchyTreeWidget(parent) {
    return createHierarchyTreeContainer(parent).get(callhierarchy_tree_widget_1.CallHierarchyTreeWidget);
}
exports.createHierarchyTreeWidget = createHierarchyTreeWidget;


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-model.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-model.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyTreeModel = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const callhierarchy_tree_1 = __webpack_require__(/*! ./callhierarchy-tree */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js");
const callhierarchy_service_1 = __webpack_require__(/*! ../callhierarchy-service */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
let CallHierarchyTreeModel = class CallHierarchyTreeModel extends browser_1.TreeModelImpl {
    getTree() {
        return this.tree;
    }
    get languageId() {
        return this._languageId;
    }
    async initializeCallHierarchy(languageId, uri, position) {
        var _a;
        this.tree.root = undefined;
        this.tree.callHierarchyService = undefined;
        this._languageId = languageId;
        if (languageId && uri && position) {
            const callHierarchyService = this.callHierarchyServiceProvider.get(languageId, new uri_1.default(uri));
            if (callHierarchyService) {
                this.tree.callHierarchyService = callHierarchyService;
                const cancellationSource = new cancellation_1.CancellationTokenSource();
                const rootDefinition = await callHierarchyService.getRootDefinition(uri, position, cancellationSource.token);
                if (rootDefinition) {
                    (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.dispose();
                    this.currentSession = rootDefinition;
                    const root = {
                        id: 'call-hierarchy-tree-root',
                        parent: undefined,
                        children: [],
                        visible: false,
                    };
                    rootDefinition.items.forEach(definition => browser_1.CompositeTreeNode.addChild(root, callhierarchy_tree_1.ItemNode.create(definition, root)));
                    this.tree.root = root;
                }
            }
        }
    }
    doOpenNode(node) {
        // do nothing (in particular do not expand the node)
    }
};
exports.CallHierarchyTreeModel = CallHierarchyTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(callhierarchy_tree_1.CallHierarchyTree),
    tslib_1.__metadata("design:type", callhierarchy_tree_1.CallHierarchyTree)
], CallHierarchyTreeModel.prototype, "tree", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(callhierarchy_service_1.CallHierarchyServiceProvider),
    tslib_1.__metadata("design:type", callhierarchy_service_1.CallHierarchyServiceProvider)
], CallHierarchyTreeModel.prototype, "callHierarchyServiceProvider", void 0);
exports.CallHierarchyTreeModel = CallHierarchyTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CallHierarchyTreeModel);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-widget.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-widget.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyTreeWidget = exports.DEFINITION_ICON_CLASS = exports.DEFINITION_NODE_CLASS = exports.HIERARCHY_TREE_CLASS = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../node_modules/@theia/core/lib/browser/label-provider.js");
const callhierarchy_tree_1 = __webpack_require__(/*! ./callhierarchy-tree */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js");
const callhierarchy_tree_model_1 = __webpack_require__(/*! ./callhierarchy-tree-model */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-model.js");
const callhierarchy_1 = __webpack_require__(/*! ../callhierarchy */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
exports.HIERARCHY_TREE_CLASS = 'theia-CallHierarchyTree';
exports.DEFINITION_NODE_CLASS = 'theia-CallHierarchyTreeNode';
exports.DEFINITION_ICON_CLASS = 'theia-CallHierarchyTreeNodeIcon';
let CallHierarchyTreeWidget = class CallHierarchyTreeWidget extends browser_1.TreeWidget {
    constructor(props, model, contextMenuRenderer, labelProvider, editorManager) {
        super(props, model, contextMenuRenderer);
        this.props = props;
        this.model = model;
        this.labelProvider = labelProvider;
        this.editorManager = editorManager;
        this.id = callhierarchy_1.CALLHIERARCHY_ID;
        this.title.label = callhierarchy_1.CALL_HIERARCHY_LABEL;
        this.title.caption = callhierarchy_1.CALL_HIERARCHY_LABEL;
        this.title.iconClass = (0, browser_1.codicon)('references');
        this.title.closable = true;
        this.addClass(exports.HIERARCHY_TREE_CLASS);
        this.toDispose.push(this.model.onSelectionChanged(selection => {
            const node = selection[0];
            if (node) {
                this.openEditor(node, true);
            }
        }));
        this.toDispose.push(this.model.onOpenNode((node) => {
            this.openEditor(node, false);
        }));
        this.toDispose.push(this.labelProvider.onDidChange(() => this.update()));
    }
    initializeModel(selection, languageId) {
        this.model.initializeCallHierarchy(languageId, selection ? selection.uri : undefined, selection ? selection.range.start : undefined);
    }
    createNodeClassNames(node, props) {
        const classNames = super.createNodeClassNames(node, props);
        if (callhierarchy_tree_1.ItemNode.is(node)) {
            classNames.push(exports.DEFINITION_NODE_CLASS);
        }
        return classNames;
    }
    createNodeAttributes(node, props) {
        const elementAttrs = super.createNodeAttributes(node, props);
        return {
            ...elementAttrs,
        };
    }
    renderTree(model) {
        return super.renderTree(model)
            || React.createElement("div", { className: 'theia-widget-noInfo' }, nls_1.nls.localize('theia/callhierarchy/noCallers', 'No callers have been detected.'));
    }
    renderCaption(node, props) {
        if (callhierarchy_tree_1.ItemNode.is(node)) {
            return this.decorateDefinitionCaption(node.definition);
        }
        if (callhierarchy_tree_1.CallerNode.is(node)) {
            return this.decorateCallerCaption(node.caller);
        }
        return 'caption';
    }
    decorateDefinitionCaption(definition) {
        var _a;
        const symbol = definition.name;
        const location = this.labelProvider.getName(uri_1.default.fromComponents(definition.uri));
        const container = location;
        const isDeprecated = (_a = definition.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_protocol_1.SymbolTag.Deprecated);
        const classNames = ['definitionNode'];
        if (isDeprecated) {
            classNames.push('deprecatedDefinition');
        }
        return React.createElement("div", { className: classNames.join(' ') },
            React.createElement("div", { className: 'symbol-icon-center codicon codicon-symbol-' + this.toIconClass(definition.kind) }),
            React.createElement("div", { className: 'definitionNode-content' },
                React.createElement("span", { className: 'symbol' }, symbol),
                React.createElement("span", { className: 'container' }, container)));
    }
    decorateCallerCaption(caller) {
        var _a;
        const definition = caller.from;
        const symbol = definition.name;
        const referenceCount = caller.fromRanges.length;
        const location = this.labelProvider.getName(uri_1.default.fromComponents(definition.uri));
        const container = location;
        const isDeprecated = (_a = definition.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_protocol_1.SymbolTag.Deprecated);
        const classNames = ['definitionNode'];
        if (isDeprecated) {
            classNames.push('deprecatedDefinition');
        }
        return React.createElement("div", { className: classNames.join(' ') },
            React.createElement("div", { className: 'symbol-icon-center codicon codicon-symbol-' + this.toIconClass(definition.kind) }),
            React.createElement("div", { className: 'definitionNode-content' },
                React.createElement("span", { className: 'symbol' }, symbol),
                React.createElement("span", { className: 'referenceCount' }, (referenceCount > 1) ? `[${referenceCount}]` : ''),
                React.createElement("span", { className: 'container' }, container)));
    }
    // tslint:disable-next-line:typedef
    toIconClass(symbolKind) {
        switch (symbolKind) {
            case vscode_languageserver_protocol_1.SymbolKind.File: return 'file';
            case vscode_languageserver_protocol_1.SymbolKind.Module: return 'module';
            case vscode_languageserver_protocol_1.SymbolKind.Namespace: return 'namespace';
            case vscode_languageserver_protocol_1.SymbolKind.Package: return 'package';
            case vscode_languageserver_protocol_1.SymbolKind.Class: return 'class';
            case vscode_languageserver_protocol_1.SymbolKind.Method: return 'method';
            case vscode_languageserver_protocol_1.SymbolKind.Property: return 'property';
            case vscode_languageserver_protocol_1.SymbolKind.Field: return 'field';
            case vscode_languageserver_protocol_1.SymbolKind.Constructor: return 'constructor';
            case vscode_languageserver_protocol_1.SymbolKind.Enum: return 'enum';
            case vscode_languageserver_protocol_1.SymbolKind.Interface: return 'interface';
            case vscode_languageserver_protocol_1.SymbolKind.Function: return 'function';
            case vscode_languageserver_protocol_1.SymbolKind.Variable: return 'variable';
            case vscode_languageserver_protocol_1.SymbolKind.Constant: return 'constant';
            case vscode_languageserver_protocol_1.SymbolKind.String: return 'string';
            case vscode_languageserver_protocol_1.SymbolKind.Number: return 'number';
            case vscode_languageserver_protocol_1.SymbolKind.Boolean: return 'boolean';
            case vscode_languageserver_protocol_1.SymbolKind.Array: return 'array';
            default: return 'unknown';
        }
    }
    openEditor(node, keepFocus) {
        if (callhierarchy_tree_1.ItemNode.is(node)) {
            const def = node.definition;
            this.doOpenEditor(uri_1.default.fromComponents(def.uri).toString(), def.selectionRange ? def.selectionRange : def.range, keepFocus);
        }
        if (callhierarchy_tree_1.CallerNode.is(node)) {
            this.doOpenEditor(uri_1.default.fromComponents(node.caller.from.uri).toString(), node.caller.fromRanges[0], keepFocus);
        }
    }
    doOpenEditor(uri, range, keepFocus) {
        this.editorManager.open(new uri_1.default(uri), {
            mode: keepFocus ? 'reveal' : 'activate',
            selection: range
        }).then(editorWidget => {
            if (editorWidget.parent instanceof browser_1.DockPanel) {
                editorWidget.parent.selectWidget(editorWidget);
            }
        });
    }
    storeState() {
        const callHierarchyService = this.model.getTree().callHierarchyService;
        if (this.model.root && callHierarchyService) {
            return {
                root: this.deflateForStorage(this.model.root),
                languageId: this.model.languageId,
            };
        }
        else {
            return {};
        }
    }
    restoreState(oldState) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (oldState.root && oldState.languageId) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const root = this.inflateFromStorage(oldState.root);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.model.initializeCallHierarchy(oldState.languageId, uri_1.default.fromComponents(root.definition.uri).toString(), root.definition.range.start);
        }
    }
};
exports.CallHierarchyTreeWidget = CallHierarchyTreeWidget;
exports.CallHierarchyTreeWidget = CallHierarchyTreeWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(callhierarchy_tree_model_1.CallHierarchyTreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__param(3, (0, inversify_1.inject)(label_provider_1.LabelProvider)),
    tslib_1.__param(4, (0, inversify_1.inject)(browser_2.EditorManager)),
    tslib_1.__metadata("design:paramtypes", [Object, callhierarchy_tree_model_1.CallHierarchyTreeModel,
        browser_1.ContextMenuRenderer,
        label_provider_1.LabelProvider,
        browser_2.EditorManager])
], CallHierarchyTreeWidget);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallerNode = exports.ItemNode = exports.CallHierarchyTree = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const ts_md5_1 = __webpack_require__(/*! ts-md5 */ "../node_modules/ts-md5/dist/esm/index.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
let CallHierarchyTree = class CallHierarchyTree extends browser_1.TreeImpl {
    set callHierarchyService(callHierarchyService) {
        this._callHierarchyService = callHierarchyService;
    }
    get callHierarchyService() {
        return this._callHierarchyService;
    }
    async resolveChildren(parent) {
        if (!this.callHierarchyService) {
            return Promise.resolve([]);
        }
        if (parent.children.length > 0) {
            return Promise.resolve([...parent.children]);
        }
        let definition;
        if (ItemNode.is(parent)) {
            definition = parent.definition;
        }
        else if (CallerNode.is(parent)) {
            definition = parent.caller.from;
        }
        if (definition) {
            const cancellationSource = new cancellation_1.CancellationTokenSource();
            const callers = await this.callHierarchyService.getCallers(definition, cancellationSource.token);
            if (!callers) {
                return Promise.resolve([]);
            }
            return this.toNodes(callers, parent);
        }
        return Promise.resolve([]);
    }
    toNodes(callers, parent) {
        return callers.map(caller => this.toNode(caller, parent));
    }
    toNode(caller, parent) {
        return CallerNode.create(caller, parent);
    }
};
exports.CallHierarchyTree = CallHierarchyTree;
exports.CallHierarchyTree = CallHierarchyTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CallHierarchyTree);
var ItemNode;
(function (ItemNode) {
    function is(node) {
        return !!node && 'definition' in node;
    }
    ItemNode.is = is;
    function create(definition, parent) {
        const name = definition.name;
        const id = createId(definition, parent);
        return {
            id, definition, name, parent,
            visible: true,
            children: [],
            expanded: false,
            selected: false,
        };
    }
    ItemNode.create = create;
})(ItemNode || (exports.ItemNode = ItemNode = {}));
var CallerNode;
(function (CallerNode) {
    function is(node) {
        return !!node && 'caller' in node;
    }
    CallerNode.is = is;
    function create(caller, parent) {
        const callerDefinition = caller.from;
        const name = callerDefinition.name;
        const id = createId(callerDefinition, parent);
        return {
            id, caller, name, parent,
            visible: true,
            children: [],
            expanded: false,
            selected: false,
        };
    }
    CallerNode.create = create;
})(CallerNode || (exports.CallerNode = CallerNode = {}));
function createId(definition, parent) {
    const idPrefix = (parent) ? parent.id + '/' : '';
    const id = idPrefix + ts_md5_1.Md5.hashStr(JSON.stringify(definition));
    return id;
}


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/index.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-tree */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-tree-model */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-model.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-tree-widget */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-widget.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-tree-container */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-tree/callhierarchy-tree-container.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CALL_HIERARCHY_LABEL = exports.CALL_HIERARCHY_TOGGLE_COMMAND_ID = exports.CALLHIERARCHY_ID = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
exports.CALLHIERARCHY_ID = 'callhierarchy';
exports.CALL_HIERARCHY_TOGGLE_COMMAND_ID = 'callhierarchy:toggle';
exports.CALL_HIERARCHY_LABEL = core_1.nls.localizeByDefault('Call Hierarchy');


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/lib/browser/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/lib/browser/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-contribution */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-frontend-module */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-frontend-module.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-service */ "../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/callhierarchy/src/browser/style/index.css":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/callhierarchy/src/browser/style/index.css ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./index.css */ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/callhierarchy/src/browser/style/index.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/ansi-console-item.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/ansi-console-item.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiConsoleItem = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const DOMPurify = __webpack_require__(/*! @theia/core/shared/dompurify */ "../node_modules/@theia/core/shared/dompurify/index.js");
const Anser = __webpack_require__(/*! anser */ "../node_modules/anser/lib/index.js");
class AnsiConsoleItem {
    constructor(content, severity) {
        this.content = content;
        this.severity = severity;
        this.htmlContent = new Anser().ansiToHtml(this.content, {
            use_classes: true,
            remove_empty: true
        });
    }
    get visible() {
        return !!this.htmlContent;
    }
    render() {
        return React.createElement("div", { className: 'theia-console-ansi-console-item', dangerouslySetInnerHTML: { __html: DOMPurify.sanitize(this.htmlContent) } });
    }
}
exports.AnsiConsoleItem = AnsiConsoleItem;


/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/console-content-widget.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/console-content-widget.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ConsoleContentWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleContentWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const console_session_1 = __webpack_require__(/*! ./console-session */ "../node_modules/@theia/console/lib/browser/console-session.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
let ConsoleContentWidget = ConsoleContentWidget_1 = class ConsoleContentWidget extends source_tree_1.SourceTreeWidget {
    static createContainer(parent, props) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: ConsoleContentWidget_1.CONTEXT_MENU,
            viewProps: {
                followOutput: true
            },
            ...props
        });
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(ConsoleContentWidget_1).toSelf();
        return child;
    }
    createTreeElementNodeClassNames(node) {
        const classNames = super.createTreeElementNodeClassNames(node);
        if (node.element) {
            const className = this.toClassName(node.element);
            if (className) {
                classNames.push(className);
            }
        }
        return classNames;
    }
    toClassName(item) {
        if (item.severity === severity_1.Severity.Error) {
            return console_session_1.ConsoleItem.errorClassName;
        }
        if (item.severity === severity_1.Severity.Warning) {
            return console_session_1.ConsoleItem.warningClassName;
        }
        if (item.severity === severity_1.Severity.Info) {
            return console_session_1.ConsoleItem.infoClassName;
        }
        if (item.severity === severity_1.Severity.Log) {
            return console_session_1.ConsoleItem.logClassName;
        }
        return undefined;
    }
};
exports.ConsoleContentWidget = ConsoleContentWidget;
ConsoleContentWidget.CONTEXT_MENU = ['console-context-menu'];
exports.ConsoleContentWidget = ConsoleContentWidget = ConsoleContentWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ConsoleContentWidget);


/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/console-history.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/console-history.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ConsoleHistory_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleHistory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let ConsoleHistory = ConsoleHistory_1 = class ConsoleHistory {
    constructor() {
        this.values = [];
        this.index = -1;
    }
    push(value) {
        this.delete(value);
        this.values.push(value);
        this.trim();
        this.index = this.values.length;
    }
    delete(value) {
        const index = this.values.indexOf(value);
        if (index !== -1) {
            this.values.splice(index, 1);
        }
    }
    trim() {
        const index = this.values.length - ConsoleHistory_1.limit;
        if (index > 0) {
            this.values = this.values.slice(index);
        }
    }
    get current() {
        return this.values[this.index];
    }
    get previous() {
        this.index = Math.max(this.index - 1, -1);
        return this.current;
    }
    get next() {
        this.index = Math.min(this.index + 1, this.values.length);
        return this.current;
    }
    store() {
        const { values, index } = this;
        return { values, index };
    }
    restore(object) {
        this.values = object.values;
        this.index = object.index;
    }
};
exports.ConsoleHistory = ConsoleHistory;
ConsoleHistory.limit = 50;
exports.ConsoleHistory = ConsoleHistory = ConsoleHistory_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ConsoleHistory);


/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/console-session-manager.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/console-session-manager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleSessionManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
let ConsoleSessionManager = class ConsoleSessionManager {
    constructor() {
        this.sessions = new Map();
        this.sessionAddedEmitter = new core_1.Emitter();
        this.sessionDeletedEmitter = new core_1.Emitter();
        this.sessionWasShownEmitter = new core_1.Emitter();
        this.sessionWasHiddenEmitter = new core_1.Emitter();
        this.selectedSessionChangedEmitter = new core_1.Emitter();
        this.severityChangedEmitter = new core_1.Emitter();
        this.toDispose = new core_1.DisposableCollection();
        this.toDisposeOnSessionDeletion = new Map();
    }
    get onDidAddSession() {
        return this.sessionAddedEmitter.event;
    }
    get onDidDeleteSession() {
        return this.sessionDeletedEmitter.event;
    }
    get onDidShowSession() {
        return this.sessionWasShownEmitter.event;
    }
    get onDidHideSession() {
        return this.sessionWasHiddenEmitter.event;
    }
    get onDidChangeSelectedSession() {
        return this.selectedSessionChangedEmitter.event;
    }
    get onDidChangeSeverity() {
        return this.severityChangedEmitter.event;
    }
    dispose() {
        this.toDispose.dispose();
    }
    get severity() {
        return this._severity;
    }
    set severity(value) {
        value = value || severity_1.Severity.Ignore;
        this._severity = value;
        for (const session of this.sessions.values()) {
            session.severity = value;
        }
        this.severityChangedEmitter.fire(undefined);
    }
    get all() {
        return Array.from(this.sessions.values());
    }
    get selectedSession() {
        return this._selectedSession;
    }
    set selectedSession(session) {
        const oldSession = this.selectedSession;
        this._selectedSession = session;
        this.selectedSessionChangedEmitter.fire(session);
        if (oldSession !== session) {
            if (oldSession) {
                this.sessionWasHiddenEmitter.fire(oldSession);
            }
            if (session) {
                this.sessionWasShownEmitter.fire(session);
            }
        }
    }
    get(id) {
        return this.sessions.get(id);
    }
    add(session) {
        this.sessions.set(session.id, session);
        this.sessionAddedEmitter.fire(session);
        if (this.sessions.size === 1) {
            this.selectedSession = session;
        }
    }
    delete(id) {
        const session = this.sessions.get(id);
        if (this.sessions.delete(id) && session) {
            if (this.selectedSession === session) {
                // select a new sessions or undefined if none are left
                this.selectedSession = this.sessions.values().next().value;
            }
            session.dispose();
            this.sessionDeletedEmitter.fire(session);
        }
    }
};
exports.ConsoleSessionManager = ConsoleSessionManager;
exports.ConsoleSessionManager = ConsoleSessionManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ConsoleSessionManager);


/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/console-session.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/console-session.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleSession = exports.ConsoleItem = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
var ConsoleItem;
(function (ConsoleItem) {
    ConsoleItem.errorClassName = 'theia-console-error';
    ConsoleItem.warningClassName = 'theia-console-warning';
    ConsoleItem.infoClassName = 'theia-console-info';
    ConsoleItem.logClassName = 'theia-console-log';
})(ConsoleItem || (exports.ConsoleItem = ConsoleItem = {}));
let ConsoleSession = class ConsoleSession extends source_tree_1.TreeSource {
    constructor() {
        super(...arguments);
        this.selectionEmitter = new event_1.Emitter();
        this.onSelectionChange = this.selectionEmitter.event;
    }
    get severity() {
        return this.selectedSeverity;
    }
    set severity(severity) {
        if (severity === this.selectedSeverity) {
            return;
        }
        this.selectedSeverity = severity;
        this.selectionEmitter.fire(undefined);
        this.fireDidChange();
    }
};
exports.ConsoleSession = ConsoleSession;
exports.ConsoleSession = ConsoleSession = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ConsoleSession);


/***/ }),

/***/ "../node_modules/@theia/console/lib/browser/console-widget.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/console/lib/browser/console-widget.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ConsoleWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleWidget = exports.ConsoleOptions = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const domutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/domutils */ "../node_modules/@theia/core/shared/@phosphor/domutils/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const console_history_1 = __webpack_require__(/*! ./console-history */ "../node_modules/@theia/console/lib/browser/console-history.js");
const console_content_widget_1 = __webpack_require__(/*! ./console-content-widget */ "../node_modules/@theia/console/lib/browser/console-content-widget.js");
const console_session_manager_1 = __webpack_require__(/*! ./console-session-manager */ "../node_modules/@theia/console/lib/browser/console-session-manager.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-service */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-service.js");
exports.ConsoleOptions = Symbol('ConsoleWidgetOptions');
let ConsoleWidget = ConsoleWidget_1 = class ConsoleWidget extends browser_1.BaseWidget {
    static createContainer(parent, options) {
        const child = console_content_widget_1.ConsoleContentWidget.createContainer(parent);
        child.bind(console_history_1.ConsoleHistory).toSelf();
        child.bind(exports.ConsoleOptions).toConstantValue(options);
        child.bind(ConsoleWidget_1).toSelf();
        return child;
    }
    constructor() {
        super();
        this.modelChangeListener = disposable_1.Disposable.NULL;
        this.totalHeight = -1;
        this.totalWidth = -1;
        this.node.classList.add(ConsoleWidget_1.styles.node);
    }
    init() {
        this.doInit();
    }
    async doInit() {
        const { id, title, inputFocusContextKey } = this.options;
        const { label, iconClass, caption } = Object.assign({}, title);
        this.id = id;
        this.title.closable = true;
        this.title.label = label || id;
        if (iconClass) {
            this.title.iconClass = iconClass;
        }
        this.title.caption = caption || label || id;
        const layout = this.layout = new browser_1.PanelLayout();
        this.content.node.classList.add(ConsoleWidget_1.styles.content);
        this.toDispose.push(this.content);
        layout.addWidget(this.content);
        const inputWidget = new browser_1.Widget();
        inputWidget.node.classList.add(ConsoleWidget_1.styles.input);
        layout.addWidget(inputWidget);
        const input = this._input = await this.createInput(inputWidget.node);
        this.toDispose.push(input);
        this.toDispose.push(input.getControl().onDidLayoutChange(() => this.resizeContent()));
        this.toDispose.push(input.getControl().onDidChangeConfiguration(event => {
            if (event.hasChanged(monaco.editor.EditorOption.fontInfo)) {
                this.updateFont();
            }
        }));
        this.session = this.sessionManager.selectedSession;
        this.toDispose.push(this.sessionManager.onDidChangeSelectedSession(session => {
            // Do not clear the session output when `undefined`.
            if (session) {
                this.session = session;
            }
        }));
        this.updateFont();
        if (inputFocusContextKey) {
            this.toDispose.push(input.onFocusChanged(() => inputFocusContextKey.set(this.hasInputFocus())));
            this.toDispose.push(input.onCursorPositionChanged(() => input.getControl().createContextKey('consoleNavigationBackEnabled', this.consoleNavigationBackEnabled)));
            this.toDispose.push(input.onCursorPositionChanged(() => input.getControl().createContextKey('consoleNavigationForwardEnabled', this.consoleNavigationForwardEnabled)));
        }
        input.getControl().createContextKey('consoleInputFocus', true);
        const contentContext = this.contextKeyService.createScoped(this.content.node);
        contentContext.setContext('consoleContentFocus', true);
        this.toDispose.pushAll([
            this.editorManager.onActiveEditorChanged(() => this.setMode()),
            this.onDidChangeVisibility(() => this.setMode())
        ]);
    }
    createInput(node) {
        return this.editorProvider.createInline(this.options.input.uri, node, this.options.input.options);
    }
    updateFont() {
        const { fontFamily, fontSize, lineHeight } = this._input.getControl().getOption(monaco.editor.EditorOption.fontInfo);
        this.content.node.style.fontFamily = fontFamily;
        this.content.node.style.fontSize = fontSize + 'px';
        this.content.node.style.lineHeight = lineHeight + 'px';
    }
    set session(session) {
        if (this._session === session) {
            return;
        }
        this._session = session;
        this.content.source = session;
    }
    get session() {
        return this._session;
    }
    get input() {
        return this._input;
    }
    get consoleNavigationBackEnabled() {
        const editor = this.input.getControl();
        return !!editor.getPosition().equals({ lineNumber: 1, column: 1 });
    }
    get consoleNavigationForwardEnabled() {
        const editor = this.input.getControl();
        const model = editor.getModel();
        if (!model) {
            return false;
        }
        const lineNumber = editor.getModel().getLineCount();
        const column = editor.getModel().getLineMaxColumn(lineNumber);
        return !!editor.getPosition().equals({ lineNumber, column });
    }
    selectAll() {
        const selection = document.getSelection();
        if (selection) {
            selection.selectAllChildren(this.content.node);
        }
    }
    collapseAll() {
        const { root } = this.content.model;
        if (browser_1.CompositeTreeNode.is(root)) {
            this.content.model.collapseAll(root);
        }
    }
    clear() {
        if (this.session) {
            this.session.clear();
        }
    }
    async execute() {
        const value = this._input.getControl().getValue();
        this._input.getControl().setValue('');
        this.history.push(value);
        if (this.session) {
            const listener = this.content.model.onNodeRefreshed(() => {
                listener.dispose();
                this.revealLastOutput();
            });
            await this.session.execute(value);
        }
    }
    navigateBack() {
        const value = this.history.previous;
        if (value === undefined) {
            return;
        }
        const editor = this.input.getControl();
        editor.setValue(value);
        editor.setPosition({
            lineNumber: 1,
            column: 1
        });
    }
    navigateForward() {
        const value = this.history.next || '';
        const editor = this.input.getControl();
        editor.setValue(value);
        const lineNumber = editor.getModel().getLineCount();
        const column = editor.getModel().getLineMaxColumn(lineNumber);
        editor.setPosition({ lineNumber, column });
    }
    revealLastOutput() {
        const { root } = this.content.model;
        if (source_tree_1.TreeSourceNode.is(root)) {
            this.content.model.selectNode(root.children[root.children.length - 1]);
        }
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this._input.focus();
    }
    onResize(msg) {
        super.onResize(msg);
        this.totalWidth = msg.width;
        this.totalHeight = msg.height;
        this._input.resizeToFit();
        this.resizeContent();
    }
    resizeContent() {
        this.totalHeight = this.totalHeight < 0 ? this.computeHeight() : this.totalHeight;
        const inputHeight = this._input.getControl().getLayoutInfo().height;
        const contentHeight = this.totalHeight - inputHeight;
        this.content.node.style.height = `${contentHeight}px`;
        browser_1.MessageLoop.sendMessage(this.content, new browser_1.Widget.ResizeMessage(this.totalWidth, contentHeight));
    }
    computeHeight() {
        const { verticalSum } = domutils_1.ElementExt.boxSizing(this.node);
        return this.node.offsetHeight - verticalSum;
    }
    storeState() {
        const history = this.history.store();
        const input = this.input.storeViewState();
        return {
            history,
            input
        };
    }
    restoreState(oldState) {
        if ('history' in oldState) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.history.restore(oldState['history']);
        }
        this.input.getControl().setValue(this.history.current || '');
        if ('input' in oldState) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.input.restoreViewState(oldState['input']);
        }
    }
    hasInputFocus() {
        return this._input && this._input.isFocused({ strict: true });
    }
    dispose() {
        super.dispose();
        this.modelChangeListener.dispose();
    }
    // To set the active language for the console input text model.
    // https://github.com/microsoft/vscode/blob/2af422737386e792c3fcde7884f9bf47a1aff2f5/src/vs/workbench/contrib/debug/browser/repl.ts#L371-L384
    setMode() {
        if (this.isHidden) {
            return;
        }
        const activeEditorControl = this.editorService.getActiveCodeEditor();
        if (activeEditorControl) {
            this.modelChangeListener.dispose();
            this.modelChangeListener = activeEditorControl.onDidChangeModelLanguage(() => this.setMode());
            const consoleModel = this._input.getControl().getModel();
            const activeEditorModel = activeEditorControl.getModel();
            if (consoleModel && activeEditorModel) {
                monaco.editor.setModelLanguage(consoleModel, activeEditorModel.getLanguageId());
            }
        }
    }
};
exports.ConsoleWidget = ConsoleWidget;
ConsoleWidget.styles = {
    node: 'theia-console-widget',
    content: 'theia-console-content',
    input: 'theia-console-input',
};
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.ConsoleOptions),
    tslib_1.__metadata("design:type", Object)
], ConsoleWidget.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(console_content_widget_1.ConsoleContentWidget),
    tslib_1.__metadata("design:type", console_content_widget_1.ConsoleContentWidget)
], ConsoleWidget.prototype, "content", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(console_history_1.ConsoleHistory),
    tslib_1.__metadata("design:type", console_history_1.ConsoleHistory)
], ConsoleWidget.prototype, "history", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(console_session_manager_1.ConsoleSessionManager),
    tslib_1.__metadata("design:type", console_session_manager_1.ConsoleSessionManager)
], ConsoleWidget.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider),
    tslib_1.__metadata("design:type", monaco_editor_provider_1.MonacoEditorProvider)
], ConsoleWidget.prototype, "editorProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ConsoleWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_service_1.MonacoEditorService),
    tslib_1.__metadata("design:type", monaco_editor_service_1.MonacoEditorService)
], ConsoleWidget.prototype, "editorService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], ConsoleWidget.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ConsoleWidget.prototype, "init", null);
exports.ConsoleWidget = ConsoleWidget = ConsoleWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ConsoleWidget);


/***/ }),

/***/ "../node_modules/@theia/core/lib/browser/source-tree/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/core/lib/browser/source-tree/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./tree-source */ "../node_modules/@theia/core/lib/browser/source-tree/tree-source.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/source-tree.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./source-tree-widget */ "../node_modules/@theia/core/lib/browser/source-tree/source-tree-widget.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/core/lib/browser/source-tree/source-tree-widget.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/core/lib/browser/source-tree/source-tree-widget.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var SourceTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceTreeWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! react */ "../node_modules/react/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../node_modules/inversify/lib/cjs/index.js");
const disposable_1 = __webpack_require__(/*! ../../common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const tree_1 = __webpack_require__(/*! ../tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const source_tree_1 = __webpack_require__(/*! ./source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/source-tree.js");
let SourceTreeWidget = SourceTreeWidget_1 = class SourceTreeWidget extends tree_1.TreeWidget {
    constructor() {
        super(...arguments);
        this.toDisposeOnSource = new disposable_1.DisposableCollection();
    }
    static createContainer(parent, props) {
        const child = (0, tree_1.createTreeContainer)(parent, {
            props,
            tree: source_tree_1.SourceTree,
            widget: SourceTreeWidget_1,
        });
        return child;
    }
    init() {
        super.init();
        this.addClass('theia-source-tree');
        this.toDispose.push(this.model.onOpenNode(node => {
            if (source_tree_1.TreeElementNode.is(node) && node.element.open) {
                node.element.open();
            }
        }));
    }
    get source() {
        const root = this.model.root;
        return source_tree_1.TreeSourceNode.is(root) ? root.source : undefined;
    }
    set source(source) {
        if (this.source === source) {
            return;
        }
        this.toDisposeOnSource.dispose();
        this.toDispose.push(this.toDisposeOnSource);
        this.model.root = source_tree_1.TreeSourceNode.to(source);
        if (source) {
            this.toDisposeOnSource.push(source.onDidChange(() => this.model.refresh()));
        }
    }
    get selectedElement() {
        const node = this.model.selectedNodes[0];
        return source_tree_1.TreeElementNode.is(node) && node.element || undefined;
    }
    renderTree(model) {
        if (source_tree_1.TreeSourceNode.is(model.root) && model.root.children.length === 0) {
            const { placeholder } = model.root.source;
            if (placeholder) {
                return React.createElement("div", { className: 'theia-tree-source-node-placeholder noselect' }, placeholder);
            }
        }
        return super.renderTree(model);
    }
    renderCaption(node) {
        if (source_tree_1.TreeElementNode.is(node)) {
            const classNames = this.createTreeElementNodeClassNames(node);
            return React.createElement("div", { className: classNames.join(' ') }, node.element.render(this));
        }
        return undefined;
    }
    createTreeElementNodeClassNames(node) {
        return [tree_1.TREE_NODE_SEGMENT_GROW_CLASS];
    }
    storeState() {
        // no-op
        return {};
    }
    superStoreState() {
        return super.storeState();
    }
    restoreState(state) {
        // no-op
    }
    superRestoreState(state) {
        super.restoreState(state);
        return;
    }
};
exports.SourceTreeWidget = SourceTreeWidget;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SourceTreeWidget.prototype, "init", null);
exports.SourceTreeWidget = SourceTreeWidget = SourceTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SourceTreeWidget);


/***/ }),

/***/ "../node_modules/@theia/core/lib/browser/source-tree/source-tree.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/core/lib/browser/source-tree/source-tree.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeSourceNode = exports.CompositeTreeElementNode = exports.TreeElementNode = exports.SourceTree = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! inversify */ "../node_modules/inversify/lib/cjs/index.js");
const tree_1 = __webpack_require__(/*! ../tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const tree_source_1 = __webpack_require__(/*! ./tree-source */ "../node_modules/@theia/core/lib/browser/source-tree/tree-source.js");
let SourceTree = class SourceTree extends tree_1.TreeImpl {
    async resolveChildren(parent) {
        const elements = await this.resolveElements(parent);
        const nodes = [];
        let index = 0;
        for (const element of elements) {
            if (element.visible !== false) {
                nodes.push(this.toNode(element, index++, parent));
            }
        }
        return nodes;
    }
    resolveElements(parent) {
        if (TreeSourceNode.is(parent)) {
            return parent.source.getElements();
        }
        return parent.element.getElements();
    }
    toNode(element, index, parent) {
        const id = element.id ? String(element.id) : (parent.id + ':' + index);
        const name = id;
        const existing = this.getNode(id);
        const updated = existing && Object.assign(existing, { element, parent });
        if (tree_source_1.CompositeTreeElement.hasElements(element)) {
            if (updated) {
                if (!tree_1.ExpandableTreeNode.is(updated)) {
                    Object.assign(updated, { expanded: false });
                }
                if (!tree_1.CompositeTreeNode.is(updated)) {
                    Object.assign(updated, { children: [] });
                }
                return updated;
            }
            return {
                element,
                parent,
                id,
                name,
                selected: false,
                expanded: false,
                children: []
            };
        }
        if (CompositeTreeElementNode.is(updated)) {
            delete updated.expanded;
            delete updated.children;
        }
        if (updated) {
            if (tree_1.ExpandableTreeNode.is(updated)) {
                delete updated.expanded;
            }
            if (tree_1.CompositeTreeNode.is(updated)) {
                delete updated.children;
            }
            return updated;
        }
        return {
            element,
            parent,
            id,
            name,
            selected: false
        };
    }
};
exports.SourceTree = SourceTree;
exports.SourceTree = SourceTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SourceTree);
var TreeElementNode;
(function (TreeElementNode) {
    function is(node) {
        return tree_1.SelectableTreeNode.is(node) && 'element' in node;
    }
    TreeElementNode.is = is;
})(TreeElementNode || (exports.TreeElementNode = TreeElementNode = {}));
var CompositeTreeElementNode;
(function (CompositeTreeElementNode) {
    function is(node) {
        return TreeElementNode.is(node) && tree_1.CompositeTreeNode.is(node) && tree_1.ExpandableTreeNode.is(node) && !!node.visible;
    }
    CompositeTreeElementNode.is = is;
})(CompositeTreeElementNode || (exports.CompositeTreeElementNode = CompositeTreeElementNode = {}));
var TreeSourceNode;
(function (TreeSourceNode) {
    function is(node) {
        return tree_1.CompositeTreeNode.is(node) && !node.visible && 'source' in node;
    }
    TreeSourceNode.is = is;
    function to(source) {
        if (!source) {
            return source;
        }
        const id = source.id || '__source__';
        return {
            id,
            name: id,
            visible: false,
            children: [],
            source,
            parent: undefined,
            selected: false
        };
    }
    TreeSourceNode.to = to;
})(TreeSourceNode || (exports.TreeSourceNode = TreeSourceNode = {}));


/***/ }),

/***/ "../node_modules/@theia/core/lib/browser/source-tree/tree-source.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/core/lib/browser/source-tree/tree-source.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeSource = exports.CompositeTreeElement = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! inversify */ "../node_modules/inversify/lib/cjs/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/core/lib/common/index.js");
var CompositeTreeElement;
(function (CompositeTreeElement) {
    function is(element) {
        return (0, common_1.isObject)(element) && 'getElements' in element;
    }
    CompositeTreeElement.is = is;
    function hasElements(element) {
        return is(element) && element.hasElements !== false;
    }
    CompositeTreeElement.hasElements = hasElements;
})(CompositeTreeElement || (exports.CompositeTreeElement = CompositeTreeElement = {}));
let TreeSource = class TreeSource {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    constructor(options = {}) {
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter);
        this.id = options.id;
        this.placeholder = options.placeholder;
    }
    dispose() {
        this.toDispose.dispose();
    }
};
exports.TreeSource = TreeSource;
exports.TreeSource = TreeSource = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.unmanaged)()),
    tslib_1.__metadata("design:paramtypes", [Object])
], TreeSource);


/***/ }),

/***/ "../node_modules/@theia/core/lib/browser/widgets/alert-message.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/core/lib/browser/widgets/alert-message.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlertMessage = void 0;
const React = __webpack_require__(/*! react */ "../node_modules/react/index.js");
const widget_1 = __webpack_require__(/*! ./widget */ "../node_modules/@theia/core/lib/browser/widgets/widget.js");
const AlertMessageIcon = {
    INFO: (0, widget_1.codicon)('info'),
    SUCCESS: (0, widget_1.codicon)('pass'),
    WARNING: (0, widget_1.codicon)('warning'),
    ERROR: (0, widget_1.codicon)('error')
};
class AlertMessage extends React.Component {
    render() {
        return React.createElement("div", { className: 'theia-alert-message-container' },
            React.createElement("div", { className: `theia-${this.props.type.toLowerCase()}-alert` },
                React.createElement("div", { className: 'theia-message-header' },
                    React.createElement("i", { className: AlertMessageIcon[this.props.type] }),
                    "\u00A0",
                    this.props.header),
                React.createElement("div", { className: 'theia-message-content' }, this.props.children)));
    }
}
exports.AlertMessage = AlertMessage;


/***/ }),

/***/ "../node_modules/@theia/core/shared/@theia/request/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/core/shared/@theia/request/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! @theia/request */ "../node_modules/@theia/request/lib/index.js");


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var BreakpointManager_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BreakpointManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const deepEqual = __webpack_require__(/*! fast-deep-equal */ "../node_modules/fast-deep-equal/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const marker_manager_1 = __webpack_require__(/*! @theia/markers/lib/browser/marker-manager */ "../node_modules/@theia/markers/lib/browser/marker-manager.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const breakpoint_marker_1 = __webpack_require__(/*! ./breakpoint-marker */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js");
let BreakpointManager = BreakpointManager_1 = class BreakpointManager extends marker_manager_1.MarkerManager {
    constructor() {
        super(...arguments);
        this.owner = 'breakpoint';
        this.onDidChangeBreakpointsEmitter = new common_1.Emitter();
        this.onDidChangeBreakpoints = this.onDidChangeBreakpointsEmitter.event;
        this.onDidChangeFunctionBreakpointsEmitter = new common_1.Emitter();
        this.onDidChangeFunctionBreakpoints = this.onDidChangeFunctionBreakpointsEmitter.event;
        this.onDidChangeInstructionBreakpointsEmitter = new common_1.Emitter();
        this.onDidChangeInstructionBreakpoints = this.onDidChangeInstructionBreakpointsEmitter.event;
        this._breakpointsEnabled = true;
        this.exceptionBreakpoints = new Map();
        this.functionBreakpoints = [];
        this.instructionBreakpoints = [];
    }
    getKind() {
        return breakpoint_marker_1.BREAKPOINT_KIND;
    }
    setMarkers(uri, owner, newMarkers) {
        const result = this.findMarkers({ uri, owner });
        const added = [];
        const removed = [];
        const changed = [];
        const oldMarkers = new Map(result.map(({ data }) => [data.id, data]));
        const ids = new Set();
        let didChangeMarkers = false;
        for (const newMarker of newMarkers) {
            ids.add(newMarker.id);
            const oldMarker = oldMarkers.get(newMarker.id);
            if (!oldMarker) {
                added.push(newMarker);
            }
            else {
                // We emit all existing markers as 'changed', but we only fire an event if something really did change.
                // We also fire an event if oldMarker === newMarker, as we cannot actually detect a change in this case
                // (https://github.com/eclipse-theia/theia/issues/12546).
                didChangeMarkers || (didChangeMarkers = !!added.length || oldMarker === newMarker || !deepEqual(oldMarker, newMarker));
                changed.push(newMarker);
            }
        }
        for (const [id, data] of oldMarkers.entries()) {
            if (!ids.has(id)) {
                removed.push(data);
            }
        }
        if (added.length || removed.length || didChangeMarkers) {
            super.setMarkers(uri, owner, newMarkers);
            this.onDidChangeBreakpointsEmitter.fire({ uri, added, removed, changed });
        }
        return result;
    }
    getLineBreakpoints(uri, line) {
        return this.findMarkers({
            uri,
            dataFilter: breakpoint => breakpoint.raw.line === line
        }).map(({ data }) => data);
    }
    getInlineBreakpoint(uri, line, column) {
        const marker = this.findMarkers({
            uri,
            dataFilter: breakpoint => breakpoint.raw.line === line && breakpoint.raw.column === column
        })[0];
        return marker && marker.data;
    }
    getBreakpoints(uri) {
        return this.findMarkers({ uri }).map(marker => marker.data);
    }
    setBreakpoints(uri, breakpoints) {
        this.setMarkers(uri, this.owner, breakpoints.sort((a, b) => (a.raw.line - b.raw.line) || ((a.raw.column || 0) - (b.raw.column || 0))));
    }
    addBreakpoint(breakpoint) {
        const uri = new uri_1.default(breakpoint.uri);
        const breakpoints = this.getBreakpoints(uri);
        const newBreakpoints = breakpoints.filter(({ raw }) => !(raw.line === breakpoint.raw.line && raw.column === breakpoint.raw.column));
        if (breakpoints.length === newBreakpoints.length) {
            newBreakpoints.push(breakpoint);
            this.setBreakpoints(uri, newBreakpoints);
            return true;
        }
        return false;
    }
    enableAllBreakpoints(enabled) {
        for (const uriString of this.getUris()) {
            let didChange = false;
            const uri = new uri_1.default(uriString);
            const markers = this.findMarkers({ uri });
            for (const marker of markers) {
                if (marker.data.enabled !== enabled) {
                    marker.data.enabled = enabled;
                    didChange = true;
                }
            }
            if (didChange) {
                this.fireOnDidChangeMarkers(uri);
            }
        }
        let didChangeFunction = false;
        for (const breakpoint of this.getFunctionBreakpoints().concat(this.getInstructionBreakpoints())) {
            if (breakpoint.enabled !== enabled) {
                breakpoint.enabled = enabled;
                didChangeFunction = true;
            }
        }
        if (didChangeFunction) {
            this.fireOnDidChangeMarkers(BreakpointManager_1.FUNCTION_URI);
        }
    }
    get breakpointsEnabled() {
        return this._breakpointsEnabled;
    }
    set breakpointsEnabled(breakpointsEnabled) {
        if (this._breakpointsEnabled !== breakpointsEnabled) {
            this._breakpointsEnabled = breakpointsEnabled;
            for (const uri of this.getUris()) {
                this.fireOnDidChangeMarkers(new uri_1.default(uri));
            }
            this.fireOnDidChangeMarkers(BreakpointManager_1.FUNCTION_URI);
        }
    }
    getExceptionBreakpoint(filter) {
        return this.exceptionBreakpoints.get(filter);
    }
    getExceptionBreakpoints() {
        return this.exceptionBreakpoints.values();
    }
    setExceptionBreakpoints(exceptionBreakpoints) {
        const toRemove = new Set(this.exceptionBreakpoints.keys());
        for (const exceptionBreakpoint of exceptionBreakpoints) {
            const filter = exceptionBreakpoint.raw.filter;
            toRemove.delete(filter);
            this.exceptionBreakpoints.set(filter, exceptionBreakpoint);
        }
        for (const filter of toRemove) {
            this.exceptionBreakpoints.delete(filter);
        }
        if (toRemove.size || exceptionBreakpoints.length) {
            this.fireOnDidChangeMarkers(BreakpointManager_1.EXCEPTION_URI);
        }
    }
    toggleExceptionBreakpoint(filter) {
        const breakpoint = this.getExceptionBreakpoint(filter);
        if (breakpoint) {
            breakpoint.enabled = !breakpoint.enabled;
            this.fireOnDidChangeMarkers(BreakpointManager_1.EXCEPTION_URI);
        }
    }
    updateExceptionBreakpoint(filter, options) {
        const breakpoint = this.getExceptionBreakpoint(filter);
        if (breakpoint) {
            Object.assign(breakpoint, options);
            this.fireOnDidChangeMarkers(BreakpointManager_1.EXCEPTION_URI);
        }
    }
    getFunctionBreakpoints() {
        return this.functionBreakpoints;
    }
    setFunctionBreakpoints(functionBreakpoints) {
        const oldBreakpoints = new Map(this.functionBreakpoints.map(b => [b.id, b]));
        this.functionBreakpoints = functionBreakpoints;
        this.fireOnDidChangeMarkers(BreakpointManager_1.FUNCTION_URI);
        const added = [];
        const removed = [];
        const changed = [];
        const ids = new Set();
        for (const newBreakpoint of functionBreakpoints) {
            ids.add(newBreakpoint.id);
            if (oldBreakpoints.has(newBreakpoint.id)) {
                changed.push(newBreakpoint);
            }
            else {
                added.push(newBreakpoint);
            }
        }
        for (const [id, breakpoint] of oldBreakpoints.entries()) {
            if (!ids.has(id)) {
                removed.push(breakpoint);
            }
        }
        this.onDidChangeFunctionBreakpointsEmitter.fire({ uri: BreakpointManager_1.FUNCTION_URI, added, removed, changed });
    }
    getInstructionBreakpoints() {
        return Object.freeze(this.instructionBreakpoints.slice());
    }
    hasBreakpoints() {
        return Boolean(this.getUris().next().value || this.functionBreakpoints.length || this.instructionBreakpoints.length);
    }
    setInstructionBreakpoints(newBreakpoints) {
        const oldBreakpoints = new Map(this.instructionBreakpoints.map(breakpoint => [breakpoint.id, breakpoint]));
        const currentBreakpoints = new Map(newBreakpoints.map(breakpoint => [breakpoint.id, breakpoint]));
        const added = [];
        const changed = [];
        for (const [id, breakpoint] of currentBreakpoints.entries()) {
            const old = oldBreakpoints.get(id);
            if (old) {
                changed.push(old);
            }
            else {
                added.push(breakpoint);
            }
            oldBreakpoints.delete(id);
        }
        const removed = Array.from(oldBreakpoints.values());
        this.instructionBreakpoints = Array.from(currentBreakpoints.values());
        this.fireOnDidChangeMarkers(BreakpointManager_1.INSTRUCTION_URI);
        this.onDidChangeInstructionBreakpointsEmitter.fire({ uri: BreakpointManager_1.INSTRUCTION_URI, added, removed, changed });
    }
    addInstructionBreakpoint(address, offset, condition, hitCondition) {
        this.setInstructionBreakpoints(this.instructionBreakpoints.concat(breakpoint_marker_1.InstructionBreakpoint.create({
            instructionReference: address,
            offset,
            condition,
            hitCondition,
        })));
    }
    updateInstructionBreakpoint(id, options) {
        const breakpoint = this.instructionBreakpoints.find(candidate => id === candidate.id);
        if (breakpoint) {
            Object.assign(breakpoint, options);
            this.fireOnDidChangeMarkers(BreakpointManager_1.INSTRUCTION_URI);
            this.onDidChangeInstructionBreakpointsEmitter.fire({ uri: BreakpointManager_1.INSTRUCTION_URI, changed: [breakpoint], added: [], removed: [] });
        }
    }
    removeInstructionBreakpoint(address) {
        if (!address) {
            this.clearInstructionBreakpoints();
        }
        const breakpointIndex = this.instructionBreakpoints.findIndex(breakpoint => breakpoint.instructionReference === address);
        if (breakpointIndex !== -1) {
            const removed = this.instructionBreakpoints.splice(breakpointIndex, 1);
            this.fireOnDidChangeMarkers(BreakpointManager_1.INSTRUCTION_URI);
            this.onDidChangeInstructionBreakpointsEmitter.fire({ uri: BreakpointManager_1.INSTRUCTION_URI, added: [], changed: [], removed });
        }
    }
    clearInstructionBreakpoints() {
        this.setInstructionBreakpoints([]);
    }
    removeBreakpoints() {
        this.cleanAllMarkers();
        this.setFunctionBreakpoints([]);
        this.setInstructionBreakpoints([]);
    }
    async load() {
        const data = await this.storage.getData('breakpoints', {
            breakpointsEnabled: true,
            breakpoints: {}
        });
        this._breakpointsEnabled = data.breakpointsEnabled;
        // eslint-disable-next-line guard-for-in
        for (const uri in data.breakpoints) {
            this.setBreakpoints(new uri_1.default(uri), data.breakpoints[uri]);
        }
        if (data.functionBreakpoints) {
            this.setFunctionBreakpoints(data.functionBreakpoints);
        }
        if (data.exceptionBreakpoints) {
            this.setExceptionBreakpoints(data.exceptionBreakpoints);
        }
        if (data.instructionBreakpoints) {
            this.setInstructionBreakpoints(data.instructionBreakpoints);
        }
    }
    save() {
        const data = {
            breakpointsEnabled: this._breakpointsEnabled,
            breakpoints: {}
        };
        const uris = this.getUris();
        for (const uri of uris) {
            data.breakpoints[uri] = this.findMarkers({ uri: new uri_1.default(uri) }).map(marker => marker.data);
        }
        if (this.functionBreakpoints.length) {
            data.functionBreakpoints = this.functionBreakpoints;
        }
        if (this.exceptionBreakpoints.size) {
            data.exceptionBreakpoints = [...this.exceptionBreakpoints.values()];
        }
        if (this.instructionBreakpoints.length) {
            data.instructionBreakpoints = this.instructionBreakpoints;
        }
        this.storage.setData('breakpoints', data);
    }
};
exports.BreakpointManager = BreakpointManager;
BreakpointManager.EXCEPTION_URI = new uri_1.default('debug:exception://');
BreakpointManager.FUNCTION_URI = new uri_1.default('debug:function://');
BreakpointManager.INSTRUCTION_URI = new uri_1.default('debug:instruction://');
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], BreakpointManager.prototype, "storage", void 0);
exports.BreakpointManager = BreakpointManager = BreakpointManager_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], BreakpointManager);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstructionBreakpoint = exports.FunctionBreakpoint = exports.ExceptionBreakpoint = exports.BreakpointMarker = exports.SourceBreakpoint = exports.BREAKPOINT_KIND = void 0;
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
exports.BREAKPOINT_KIND = 'breakpoint';
var SourceBreakpoint;
(function (SourceBreakpoint) {
    function create(uri, data, origin) {
        return {
            id: origin ? origin.id : coreutils_1.UUID.uuid4(),
            uri: uri.toString(),
            enabled: origin ? origin.enabled : true,
            raw: {
                ...(origin && origin.raw),
                ...data
            }
        };
    }
    SourceBreakpoint.create = create;
})(SourceBreakpoint || (exports.SourceBreakpoint = SourceBreakpoint = {}));
var BreakpointMarker;
(function (BreakpointMarker) {
    function is(node) {
        return 'kind' in node && node.kind === exports.BREAKPOINT_KIND;
    }
    BreakpointMarker.is = is;
})(BreakpointMarker || (exports.BreakpointMarker = BreakpointMarker = {}));
var ExceptionBreakpoint;
(function (ExceptionBreakpoint) {
    function create(data, origin) {
        return {
            enabled: origin ? origin.enabled : false,
            condition: origin ? origin.condition : undefined,
            raw: {
                ...(origin && origin.raw),
                ...data
            }
        };
    }
    ExceptionBreakpoint.create = create;
})(ExceptionBreakpoint || (exports.ExceptionBreakpoint = ExceptionBreakpoint = {}));
var FunctionBreakpoint;
(function (FunctionBreakpoint) {
    function create(data, origin) {
        return {
            id: origin ? origin.id : coreutils_1.UUID.uuid4(),
            enabled: origin ? origin.enabled : true,
            raw: {
                ...(origin && origin.raw),
                ...data
            }
        };
    }
    FunctionBreakpoint.create = create;
})(FunctionBreakpoint || (exports.FunctionBreakpoint = FunctionBreakpoint = {}));
var InstructionBreakpoint;
(function (InstructionBreakpoint) {
    function create(raw, existing) {
        var _a, _b;
        return {
            ...raw,
            id: (_a = existing === null || existing === void 0 ? void 0 : existing.id) !== null && _a !== void 0 ? _a : coreutils_1.UUID.uuid4(),
            enabled: (_b = existing === null || existing === void 0 ? void 0 : existing.enabled) !== null && _b !== void 0 ? _b : true,
        };
    }
    InstructionBreakpoint.create = create;
    function is(arg) {
        return (0, common_1.isObject)(arg) && (0, common_1.isString)(arg.instructionReference);
    }
    InstructionBreakpoint.is = is;
})(InstructionBreakpoint || (exports.InstructionBreakpoint = InstructionBreakpoint = {}));


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugConsoleContribution_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConsoleContribution = exports.DebugConsoleCommands = exports.InDebugReplContextKey = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const console_session_manager_1 = __webpack_require__(/*! @theia/console/lib/browser/console-session-manager */ "../node_modules/@theia/console/lib/browser/console-session-manager.js");
const console_widget_1 = __webpack_require__(/*! @theia/console/lib/browser/console-widget */ "../node_modules/@theia/console/lib/browser/console-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const tab_bar_toolbar_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/tab-bar-toolbar */ "../node_modules/@theia/core/lib/browser/shell/tab-bar-toolbar/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const select_component_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/select-component */ "../node_modules/@theia/core/lib/browser/widgets/select-component.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_console_session_1 = __webpack_require__(/*! ./debug-console-session */ "../node_modules/@theia/debug/lib/browser/console/debug-console-session.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
exports.InDebugReplContextKey = Symbol('inDebugReplContextKey');
var DebugConsoleCommands;
(function (DebugConsoleCommands) {
    DebugConsoleCommands.DEBUG_CATEGORY = 'Debug';
    DebugConsoleCommands.CLEAR = command_1.Command.toDefaultLocalizedCommand({
        id: 'debug.console.clear',
        category: DebugConsoleCommands.DEBUG_CATEGORY,
        label: 'Clear Console',
        iconClass: (0, browser_1.codicon)('clear-all')
    });
})(DebugConsoleCommands || (exports.DebugConsoleCommands = DebugConsoleCommands = {}));
let DebugConsoleContribution = DebugConsoleContribution_1 = class DebugConsoleContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: DebugConsoleContribution_1.options.id,
            widgetName: DebugConsoleContribution_1.options.title.label,
            defaultWidgetOptions: {
                area: 'bottom'
            },
            toggleCommandId: 'debug:console:toggle',
            toggleKeybinding: 'ctrlcmd+shift+y'
        });
        this.changeDebugConsole = (option) => {
            const id = option.value;
            const session = this.consoleSessionManager.get(id);
            this.consoleSessionManager.selectedSession = session;
        };
        this.changeSeverity = (option) => {
            this.consoleSessionManager.severity = severity_1.Severity.fromValue(option.value);
        };
    }
    init() {
        this.resources.add(debug_console_session_1.DebugConsoleSession.uri, '');
        this.debugSessionManager.onDidCreateDebugSession(session => {
            const consoleParent = session.findConsoleParent();
            if (consoleParent) {
                const parentConsoleSession = this.consoleSessionManager.get(consoleParent.id);
                if (parentConsoleSession instanceof debug_console_session_1.DebugConsoleSession) {
                    session.on('output', event => parentConsoleSession.logOutput(parentConsoleSession.debugSession, event));
                }
            }
            else {
                const consoleSession = this.debugConsoleSessionFactory(session);
                this.consoleSessionManager.add(consoleSession);
                session.on('output', event => consoleSession.logOutput(session, event));
            }
        });
        this.debugSessionManager.onDidChangeActiveDebugSession(event => this.handleActiveDebugSessionChanged(event));
        this.debugSessionManager.onDidDestroyDebugSession(session => {
            this.consoleSessionManager.delete(session.id);
        });
    }
    handleActiveDebugSessionChanged(event) {
        if (!event.current) {
            this.consoleSessionManager.selectedSession = undefined;
        }
        else {
            const topSession = event.current.findConsoleParent() || event.current;
            const consoleSession = topSession ? this.consoleSessionManager.get(topSession.id) : undefined;
            this.consoleSessionManager.selectedSession = consoleSession;
            const consoleSelector = document.getElementById('debugConsoleSelector');
            if (consoleSession && consoleSelector instanceof HTMLSelectElement) {
                consoleSelector.value = consoleSession.id;
            }
        }
    }
    registerCommands(commands) {
        super.registerCommands(commands);
        commands.registerCommand(DebugConsoleCommands.CLEAR, {
            isEnabled: widget => this.withWidget(widget, () => true),
            isVisible: widget => this.withWidget(widget, () => true),
            execute: widget => this.withWidget(widget, () => {
                this.clearConsole();
            }),
        });
    }
    async registerToolbarItems(toolbarRegistry) {
        toolbarRegistry.registerItem({
            id: 'debug-console-severity',
            render: widget => this.renderSeveritySelector(widget),
            isVisible: widget => this.withWidget(widget, () => true),
            onDidChange: this.consoleSessionManager.onDidChangeSeverity
        });
        toolbarRegistry.registerItem({
            id: 'debug-console-session-selector',
            render: widget => this.renderDebugConsoleSelector(widget),
            isVisible: widget => this.withWidget(widget, () => this.consoleSessionManager.all.length > 1)
        });
        toolbarRegistry.registerItem({
            id: DebugConsoleCommands.CLEAR.id,
            command: DebugConsoleCommands.CLEAR.id,
            tooltip: DebugConsoleCommands.CLEAR.label,
            priority: 0,
        });
    }
    static create(parent) {
        const inputFocusContextKey = parent.get(exports.InDebugReplContextKey);
        const child = console_widget_1.ConsoleWidget.createContainer(parent, {
            ...DebugConsoleContribution_1.options,
            inputFocusContextKey
        });
        const widget = child.get(console_widget_1.ConsoleWidget);
        return widget;
    }
    static bindContribution(bind) {
        bind(exports.InDebugReplContextKey).toDynamicValue(({ container }) => container.get(context_key_service_1.ContextKeyService).createKey('inDebugRepl', false)).inSingletonScope();
        bind(debug_console_session_1.DebugConsoleSession).toSelf().inRequestScope();
        bind(debug_console_session_1.DebugConsoleSessionFactory).toFactory(context => (session) => {
            const consoleSession = context.container.get(debug_console_session_1.DebugConsoleSession);
            consoleSession.debugSession = session;
            return consoleSession;
        });
        bind(console_session_manager_1.ConsoleSessionManager).toSelf().inSingletonScope();
        (0, browser_1.bindViewContribution)(bind, DebugConsoleContribution_1);
        bind(tab_bar_toolbar_1.TabBarToolbarContribution).toService(DebugConsoleContribution_1);
        bind(browser_1.WidgetFactory).toDynamicValue(({ container }) => ({
            id: DebugConsoleContribution_1.options.id,
            createWidget: () => DebugConsoleContribution_1.create(container)
        }));
    }
    renderSeveritySelector(widget) {
        const severityElements = severity_1.Severity.toArray().map(e => ({
            value: e,
            label: severity_1.Severity.toLocaleString(e)
        }));
        return React.createElement(select_component_1.SelectComponent, { key: "debugConsoleSeverity", options: severityElements, defaultValue: this.consoleSessionManager.severity || severity_1.Severity.Ignore, onChange: this.changeSeverity });
    }
    renderDebugConsoleSelector(widget) {
        const availableConsoles = [];
        this.consoleSessionManager.all.forEach(e => {
            if (e instanceof debug_console_session_1.DebugConsoleSession) {
                availableConsoles.push({
                    value: e.id,
                    label: e.debugSession.label
                });
            }
        });
        return React.createElement(select_component_1.SelectComponent, { key: "debugConsoleSelector", options: availableConsoles, defaultValue: 0, onChange: this.changeDebugConsole });
    }
    withWidget(widget = this.tryGetWidget(), fn) {
        if (widget instanceof console_widget_1.ConsoleWidget && widget.id === DebugConsoleContribution_1.options.id) {
            return fn(widget);
        }
        return false;
    }
    /**
     * Clear the console widget.
     */
    async clearConsole() {
        const widget = await this.widget;
        widget.clear();
    }
};
exports.DebugConsoleContribution = DebugConsoleContribution;
DebugConsoleContribution.options = {
    id: 'debug-console',
    title: {
        label: nls_1.nls.localizeByDefault('Debug Console'),
        iconClass: (0, browser_1.codicon)('debug-console')
    },
    input: {
        uri: debug_console_session_1.DebugConsoleSession.uri,
        options: {
            autoSizing: true,
            minHeight: 1,
            maxHeight: 10
        }
    }
};
tslib_1.__decorate([
    (0, inversify_1.inject)(console_session_manager_1.ConsoleSessionManager),
    tslib_1.__metadata("design:type", console_session_manager_1.ConsoleSessionManager)
], DebugConsoleContribution.prototype, "consoleSessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_console_session_1.DebugConsoleSessionFactory),
    tslib_1.__metadata("design:type", Function)
], DebugConsoleContribution.prototype, "debugConsoleSessionFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugConsoleContribution.prototype, "debugSessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.InMemoryResources),
    tslib_1.__metadata("design:type", core_1.InMemoryResources)
], DebugConsoleContribution.prototype, "resources", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugConsoleContribution.prototype, "init", null);
exports.DebugConsoleContribution = DebugConsoleContribution = DebugConsoleContribution_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], DebugConsoleContribution);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/console/debug-console-items.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugScope = exports.ExpressionItem = exports.DebugVirtualVariable = exports.DebugVariable = exports.ExpressionContainer = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const console_session_1 = __webpack_require__(/*! @theia/console/lib/browser/console-session */ "../node_modules/@theia/console/lib/browser/console-session.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class ExpressionContainer {
    get session() {
        return this.sessionProvider();
    }
    constructor(options) {
        this.sessionProvider = options.session;
        this.variablesReference = options.variablesReference || 0;
        this.namedVariables = options.namedVariables;
        this.indexedVariables = options.indexedVariables;
        this.startOfVariables = options.startOfVariables || 0;
    }
    render() {
        return undefined;
    }
    get hasElements() {
        return !!this.variablesReference;
    }
    async getElements() {
        if (!this.hasElements || !this.session) {
            return [][Symbol.iterator]();
        }
        if (!this.elements) {
            this.elements = this.doResolve();
        }
        return (await this.elements)[Symbol.iterator]();
    }
    async doResolve() {
        const result = [];
        if (this.namedVariables) {
            await this.fetch(result, 'named');
        }
        if (this.indexedVariables) {
            let chunkSize = ExpressionContainer.BASE_CHUNK_SIZE;
            while (this.indexedVariables > chunkSize * ExpressionContainer.BASE_CHUNK_SIZE) {
                chunkSize *= ExpressionContainer.BASE_CHUNK_SIZE;
            }
            if (this.indexedVariables > chunkSize) {
                const numberOfChunks = Math.ceil(this.indexedVariables / chunkSize);
                for (let i = 0; i < numberOfChunks; i++) {
                    const start = this.startOfVariables + i * chunkSize;
                    const count = Math.min(chunkSize, this.indexedVariables - i * chunkSize);
                    const { variablesReference } = this;
                    result.push(new DebugVirtualVariable({
                        session: this.sessionProvider,
                        variablesReference,
                        namedVariables: 0,
                        indexedVariables: count,
                        startOfVariables: start,
                        name: `[${start}..${start + count - 1}]`
                    }));
                }
                return result;
            }
        }
        await this.fetch(result, 'indexed', this.startOfVariables, this.indexedVariables);
        return result;
    }
    async fetch(result, filter, start, count) {
        try {
            const { variablesReference } = this;
            const response = await this.session.sendRequest('variables', { variablesReference, filter, start, count });
            const { variables } = response.body;
            const names = new Set();
            for (const variable of variables) {
                if (!names.has(variable.name)) {
                    result.push(new DebugVariable(this.sessionProvider, variable, this));
                    names.add(variable.name);
                }
            }
        }
        catch (e) {
            result.push({
                severity: severity_1.Severity.Error,
                visible: !!e.message,
                render: () => e.message
            });
        }
    }
}
exports.ExpressionContainer = ExpressionContainer;
ExpressionContainer.BASE_CHUNK_SIZE = 100;
class DebugVariable extends ExpressionContainer {
    constructor(session, variable, parent) {
        super({
            session,
            variablesReference: variable.variablesReference,
            namedVariables: variable.namedVariables,
            indexedVariables: variable.indexedVariables
        });
        this.variable = variable;
        this.parent = parent;
        this.setValueRef = (valueRef) => this.valueRef = valueRef || undefined;
        this.setNameRef = (nameRef) => this.nameRef = nameRef || undefined;
    }
    get name() {
        return this.variable.name;
    }
    get type() {
        return this._type || this.variable.type;
    }
    get value() {
        return this._value || this.variable.value;
    }
    get readOnly() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.variable.presentationHint) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.includes('readOnly')) !== null && _c !== void 0 ? _c : false;
    }
    render() {
        const { type, value, name } = this;
        return React.createElement("div", { className: this.variableClassName },
            React.createElement("span", { title: type || name, className: 'name', ref: this.setNameRef },
                name,
                !!value && ': '),
            React.createElement("span", { title: value, ref: this.setValueRef }, value));
    }
    get variableClassName() {
        const { type, value } = this;
        const classNames = ['theia-debug-console-variable'];
        if (type === 'number' || type === 'boolean' || type === 'string') {
            classNames.push(type);
        }
        else if (!isNaN(+value)) {
            classNames.push('number');
        }
        else if (DebugVariable.booleanRegex.test(value)) {
            classNames.push('boolean');
        }
        else if (DebugVariable.stringRegex.test(value)) {
            classNames.push('string');
        }
        return classNames.join(' ');
    }
    get supportSetVariable() {
        return !!this.session && !!this.session.capabilities.supportsSetVariable;
    }
    async setValue(value) {
        if (!this.session) {
            return;
        }
        const { name, parent } = this;
        const variablesReference = parent['variablesReference'];
        try {
            const response = await this.session.sendRequest('setVariable', { variablesReference, name, value });
            this._value = response.body.value;
            this._type = response.body.type;
            this.variablesReference = response.body.variablesReference || 0;
            this.namedVariables = response.body.namedVariables;
            this.indexedVariables = response.body.indexedVariables;
            this.elements = undefined;
            this.session['fireDidChange']();
        }
        catch (error) {
            console.error('setValue failed:', error);
        }
    }
    get supportCopyValue() {
        return !!this.valueRef && document.queryCommandSupported('copy');
    }
    copyValue() {
        const selection = document.getSelection();
        if (this.valueRef && selection) {
            selection.selectAllChildren(this.valueRef);
            document.execCommand('copy');
        }
    }
    get supportCopyAsExpression() {
        return !!this.nameRef && document.queryCommandSupported('copy');
    }
    copyAsExpression() {
        const selection = document.getSelection();
        if (this.nameRef && selection) {
            selection.selectAllChildren(this.nameRef);
            document.execCommand('copy');
        }
    }
    async open() {
        if (!this.supportSetVariable || this.readOnly) {
            return;
        }
        const input = new browser_1.SingleTextInputDialog({
            title: core_1.nls.localize('theia/debug/debugVariableInput', 'Set {0} Value', this.name),
            initialValue: this.value,
            placeholder: core_1.nls.localizeByDefault('Value')
        });
        const newValue = await input.open();
        if (newValue) {
            await this.setValue(newValue);
        }
    }
}
exports.DebugVariable = DebugVariable;
DebugVariable.booleanRegex = /^true|false$/i;
DebugVariable.stringRegex = /^(['"]).*\1$/;
class DebugVirtualVariable extends ExpressionContainer {
    constructor(options) {
        super(options);
        this.options = options;
    }
    render() {
        return this.options.name;
    }
}
exports.DebugVirtualVariable = DebugVirtualVariable;
class ExpressionItem extends ExpressionContainer {
    get value() {
        return this._value;
    }
    get type() {
        return this._type;
    }
    get available() {
        return this._available;
    }
    constructor(_expression, session) {
        super({ session });
        this._expression = _expression;
        this._value = ExpressionItem.notAvailable;
        this._available = false;
    }
    get expression() {
        return this._expression;
    }
    render() {
        const valueClassNames = [];
        if (!this._available) {
            valueClassNames.push(console_session_1.ConsoleItem.errorClassName);
            valueClassNames.push('theia-debug-console-unavailable');
        }
        return React.createElement("div", { className: 'theia-debug-console-expression' },
            React.createElement("div", null, this._expression),
            React.createElement("div", { className: valueClassNames.join(' ') }, this._value));
    }
    async evaluate(context = 'repl') {
        const session = this.session;
        if (!(session === null || session === void 0 ? void 0 : session.currentFrame)) {
            this.setResult(undefined, ExpressionItem.notAvailable);
            return;
        }
        try {
            const body = await session.evaluate(this._expression, context);
            this.setResult(body);
        }
        catch (err) {
            this.setResult(undefined, err.message);
        }
    }
    setResult(body, error = ExpressionItem.notAvailable) {
        if (body) {
            this._value = body.result;
            this._type = body.type;
            this._available = true;
            this.variablesReference = body.variablesReference;
            this.namedVariables = body.namedVariables;
            this.indexedVariables = body.indexedVariables;
            this.severity = severity_1.Severity.Log;
        }
        else {
            this._value = error;
            this._type = undefined;
            this._available = false;
            this.variablesReference = 0;
            this.namedVariables = undefined;
            this.indexedVariables = undefined;
            this.severity = severity_1.Severity.Error;
        }
        this.elements = undefined;
    }
}
exports.ExpressionItem = ExpressionItem;
ExpressionItem.notAvailable = 'not available';
class DebugScope extends ExpressionContainer {
    constructor(raw, session) {
        super({
            session,
            variablesReference: raw.variablesReference,
            namedVariables: raw.namedVariables,
            indexedVariables: raw.indexedVariables
        });
        this.raw = raw;
    }
    render() {
        return this.name;
    }
    get expensive() {
        return this.raw.expensive;
    }
    get range() {
        const { line, column, endLine, endColumn } = this.raw;
        if (line !== undefined && column !== undefined && endLine !== undefined && endColumn !== undefined) {
            return new monaco.Range(line, column, endLine, endColumn);
        }
        return undefined;
    }
    get name() {
        return this.raw.name;
    }
}
exports.DebugScope = DebugScope;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/console/debug-console-session.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/console/debug-console-session.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugConsoleSession_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConsoleSession = exports.DebugConsoleSessionFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const throttle = __webpack_require__(/*! @theia/core/shared/lodash.throttle */ "../node_modules/@theia/core/shared/lodash.throttle/index.js");
const console_session_1 = __webpack_require__(/*! @theia/console/lib/browser/console-session */ "../node_modules/@theia/console/lib/browser/console-session.js");
const ansi_console_item_1 = __webpack_require__(/*! @theia/console/lib/browser/ansi-console-item */ "../node_modules/@theia/console/lib/browser/ansi-console-item.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const debug_console_items_1 = __webpack_require__(/*! ./debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
exports.DebugConsoleSessionFactory = Symbol('DebugConsoleSessionFactory');
let DebugConsoleSession = DebugConsoleSession_1 = class DebugConsoleSession extends console_session_1.ConsoleSession {
    constructor() {
        super(...arguments);
        this.items = [];
        this.completionKinds = new Map();
        this.fireDidChange = throttle(() => super.fireDidChange(), 50);
    }
    get debugSession() {
        return this._debugSession;
    }
    set debugSession(value) {
        this._debugSession = value;
        this.id = value.id;
    }
    init() {
        this.completionKinds.set('method', monaco.languages.CompletionItemKind.Method);
        this.completionKinds.set('function', monaco.languages.CompletionItemKind.Function);
        this.completionKinds.set('constructor', monaco.languages.CompletionItemKind.Constructor);
        this.completionKinds.set('field', monaco.languages.CompletionItemKind.Field);
        this.completionKinds.set('variable', monaco.languages.CompletionItemKind.Variable);
        this.completionKinds.set('class', monaco.languages.CompletionItemKind.Class);
        this.completionKinds.set('interface', monaco.languages.CompletionItemKind.Interface);
        this.completionKinds.set('module', monaco.languages.CompletionItemKind.Module);
        this.completionKinds.set('property', monaco.languages.CompletionItemKind.Property);
        this.completionKinds.set('unit', monaco.languages.CompletionItemKind.Unit);
        this.completionKinds.set('value', monaco.languages.CompletionItemKind.Value);
        this.completionKinds.set('enum', monaco.languages.CompletionItemKind.Enum);
        this.completionKinds.set('keyword', monaco.languages.CompletionItemKind.Keyword);
        this.completionKinds.set('snippet', monaco.languages.CompletionItemKind.Snippet);
        this.completionKinds.set('text', monaco.languages.CompletionItemKind.Text);
        this.completionKinds.set('color', monaco.languages.CompletionItemKind.Color);
        this.completionKinds.set('file', monaco.languages.CompletionItemKind.File);
        this.completionKinds.set('reference', monaco.languages.CompletionItemKind.Reference);
        this.completionKinds.set('customcolor', monaco.languages.CompletionItemKind.Color);
        this.toDispose.push(monaco.languages.registerCompletionItemProvider({
            scheme: DebugConsoleSession_1.uri.scheme,
            hasAccessToAllModels: true
        }, {
            triggerCharacters: ['.'],
            provideCompletionItems: (model, position) => this.completions(model, position),
        }));
    }
    getElements() {
        return this.items.filter(e => !this.severity || e.severity === this.severity)[Symbol.iterator]();
    }
    async completions(model, position) {
        const completionSession = this.findCompletionSession();
        if (completionSession) {
            const column = position.column;
            const lineNumber = position.lineNumber;
            const word = model.getWordAtPosition({ column, lineNumber });
            const overwriteBefore = word ? word.word.length : 0;
            const text = model.getValue();
            const items = await completionSession.completions(text, column, lineNumber);
            const suggestions = items.map(item => this.asCompletionItem(text, position, overwriteBefore, item));
            return { suggestions };
        }
        return undefined;
    }
    findCurrentSession() {
        const currentSession = this.sessionManager.currentSession;
        if (!currentSession) {
            return undefined;
        }
        if (currentSession.id === this.debugSession.id) {
            // perfect match
            return this.debugSession;
        }
        const parentSession = currentSession.findConsoleParent();
        if ((parentSession === null || parentSession === void 0 ? void 0 : parentSession.id) === this.debugSession.id) {
            // child of our session
            return currentSession;
        }
        return undefined;
    }
    findCompletionSession() {
        let completionSession = this.findCurrentSession();
        while (completionSession !== undefined) {
            if (completionSession.capabilities.supportsCompletionsRequest) {
                return completionSession;
            }
            completionSession = completionSession.parentSession;
        }
        return completionSession;
    }
    asCompletionItem(text, position, overwriteBefore, item) {
        return {
            label: item.label,
            insertText: item.text || item.label,
            kind: this.completionKinds.get(item.type) || monaco.languages.CompletionItemKind.Property,
            filterText: (item.start && item.length) ? text.substring(item.start, item.start + item.length).concat(item.label) : undefined,
            range: monaco.Range.fromPositions(position.delta(0, -(item.length || overwriteBefore)), position),
            sortText: item.sortText
        };
    }
    async execute(value) {
        const expression = new debug_console_items_1.ExpressionItem(value, () => this.findCurrentSession());
        this.items.push(expression);
        await expression.evaluate();
        this.fireDidChange();
    }
    clear() {
        this.items = [];
        this.fireDidChange();
    }
    append(value) {
        if (!value) {
            return;
        }
        const lastItem = this.items.slice(-1)[0];
        if (lastItem instanceof ansi_console_item_1.AnsiConsoleItem && lastItem.content === this.uncompletedItemContent) {
            this.items.pop();
            this.uncompletedItemContent += value;
        }
        else {
            this.uncompletedItemContent = value;
        }
        this.items.push(new ansi_console_item_1.AnsiConsoleItem(this.uncompletedItemContent, severity_1.Severity.Info));
        this.fireDidChange();
    }
    appendLine(value) {
        this.items.push(new ansi_console_item_1.AnsiConsoleItem(value, severity_1.Severity.Info));
        this.fireDidChange();
    }
    async logOutput(session, event) {
        const body = event.body;
        const { category, variablesReference } = body;
        if (category === 'telemetry') {
            console.debug(`telemetry/${event.body.output}`, event.body.data);
            return;
        }
        const severity = category === 'stderr' ? severity_1.Severity.Error : event.body.category === 'console' ? severity_1.Severity.Warning : severity_1.Severity.Info;
        if (variablesReference) {
            const items = await new debug_console_items_1.ExpressionContainer({ session: () => session, variablesReference }).getElements();
            for (const item of items) {
                this.items.push(Object.assign(item, { severity }));
            }
        }
        else if (typeof body.output === 'string') {
            for (const line of body.output.split('\n')) {
                this.items.push(new ansi_console_item_1.AnsiConsoleItem(line, severity));
            }
        }
        this.fireDidChange();
    }
};
exports.DebugConsoleSession = DebugConsoleSession;
DebugConsoleSession.uri = new uri_1.default().withScheme('debugconsole');
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugConsoleSession.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugConsoleSession.prototype, "init", null);
exports.DebugConsoleSession = DebugConsoleSession = DebugConsoleSession_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugConsoleSession);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-call-stack-item-type-key.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-call-stack-item-type-key.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugCallStackItemTypeKey = void 0;
exports.DebugCallStackItemTypeKey = Symbol('DebugCallStackItemTypeKey');


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConfigurationManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const jsonc_parser_1 = __webpack_require__(/*! jsonc-parser */ "../node_modules/jsonc-parser/lib/esm/main.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const quick_pick_service_1 = __webpack_require__(/*! @theia/core/lib/common/quick-pick-service */ "../node_modules/@theia/core/lib/common/quick-pick-service.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../node_modules/@theia/workspace/lib/browser/workspace-service.js");
const debug_configuration_model_1 = __webpack_require__(/*! ./debug-configuration-model */ "../node_modules/@theia/debug/lib/browser/debug-configuration-model.js");
const debug_session_options_1 = __webpack_require__(/*! ./debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const debug_service_1 = __webpack_require__(/*! ../common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const debug_common_1 = __webpack_require__(/*! ../common/debug-common */ "../node_modules/@theia/debug/lib/common/debug-common.js");
const workspace_variable_contribution_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-variable-contribution */ "../node_modules/@theia/workspace/lib/browser/workspace-variable-contribution.js");
const preference_configurations_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences/preference-configurations */ "../node_modules/@theia/core/lib/browser/preferences/preference-configurations.js");
const monaco_text_model_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-text-model-service */ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const commands_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/commands/common/commands */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/commands/common/commands.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
let DebugConfigurationManager = class DebugConfigurationManager {
    constructor() {
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.onWillProvideDebugConfigurationEmitter = new event_1.Emitter();
        this.onWillProvideDebugConfiguration = this.onWillProvideDebugConfigurationEmitter.event;
        this.onWillProvideDynamicDebugConfigurationEmitter = new event_1.Emitter();
        this.recentDynamicOptionsTracker = [];
        this.models = new Map();
        this.updateModels = debounce(async () => {
            const roots = await this.workspaceService.roots;
            const toDelete = new Set(this.models.keys());
            for (const rootStat of roots) {
                const key = rootStat.resource.toString();
                toDelete.delete(key);
                if (!this.models.has(key)) {
                    const model = new debug_configuration_model_1.DebugConfigurationModel(key, this.preferences);
                    model.onDidChange(() => this.updateCurrent());
                    model.onDispose(() => this.models.delete(key));
                    this.models.set(key, model);
                }
            }
            for (const uri of toDelete) {
                const model = this.models.get(uri);
                if (model) {
                    model.dispose();
                }
            }
            this.updateCurrent();
        }, 500);
    }
    get onWillProvideDynamicDebugConfiguration() {
        return this.onWillProvideDynamicDebugConfigurationEmitter.event;
    }
    get onDidChangeConfigurationProviders() {
        return this.debug.onDidChangeDebugConfigurationProviders;
    }
    init() {
        this.doInit();
    }
    async doInit() {
        this.debugConfigurationTypeKey = this.contextKeyService.createKey('debugConfigurationType', undefined);
        this.initialized = this.preferences.ready.then(() => {
            this.workspaceService.onWorkspaceChanged(this.updateModels);
            this.preferences.onPreferenceChanged(e => {
                if (e.preferenceName === 'launch') {
                    this.updateModels();
                }
            });
            return this.updateModels();
        });
    }
    /**
     * All _non-dynamic_ debug configurations.
     */
    get all() {
        return this.getAll();
    }
    *getAll() {
        for (const model of this.models.values()) {
            for (const configuration of model.configurations) {
                yield this.configurationToOptions(configuration, model.workspaceFolderUri);
            }
            for (const compound of model.compounds) {
                yield this.compoundToOptions(compound, model.workspaceFolderUri);
            }
        }
    }
    get supported() {
        return this.getSupported();
    }
    async getSupported() {
        await this.initialized;
        const debugTypes = await this.debug.debugTypes();
        return this.doGetSupported(new Set(debugTypes));
    }
    *doGetSupported(debugTypes) {
        for (const options of this.getAll()) {
            if (options.configuration && debugTypes.has(options.configuration.type)) {
                yield options;
            }
        }
    }
    get current() {
        return this._currentOptions;
    }
    async getSelectedConfiguration() {
        if (!debug_session_options_1.DebugSessionOptions.isDynamic(this._currentOptions)) {
            return this._currentOptions;
        }
        // Refresh a dynamic configuration from the provider.
        // This allow providers to update properties before the execution e.g. program
        const { providerType, workspaceFolderUri, configuration: { name } } = this._currentOptions;
        const configuration = await this.fetchDynamicDebugConfiguration(name, providerType, workspaceFolderUri);
        if (!configuration) {
            const message = core_1.nls.localize('theia/debug/missingConfiguration', "Dynamic configuration '{0}:{1}' is missing or not applicable", providerType, name);
            throw new Error(message);
        }
        return { name, configuration, providerType, workspaceFolderUri };
    }
    set current(option) {
        this.updateCurrent(option);
        this.updateRecentlyUsedDynamicConfigurationOptions(option);
    }
    updateRecentlyUsedDynamicConfigurationOptions(option) {
        if (debug_session_options_1.DebugSessionOptions.isDynamic(option)) {
            // Removing an item already present in the list
            const index = this.recentDynamicOptionsTracker.findIndex(item => this.dynamicOptionsMatch(item, option));
            if (index > -1) {
                this.recentDynamicOptionsTracker.splice(index, 1);
            }
            // Adding new item, most recent at the top of the list
            const recentMax = 3;
            if (this.recentDynamicOptionsTracker.unshift(option) > recentMax) {
                // Keep the latest 3 dynamic configuration options to not clutter the dropdown.
                this.recentDynamicOptionsTracker.splice(recentMax);
            }
        }
    }
    dynamicOptionsMatch(one, other) {
        return one.providerType !== undefined
            && one.configuration.name === other.configuration.name
            && one.providerType === other.providerType
            && one.workspaceFolderUri === other.workspaceFolderUri;
    }
    get recentDynamicOptions() {
        return this.recentDynamicOptionsTracker;
    }
    updateCurrent(options = this._currentOptions) {
        var _a;
        if (debug_session_options_1.DebugSessionOptions.isCompound(options)) {
            this._currentOptions = options && this.find(options.compound, options.workspaceFolderUri);
        }
        else {
            this._currentOptions = options && this.find(options.configuration, options.workspaceFolderUri, options.providerType);
        }
        if (!this._currentOptions) {
            const model = this.getModel();
            if (model) {
                const configuration = model.configurations[0];
                if (configuration) {
                    this._currentOptions = this.configurationToOptions(configuration, model.workspaceFolderUri);
                }
            }
        }
        this.debugConfigurationTypeKey.set(this.current && ((_a = this.current.configuration) === null || _a === void 0 ? void 0 : _a.type));
        this.onDidChangeEmitter.fire(undefined);
    }
    find(nameOrConfigurationOrCompound, workspaceFolderUri, providerType) {
        if (debug_common_1.DebugConfiguration.is(nameOrConfigurationOrCompound) && providerType) {
            // providerType is only applicable to dynamic debug configurations and may only be created if we have a configuration given
            return this.configurationToOptions(nameOrConfigurationOrCompound, workspaceFolderUri, providerType);
        }
        const name = typeof nameOrConfigurationOrCompound === 'string' ? nameOrConfigurationOrCompound : nameOrConfigurationOrCompound.name;
        const configuration = this.findConfiguration(name, workspaceFolderUri);
        if (configuration) {
            return this.configurationToOptions(configuration, workspaceFolderUri);
        }
        const compound = this.findCompound(name, workspaceFolderUri);
        if (compound) {
            return this.compoundToOptions(compound, workspaceFolderUri);
        }
    }
    findConfigurations(name, workspaceFolderUri) {
        const matches = [];
        for (const model of this.models.values()) {
            if (model.workspaceFolderUri === workspaceFolderUri) {
                for (const configuration of model.configurations) {
                    if (configuration.name === name) {
                        matches.push(configuration);
                    }
                }
            }
        }
        return matches;
    }
    findConfiguration(name, workspaceFolderUri) {
        for (const model of this.models.values()) {
            if (model.workspaceFolderUri === workspaceFolderUri) {
                for (const configuration of model.configurations) {
                    if (configuration.name === name) {
                        return configuration;
                    }
                }
            }
        }
    }
    findCompound(name, workspaceFolderUri) {
        for (const model of this.models.values()) {
            if (model.workspaceFolderUri === workspaceFolderUri) {
                for (const compound of model.compounds) {
                    if (compound.name === name) {
                        return compound;
                    }
                }
            }
        }
    }
    async openConfiguration() {
        var _a;
        const currentUri = new uri_1.default((_a = this.current) === null || _a === void 0 ? void 0 : _a.workspaceFolderUri);
        const model = this.getModel(currentUri);
        if (model) {
            await this.doOpen(model);
        }
    }
    configurationToOptions(configuration, workspaceFolderUri, providerType) {
        return { name: configuration.name, configuration, providerType, workspaceFolderUri };
    }
    compoundToOptions(compound, workspaceFolderUri) {
        return { name: compound.name, compound, workspaceFolderUri };
    }
    async addConfiguration() {
        let rootUri = undefined;
        if (this.workspaceService.saved && this.workspaceService.tryGetRoots().length > 1) {
            rootUri = await this.selectRootUri();
            // Do not continue if the user explicitly does not choose a location.
            if (!rootUri) {
                return;
            }
        }
        const model = this.getModel(rootUri);
        if (!model) {
            return;
        }
        const widget = await this.doOpen(model);
        if (!(widget.editor instanceof monaco_editor_1.MonacoEditor)) {
            return;
        }
        const editor = widget.editor.getControl();
        const editorModel = editor.getModel();
        if (!editorModel) {
            return;
        }
        const commandService = standaloneServices_1.StandaloneServices.get(commands_1.ICommandService);
        let position;
        let depthInArray = 0;
        let lastProperty = '';
        (0, jsonc_parser_1.visit)(editor.getValue(), {
            onObjectProperty: property => {
                lastProperty = property;
            },
            onArrayBegin: offset => {
                if (lastProperty === 'configurations' && depthInArray === 0) {
                    position = editorModel.getPositionAt(offset + 1);
                }
                depthInArray++;
            },
            onArrayEnd: () => {
                depthInArray--;
            }
        });
        if (!position) {
            return;
        }
        // Check if there are more characters on a line after a "configurations": [, if yes enter a newline
        if (editorModel.getLineLastNonWhitespaceColumn(position.lineNumber) > position.column) {
            editor.setPosition(position);
            editor.trigger('debug', 'lineBreakInsert', undefined);
        }
        // Check if there is already an empty line to insert suggest, if yes just place the cursor
        if (editorModel.getLineLastNonWhitespaceColumn(position.lineNumber + 1) === 0) {
            editor.setPosition({ lineNumber: position.lineNumber + 1, column: 1 << 30 });
            await commandService.executeCommand('editor.action.deleteLines');
        }
        editor.setPosition(position);
        await commandService.executeCommand('editor.action.insertLineAfter');
        await commandService.executeCommand('editor.action.triggerSuggest');
    }
    async selectRootUri() {
        const workspaceRoots = this.workspaceService.tryGetRoots();
        const items = [];
        for (const workspaceRoot of workspaceRoots) {
            items.push({
                label: this.labelProvider.getName(workspaceRoot.resource),
                description: this.labelProvider.getLongName(workspaceRoot.resource),
                value: workspaceRoot.resource
            });
        }
        const root = await this.quickPickService.show(items, {
            placeholder: core_1.nls.localize('theia/debug/addConfigurationPlaceholder', 'Select workspace root to add configuration to'),
        });
        return root === null || root === void 0 ? void 0 : root.value;
    }
    getModel(uri) {
        const workspaceFolderUri = this.workspaceVariables.getWorkspaceRootUri(uri);
        if (workspaceFolderUri) {
            const key = workspaceFolderUri.toString();
            for (const model of this.models.values()) {
                if (model.workspaceFolderUri === key) {
                    return model;
                }
            }
        }
        for (const model of this.models.values()) {
            if (model.uri) {
                return model;
            }
        }
        return this.models.values().next().value;
    }
    async doOpen(model) {
        const uri = await this.doCreate(model);
        return this.editorManager.open(uri, {
            mode: 'activate'
        });
    }
    async doCreate(model) {
        var _a;
        const uri = (_a = model.uri) !== null && _a !== void 0 ? _a : this.preferences.getConfigUri(browser_2.PreferenceScope.Folder, model.workspaceFolderUri, 'launch');
        if (!uri) { // Since we are requesting information about a known workspace folder, this should never happen.
            throw new Error('PreferenceService.getConfigUri has returned undefined when a URI was expected.');
        }
        const settingsUri = this.preferences.getConfigUri(browser_2.PreferenceScope.Folder, model.workspaceFolderUri);
        // Users may have placed their debug configurations in a `settings.json`, in which case we shouldn't modify the file.
        if (settingsUri && !uri.isEqual(settingsUri)) {
            await this.ensureContent(uri, model);
        }
        return uri;
    }
    /**
     * Checks whether a `launch.json` file contains the minimum necessary content.
     * If content not found, provides content and populates the file using Monaco.
     */
    async ensureContent(uri, model) {
        const textModel = await this.textModelService.createModelReference(uri);
        const currentContent = textModel.object.valid ? textModel.object.getText() : '';
        try { // Look for the minimal well-formed launch.json content: {configurations: []}
            const parsedContent = (0, jsonc_parser_1.parse)(currentContent);
            if (Array.isArray(parsedContent.configurations)) {
                return;
            }
        }
        catch {
            // Just keep going
        }
        const debugType = await this.selectDebugType();
        const configurations = debugType ? await this.provideDebugConfigurations(debugType, model.workspaceFolderUri) : [];
        const content = this.getInitialConfigurationContent(configurations);
        textModel.object.textEditorModel.setValue(content); // Will clobber anything the user has entered!
        await textModel.object.save();
    }
    async provideDebugConfigurations(debugType, workspaceFolderUri) {
        await this.fireWillProvideDebugConfiguration();
        return this.debug.provideDebugConfigurations(debugType, workspaceFolderUri);
    }
    async fireWillProvideDebugConfiguration() {
        await event_1.WaitUntilEvent.fire(this.onWillProvideDebugConfigurationEmitter, {});
    }
    async provideDynamicDebugConfigurations() {
        await this.fireWillProvideDynamicDebugConfiguration();
        const roots = this.workspaceService.tryGetRoots();
        const promises = roots.map(async (root) => {
            const configsMap = await this.debug.provideDynamicDebugConfigurations(root.resource.toString());
            const optionsMap = Object.fromEntries(Object.entries(configsMap).map(([type, configs]) => {
                const options = configs.map(config => ({
                    name: config.name,
                    providerType: type,
                    configuration: config,
                    workspaceFolderUri: root.resource.toString()
                }));
                return [type, options];
            }));
            return optionsMap;
        });
        const typesToOptionsRecords = await Promise.all(promises);
        const consolidatedTypesToOptions = {};
        for (const typesToOptionsInstance of typesToOptionsRecords) {
            for (const [providerType, configurationsOptions] of Object.entries(typesToOptionsInstance)) {
                if (!consolidatedTypesToOptions[providerType]) {
                    consolidatedTypesToOptions[providerType] = [];
                }
                consolidatedTypesToOptions[providerType].push(...configurationsOptions);
            }
        }
        return consolidatedTypesToOptions;
    }
    async fetchDynamicDebugConfiguration(name, type, folder) {
        await this.fireWillProvideDynamicDebugConfiguration();
        return this.debug.fetchDynamicDebugConfiguration(name, type, folder);
    }
    async fireWillProvideDynamicDebugConfiguration() {
        await this.initialized;
        await event_1.WaitUntilEvent.fire(this.onWillProvideDynamicDebugConfigurationEmitter, {});
    }
    getInitialConfigurationContent(initialConfigurations) {
        return `{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  "version": "0.2.0",
  "configurations": ${JSON.stringify(initialConfigurations, undefined, '  ').split('\n').map(line => '  ' + line).join('\n').trim()}
}
`;
    }
    async selectDebugType() {
        const widget = this.editorManager.currentEditor;
        if (!widget) {
            return undefined;
        }
        const { languageId } = widget.editor.document;
        const debuggers = await this.debug.getDebuggersForLanguage(languageId);
        if (debuggers.length === 0) {
            return undefined;
        }
        const items = debuggers.map(({ label, type }) => ({ label, value: type }));
        const selectedItem = await this.quickPickService.show(items, { placeholder: 'Select Environment' });
        return selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value;
    }
    async load() {
        var _a, _b;
        await this.initialized;
        const data = await this.storage.getData('debug.configurations', {});
        this.resolveRecentDynamicOptionsFromData(data.recentDynamicOptions);
        // Between versions v1.26 and v1.27, the expected format of the data changed so that old stored data
        // may not contain the configuration key.
        if (debug_session_options_1.DebugSessionOptions.isConfiguration(data.current)) {
            // ensure options name is reflected from old configurations data
            data.current.name = (_a = data.current.name) !== null && _a !== void 0 ? _a : (_b = data.current.configuration) === null || _b === void 0 ? void 0 : _b.name;
            this.current = this.find(data.current.configuration, data.current.workspaceFolderUri, data.current.providerType);
        }
        else if (debug_session_options_1.DebugSessionOptions.isCompound(data.current)) {
            this.current = this.find(data.current.name, data.current.workspaceFolderUri);
        }
    }
    resolveRecentDynamicOptionsFromData(options) {
        if (!options || this.recentDynamicOptionsTracker.length !== 0) {
            return;
        }
        // ensure options name is reflected from old configurations data
        const dynamicOptions = options.map(option => {
            var _a;
            option.name = (_a = option.name) !== null && _a !== void 0 ? _a : option.configuration.name;
            return option;
        }).filter(debug_session_options_1.DebugSessionOptions.isDynamic);
        this.recentDynamicOptionsTracker = dynamicOptions;
    }
    save() {
        const data = {};
        const { current, recentDynamicOptionsTracker } = this;
        if (current) {
            data.current = current;
        }
        if (this.recentDynamicOptionsTracker.length > 0) {
            data.recentDynamicOptions = recentDynamicOptionsTracker;
        }
        if (Object.keys(data).length > 0) {
            this.storage.setData('debug.configurations', data);
        }
    }
};
exports.DebugConfigurationManager = DebugConfigurationManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_service_1.WorkspaceService),
    tslib_1.__metadata("design:type", workspace_service_1.WorkspaceService)
], DebugConfigurationManager.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.EditorManager),
    tslib_1.__metadata("design:type", browser_1.EditorManager)
], DebugConfigurationManager.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_service_1.DebugService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationManager.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(quick_pick_service_1.QuickPickService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationManager.prototype, "quickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationManager.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.LabelProvider),
    tslib_1.__metadata("design:type", browser_2.LabelProvider)
], DebugConfigurationManager.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_text_model_service_1.MonacoTextModelService),
    tslib_1.__metadata("design:type", monaco_text_model_service_1.MonacoTextModelService)
], DebugConfigurationManager.prototype, "textModelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationManager.prototype, "preferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preference_configurations_1.PreferenceConfigurations),
    tslib_1.__metadata("design:type", preference_configurations_1.PreferenceConfigurations)
], DebugConfigurationManager.prototype, "preferenceConfigurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_variable_contribution_1.WorkspaceVariableContribution),
    tslib_1.__metadata("design:type", workspace_variable_contribution_1.WorkspaceVariableContribution)
], DebugConfigurationManager.prototype, "workspaceVariables", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugConfigurationManager.prototype, "init", null);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.StorageService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationManager.prototype, "storage", void 0);
exports.DebugConfigurationManager = DebugConfigurationManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugConfigurationManager);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-configuration-model.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-configuration-model.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConfigurationModel = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const debug_common_1 = __webpack_require__(/*! ../common/debug-common */ "../node_modules/@theia/debug/lib/common/debug-common.js");
const debug_compound_1 = __webpack_require__(/*! ../common/debug-compound */ "../node_modules/@theia/debug/lib/common/debug-compound.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
class DebugConfigurationModel {
    constructor(workspaceFolderUri, preferences) {
        this.workspaceFolderUri = workspaceFolderUri;
        this.preferences = preferences;
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDispose = new disposable_1.DisposableCollection(this.onDidChangeEmitter);
        this.reconcile();
        this.toDispose.push(this.preferences.onPreferenceChanged(e => {
            if (e.preferenceName === 'launch' && e.affects(workspaceFolderUri)) {
                this.reconcile();
            }
        }));
    }
    get uri() {
        return this.json.uri;
    }
    dispose() {
        this.toDispose.dispose();
    }
    get onDispose() {
        return this.toDispose.onDispose;
    }
    get configurations() {
        return this.json.configurations;
    }
    get compounds() {
        return this.json.compounds;
    }
    async reconcile() {
        this.json = this.parseConfigurations();
        this.onDidChangeEmitter.fire(undefined);
    }
    parseConfigurations() {
        const configurations = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { configUri, value } = this.preferences.resolve('launch', undefined, this.workspaceFolderUri);
        if ((0, common_1.isObject)(value) && Array.isArray(value.configurations)) {
            for (const configuration of value.configurations) {
                if (debug_common_1.DebugConfiguration.is(configuration)) {
                    configurations.push(configuration);
                }
            }
        }
        const compounds = [];
        if ((0, common_1.isObject)(value) && Array.isArray(value.compounds)) {
            for (const compound of value.compounds) {
                if (debug_compound_1.DebugCompound.is(compound)) {
                    compounds.push(compound);
                }
            }
        }
        return { uri: configUri, configurations, compounds };
    }
}
exports.DebugConfigurationModel = DebugConfigurationModel;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-contribution.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-contribution.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugContribution = void 0;
exports.DebugContribution = Symbol('DebugContribution');


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-frontend-application-contribution.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-frontend-application-contribution.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugFrontendApplicationContribution = exports.DebugBreakpointWidgetCommands = exports.DebugEditorContextCommands = exports.DebugSessionContextCommands = exports.DebugThreadContextCommands = exports.DebugCommands = exports.DebugMenus = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const debug_session_manager_1 = __webpack_require__(/*! ./debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_widget_1 = __webpack_require__(/*! ./view/debug-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-widget.js");
const breakpoint_marker_1 = __webpack_require__(/*! ./breakpoint/breakpoint-marker */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js");
const breakpoint_manager_1 = __webpack_require__(/*! ./breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_configuration_manager_1 = __webpack_require__(/*! ./debug-configuration-manager */ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const debug_session_1 = __webpack_require__(/*! ./debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_breakpoints_widget_1 = __webpack_require__(/*! ./view/debug-breakpoints-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-widget.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! ./model/debug-source-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const debug_threads_widget_1 = __webpack_require__(/*! ./view/debug-threads-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js");
const debug_thread_1 = __webpack_require__(/*! ./model/debug-thread */ "../node_modules/@theia/debug/lib/browser/model/debug-thread.js");
const debug_stack_frames_widget_1 = __webpack_require__(/*! ./view/debug-stack-frames-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js");
const debug_stack_frame_1 = __webpack_require__(/*! ./model/debug-stack-frame */ "../node_modules/@theia/debug/lib/browser/model/debug-stack-frame.js");
const debug_variables_widget_1 = __webpack_require__(/*! ./view/debug-variables-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js");
const debug_console_items_1 = __webpack_require__(/*! ./console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const debug_editor_model_1 = __webpack_require__(/*! ./editor/debug-editor-model */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor-model.js");
const debug_editor_service_1 = __webpack_require__(/*! ./editor/debug-editor-service */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor-service.js");
const debug_console_contribution_1 = __webpack_require__(/*! ./console/debug-console-contribution */ "../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js");
const debug_service_1 = __webpack_require__(/*! ../common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const debug_schema_updater_1 = __webpack_require__(/*! ./debug-schema-updater */ "../node_modules/@theia/debug/lib/browser/debug-schema-updater.js");
const debug_preferences_1 = __webpack_require__(/*! ./debug-preferences */ "../node_modules/@theia/debug/lib/browser/debug-preferences.js");
const debug_watch_widget_1 = __webpack_require__(/*! ./view/debug-watch-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-watch-widget.js");
const debug_watch_expression_1 = __webpack_require__(/*! ./view/debug-watch-expression */ "../node_modules/@theia/debug/lib/browser/view/debug-watch-expression.js");
const debug_watch_manager_1 = __webpack_require__(/*! ./debug-watch-manager */ "../node_modules/@theia/debug/lib/browser/debug-watch-manager.js");
const debug_function_breakpoint_1 = __webpack_require__(/*! ./model/debug-function-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js");
const debug_breakpoint_1 = __webpack_require__(/*! ./model/debug-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const debug_instruction_breakpoint_1 = __webpack_require__(/*! ./model/debug-instruction-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-instruction-breakpoint.js");
const debug_exception_breakpoint_1 = __webpack_require__(/*! ./view/debug-exception-breakpoint */ "../node_modules/@theia/debug/lib/browser/view/debug-exception-breakpoint.js");
var DebugMenus;
(function (DebugMenus) {
    DebugMenus.DEBUG = [...common_1.MAIN_MENU_BAR, '6_debug'];
    DebugMenus.DEBUG_CONTROLS = [...DebugMenus.DEBUG, 'a_controls'];
    DebugMenus.DEBUG_CONFIGURATION = [...DebugMenus.DEBUG, 'b_configuration'];
    DebugMenus.DEBUG_THREADS = [...DebugMenus.DEBUG, 'c_threads'];
    DebugMenus.DEBUG_SESSIONS = [...DebugMenus.DEBUG, 'd_sessions'];
    DebugMenus.DEBUG_BREAKPOINT = [...DebugMenus.DEBUG, 'e_breakpoint'];
    DebugMenus.DEBUG_NEW_BREAKPOINT = [...DebugMenus.DEBUG_BREAKPOINT, 'a_new_breakpoint'];
    DebugMenus.DEBUG_BREAKPOINTS = [...DebugMenus.DEBUG, 'f_breakpoints'];
})(DebugMenus || (exports.DebugMenus = DebugMenus = {}));
function nlsEditBreakpoint(breakpoint) {
    return nls_1.nls.localizeByDefault('Edit {0}...', nls_1.nls.localizeByDefault(breakpoint));
}
function nlsRemoveBreakpoint(breakpoint) {
    return nls_1.nls.localizeByDefault('Remove {0}', nls_1.nls.localizeByDefault(breakpoint));
}
function nlsEnableBreakpoint(breakpoint) {
    return nls_1.nls.localizeByDefault('Enable {0}', nls_1.nls.localizeByDefault(breakpoint));
}
function nlsDisableBreakpoint(breakpoint) {
    return nls_1.nls.localizeByDefault('Disable {0}', nls_1.nls.localizeByDefault(breakpoint));
}
var DebugCommands;
(function (DebugCommands) {
    DebugCommands.DEBUG_CATEGORY = 'Debug';
    DebugCommands.DEBUG_CATEGORY_KEY = nls_1.nls.getDefaultKey(DebugCommands.DEBUG_CATEGORY);
    DebugCommands.START = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.start',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Start Debugging',
        iconClass: (0, browser_1.codicon)('debug-alt')
    });
    DebugCommands.START_NO_DEBUG = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.run',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Start Without Debugging'
    });
    DebugCommands.STOP = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.stop',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Stop',
        iconClass: (0, browser_1.codicon)('debug-stop')
    });
    DebugCommands.RESTART = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.restart',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Restart',
    });
    DebugCommands.OPEN_CONFIGURATIONS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.configurations.open',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Open Configurations'
    });
    DebugCommands.ADD_CONFIGURATION = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.configurations.add',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add Configuration...'
    });
    DebugCommands.STEP_OVER = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.stepOver',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Step Over',
        iconClass: (0, browser_1.codicon)('debug-step-over')
    });
    DebugCommands.STEP_INTO = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.stepInto',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Step Into',
        iconClass: (0, browser_1.codicon)('debug-step-into')
    });
    DebugCommands.STEP_OUT = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.stepOut',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Step Out',
        iconClass: (0, browser_1.codicon)('debug-step-out')
    });
    DebugCommands.CONTINUE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.continue',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Continue',
        iconClass: (0, browser_1.codicon)('debug-continue')
    });
    DebugCommands.PAUSE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.debug.pause',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Pause',
        iconClass: (0, browser_1.codicon)('debug-pause')
    });
    DebugCommands.CONTINUE_ALL = common_1.Command.toLocalizedCommand({
        id: 'debug.thread.continue.all',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Continue All',
        iconClass: (0, browser_1.codicon)('debug-continue')
    }, 'theia/debug/continueAll', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.PAUSE_ALL = common_1.Command.toLocalizedCommand({
        id: 'debug.thread.pause.all',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Pause All',
        iconClass: (0, browser_1.codicon)('debug-pause')
    }, 'theia/debug/pauseAll', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.TOGGLE_BREAKPOINT = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.debug.action.toggleBreakpoint',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Toggle Breakpoint',
    });
    DebugCommands.INLINE_BREAKPOINT = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.debug.action.inlineBreakpoint',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Inline Breakpoint',
    });
    DebugCommands.ADD_CONDITIONAL_BREAKPOINT = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.add.conditional',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add Conditional Breakpoint...',
    });
    DebugCommands.ADD_LOGPOINT = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.add.logpoint',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add Logpoint...',
    });
    DebugCommands.ADD_FUNCTION_BREAKPOINT = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.add.function',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add Function Breakpoint',
    });
    DebugCommands.ENABLE_ALL_BREAKPOINTS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.enableAll',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Enable All Breakpoints',
    });
    DebugCommands.DISABLE_ALL_BREAKPOINTS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.disableAll',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Disable All Breakpoints',
    });
    DebugCommands.EDIT_BREAKPOINT = common_1.Command.toLocalizedCommand({
        id: 'debug.breakpoint.edit',
        category: DebugCommands.DEBUG_CATEGORY,
        originalLabel: 'Edit Breakpoint...',
        label: nlsEditBreakpoint('Breakpoint')
    }, '', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.EDIT_LOGPOINT = common_1.Command.toLocalizedCommand({
        id: 'debug.logpoint.edit',
        category: DebugCommands.DEBUG_CATEGORY,
        originalLabel: 'Edit Logpoint...',
        label: nlsEditBreakpoint('Logpoint')
    }, '', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.EDIT_BREAKPOINT_CONDITION = common_1.Command.toLocalizedCommand({
        id: 'debug.breakpoint.editCondition',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Edit Condition...'
    }, '', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.REMOVE_BREAKPOINT = common_1.Command.toLocalizedCommand({
        id: 'debug.breakpoint.remove',
        category: DebugCommands.DEBUG_CATEGORY,
        originalLabel: 'Remove Breakpoint',
        label: nlsRemoveBreakpoint('Breakpoint')
    }, '', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.REMOVE_LOGPOINT = common_1.Command.toLocalizedCommand({
        id: 'debug.logpoint.remove',
        category: DebugCommands.DEBUG_CATEGORY,
        originalLabel: 'Remove Logpoint',
        label: nlsRemoveBreakpoint('Logpoint')
    }, '', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.REMOVE_ALL_BREAKPOINTS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.breakpoint.removeAll',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Remove All Breakpoints',
    });
    DebugCommands.TOGGLE_BREAKPOINTS_ENABLED = common_1.Command.toLocalizedCommand({
        id: 'debug.breakpoint.toggleEnabled'
    });
    DebugCommands.SHOW_HOVER = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.debug.action.showDebugHover',
        label: 'Debug: Show Hover'
    });
    DebugCommands.JUMP_TO_CURSOR = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.debug.action.jumpToCursor',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Jump to Cursor'
    });
    DebugCommands.RESTART_FRAME = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.frame.restart',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Restart Frame',
    });
    DebugCommands.COPY_CALL_STACK = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.callStack.copy',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Copy Call Stack',
    });
    DebugCommands.SET_VARIABLE_VALUE = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.variable.setValue',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Set Value',
    });
    DebugCommands.COPY_VARIABLE_VALUE = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.variable.copyValue',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Copy Value',
    });
    DebugCommands.COPY_VARIABLE_AS_EXPRESSION = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.variable.copyAsExpression',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Copy as Expression',
    });
    DebugCommands.WATCH_VARIABLE = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.variable.watch',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add to Watch',
    });
    DebugCommands.ADD_WATCH_EXPRESSION = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.watch.addExpression',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Add Expression'
    });
    DebugCommands.EDIT_WATCH_EXPRESSION = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.watch.editExpression',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Edit Expression'
    });
    DebugCommands.COPY_WATCH_EXPRESSION_VALUE = common_1.Command.toLocalizedCommand({
        id: 'debug.watch.copyExpressionValue',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Copy Expression Value'
    }, 'theia/debug/copyExpressionValue', DebugCommands.DEBUG_CATEGORY_KEY);
    DebugCommands.REMOVE_WATCH_EXPRESSION = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.watch.removeExpression',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Remove Expression'
    });
    DebugCommands.COLLAPSE_ALL_WATCH_EXPRESSIONS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.watch.collapseAllExpressions',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Collapse All'
    });
    DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS = common_1.Command.toDefaultLocalizedCommand({
        id: 'debug.watch.removeAllExpressions',
        category: DebugCommands.DEBUG_CATEGORY,
        label: 'Remove All Expressions'
    });
})(DebugCommands || (exports.DebugCommands = DebugCommands = {}));
var DebugThreadContextCommands;
(function (DebugThreadContextCommands) {
    DebugThreadContextCommands.STEP_OVER = {
        id: 'debug.thread.context.context.next'
    };
    DebugThreadContextCommands.STEP_INTO = {
        id: 'debug.thread.context.stepin'
    };
    DebugThreadContextCommands.STEP_OUT = {
        id: 'debug.thread.context.stepout'
    };
    DebugThreadContextCommands.CONTINUE = {
        id: 'debug.thread.context.continue'
    };
    DebugThreadContextCommands.PAUSE = {
        id: 'debug.thread.context.pause'
    };
    DebugThreadContextCommands.TERMINATE = {
        id: 'debug.thread.context.terminate'
    };
})(DebugThreadContextCommands || (exports.DebugThreadContextCommands = DebugThreadContextCommands = {}));
var DebugSessionContextCommands;
(function (DebugSessionContextCommands) {
    DebugSessionContextCommands.STOP = {
        id: 'debug.session.context.stop'
    };
    DebugSessionContextCommands.RESTART = {
        id: 'debug.session.context.restart'
    };
    DebugSessionContextCommands.PAUSE_ALL = {
        id: 'debug.session.context.pauseAll'
    };
    DebugSessionContextCommands.CONTINUE_ALL = {
        id: 'debug.session.context.continueAll'
    };
    DebugSessionContextCommands.REVEAL = {
        id: 'debug.session.context.reveal'
    };
})(DebugSessionContextCommands || (exports.DebugSessionContextCommands = DebugSessionContextCommands = {}));
var DebugEditorContextCommands;
(function (DebugEditorContextCommands) {
    DebugEditorContextCommands.ADD_BREAKPOINT = {
        id: 'debug.editor.context.addBreakpoint'
    };
    DebugEditorContextCommands.ADD_CONDITIONAL_BREAKPOINT = {
        id: 'debug.editor.context.addBreakpoint.conditional'
    };
    DebugEditorContextCommands.ADD_LOGPOINT = {
        id: 'debug.editor.context.add.logpoint'
    };
    DebugEditorContextCommands.REMOVE_BREAKPOINT = {
        id: 'debug.editor.context.removeBreakpoint'
    };
    DebugEditorContextCommands.EDIT_BREAKPOINT = {
        id: 'debug.editor.context.edit.breakpoint'
    };
    DebugEditorContextCommands.ENABLE_BREAKPOINT = {
        id: 'debug.editor.context.enableBreakpoint'
    };
    DebugEditorContextCommands.DISABLE_BREAKPOINT = {
        id: 'debug.editor.context.disableBreakpoint'
    };
    DebugEditorContextCommands.REMOVE_LOGPOINT = {
        id: 'debug.editor.context.logpoint.remove'
    };
    DebugEditorContextCommands.EDIT_LOGPOINT = {
        id: 'debug.editor.context.logpoint.edit'
    };
    DebugEditorContextCommands.ENABLE_LOGPOINT = {
        id: 'debug.editor.context.logpoint.enable'
    };
    DebugEditorContextCommands.DISABLE_LOGPOINT = {
        id: 'debug.editor.context.logpoint.disable'
    };
    DebugEditorContextCommands.JUMP_TO_CURSOR = {
        id: 'debug.editor.context.jumpToCursor'
    };
})(DebugEditorContextCommands || (exports.DebugEditorContextCommands = DebugEditorContextCommands = {}));
var DebugBreakpointWidgetCommands;
(function (DebugBreakpointWidgetCommands) {
    DebugBreakpointWidgetCommands.ACCEPT = {
        id: 'debug.breakpointWidget.accept'
    };
    DebugBreakpointWidgetCommands.CLOSE = {
        id: 'debug.breakpointWidget.close'
    };
})(DebugBreakpointWidgetCommands || (exports.DebugBreakpointWidgetCommands = DebugBreakpointWidgetCommands = {}));
let DebugFrontendApplicationContribution = class DebugFrontendApplicationContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: debug_widget_1.DebugWidget.ID,
            widgetName: debug_widget_1.DebugWidget.LABEL,
            defaultWidgetOptions: {
                area: 'left',
                rank: 400
            },
            toggleCommandId: 'debug:toggle',
            toggleKeybinding: 'ctrlcmd+shift+d'
        });
        this.firstSessionStart = true;
    }
    async initializeLayout() {
        await this.openView();
    }
    async onStart() {
        this.manager.onDidCreateDebugSession(session => this.openSession(session, { reveal: false }));
        this.manager.onDidStartDebugSession(session => {
            const { noDebug } = session.configuration;
            const openDebug = session.configuration.openDebug || this.preference['debug.openDebug'];
            const internalConsoleOptions = session.configuration.internalConsoleOptions || this.preference['debug.internalConsoleOptions'];
            if (internalConsoleOptions === 'openOnSessionStart' ||
                (internalConsoleOptions === 'openOnFirstSessionStart' && this.firstSessionStart)) {
                this.console.openView({
                    reveal: true,
                    activate: false,
                });
            }
            const shouldOpenDebug = openDebug === 'openOnSessionStart' || (openDebug === 'openOnFirstSessionStart' && this.firstSessionStart);
            // Do not open debug view when suppressed via configuration
            if (!noDebug && !this.getOption(session, 'suppressDebugView') && shouldOpenDebug) {
                this.openSession(session);
            }
            this.firstSessionStart = false;
        });
        this.manager.onDidStopDebugSession(session => {
            const { openDebug } = session.configuration;
            if (!this.getOption(session, 'suppressDebugView') && openDebug === 'openOnDebugBreak') {
                this.openSession(session);
            }
        });
        this.updateStatusBar();
        this.manager.onDidChange(() => this.updateStatusBar());
        this.schemaUpdater.update();
        this.configurations.load();
        this.breakpointManager.load();
        this.watchManager.load();
    }
    onStop() {
        this.configurations.save();
        this.breakpointManager.save();
        this.watchManager.save();
    }
    onWillStop() {
        if (this.preference['debug.confirmOnExit'] === 'always' && this.manager.currentSession) {
            return {
                reason: 'active-debug-sessions',
                action: async () => {
                    if (this.manager.currentSession) {
                        const msg = this.manager.sessions.length === 1
                            ? nls_1.nls.localizeByDefault('There is an active debug session, are you sure you want to stop it?')
                            : nls_1.nls.localizeByDefault('There are active debug sessions, are you sure you want to stop them?');
                        const safeToExit = await new browser_1.ConfirmDialog({
                            title: '',
                            msg,
                            ok: nls_1.nls.localizeByDefault('Stop Debugging'),
                            cancel: browser_1.Dialog.CANCEL,
                        }).open();
                        return safeToExit === true;
                    }
                    return true;
                },
            };
        }
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        const registerMenuActions = (menuPath, ...commands) => {
            for (const [index, command] of commands.entries()) {
                const label = command.label;
                const debug = `${DebugCommands.DEBUG_CATEGORY}:`;
                menus.registerMenuAction(menuPath, {
                    commandId: command.id,
                    label: label && label.startsWith(debug) && label.slice(debug.length).trimStart() || label,
                    icon: command.iconClass,
                    order: String.fromCharCode('a'.charCodeAt(0) + index)
                });
            }
        };
        menus.registerSubmenu(DebugMenus.DEBUG, nls_1.nls.localizeByDefault('Run'));
        registerMenuActions(DebugMenus.DEBUG_CONTROLS, DebugCommands.START, DebugCommands.START_NO_DEBUG, DebugCommands.STOP, DebugCommands.RESTART);
        registerMenuActions(DebugMenus.DEBUG_CONFIGURATION, DebugCommands.OPEN_CONFIGURATIONS, DebugCommands.ADD_CONFIGURATION);
        registerMenuActions(DebugMenus.DEBUG_THREADS, DebugCommands.CONTINUE, DebugCommands.STEP_OVER, DebugCommands.STEP_INTO, DebugCommands.STEP_OUT, DebugCommands.PAUSE);
        registerMenuActions(DebugMenus.DEBUG_SESSIONS, DebugCommands.CONTINUE_ALL, DebugCommands.PAUSE_ALL);
        registerMenuActions(DebugMenus.DEBUG_BREAKPOINT, DebugCommands.TOGGLE_BREAKPOINT);
        menus.registerSubmenu(DebugMenus.DEBUG_NEW_BREAKPOINT, nls_1.nls.localizeByDefault('New Breakpoint'));
        registerMenuActions(DebugMenus.DEBUG_NEW_BREAKPOINT, DebugCommands.ADD_CONDITIONAL_BREAKPOINT, DebugCommands.INLINE_BREAKPOINT, DebugCommands.ADD_FUNCTION_BREAKPOINT, DebugCommands.ADD_LOGPOINT);
        registerMenuActions(DebugMenus.DEBUG_BREAKPOINTS, DebugCommands.ENABLE_ALL_BREAKPOINTS, DebugCommands.DISABLE_ALL_BREAKPOINTS, DebugCommands.REMOVE_ALL_BREAKPOINTS);
        registerMenuActions(debug_threads_widget_1.DebugThreadsWidget.CONTROL_MENU, { ...DebugCommands.PAUSE, ...DebugThreadContextCommands.PAUSE }, { ...DebugCommands.CONTINUE, ...DebugThreadContextCommands.CONTINUE }, { ...DebugCommands.STEP_OVER, ...DebugThreadContextCommands.STEP_OVER }, { ...DebugCommands.STEP_INTO, ...DebugThreadContextCommands.STEP_INTO }, { ...DebugCommands.STEP_OUT, ...DebugThreadContextCommands.STEP_OUT }, { ...DebugCommands.PAUSE_ALL, ...DebugSessionContextCommands.PAUSE_ALL }, { ...DebugCommands.CONTINUE_ALL, ...DebugSessionContextCommands.CONTINUE_ALL });
        registerMenuActions(debug_threads_widget_1.DebugThreadsWidget.TERMINATE_MENU, { ...DebugCommands.RESTART, ...DebugSessionContextCommands.RESTART }, { ...DebugCommands.STOP, ...DebugSessionContextCommands.STOP }, { ...DebugThreadContextCommands.TERMINATE, label: nls_1.nls.localizeByDefault('Terminate Thread') });
        registerMenuActions(debug_threads_widget_1.DebugThreadsWidget.OPEN_MENU, { ...DebugSessionContextCommands.REVEAL, label: nls_1.nls.localize('theia/debug/reveal', 'Reveal') });
        registerMenuActions(debug_stack_frames_widget_1.DebugStackFramesWidget.CONTEXT_MENU, DebugCommands.RESTART_FRAME, DebugCommands.COPY_CALL_STACK);
        registerMenuActions(debug_variables_widget_1.DebugVariablesWidget.EDIT_MENU, DebugCommands.SET_VARIABLE_VALUE, DebugCommands.COPY_VARIABLE_VALUE, DebugCommands.COPY_VARIABLE_AS_EXPRESSION);
        registerMenuActions(debug_variables_widget_1.DebugVariablesWidget.WATCH_MENU, DebugCommands.WATCH_VARIABLE);
        registerMenuActions(debug_watch_widget_1.DebugWatchWidget.EDIT_MENU, DebugCommands.EDIT_WATCH_EXPRESSION, DebugCommands.COPY_WATCH_EXPRESSION_VALUE);
        registerMenuActions(debug_watch_widget_1.DebugWatchWidget.REMOVE_MENU, DebugCommands.REMOVE_WATCH_EXPRESSION, DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS);
        registerMenuActions(debug_breakpoints_widget_1.DebugBreakpointsWidget.EDIT_MENU, DebugCommands.EDIT_BREAKPOINT, DebugCommands.EDIT_LOGPOINT, DebugCommands.EDIT_BREAKPOINT_CONDITION);
        registerMenuActions(debug_breakpoints_widget_1.DebugBreakpointsWidget.REMOVE_MENU, DebugCommands.REMOVE_BREAKPOINT, DebugCommands.REMOVE_LOGPOINT, DebugCommands.REMOVE_ALL_BREAKPOINTS);
        registerMenuActions(debug_breakpoints_widget_1.DebugBreakpointsWidget.ENABLE_MENU, DebugCommands.ENABLE_ALL_BREAKPOINTS, DebugCommands.DISABLE_ALL_BREAKPOINTS);
        const DEBUG_EDITOR_CONTEXT_MENU_GROUP = [...browser_2.EDITOR_CONTEXT_MENU, '2_debug'];
        registerMenuActions(DEBUG_EDITOR_CONTEXT_MENU_GROUP, DebugCommands.JUMP_TO_CURSOR);
        registerMenuActions(debug_editor_model_1.DebugEditorModel.CONTEXT_MENU, { ...DebugEditorContextCommands.ADD_BREAKPOINT, label: nls_1.nls.localizeByDefault('Add Breakpoint') }, { ...DebugEditorContextCommands.ADD_CONDITIONAL_BREAKPOINT, label: DebugCommands.ADD_CONDITIONAL_BREAKPOINT.label }, { ...DebugEditorContextCommands.ADD_LOGPOINT, label: DebugCommands.ADD_LOGPOINT.label }, { ...DebugEditorContextCommands.REMOVE_BREAKPOINT, label: DebugCommands.REMOVE_BREAKPOINT.label }, { ...DebugEditorContextCommands.EDIT_BREAKPOINT, label: DebugCommands.EDIT_BREAKPOINT.label }, { ...DebugEditorContextCommands.ENABLE_BREAKPOINT, label: nlsEnableBreakpoint('Breakpoint') }, { ...DebugEditorContextCommands.DISABLE_BREAKPOINT, label: nlsDisableBreakpoint('Breakpoint') }, { ...DebugEditorContextCommands.REMOVE_LOGPOINT, label: DebugCommands.REMOVE_LOGPOINT.label }, { ...DebugEditorContextCommands.EDIT_LOGPOINT, label: DebugCommands.EDIT_LOGPOINT.label }, { ...DebugEditorContextCommands.ENABLE_LOGPOINT, label: nlsEnableBreakpoint('Logpoint') }, { ...DebugEditorContextCommands.DISABLE_LOGPOINT, label: nlsDisableBreakpoint('Logpoint') }, { ...DebugEditorContextCommands.JUMP_TO_CURSOR, label: nls_1.nls.localizeByDefault('Jump to Cursor') });
        menus.linkSubmenu(browser_2.EDITOR_LINENUMBER_CONTEXT_MENU, debug_editor_model_1.DebugEditorModel.CONTEXT_MENU, { role: 1 /* CompoundMenuNodeRole.Group */ });
    }
    registerCommands(registry) {
        super.registerCommands(registry);
        registry.registerCommand(DebugCommands.START, {
            execute: (config) => this.start(false, config)
        });
        registry.registerCommand(DebugCommands.START_NO_DEBUG, {
            execute: (config) => this.start(true, config)
        });
        registry.registerCommand(DebugCommands.STOP, {
            execute: () => this.manager.terminateSession(),
            isEnabled: () => this.manager.state !== debug_session_1.DebugState.Inactive
        });
        registry.registerCommand(DebugCommands.RESTART, {
            execute: () => this.manager.restartSession(),
            isEnabled: () => this.manager.state !== debug_session_1.DebugState.Inactive
        });
        registry.registerCommand(DebugCommands.OPEN_CONFIGURATIONS, {
            execute: () => this.configurations.openConfiguration()
        });
        registry.registerCommand(DebugCommands.ADD_CONFIGURATION, {
            execute: () => this.configurations.addConfiguration()
        });
        registry.registerCommand(DebugCommands.STEP_OVER, {
            execute: () => this.manager.currentThread && this.manager.currentThread.stepOver(),
            isEnabled: () => this.manager.state === debug_session_1.DebugState.Stopped
        });
        registry.registerCommand(DebugCommands.STEP_INTO, {
            execute: () => this.manager.currentThread && this.manager.currentThread.stepIn(),
            isEnabled: () => this.manager.state === debug_session_1.DebugState.Stopped
        });
        registry.registerCommand(DebugCommands.STEP_OUT, {
            execute: () => this.manager.currentThread && this.manager.currentThread.stepOut(),
            isEnabled: () => this.manager.state === debug_session_1.DebugState.Stopped
        });
        registry.registerCommand(DebugCommands.CONTINUE, {
            execute: () => this.manager.currentThread && this.manager.currentThread.continue(),
            isEnabled: () => this.manager.state === debug_session_1.DebugState.Stopped
        });
        registry.registerCommand(DebugCommands.PAUSE, {
            execute: () => this.manager.currentThread && this.manager.currentThread.pause(),
            isEnabled: () => this.manager.state === debug_session_1.DebugState.Running
        });
        registry.registerCommand(DebugCommands.PAUSE_ALL, {
            execute: () => this.manager.currentSession && this.manager.currentSession.pauseAll(),
            isEnabled: () => !!this.manager.currentSession && !!this.manager.currentSession.runningThreads.next().value
        });
        registry.registerCommand(DebugCommands.CONTINUE_ALL, {
            execute: () => this.manager.currentSession && this.manager.currentSession.continueAll(),
            isEnabled: () => !!this.manager.currentSession && !!this.manager.currentSession.stoppedThreads.next().value
        });
        registry.registerCommand(DebugThreadContextCommands.STEP_OVER, {
            execute: () => this.selectedThread && this.selectedThread.stepOver(),
            isEnabled: () => !!this.selectedThread && this.selectedThread.stopped,
            isVisible: () => !!this.selectedThread
        });
        registry.registerCommand(DebugThreadContextCommands.STEP_INTO, {
            execute: () => this.selectedThread && this.selectedThread.stepIn(),
            isEnabled: () => !!this.selectedThread && this.selectedThread.stopped,
            isVisible: () => !!this.selectedThread
        });
        registry.registerCommand(DebugThreadContextCommands.STEP_OUT, {
            execute: () => this.selectedThread && this.selectedThread.stepOut(),
            isEnabled: () => !!this.selectedThread && this.selectedThread.stopped,
            isVisible: () => !!this.selectedThread
        });
        registry.registerCommand(DebugThreadContextCommands.CONTINUE, {
            execute: () => this.selectedThread && this.selectedThread.continue(),
            isEnabled: () => !!this.selectedThread && this.selectedThread.stopped,
            isVisible: () => !!this.selectedThread && this.selectedThread.stopped,
        });
        registry.registerCommand(DebugThreadContextCommands.PAUSE, {
            execute: () => this.selectedThread && this.selectedThread.pause(),
            isEnabled: () => !!this.selectedThread && !this.selectedThread.stopped,
            isVisible: () => !!this.selectedThread && !this.selectedThread.stopped,
        });
        registry.registerCommand(DebugThreadContextCommands.TERMINATE, {
            execute: () => this.selectedThread && this.selectedThread.terminate(),
            isEnabled: () => !!this.selectedThread && this.selectedThread.supportsTerminate,
            isVisible: () => !!this.selectedThread && this.selectedThread.supportsTerminate
        });
        registry.registerCommand(DebugSessionContextCommands.STOP, {
            execute: () => this.selectedSession && this.manager.terminateSession(this.selectedSession),
            isEnabled: () => !!this.selectedSession && this.selectedSession.state !== debug_session_1.DebugState.Inactive,
            isVisible: () => !this.selectedThread
        });
        registry.registerCommand(DebugSessionContextCommands.RESTART, {
            execute: () => this.selectedSession && this.manager.restartSession(this.selectedSession),
            isEnabled: () => !!this.selectedSession && this.selectedSession.state !== debug_session_1.DebugState.Inactive,
            isVisible: () => !this.selectedThread
        });
        registry.registerCommand(DebugSessionContextCommands.CONTINUE_ALL, {
            execute: () => this.selectedSession && this.selectedSession.continueAll(),
            isEnabled: () => !!this.selectedSession && !!this.selectedSession.stoppedThreads.next().value,
            isVisible: () => !this.selectedThread
        });
        registry.registerCommand(DebugSessionContextCommands.PAUSE_ALL, {
            execute: () => this.selectedSession && this.selectedSession.pauseAll(),
            isEnabled: () => !!this.selectedSession && !!this.selectedSession.runningThreads.next().value,
            isVisible: () => !this.selectedThread
        });
        registry.registerCommand(DebugSessionContextCommands.REVEAL, {
            execute: () => this.selectedSession && this.revealSession(this.selectedSession),
            isEnabled: () => Boolean(this.selectedSession),
            isVisible: () => !this.selectedThread && Boolean(this.selectedSession)
        });
        registry.registerCommand(DebugCommands.TOGGLE_BREAKPOINT, {
            execute: () => this.editors.toggleBreakpoint(),
            isEnabled: () => !!this.editors.model
        });
        registry.registerCommand(DebugCommands.INLINE_BREAKPOINT, {
            execute: () => this.editors.addInlineBreakpoint(),
            isEnabled: () => !!this.editors.model && !this.editors.getInlineBreakpoint()
        });
        registry.registerCommand(DebugCommands.ADD_CONDITIONAL_BREAKPOINT, {
            execute: () => this.editors.addBreakpoint('condition'),
            isEnabled: () => !!this.editors.model && !this.editors.anyBreakpoint()
        });
        registry.registerCommand(DebugCommands.ADD_LOGPOINT, {
            execute: () => this.editors.addBreakpoint('logMessage'),
            isEnabled: () => !!this.editors.model && !this.editors.anyBreakpoint()
        });
        registry.registerCommand(DebugCommands.ADD_FUNCTION_BREAKPOINT, {
            execute: async () => {
                const { labelProvider, breakpointManager, editorManager } = this;
                const options = { labelProvider, breakpoints: breakpointManager, editorManager };
                await new debug_function_breakpoint_1.DebugFunctionBreakpoint(breakpoint_marker_1.FunctionBreakpoint.create({ name: '' }), options).open();
            },
            isEnabled: widget => !(widget instanceof browser_1.Widget) || widget instanceof debug_breakpoints_widget_1.DebugBreakpointsWidget,
            isVisible: widget => !(widget instanceof browser_1.Widget) || widget instanceof debug_breakpoints_widget_1.DebugBreakpointsWidget
        });
        registry.registerCommand(DebugCommands.ENABLE_ALL_BREAKPOINTS, {
            execute: () => this.breakpointManager.enableAllBreakpoints(true),
            isEnabled: () => this.breakpointManager.hasBreakpoints()
        });
        registry.registerCommand(DebugCommands.DISABLE_ALL_BREAKPOINTS, {
            execute: () => this.breakpointManager.enableAllBreakpoints(false),
            isEnabled: () => this.breakpointManager.hasBreakpoints()
        });
        registry.registerCommand(DebugCommands.EDIT_BREAKPOINT, {
            execute: async () => {
                const { selectedBreakpoint, selectedFunctionBreakpoint } = this;
                if (selectedBreakpoint) {
                    await this.editors.editBreakpoint(selectedBreakpoint);
                }
                else if (selectedFunctionBreakpoint) {
                    await selectedFunctionBreakpoint.open();
                }
            },
            isEnabled: () => !!this.selectedBreakpoint || !!this.selectedFunctionBreakpoint,
            isVisible: () => !!this.selectedBreakpoint || !!this.selectedFunctionBreakpoint
        });
        registry.registerCommand(DebugCommands.EDIT_LOGPOINT, {
            execute: async () => {
                const { selectedLogpoint } = this;
                if (selectedLogpoint) {
                    await this.editors.editBreakpoint(selectedLogpoint);
                }
            },
            isEnabled: () => !!this.selectedLogpoint,
            isVisible: () => !!this.selectedLogpoint
        });
        registry.registerCommand(DebugCommands.EDIT_BREAKPOINT_CONDITION, {
            execute: async () => {
                const { selectedExceptionBreakpoint } = this;
                if (selectedExceptionBreakpoint) {
                    await selectedExceptionBreakpoint.editCondition();
                }
            },
            isEnabled: () => { var _a; return !!((_a = this.selectedExceptionBreakpoint) === null || _a === void 0 ? void 0 : _a.data.raw.supportsCondition); },
            isVisible: () => { var _a; return !!((_a = this.selectedExceptionBreakpoint) === null || _a === void 0 ? void 0 : _a.data.raw.supportsCondition); }
        });
        registry.registerCommand(DebugCommands.REMOVE_BREAKPOINT, {
            execute: () => {
                const selectedBreakpoint = this.selectedSettableBreakpoint;
                if (selectedBreakpoint) {
                    selectedBreakpoint.remove();
                }
            },
            isEnabled: () => Boolean(this.selectedSettableBreakpoint),
            isVisible: () => Boolean(this.selectedSettableBreakpoint),
        });
        registry.registerCommand(DebugCommands.REMOVE_LOGPOINT, {
            execute: () => {
                const { selectedLogpoint } = this;
                if (selectedLogpoint) {
                    selectedLogpoint.remove();
                }
            },
            isEnabled: () => !!this.selectedLogpoint,
            isVisible: () => !!this.selectedLogpoint
        });
        registry.registerCommand(DebugCommands.REMOVE_ALL_BREAKPOINTS, {
            execute: () => this.breakpointManager.removeBreakpoints(),
            isEnabled: () => this.breakpointManager.hasBreakpoints(),
            isVisible: widget => !(widget instanceof browser_1.Widget) || (widget instanceof debug_breakpoints_widget_1.DebugBreakpointsWidget)
        });
        registry.registerCommand(DebugCommands.TOGGLE_BREAKPOINTS_ENABLED, {
            execute: () => this.breakpointManager.breakpointsEnabled = !this.breakpointManager.breakpointsEnabled,
            isVisible: arg => arg instanceof debug_breakpoints_widget_1.DebugBreakpointsWidget
        });
        registry.registerCommand(DebugCommands.SHOW_HOVER, {
            execute: () => this.editors.showHover(),
            isEnabled: () => this.editors.canShowHover()
        });
        registry.registerCommand(DebugCommands.JUMP_TO_CURSOR, {
            execute: () => {
                const model = this.editors.model;
                if (model && this.manager.currentThread) {
                    this.manager.currentThread.jumpToCursor(model.editor.getResourceUri(), model.position);
                }
            },
            isEnabled: () => !!this.manager.currentThread && this.manager.currentThread.supportsGoto,
            isVisible: () => !!this.manager.currentThread && this.manager.currentThread.supportsGoto
        });
        registry.registerCommand(DebugCommands.RESTART_FRAME, {
            execute: () => this.selectedFrame && this.selectedFrame.restart(),
            isEnabled: () => !!this.selectedFrame
        });
        registry.registerCommand(DebugCommands.COPY_CALL_STACK, {
            execute: () => {
                const { frames } = this;
                const selection = document.getSelection();
                if (frames && selection) {
                    selection.selectAllChildren(frames.node);
                    document.execCommand('copy');
                }
            },
            isEnabled: () => document.queryCommandSupported('copy'),
            isVisible: () => document.queryCommandSupported('copy')
        });
        registry.registerCommand(DebugCommands.SET_VARIABLE_VALUE, {
            execute: () => this.selectedVariable && this.selectedVariable.open(),
            isEnabled: () => !!this.selectedVariable && this.selectedVariable.supportSetVariable && !this.selectedVariable.readOnly,
            isVisible: () => !!this.selectedVariable && this.selectedVariable.supportSetVariable
        });
        registry.registerCommand(DebugCommands.COPY_VARIABLE_VALUE, {
            execute: () => this.selectedVariable && this.selectedVariable.copyValue(),
            isEnabled: () => !!this.selectedVariable && this.selectedVariable.supportCopyValue,
            isVisible: () => !!this.selectedVariable && this.selectedVariable.supportCopyValue
        });
        registry.registerCommand(DebugCommands.COPY_VARIABLE_AS_EXPRESSION, {
            execute: () => this.selectedVariable && this.selectedVariable.copyAsExpression(),
            isEnabled: () => !!this.selectedVariable && this.selectedVariable.supportCopyAsExpression,
            isVisible: () => !!this.selectedVariable && this.selectedVariable.supportCopyAsExpression
        });
        registry.registerCommand(DebugCommands.WATCH_VARIABLE, {
            execute: () => {
                const { selectedVariable, watch } = this;
                if (selectedVariable && watch) {
                    watch.viewModel.addWatchExpression(selectedVariable.name);
                }
            },
            isEnabled: () => !!this.selectedVariable && !!this.watch,
            isVisible: () => !!this.selectedVariable && !!this.watch,
        });
        // Debug context menu commands
        registry.registerCommand(DebugEditorContextCommands.ADD_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.toggleBreakpoint(this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.ADD_CONDITIONAL_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.addBreakpoint('condition', this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.ADD_LOGPOINT, {
            execute: position => this.isPosition(position) && this.editors.addBreakpoint('logMessage', this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !this.editors.anyBreakpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.REMOVE_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.toggleBreakpoint(this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !!this.editors.getBreakpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getBreakpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.EDIT_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.editBreakpoint(this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !!this.editors.getBreakpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getBreakpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.ENABLE_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.setBreakpointEnabled(this.asPosition(position), true),
            isEnabled: position => this.isPosition(position) && this.editors.getBreakpointEnabled(this.asPosition(position)) === false,
            isVisible: position => this.isPosition(position) && this.editors.getBreakpointEnabled(this.asPosition(position)) === false
        });
        registry.registerCommand(DebugEditorContextCommands.DISABLE_BREAKPOINT, {
            execute: position => this.isPosition(position) && this.editors.setBreakpointEnabled(this.asPosition(position), false),
            isEnabled: position => this.isPosition(position) && !!this.editors.getBreakpointEnabled(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getBreakpointEnabled(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.REMOVE_LOGPOINT, {
            execute: position => this.isPosition(position) && this.editors.toggleBreakpoint(this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !!this.editors.getLogpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getLogpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.EDIT_LOGPOINT, {
            execute: position => this.isPosition(position) && this.editors.editBreakpoint(this.asPosition(position)),
            isEnabled: position => this.isPosition(position) && !!this.editors.getLogpoint(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getLogpoint(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.ENABLE_LOGPOINT, {
            execute: position => this.isPosition(position) && this.editors.setBreakpointEnabled(this.asPosition(position), true),
            isEnabled: position => this.isPosition(position) && this.editors.getLogpointEnabled(this.asPosition(position)) === false,
            isVisible: position => this.isPosition(position) && this.editors.getLogpointEnabled(this.asPosition(position)) === false
        });
        registry.registerCommand(DebugEditorContextCommands.DISABLE_LOGPOINT, {
            execute: position => this.isPosition(position) && this.editors.setBreakpointEnabled(this.asPosition(position), false),
            isEnabled: position => this.isPosition(position) && !!this.editors.getLogpointEnabled(this.asPosition(position)),
            isVisible: position => this.isPosition(position) && !!this.editors.getLogpointEnabled(this.asPosition(position))
        });
        registry.registerCommand(DebugEditorContextCommands.JUMP_TO_CURSOR, {
            execute: position => {
                if (this.isPosition(position) && this.editors.currentUri && this.manager.currentThread) {
                    this.manager.currentThread.jumpToCursor(this.editors.currentUri, this.asPosition(position));
                }
            },
            isEnabled: () => !!this.manager.currentThread && this.manager.currentThread.supportsGoto,
            isVisible: () => !!this.manager.currentThread && this.manager.currentThread.supportsGoto
        });
        registry.registerCommand(DebugBreakpointWidgetCommands.ACCEPT, {
            execute: () => this.editors.acceptBreakpoint()
        });
        registry.registerCommand(DebugBreakpointWidgetCommands.CLOSE, {
            execute: () => this.editors.closeBreakpoint()
        });
        registry.registerCommand(DebugCommands.ADD_WATCH_EXPRESSION, {
            execute: widget => {
                if (widget instanceof browser_1.Widget) {
                    if (widget instanceof debug_watch_widget_1.DebugWatchWidget) {
                        widget.viewModel.addWatchExpression();
                    }
                }
                else if (this.watch) {
                    this.watch.viewModel.addWatchExpression();
                }
            },
            isEnabled: widget => widget instanceof browser_1.Widget ? widget instanceof debug_watch_widget_1.DebugWatchWidget : !!this.watch,
            isVisible: widget => widget instanceof browser_1.Widget ? widget instanceof debug_watch_widget_1.DebugWatchWidget : !!this.watch
        });
        registry.registerCommand(DebugCommands.EDIT_WATCH_EXPRESSION, {
            execute: () => {
                const { watchExpression } = this;
                if (watchExpression) {
                    watchExpression.open();
                }
            },
            isEnabled: () => !!this.watchExpression,
            isVisible: () => !!this.watchExpression
        });
        registry.registerCommand(DebugCommands.COPY_WATCH_EXPRESSION_VALUE, {
            execute: () => this.watchExpression && this.watchExpression.copyValue(),
            isEnabled: () => !!this.watchExpression && this.watchExpression.supportCopyValue,
            isVisible: () => !!this.watchExpression && this.watchExpression.supportCopyValue
        });
        registry.registerCommand(DebugCommands.COLLAPSE_ALL_WATCH_EXPRESSIONS, {
            execute: widget => {
                if (widget instanceof debug_watch_widget_1.DebugWatchWidget) {
                    const root = widget.model.root;
                    widget.model.collapseAll(browser_1.CompositeTreeNode.is(root) ? root : undefined);
                }
            },
            isEnabled: widget => widget instanceof debug_watch_widget_1.DebugWatchWidget,
            isVisible: widget => widget instanceof debug_watch_widget_1.DebugWatchWidget
        });
        registry.registerCommand(DebugCommands.REMOVE_WATCH_EXPRESSION, {
            execute: () => {
                const { watch, watchExpression } = this;
                if (watch && watchExpression) {
                    watch.viewModel.removeWatchExpression(watchExpression);
                }
            },
            isEnabled: () => !!this.watchExpression,
            isVisible: () => !!this.watchExpression
        });
        registry.registerCommand(DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS, {
            execute: widget => {
                if (widget instanceof browser_1.Widget) {
                    if (widget instanceof debug_watch_widget_1.DebugWatchWidget) {
                        widget.viewModel.removeWatchExpressions();
                    }
                }
                else if (this.watch) {
                    this.watch.viewModel.removeWatchExpressions();
                }
            },
            isEnabled: widget => widget instanceof browser_1.Widget ? widget instanceof debug_watch_widget_1.DebugWatchWidget : !!this.watch,
            isVisible: widget => widget instanceof browser_1.Widget ? widget instanceof debug_watch_widget_1.DebugWatchWidget : !!this.watch
        });
    }
    registerKeybindings(keybindings) {
        super.registerKeybindings(keybindings);
        keybindings.registerKeybinding({
            command: DebugCommands.START.id,
            keybinding: 'f5'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.START_NO_DEBUG.id,
            keybinding: 'ctrl+f5'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.STOP.id,
            keybinding: 'shift+f5',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.RESTART.id,
            keybinding: 'shift+ctrlcmd+f5',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.STEP_OVER.id,
            keybinding: 'f10',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.STEP_INTO.id,
            keybinding: 'f11',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.STEP_OUT.id,
            keybinding: 'shift+f11',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.CONTINUE.id,
            keybinding: 'f5',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.PAUSE.id,
            keybinding: 'f6',
            when: 'inDebugMode'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.TOGGLE_BREAKPOINT.id,
            keybinding: 'f9',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: DebugCommands.INLINE_BREAKPOINT.id,
            keybinding: 'shift+f9',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: DebugBreakpointWidgetCommands.ACCEPT.id,
            keybinding: 'enter',
            when: 'breakpointWidgetFocus'
        });
        keybindings.registerKeybinding({
            command: DebugBreakpointWidgetCommands.CLOSE.id,
            keybinding: 'esc',
            when: 'isBreakpointWidgetVisible || breakpointWidgetFocus'
        });
    }
    registerToolbarItems(toolbar) {
        const onDidChangeToggleBreakpointsEnabled = new common_1.Emitter();
        const toggleBreakpointsEnabled = {
            id: DebugCommands.TOGGLE_BREAKPOINTS_ENABLED.id,
            command: DebugCommands.TOGGLE_BREAKPOINTS_ENABLED.id,
            icon: (0, browser_1.codicon)('activate-breakpoints'),
            onDidChange: onDidChangeToggleBreakpointsEnabled.event,
            priority: 1
        };
        const updateToggleBreakpointsEnabled = () => {
            const activateBreakpoints = nls_1.nls.localizeByDefault('Enable All Breakpoints');
            const deactivateBreakpoints = nls_1.nls.localizeByDefault('Disable All Breakpoints');
            const tooltip = this.breakpointManager.breakpointsEnabled ? deactivateBreakpoints : activateBreakpoints;
            if (toggleBreakpointsEnabled.tooltip !== tooltip) {
                toggleBreakpointsEnabled.tooltip = tooltip;
                onDidChangeToggleBreakpointsEnabled.fire(undefined);
            }
        };
        toolbar.registerItem({
            id: DebugCommands.ADD_FUNCTION_BREAKPOINT.id,
            command: DebugCommands.ADD_FUNCTION_BREAKPOINT.id,
            icon: (0, browser_1.codicon)('add'),
            tooltip: DebugCommands.ADD_FUNCTION_BREAKPOINT.label
        });
        updateToggleBreakpointsEnabled();
        this.breakpointManager.onDidChangeBreakpoints(updateToggleBreakpointsEnabled);
        toolbar.registerItem(toggleBreakpointsEnabled);
        toolbar.registerItem({
            id: DebugCommands.REMOVE_ALL_BREAKPOINTS.id,
            command: DebugCommands.REMOVE_ALL_BREAKPOINTS.id,
            icon: (0, browser_1.codicon)('close-all'),
            priority: 2
        });
        toolbar.registerItem({
            id: DebugCommands.ADD_WATCH_EXPRESSION.id,
            command: DebugCommands.ADD_WATCH_EXPRESSION.id,
            icon: (0, browser_1.codicon)('add'),
            tooltip: DebugCommands.ADD_WATCH_EXPRESSION.label
        });
        toolbar.registerItem({
            id: DebugCommands.COLLAPSE_ALL_WATCH_EXPRESSIONS.id,
            command: DebugCommands.COLLAPSE_ALL_WATCH_EXPRESSIONS.id,
            icon: (0, browser_1.codicon)('collapse-all'),
            tooltip: DebugCommands.COLLAPSE_ALL_WATCH_EXPRESSIONS.label,
            priority: 1
        });
        toolbar.registerItem({
            id: DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS.id,
            command: DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS.id,
            icon: (0, browser_1.codicon)('close-all'),
            tooltip: DebugCommands.REMOVE_ALL_WATCH_EXPRESSIONS.label,
            priority: 2
        });
    }
    async openSession(session, options) {
        const { reveal } = {
            reveal: true,
            ...options
        };
        const debugWidget = await this.openView({ reveal });
        debugWidget.sessionManager.currentSession = session;
        return debugWidget['sessionWidget'];
    }
    revealSession(session) {
        var _a;
        const widget = (_a = this.tryGetWidget()) === null || _a === void 0 ? void 0 : _a['sessionWidget'];
        if (widget) {
            this.shell.revealWidget(widget.id);
        }
        return widget;
    }
    async start(noDebug, debugSessionOptions) {
        let current = debugSessionOptions ? debugSessionOptions : this.configurations.current;
        // If no configurations are currently present, create the `launch.json` and prompt users to select the config.
        if (!current) {
            await this.configurations.addConfiguration();
            return;
        }
        if (noDebug !== undefined) {
            if (current.configuration) {
                current = {
                    ...current,
                    configuration: {
                        ...current.configuration,
                        noDebug
                    }
                };
            }
            else {
                current = {
                    ...current,
                    noDebug
                };
            }
        }
        await this.manager.start(current);
    }
    get threads() {
        const { currentWidget } = this.shell;
        return currentWidget instanceof debug_threads_widget_1.DebugThreadsWidget && currentWidget || undefined;
    }
    get selectedSession() {
        const { threads } = this;
        return threads && threads.selectedElement instanceof debug_session_1.DebugSession && threads.selectedElement || undefined;
    }
    get selectedThread() {
        const { threads } = this;
        return threads && threads.selectedElement instanceof debug_thread_1.DebugThread && threads.selectedElement || undefined;
    }
    get frames() {
        const { currentWidget } = this.shell;
        return currentWidget instanceof debug_stack_frames_widget_1.DebugStackFramesWidget && currentWidget || undefined;
    }
    get selectedFrame() {
        const { frames } = this;
        return frames && frames.selectedElement instanceof debug_stack_frame_1.DebugStackFrame && frames.selectedElement || undefined;
    }
    get breakpoints() {
        const { currentWidget } = this.shell;
        return currentWidget instanceof debug_breakpoints_widget_1.DebugBreakpointsWidget && currentWidget || undefined;
    }
    get selectedAnyBreakpoint() {
        const { breakpoints } = this;
        const selectedElement = breakpoints && breakpoints.selectedElement;
        return selectedElement instanceof debug_breakpoint_1.DebugBreakpoint ? selectedElement : undefined;
    }
    get selectedBreakpoint() {
        const breakpoint = this.selectedAnyBreakpoint;
        return breakpoint && breakpoint instanceof debug_source_breakpoint_1.DebugSourceBreakpoint && !breakpoint.logMessage ? breakpoint : undefined;
    }
    get selectedLogpoint() {
        const breakpoint = this.selectedAnyBreakpoint;
        return breakpoint && breakpoint instanceof debug_source_breakpoint_1.DebugSourceBreakpoint && !!breakpoint.logMessage ? breakpoint : undefined;
    }
    get selectedFunctionBreakpoint() {
        const breakpoint = this.selectedAnyBreakpoint;
        return breakpoint && breakpoint instanceof debug_function_breakpoint_1.DebugFunctionBreakpoint ? breakpoint : undefined;
    }
    get selectedInstructionBreakpoint() {
        if (this.selectedAnyBreakpoint instanceof debug_instruction_breakpoint_1.DebugInstructionBreakpoint) {
            return this.selectedAnyBreakpoint;
        }
    }
    get selectedExceptionBreakpoint() {
        const { breakpoints } = this;
        const selectedElement = breakpoints && breakpoints.selectedElement;
        return selectedElement instanceof debug_exception_breakpoint_1.DebugExceptionBreakpoint ? selectedElement : undefined;
    }
    get selectedSettableBreakpoint() {
        const selected = this.selectedAnyBreakpoint;
        if (selected instanceof debug_function_breakpoint_1.DebugFunctionBreakpoint || selected instanceof debug_instruction_breakpoint_1.DebugInstructionBreakpoint || selected instanceof debug_source_breakpoint_1.DebugSourceBreakpoint) {
            return selected;
        }
    }
    get variables() {
        const { currentWidget } = this.shell;
        return currentWidget instanceof debug_variables_widget_1.DebugVariablesWidget && currentWidget || undefined;
    }
    get selectedVariable() {
        const { variables } = this;
        return variables && variables.selectedElement instanceof debug_console_items_1.DebugVariable && variables.selectedElement || undefined;
    }
    get watch() {
        const { currentWidget } = this.shell;
        return currentWidget instanceof debug_watch_widget_1.DebugWatchWidget && currentWidget || undefined;
    }
    get watchExpression() {
        const { watch } = this;
        return watch && watch.selectedElement instanceof debug_watch_expression_1.DebugWatchExpression && watch.selectedElement || undefined;
    }
    isPosition(position) {
        return monaco.Position.isIPosition(position);
    }
    asPosition(position) {
        return monaco.Position.lift(position);
    }
    registerColors(colors) {
        colors.register(
        // Debug colors should be aligned with https://code.visualstudio.com/api/references/theme-color#debug-colors
        {
            id: 'editor.stackFrameHighlightBackground',
            defaults: {
                dark: '#ffff0033',
                light: '#ffff6673',
                hcDark: '#fff600',
                hcLight: '#ffff6673'
            }, description: 'Background color for the highlight of line at the top stack frame position.'
        }, {
            id: 'editor.focusedStackFrameHighlightBackground',
            defaults: {
                dark: '#7abd7a4d',
                light: '#cee7ce73',
                hcDark: '#cee7ce',
                hcLight: '#cee7ce73'
            }, description: 'Background color for the highlight of line at focused stack frame position.'
        }, 
        // Status bar colors should be aligned with debugging colors from https://code.visualstudio.com/api/references/theme-color#status-bar-colors
        {
            id: 'statusBar.debuggingBackground', defaults: {
                dark: '#CC6633',
                light: '#CC6633',
                hcDark: '#CC6633',
                hcLight: '#B5200D'
            }, description: 'Status bar background color when a program is being debugged. The status bar is shown in the bottom of the window'
        }, {
            id: 'statusBar.debuggingForeground', defaults: {
                dark: 'statusBar.foreground',
                light: 'statusBar.foreground',
                hcDark: 'statusBar.foreground',
                hcLight: 'statusBar.foreground'
            }, description: 'Status bar foreground color when a program is being debugged. The status bar is shown in the bottom of the window'
        }, {
            id: 'statusBar.debuggingBorder', defaults: {
                dark: 'statusBar.border',
                light: 'statusBar.border',
                hcDark: 'statusBar.border',
                hcLight: 'statusBar.border'
            }, description: 'Status bar border color separating to the sidebar and editor when a program is being debugged. The status bar is shown in the bottom of the window'
        }, 
        // Debug Exception Widget colors should be aligned with
        // https://github.com/microsoft/vscode/blob/ff5f581425da6230b6f9216ecf19abf6c9d285a6/src/vs/workbench/contrib/debug/browser/exceptionWidget.ts#L23
        {
            id: 'debugExceptionWidget.border', defaults: {
                dark: '#a31515',
                light: '#a31515',
                hcDark: '#a31515',
                hcLight: '#a31515'
            }, description: 'Exception widget border color.',
        }, {
            id: 'debugExceptionWidget.background', defaults: {
                dark: '#420b0d',
                light: '#f1dfde',
                hcDark: '#420b0d',
                hcLight: '#f1dfde'
            }, description: 'Exception widget background color.'
        }, 
        // Debug Icon colors should be aligned with
        // https://code.visualstudio.com/api/references/theme-color#debug-icons-colors
        {
            id: 'debugIcon.breakpointForeground', defaults: {
                dark: '#E51400',
                light: '#E51400',
                hcDark: '#E51400',
                hcLight: '#E51400'
            },
            description: 'Icon color for breakpoints.'
        }, {
            id: 'debugIcon.breakpointDisabledForeground', defaults: {
                dark: '#848484',
                light: '#848484',
                hcDark: '#848484',
                hcLight: '#848484'
            },
            description: 'Icon color for disabled breakpoints.'
        }, {
            id: 'debugIcon.breakpointUnverifiedForeground', defaults: {
                dark: '#848484',
                light: '#848484',
                hcDark: '#848484',
                hcLight: '#848484'
            },
            description: 'Icon color for unverified breakpoints.'
        }, {
            id: 'debugIcon.breakpointCurrentStackframeForeground', defaults: {
                dark: '#FFCC00',
                light: '#BE8700',
                hcDark: '#FFCC00',
                hcLight: '#BE8700'
            },
            description: 'Icon color for the current breakpoint stack frame.'
        }, {
            id: 'debugIcon.breakpointStackframeForeground', defaults: {
                dark: '#89D185',
                light: '#89D185',
                hcDark: '#89D185',
                hcLight: '#89D185'
            },
            description: 'Icon color for all breakpoint stack frames.'
        }, {
            id: 'debugIcon.startForeground', defaults: {
                dark: '#89D185',
                light: '#388A34',
                hcDark: '#89D185',
                hcLight: '#388A34'
            }, description: 'Debug toolbar icon for start debugging.'
        }, {
            id: 'debugIcon.pauseForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC'
            }, description: 'Debug toolbar icon for pause.'
        }, {
            id: 'debugIcon.stopForeground', defaults: {
                dark: '#F48771',
                light: '#A1260D',
                hcDark: '#F48771',
                hcLight: '#A1260D'
            }, description: 'Debug toolbar icon for stop.'
        }, {
            id: 'debugIcon.disconnectForeground', defaults: {
                dark: '#F48771',
                light: '#A1260D',
                hcDark: '#F48771',
                hcLight: '#A1260D'
            }, description: 'Debug toolbar icon for disconnect.'
        }, {
            id: 'debugIcon.restartForeground', defaults: {
                dark: '#89D185',
                light: '#388A34',
                hcDark: '#89D185',
                hcLight: '#388A34'
            }, description: 'Debug toolbar icon for restart.'
        }, {
            id: 'debugIcon.stepOverForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC',
            }, description: 'Debug toolbar icon for step over.'
        }, {
            id: 'debugIcon.stepIntoForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC'
            }, description: 'Debug toolbar icon for step into.'
        }, {
            id: 'debugIcon.stepOutForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC',
            }, description: 'Debug toolbar icon for step over.'
        }, {
            id: 'debugIcon.continueForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC'
            }, description: 'Debug toolbar icon for continue.'
        }, {
            id: 'debugIcon.stepBackForeground', defaults: {
                dark: '#75BEFF',
                light: '#007ACC',
                hcDark: '#75BEFF',
                hcLight: '#007ACC'
            }, description: 'Debug toolbar icon for step back.'
        }, {
            id: 'debugConsole.infoForeground', defaults: {
                dark: 'editorInfo.foreground',
                light: 'editorInfo.foreground',
                hcDark: 'foreground',
                hcLight: 'foreground'
            }, description: 'Foreground color for info messages in debug REPL console.'
        }, {
            id: 'debugConsole.warningForeground', defaults: {
                dark: 'editorWarning.foreground',
                light: 'editorWarning.foreground',
                hcDark: '#008000',
                hcLight: 'editorWarning.foreground'
            },
            description: 'Foreground color for warning messages in debug REPL console.'
        }, {
            id: 'debugConsole.errorForeground', defaults: {
                dark: 'errorForeground',
                light: 'errorForeground',
                hcDark: 'errorForeground',
                hcLight: 'errorForeground'
            },
            description: 'Foreground color for error messages in debug REPL console.',
        }, {
            id: 'debugConsole.sourceForeground', defaults: {
                dark: 'foreground',
                light: 'foreground',
                hcDark: 'foreground',
                hcLight: 'foreground'
            },
            description: 'Foreground color for source filenames in debug REPL console.',
        }, {
            id: 'debugConsoleInputIcon.foreground', defaults: {
                dark: 'foreground',
                light: 'foreground',
                hcDark: 'foreground',
                hcLight: 'foreground'
            },
            description: 'Foreground color for debug console input marker icon.'
        });
    }
    updateStatusBar() {
        if (this.debuggingStatusBar === document.body.classList.contains('theia-mod-debugging')) {
            return;
        }
        document.body.classList.toggle('theia-mod-debugging');
    }
    get debuggingStatusBar() {
        if (this.manager.state < debug_session_1.DebugState.Running) {
            return false;
        }
        const session = this.manager.currentSession;
        if (session) {
            if (session.configuration.noDebug) {
                return false;
            }
            if (this.getOption(session, 'suppressDebugStatusbar')) {
                return false;
            }
        }
        return true;
    }
    getOption(session, option) {
        // If session is undefined there will be no option
        if (!session) {
            return false;
        }
        // If undefined take the value of the parent
        if (option in session.configuration && session.configuration[option] !== undefined) {
            return session.configuration[option];
        }
        return this.getOption(session.parentSession, option);
    }
};
exports.DebugFrontendApplicationContribution = DebugFrontendApplicationContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_service_1.DebugService),
    tslib_1.__metadata("design:type", Object)
], DebugFrontendApplicationContribution.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugFrontendApplicationContribution.prototype, "manager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], DebugFrontendApplicationContribution.prototype, "configurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugFrontendApplicationContribution.prototype, "breakpointManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_service_1.DebugEditorService),
    tslib_1.__metadata("design:type", debug_editor_service_1.DebugEditorService)
], DebugFrontendApplicationContribution.prototype, "editors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_console_contribution_1.DebugConsoleContribution),
    tslib_1.__metadata("design:type", debug_console_contribution_1.DebugConsoleContribution)
], DebugFrontendApplicationContribution.prototype, "console", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_schema_updater_1.DebugSchemaUpdater),
    tslib_1.__metadata("design:type", debug_schema_updater_1.DebugSchemaUpdater)
], DebugFrontendApplicationContribution.prototype, "schemaUpdater", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_preferences_1.DebugPreferences),
    tslib_1.__metadata("design:type", Object)
], DebugFrontendApplicationContribution.prototype, "preference", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_watch_manager_1.DebugWatchManager),
    tslib_1.__metadata("design:type", debug_watch_manager_1.DebugWatchManager)
], DebugFrontendApplicationContribution.prototype, "watchManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], DebugFrontendApplicationContribution.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], DebugFrontendApplicationContribution.prototype, "editorManager", void 0);
exports.DebugFrontendApplicationContribution = DebugFrontendApplicationContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], DebugFrontendApplicationContribution);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-preferences.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-preferences.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindDebugPreferences = exports.createDebugPreferences = exports.DebugPreferences = exports.DebugPreferenceContribution = exports.DebugConfiguration = exports.debugPreferencesSchema = void 0;
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
exports.debugPreferencesSchema = {
    type: 'object',
    properties: {
        'debug.trace': {
            type: 'boolean',
            default: false,
            description: nls_1.nls.localize('theia/debug/toggleTracing', 'Enable/disable tracing communications with debug adapters')
        },
        'debug.openDebug': {
            enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart', 'openOnDebugBreak'],
            default: 'openOnSessionStart',
            description: nls_1.nls.localizeByDefault('Controls when the debug view should open.')
        },
        'debug.internalConsoleOptions': {
            enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],
            default: 'openOnFirstSessionStart',
            description: nls_1.nls.localizeByDefault('Controls when the internal Debug Console should open.')
        },
        'debug.inlineValues': {
            type: 'boolean',
            default: false,
            description: nls_1.nls.localizeByDefault('Show variable values inline in editor while debugging.')
        },
        'debug.showInStatusBar': {
            enum: ['never', 'always', 'onFirstSessionStart'],
            enumDescriptions: [
                nls_1.nls.localizeByDefault('Never show debug in Status bar'),
                nls_1.nls.localizeByDefault('Always show debug in Status bar'),
                nls_1.nls.localizeByDefault('Show debug in Status bar only after debug was started for the first time')
            ],
            description: nls_1.nls.localizeByDefault('Controls when the debug Status bar should be visible.'),
            default: 'onFirstSessionStart'
        },
        'debug.confirmOnExit': {
            description: 'Controls whether to confirm when the window closes if there are active debug sessions.',
            type: 'string',
            enum: ['never', 'always'],
            enumDescriptions: [
                'Never confirm.',
                'Always confirm if there are debug sessions.',
            ],
            default: 'never'
        },
        'debug.disassemblyView.showSourceCode': {
            description: nls_1.nls.localizeByDefault('Show Source Code in Disassembly View.'),
            type: 'boolean',
            default: true,
        }
    }
};
class DebugConfiguration {
}
exports.DebugConfiguration = DebugConfiguration;
exports.DebugPreferenceContribution = Symbol('DebugPreferenceContribution');
exports.DebugPreferences = Symbol('DebugPreferences');
function createDebugPreferences(preferences, schema = exports.debugPreferencesSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createDebugPreferences = createDebugPreferences;
function bindDebugPreferences(bind) {
    bind(exports.DebugPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.DebugPreferenceContribution);
        return createDebugPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.DebugPreferenceContribution).toConstantValue({ schema: exports.debugPreferencesSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.DebugPreferenceContribution);
}
exports.bindDebugPreferences = bindDebugPreferences;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-schema-updater.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-schema-updater.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.launchSchemaId = exports.DebugSchemaUpdater = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const json_schema_store_1 = __webpack_require__(/*! @theia/core/lib/browser/json-schema-store */ "../node_modules/@theia/core/lib/browser/json-schema-store.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const debug_service_1 = __webpack_require__(/*! ../common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const debug_preferences_1 = __webpack_require__(/*! ./debug-preferences */ "../node_modules/@theia/debug/lib/browser/debug-preferences.js");
const variable_input_schema_1 = __webpack_require__(/*! @theia/variable-resolver/lib/browser/variable-input-schema */ "../node_modules/@theia/variable-resolver/lib/browser/variable-input-schema.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const debug_compound_1 = __webpack_require__(/*! ../common/debug-compound */ "../node_modules/@theia/debug/lib/common/debug-compound.js");
let DebugSchemaUpdater = class DebugSchemaUpdater {
    constructor() {
        this.uri = new uri_1.default(exports.launchSchemaId);
    }
    init() {
        this.jsonStorage.setSchema(this.uri, '');
    }
    registerSchemas(context) {
        context.registerSchema({
            fileMatch: ['launch.json'],
            url: this.uri.toString()
        });
        this.workspaceService.updateSchema('launch', { $ref: this.uri.toString() });
    }
    async update() {
        const types = await this.debug.debugTypes();
        const schema = { ...(0, common_1.deepClone)(launchSchema) };
        const items = schema.properties['configurations'].items;
        const attributePromises = types.map(type => this.debug.getSchemaAttributes(type));
        for (const attributes of await Promise.all(attributePromises)) {
            for (const attribute of attributes) {
                const properties = {};
                for (const key of ['debugViewLocation', 'openDebug', 'internalConsoleOptions']) {
                    properties[key] = debug_preferences_1.debugPreferencesSchema.properties[`debug.${key}`];
                }
                attribute.properties = Object.assign(properties, attribute.properties);
                items.oneOf.push(attribute);
            }
        }
        items.defaultSnippets.push(...await this.debug.getConfigurationSnippets());
        this.jsonStorage.setSchema(this.uri, schema);
    }
};
exports.DebugSchemaUpdater = DebugSchemaUpdater;
tslib_1.__decorate([
    (0, inversify_1.inject)(json_schema_store_1.JsonSchemaDataStore),
    tslib_1.__metadata("design:type", json_schema_store_1.JsonSchemaDataStore)
], DebugSchemaUpdater.prototype, "jsonStorage", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], DebugSchemaUpdater.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_service_1.DebugService),
    tslib_1.__metadata("design:type", Object)
], DebugSchemaUpdater.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugSchemaUpdater.prototype, "init", null);
exports.DebugSchemaUpdater = DebugSchemaUpdater = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugSchemaUpdater);
exports.launchSchemaId = 'vscode://schemas/launch';
const launchSchema = {
    $id: exports.launchSchemaId,
    type: 'object',
    title: common_1.nls.localizeByDefault('Launch'),
    required: [],
    default: { version: '0.2.0', configurations: [], compounds: [] },
    properties: {
        version: {
            type: 'string',
            description: common_1.nls.localizeByDefault('Version of this file format.'),
            default: '0.2.0'
        },
        configurations: {
            type: 'array',
            description: common_1.nls.localizeByDefault('List of configurations. Add new configurations or edit existing ones by using IntelliSense.'),
            items: {
                defaultSnippets: [],
                'type': 'object',
                oneOf: []
            }
        },
        compounds: {
            type: 'array',
            description: common_1.nls.localizeByDefault('List of compounds. Each compound references multiple configurations which will get launched together.'),
            items: {
                type: 'object',
                required: ['name', 'configurations'],
                properties: {
                    name: {
                        type: 'string',
                        description: common_1.nls.localizeByDefault('Name of compound. Appears in the launch configuration drop down menu.')
                    },
                    configurations: {
                        type: 'array',
                        default: [],
                        items: {
                            oneOf: [{
                                    type: 'string',
                                    description: common_1.nls.localizeByDefault('Please use unique configuration names.')
                                }, {
                                    type: 'object',
                                    required: ['name'],
                                    properties: {
                                        name: {
                                            enum: [],
                                            description: common_1.nls.localizeByDefault('Name of compound. Appears in the launch configuration drop down menu.')
                                        },
                                        folder: {
                                            enum: [],
                                            description: common_1.nls.localizeByDefault('Name of folder in which the compound is located.')
                                        }
                                    }
                                }]
                        },
                        description: common_1.nls.localizeByDefault('Names of configurations that will be started as part of this compound.')
                    },
                    stopAll: {
                        type: 'boolean',
                        default: false,
                        description: common_1.nls.localizeByDefault('Controls whether manually terminating one session will stop all of the compound sessions.')
                    },
                    preLaunchTask: {
                        type: 'string',
                        default: '',
                        description: common_1.nls.localizeByDefault('Task to run before any of the compound configurations start.')
                    }
                },
                default: debug_compound_1.defaultCompound
            },
            default: [debug_compound_1.defaultCompound]
        },
        inputs: variable_input_schema_1.inputsSchema.definitions.inputs
    },
    allowComments: true,
    allowTrailingCommas: true,
};


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session-configuration-label-provider.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session-configuration-label-provider.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2025 and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSessionConfigurationLabelProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
/**
 * Provides a label for the debug session without the need to create the session.
 * Debug session labels are used to check if sessions are the "same".
 */
let DebugSessionConfigurationLabelProvider = class DebugSessionConfigurationLabelProvider {
    // https://github.com/microsoft/vscode/blob/907518a25c6d6b9467cbcc57132c6adb7e7396b0/src/vs/workbench/contrib/debug/browser/debugSession.ts#L253-L256
    getLabel(params, includeRoot = this.workspaceService.tryGetRoots().length > 1) {
        let { name, workspaceFolderUri } = params;
        if (includeRoot && workspaceFolderUri) {
            const uri = new uri_1.default(workspaceFolderUri);
            const path = uri.path;
            const basenameOrAuthority = path.name || uri.authority;
            name += ` (${basenameOrAuthority})`;
        }
        return name;
    }
};
exports.DebugSessionConfigurationLabelProvider = DebugSessionConfigurationLabelProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], DebugSessionConfigurationLabelProvider.prototype, "workspaceService", void 0);
exports.DebugSessionConfigurationLabelProvider = DebugSessionConfigurationLabelProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugSessionConfigurationLabelProvider);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session-connection.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session-connection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSessionConnection = exports.DebugEventTypes = void 0;
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
var DebugEventTypes;
(function (DebugEventTypes) {
    function isStandardEvent(event) {
        return standardDebugEvents.has(event);
    }
    DebugEventTypes.isStandardEvent = isStandardEvent;
    ;
})(DebugEventTypes || (exports.DebugEventTypes = DebugEventTypes = {}));
const standardDebugEvents = new Set([
    'breakpoint',
    'capabilities',
    'continued',
    'exited',
    'initialized',
    'invalidated',
    'loadedSource',
    'module',
    'output',
    'process',
    'progressEnd',
    'progressStart',
    'progressUpdate',
    'stopped',
    'terminated',
    'thread'
]);
class DebugSessionConnection {
    constructor(sessionId, connectionFactory, traceOutputChannel) {
        this.sessionId = sessionId;
        this.traceOutputChannel = traceOutputChannel;
        this.sequence = 1;
        this.pendingRequests = new Map();
        this.requestHandlers = new Map();
        this.onDidCustomEventEmitter = new core_1.Emitter();
        this.onDidCustomEvent = this.onDidCustomEventEmitter.event;
        this.onDidCloseEmitter = new core_1.Emitter();
        this.onDidClose = this.onDidCloseEmitter.event;
        this.isClosed = false;
        this.toDispose = new core_1.DisposableCollection(this.onDidCustomEventEmitter, core_1.Disposable.create(() => this.pendingRequests.clear()), core_1.Disposable.create(() => this.emitters.clear()));
        this.allThreadsContinued = true;
        this.emitters = new Map();
        this.connectionPromise = this.createConnection(connectionFactory);
    }
    get disposed() {
        return this.toDispose.disposed;
    }
    checkDisposed() {
        if (this.disposed) {
            throw new Error('the debug session connection is disposed, id: ' + this.sessionId);
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
    async createConnection(connectionFactory) {
        const connection = await connectionFactory(this.sessionId);
        connection.onClose(() => {
            this.isClosed = true;
            this.cancelPendingRequests();
            this.onDidCloseEmitter.fire();
        });
        connection.onMessage(data => this.handleMessage(data));
        return connection;
    }
    async sendRequest(command, args, timeout) {
        const result = await this.doSendRequest(command, args, timeout);
        if (command === 'next' || command === 'stepIn' ||
            command === 'stepOut' || command === 'stepBack' ||
            command === 'reverseContinue' || command === 'restartFrame') {
            this.fireContinuedEvent(args.threadId);
        }
        if (command === 'continue') {
            const response = result;
            const allThreadsContinued = response && response.body && response.body.allThreadsContinued;
            if (allThreadsContinued !== undefined) {
                this.allThreadsContinued = result.body.allThreadsContinued;
            }
            this.fireContinuedEvent(args.threadId, this.allThreadsContinued);
            return result;
        }
        return result;
    }
    sendCustomRequest(command, args) {
        return this.doSendRequest(command, args);
    }
    cancelPendingRequests() {
        this.pendingRequests.forEach((deferred, requestId) => {
            deferred.reject(new Error(`Request ${requestId} cancelled on connection close`));
        });
    }
    doSendRequest(command, args, timeout) {
        const result = new promise_util_1.Deferred();
        if (this.isClosed) {
            result.reject(new Error('Connection is closed'));
        }
        else {
            const request = {
                seq: this.sequence++,
                type: 'request',
                command: command,
                arguments: args
            };
            this.pendingRequests.set(request.seq, result);
            if (timeout) {
                const handle = setTimeout(() => {
                    const pendingRequest = this.pendingRequests.get(request.seq);
                    if (pendingRequest) {
                        // request has not been handled
                        this.pendingRequests.delete(request.seq);
                        const error = {
                            type: 'response',
                            seq: 0,
                            request_seq: request.seq,
                            success: false,
                            command,
                            message: `Request #${request.seq}: ${request.command} timed out`
                        };
                        pendingRequest.reject(error);
                    }
                }, timeout);
                result.promise.finally(() => clearTimeout(handle));
            }
            this.send(request);
        }
        return result.promise;
    }
    async send(message) {
        const connection = await this.connectionPromise;
        const messageStr = JSON.stringify(message);
        if (this.traceOutputChannel) {
            const now = new Date();
            const dateStr = `${now.toLocaleString(undefined, { hour12: false })}.${now.getMilliseconds()}`;
            this.traceOutputChannel.appendLine(`${this.sessionId.substring(0, 8)} ${dateStr} theia -> adapter: ${JSON.stringify(message, undefined, 4)}`);
        }
        connection.send(messageStr);
    }
    handleMessage(data) {
        const message = JSON.parse(data);
        if (this.traceOutputChannel) {
            const now = new Date();
            const dateStr = `${now.toLocaleString(undefined, { hour12: false })}.${now.getMilliseconds()}`;
            this.traceOutputChannel.appendLine(`${this.sessionId.substring(0, 8)} ${dateStr} theia <- adapter: ${JSON.stringify(message, undefined, 4)}`);
        }
        if (message.type === 'request') {
            this.handleRequest(message);
        }
        else if (message.type === 'response') {
            this.handleResponse(message);
        }
        else if (message.type === 'event') {
            this.handleEvent(message);
        }
    }
    handleResponse(response) {
        const pendingRequest = this.pendingRequests.get(response.request_seq);
        if (pendingRequest) {
            this.pendingRequests.delete(response.request_seq);
            if (!response.success) {
                pendingRequest.reject(response);
            }
            else {
                pendingRequest.resolve(response);
            }
        }
    }
    onRequest(command, handler) {
        this.requestHandlers.set(command, handler);
    }
    async handleRequest(request) {
        const response = {
            type: 'response',
            seq: 0,
            command: request.command,
            request_seq: request.seq,
            success: true,
        };
        const handler = this.requestHandlers.get(request.command);
        if (handler) {
            try {
                response.body = await handler(request);
            }
            catch (error) {
                response.success = false;
                response.message = error.message;
            }
        }
        else {
            console.error('Unhandled request', request);
        }
        await this.send(response);
    }
    handleEvent(event) {
        if (event.event === 'continued') {
            this.allThreadsContinued = event.body.allThreadsContinued === false ? false : true;
        }
        if (DebugEventTypes.isStandardEvent(event.event)) {
            this.doFire(event.event, event);
        }
        else {
            this.onDidCustomEventEmitter.fire(event);
        }
    }
    on(kind, listener) {
        return this.getEmitter(kind).event(listener);
    }
    onEvent(kind) {
        return this.getEmitter(kind).event;
    }
    fire(kind, e) {
        this.doFire(kind, e);
    }
    doFire(kind, e) {
        this.getEmitter(kind).fire(e);
    }
    getEmitter(kind) {
        const emitter = this.emitters.get(kind) || this.newEmitter();
        this.emitters.set(kind, emitter);
        return emitter;
    }
    newEmitter() {
        const emitter = new core_1.Emitter();
        this.checkDisposed();
        this.toDispose.push(emitter);
        return emitter;
    }
    fireContinuedEvent(threadId, allThreadsContinued = false) {
        this.fire('continued', {
            type: 'event',
            event: 'continued',
            body: {
                threadId,
                allThreadsContinued
            },
            seq: -1
        });
    }
}
exports.DebugSessionConnection = DebugSessionConnection;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session-contribution.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session-contribution.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultDebugSessionFactory = exports.DebugSessionFactory = exports.DebugSessionContributionRegistryImpl = exports.DebugSessionContributionRegistry = exports.DebugSessionContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const debug_session_1 = __webpack_require__(/*! ./debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const breakpoint_manager_1 = __webpack_require__(/*! ./breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const output_channel_1 = __webpack_require__(/*! @theia/output/lib/browser/output-channel */ "../node_modules/@theia/output/lib/browser/output-channel.js");
const debug_preferences_1 = __webpack_require__(/*! ./debug-preferences */ "../node_modules/@theia/debug/lib/browser/debug-preferences.js");
const debug_session_connection_1 = __webpack_require__(/*! ./debug-session-connection */ "../node_modules/@theia/debug/lib/browser/debug-session-connection.js");
const debug_service_1 = __webpack_require__(/*! ../common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const contribution_provider_1 = __webpack_require__(/*! @theia/core/lib/common/contribution-provider */ "../node_modules/@theia/core/lib/common/contribution-provider.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const debug_contribution_1 = __webpack_require__(/*! ./debug-contribution */ "../node_modules/@theia/debug/lib/browser/debug-contribution.js");
const browser_3 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const service_connection_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/messaging/service-connection-provider */ "../node_modules/@theia/core/lib/browser/messaging/service-connection-provider.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
/**
 * DebugSessionContribution symbol for DI.
 */
exports.DebugSessionContribution = Symbol('DebugSessionContribution');
/**
 * DebugSessionContributionRegistry symbol for DI.
 */
exports.DebugSessionContributionRegistry = Symbol('DebugSessionContributionRegistry');
let DebugSessionContributionRegistryImpl = class DebugSessionContributionRegistryImpl {
    constructor() {
        this.contribs = new Map();
    }
    init() {
        for (const contrib of this.contributions.getContributions()) {
            this.contribs.set(contrib.debugType, contrib);
        }
    }
    get(debugType) {
        return this.contribs.get(debugType);
    }
};
exports.DebugSessionContributionRegistryImpl = DebugSessionContributionRegistryImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(contribution_provider_1.ContributionProvider),
    (0, inversify_1.named)(exports.DebugSessionContribution),
    tslib_1.__metadata("design:type", Object)
], DebugSessionContributionRegistryImpl.prototype, "contributions", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugSessionContributionRegistryImpl.prototype, "init", null);
exports.DebugSessionContributionRegistryImpl = DebugSessionContributionRegistryImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugSessionContributionRegistryImpl);
/**
 * DebugSessionFactory symbol for DI.
 */
exports.DebugSessionFactory = Symbol('DebugSessionFactory');
let DefaultDebugSessionFactory = class DefaultDebugSessionFactory {
    get(manager, sessionId, options, parentSession) {
        const connection = new debug_session_connection_1.DebugSessionConnection(sessionId, () => new Promise(resolve => this.connectionProvider.listen(`${debug_service_1.DebugAdapterPath}/${sessionId}`, (_, wsChannel) => {
            resolve(new debug_service_1.ForwardingDebugChannel(wsChannel));
        }, false)), this.getTraceOutputChannel());
        return new debug_session_1.DebugSession(sessionId, options, parentSession, this.testService, options.testRun, manager, connection, this.terminalService, this.editorManager, this.breakpoints, this.labelProvider, this.messages, this.fileService, this.debugContributionProvider, this.workspaceService);
    }
    getTraceOutputChannel() {
        if (this.debugPreferences['debug.trace']) {
            return this.outputChannelManager.getChannel('Debug adapters');
        }
    }
};
exports.DefaultDebugSessionFactory = DefaultDebugSessionFactory;
tslib_1.__decorate([
    (0, inversify_1.inject)(service_connection_provider_1.RemoteConnectionProvider),
    tslib_1.__metadata("design:type", service_connection_provider_1.ServiceConnectionProvider)
], DefaultDebugSessionFactory.prototype, "connectionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], DefaultDebugSessionFactory.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], DefaultDebugSessionFactory.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DefaultDebugSessionFactory.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], DefaultDebugSessionFactory.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MessageClient),
    tslib_1.__metadata("design:type", common_1.MessageClient)
], DefaultDebugSessionFactory.prototype, "messages", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(output_channel_1.OutputChannelManager),
    tslib_1.__metadata("design:type", output_channel_1.OutputChannelManager)
], DefaultDebugSessionFactory.prototype, "outputChannelManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_preferences_1.DebugPreferences),
    tslib_1.__metadata("design:type", Object)
], DefaultDebugSessionFactory.prototype, "debugPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], DefaultDebugSessionFactory.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(contribution_provider_1.ContributionProvider),
    (0, inversify_1.named)(debug_contribution_1.DebugContribution),
    tslib_1.__metadata("design:type", Object)
], DefaultDebugSessionFactory.prototype, "debugContributionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], DefaultDebugSessionFactory.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.WorkspaceService),
    tslib_1.__metadata("design:type", browser_3.WorkspaceService)
], DefaultDebugSessionFactory.prototype, "workspaceService", void 0);
exports.DefaultDebugSessionFactory = DefaultDebugSessionFactory = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DefaultDebugSessionFactory);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session-manager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSessionManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const quick_open_task_1 = __webpack_require__(/*! @theia/task/lib/browser/quick-open-task */ "../node_modules/@theia/task/lib/browser/quick-open-task.js");
const task_service_1 = __webpack_require__(/*! @theia/task/lib/browser/task-service */ "../node_modules/@theia/task/lib/browser/task-service.js");
const browser_3 = __webpack_require__(/*! @theia/variable-resolver/lib/browser */ "../node_modules/@theia/variable-resolver/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const debug_service_1 = __webpack_require__(/*! ../common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const breakpoint_manager_1 = __webpack_require__(/*! ./breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_configuration_manager_1 = __webpack_require__(/*! ./debug-configuration-manager */ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const debug_session_1 = __webpack_require__(/*! ./debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_session_contribution_1 = __webpack_require__(/*! ./debug-session-contribution */ "../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const debug_session_options_1 = __webpack_require__(/*! ./debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! ./model/debug-source-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const debug_function_breakpoint_1 = __webpack_require__(/*! ./model/debug-function-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js");
const debug_instruction_breakpoint_1 = __webpack_require__(/*! ./model/debug-instruction-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-instruction-breakpoint.js");
const debug_widget_1 = __webpack_require__(/*! ./view/debug-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-widget.js");
const debug_session_configuration_label_provider_1 = __webpack_require__(/*! ./debug-session-configuration-label-provider */ "../node_modules/@theia/debug/lib/browser/debug-session-configuration-label-provider.js");
let DebugSessionManager = class DebugSessionManager {
    constructor() {
        this._sessions = new Map();
        this.onWillStartDebugSessionEmitter = new core_1.Emitter();
        this.onWillStartDebugSession = this.onWillStartDebugSessionEmitter.event;
        this.onWillResolveDebugConfigurationEmitter = new core_1.Emitter();
        this.onWillResolveDebugConfiguration = this.onWillResolveDebugConfigurationEmitter.event;
        this.onDidCreateDebugSessionEmitter = new core_1.Emitter();
        this.onDidCreateDebugSession = this.onDidCreateDebugSessionEmitter.event;
        this.onDidStartDebugSessionEmitter = new core_1.Emitter();
        this.onDidStartDebugSession = this.onDidStartDebugSessionEmitter.event;
        this.onDidStopDebugSessionEmitter = new core_1.Emitter();
        this.onDidStopDebugSession = this.onDidStopDebugSessionEmitter.event;
        this.onDidChangeActiveDebugSessionEmitter = new core_1.Emitter();
        this.onDidChangeActiveDebugSession = this.onDidChangeActiveDebugSessionEmitter.event;
        this.onDidDestroyDebugSessionEmitter = new core_1.Emitter();
        this.onDidDestroyDebugSession = this.onDidDestroyDebugSessionEmitter.event;
        this.onDidReceiveDebugSessionCustomEventEmitter = new core_1.Emitter();
        this.onDidReceiveDebugSessionCustomEvent = this.onDidReceiveDebugSessionCustomEventEmitter.event;
        this.onDidFocusStackFrameEmitter = new core_1.Emitter();
        this.onDidFocusStackFrame = this.onDidFocusStackFrameEmitter.event;
        this.onDidFocusThreadEmitter = new core_1.Emitter();
        this.onDidFocusThread = this.onDidFocusThreadEmitter.event;
        this.onDidChangeBreakpointsEmitter = new core_1.Emitter();
        this.onDidChangeBreakpoints = this.onDidChangeBreakpointsEmitter.event;
        this.onDidChangeEmitter = new core_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.configurationIds = new Map();
        this.disposeOnCurrentSessionChanged = new core_1.DisposableCollection();
    }
    fireDidChangeBreakpoints(event) {
        this.onDidChangeBreakpointsEmitter.fire(event);
    }
    fireDidChange(current) {
        this.debugTypeKey.set(current === null || current === void 0 ? void 0 : current.configuration.type);
        this.inDebugModeKey.set(this.inDebugMode);
        this.debugStateKey.set((0, debug_session_1.debugStateContextValue)(this.state));
        this.onDidChangeEmitter.fire(current);
    }
    init() {
        this.debugTypeKey = this.contextKeyService.createKey('debugType', undefined);
        this.inDebugModeKey = this.contextKeyService.createKey('inDebugMode', this.inDebugMode);
        this.debugStateKey = this.contextKeyService.createKey('debugState', (0, debug_session_1.debugStateContextValue)(this.state));
        this.breakpoints.onDidChangeMarkers(uri => this.fireDidChangeBreakpoints({ uri }));
        this.labelProvider.onDidChange(event => {
            for (const uriString of this.breakpoints.getUris()) {
                const uri = new uri_1.default(uriString);
                if (event.affects(uri)) {
                    this.fireDidChangeBreakpoints({ uri });
                }
            }
        });
    }
    get inDebugMode() {
        return this.state > debug_session_1.DebugState.Inactive;
    }
    isCurrentEditorFrame(uri) {
        var _a, _b;
        return ((_b = (_a = this.currentFrame) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.uri.toString()) === (uri instanceof uri_1.default ? uri : new uri_1.default(uri.toString())).toString();
    }
    async saveAll() {
        if (!this.shell.canSaveAll()) {
            return true; // Nothing to save.
        }
        try {
            await this.shell.saveAll();
            return true;
        }
        catch (error) {
            console.error('saveAll failed:', error);
            return false;
        }
    }
    async start(optionsOrName) {
        if (typeof optionsOrName === 'string') {
            const options = this.debugConfigurationManager.find(optionsOrName);
            return !!options && this.start(options);
        }
        return optionsOrName.configuration ? this.startConfiguration(optionsOrName) : this.startCompound(optionsOrName);
    }
    async startConfiguration(options) {
        return this.progressService.withProgress('Start...', 'debug', async () => {
            try {
                // If a parent session is available saving should be handled by the parent
                if (!options.configuration.parentSessionId && !options.configuration.suppressSaveBeforeStart && !await this.saveAll()) {
                    return undefined;
                }
                await this.fireWillStartDebugSession();
                const resolved = await this.resolveConfiguration(options);
                if (!resolved || !resolved.configuration) {
                    // As per vscode API: https://code.visualstudio.com/api/references/vscode-api#DebugConfigurationProvider
                    // "Returning the value 'undefined' prevents the debug session from starting.
                    // Returning the value 'null' prevents the debug session from starting and opens the
                    // underlying debug configuration instead."
                    // eslint-disable-next-line no-null/no-null
                    if (resolved === null) {
                        this.debugConfigurationManager.openConfiguration();
                    }
                    return undefined;
                }
                const sessionConfigurationLabel = this.sessionConfigurationLabelProvider.getLabel(resolved);
                if ((options === null || options === void 0 ? void 0 : options.startedByUser)
                    && options.configuration.suppressMultipleSessionWarning !== true
                    && this.sessions.some(s => this.sessionConfigurationLabelProvider.getLabel(s.options) === sessionConfigurationLabel)) {
                    const yes = await new browser_1.ConfirmDialog({
                        title: debug_widget_1.DebugWidget.LABEL,
                        msg: core_1.nls.localizeByDefault("'{0}' is already running. Do you want to start another instance?", sessionConfigurationLabel)
                    }).open();
                    if (!yes) {
                        return undefined;
                    }
                }
                // preLaunchTask isn't run in case of auto restart as well as postDebugTask
                if (!options.configuration.__restart) {
                    const taskRun = await this.runTask(options.workspaceFolderUri, resolved.configuration.preLaunchTask, true);
                    if (!taskRun) {
                        return undefined;
                    }
                }
                const sessionId = await this.debug.createDebugSession(resolved.configuration, options.workspaceFolderUri);
                return this.doStart(sessionId, resolved);
            }
            catch (e) {
                if (debug_service_1.DebugError.NotFound.is(e)) {
                    this.messageService.error(`The debug session type "${e.data.type}" is not supported.`);
                    return undefined;
                }
                this.messageService.error('There was an error starting the debug session, check the logs for more details.');
                console.error('Error starting the debug session', e);
                throw e;
            }
        });
    }
    async startCompound(options) {
        let configurations = [];
        const compoundRoot = options.compound.stopAll ? new debug_session_options_1.DebugCompoundRoot() : undefined;
        try {
            configurations = this.getCompoundConfigurations(options, compoundRoot);
        }
        catch (error) {
            this.messageService.error(error.message);
            return;
        }
        if (options.compound.preLaunchTask) {
            const taskRun = await this.runTask(options.workspaceFolderUri, options.compound.preLaunchTask, true);
            if (!taskRun) {
                return undefined;
            }
        }
        // Compound launch is a success only if each configuration launched successfully
        const values = await Promise.all(configurations.map(async (configuration) => {
            const newSession = await this.startConfiguration(configuration);
            if (newSession) {
                compoundRoot === null || compoundRoot === void 0 ? void 0 : compoundRoot.onDidSessionStop(() => newSession.stop(false, () => this.debug.terminateDebugSession(newSession.id)));
            }
            return newSession;
        }));
        const result = values.every(success => !!success);
        return result;
    }
    getCompoundConfigurations(options, compoundRoot) {
        const compound = options.compound;
        if (!compound.configurations) {
            throw new Error(core_1.nls.localizeByDefault('Compound must have "configurations" attribute set in order to start multiple configurations.'));
        }
        const configurations = [];
        for (const configData of compound.configurations) {
            const name = typeof configData === 'string' ? configData : configData.name;
            if (name === compound.name) {
                throw new Error(core_1.nls.localize('theia/debug/compound-cycle', "Launch configuration '{0}' contains a cycle with itself", name));
            }
            const workspaceFolderUri = typeof configData === 'string' ? options.workspaceFolderUri : configData.folder;
            const matchingOptions = [...this.debugConfigurationManager.all]
                .filter(option => option.name === name && !!option.configuration && option.workspaceFolderUri === workspaceFolderUri);
            if (matchingOptions.length === 1) {
                const match = matchingOptions[0];
                if (debug_session_options_1.DebugSessionOptions.isConfiguration(match)) {
                    configurations.push({ ...match, compoundRoot, configuration: { ...match.configuration, noDebug: options.noDebug } });
                }
                else {
                    throw new Error(core_1.nls.localizeByDefault("Could not find launch configuration '{0}' in the workspace.", name));
                }
            }
            else {
                throw new Error(matchingOptions.length === 0
                    ? workspaceFolderUri
                        ? core_1.nls.localizeByDefault("Can not find folder with name '{0}' for configuration '{1}' in compound '{2}'.", workspaceFolderUri, name, compound.name)
                        : core_1.nls.localizeByDefault("Could not find launch configuration '{0}' in the workspace.", name)
                    : core_1.nls.localizeByDefault("There are multiple launch configurations '{0}' in the workspace. Use folder name to qualify the configuration.", name));
            }
        }
        return configurations;
    }
    async fireWillStartDebugSession() {
        await core_1.WaitUntilEvent.fire(this.onWillStartDebugSessionEmitter, {});
    }
    async resolveConfiguration(options) {
        if (debug_session_options_1.InternalDebugSessionOptions.is(options)) {
            return options;
        }
        const { workspaceFolderUri } = options;
        let configuration = await this.resolveDebugConfiguration(options.configuration, workspaceFolderUri);
        if (configuration) {
            // Resolve command variables provided by the debugger
            const commandIdVariables = await this.debug.provideDebuggerVariables(configuration.type);
            configuration = await this.variableResolver.resolve(configuration, {
                context: options.workspaceFolderUri ? new uri_1.default(options.workspaceFolderUri) : undefined,
                configurationSection: 'launch',
                commandIdVariables,
                configuration
            });
            if (configuration) {
                configuration = await this.resolveDebugConfigurationWithSubstitutedVariables(configuration, workspaceFolderUri);
            }
        }
        if (!configuration) {
            return configuration;
        }
        const key = configuration.name + workspaceFolderUri;
        const id = this.configurationIds.has(key) ? this.configurationIds.get(key) + 1 : 0;
        this.configurationIds.set(key, id);
        return {
            id,
            ...options,
            name: configuration.name,
            configuration
        };
    }
    async resolveDebugConfiguration(configuration, workspaceFolderUri) {
        await this.fireWillResolveDebugConfiguration(configuration.type);
        return this.debug.resolveDebugConfiguration(configuration, workspaceFolderUri);
    }
    async fireWillResolveDebugConfiguration(debugType) {
        await core_1.WaitUntilEvent.fire(this.onWillResolveDebugConfigurationEmitter, { debugType });
    }
    async resolveDebugConfigurationWithSubstitutedVariables(configuration, workspaceFolderUri) {
        return this.debug.resolveDebugConfigurationWithSubstitutedVariables(configuration, workspaceFolderUri);
    }
    async doStart(sessionId, options) {
        const parentSession = options.configuration.parentSessionId ? this._sessions.get(options.configuration.parentSessionId) : undefined;
        const contrib = this.sessionContributionRegistry.get(options.configuration.type);
        const sessionFactory = contrib ? contrib.debugSessionFactory() : this.debugSessionFactory;
        const session = sessionFactory.get(this, sessionId, options, parentSession);
        this._sessions.set(sessionId, session);
        this.debugTypeKey.set(session.configuration.type);
        this.onDidCreateDebugSessionEmitter.fire(session);
        let state = debug_session_1.DebugState.Inactive;
        session.onDidChange(() => {
            if (state !== session.state) {
                state = session.state;
                if (state === debug_session_1.DebugState.Stopped) {
                    this.onDidStopDebugSessionEmitter.fire(session);
                }
            }
            this.updateCurrentSession(session);
        });
        session.onDidChangeBreakpoints(uri => this.fireDidChangeBreakpoints({ session, uri }));
        session.on('terminated', async (event) => {
            const restart = event.body && event.body.restart;
            if (restart) {
                // postDebugTask isn't run in case of auto restart as well as preLaunchTask
                this.doRestart(session, !!restart);
            }
            else {
                await session.disconnect(false, () => this.debug.terminateDebugSession(session.id));
                await this.runTask(session.options.workspaceFolderUri, session.configuration.postDebugTask);
            }
        });
        session.on('exited', async (event) => {
            await session.disconnect(false, () => this.debug.terminateDebugSession(session.id));
        });
        session.onDispose(() => this.cleanup(session));
        session.start().then(() => this.onDidStartDebugSessionEmitter.fire(session)).catch(e => {
            session.stop(false, () => {
                this.debug.terminateDebugSession(session.id);
            });
        });
        session.onDidCustomEvent(({ event, body }) => this.onDidReceiveDebugSessionCustomEventEmitter.fire({ event, body, session }));
        return session;
    }
    cleanup(session) {
        if (this.remove(session.id)) {
            this.onDidDestroyDebugSessionEmitter.fire(session);
        }
    }
    async doRestart(session, isRestart) {
        if (session.canRestart()) {
            await session.restart();
            return session;
        }
        const { options, configuration } = session;
        session.stop(isRestart, () => this.debug.terminateDebugSession(session.id));
        configuration.__restart = isRestart;
        return this.start(options);
    }
    async terminateSession(session) {
        if (!session) {
            this.updateCurrentSession(this._currentSession);
            session = this._currentSession;
        }
        if (session) {
            if (session.options.compoundRoot) {
                session.options.compoundRoot.stopSession();
            }
            else if (session.parentSession && session.configuration.lifecycleManagedByParent) {
                this.terminateSession(session.parentSession);
            }
            else {
                session.stop(false, () => this.debug.terminateDebugSession(session.id));
            }
        }
    }
    async restartSession(session) {
        if (!session) {
            this.updateCurrentSession(this._currentSession);
            session = this._currentSession;
        }
        if (session) {
            if (session.parentSession && session.configuration.lifecycleManagedByParent) {
                return this.restartSession(session.parentSession);
            }
            else {
                return this.doRestart(session, true);
            }
        }
    }
    remove(sessionId) {
        const existed = this._sessions.delete(sessionId);
        const { currentSession } = this;
        if (currentSession && currentSession.id === sessionId) {
            this.updateCurrentSession(undefined);
        }
        return existed;
    }
    getSession(sessionId) {
        return this._sessions.get(sessionId);
    }
    get sessions() {
        return Array.from(this._sessions.values()).filter(session => session.state > debug_session_1.DebugState.Inactive);
    }
    get currentSession() {
        return this._currentSession;
    }
    set currentSession(current) {
        if (this._currentSession === current) {
            return;
        }
        this.disposeOnCurrentSessionChanged.dispose();
        const previous = this.currentSession;
        this._currentSession = current;
        this.onDidChangeActiveDebugSessionEmitter.fire({ previous, current });
        if (current) {
            this.disposeOnCurrentSessionChanged.push(current.onDidChange(() => {
                if (this.currentFrame === this.topFrame) {
                    this.open();
                }
                this.fireDidChange(current);
            }));
            this.disposeOnCurrentSessionChanged.push(current.onDidFocusStackFrame(frame => this.onDidFocusStackFrameEmitter.fire(frame)));
            this.disposeOnCurrentSessionChanged.push(current.onDidFocusThread(thread => this.onDidFocusThreadEmitter.fire(thread)));
            const { currentThread } = current;
            this.onDidFocusThreadEmitter.fire(currentThread);
        }
        this.updateBreakpoints(previous, current);
        this.open();
        this.fireDidChange(current);
    }
    open() {
        const { currentFrame } = this;
        if (currentFrame && currentFrame.thread.stopped) {
            currentFrame.open();
        }
    }
    updateBreakpoints(previous, current) {
        const affectedUri = new Set();
        for (const session of [previous, current]) {
            if (session) {
                for (const uriString of session.breakpointUris) {
                    if (!affectedUri.has(uriString)) {
                        affectedUri.add(uriString);
                        this.fireDidChangeBreakpoints({
                            session: current,
                            uri: new uri_1.default(uriString)
                        });
                    }
                }
            }
        }
    }
    updateCurrentSession(session) {
        this.currentSession = session || this.sessions[0];
    }
    get currentThread() {
        const session = this.currentSession;
        return session && session.currentThread;
    }
    get state() {
        const session = this.currentSession;
        return session ? session.state : debug_session_1.DebugState.Inactive;
    }
    get currentFrame() {
        const { currentThread } = this;
        return currentThread && currentThread.currentFrame;
    }
    get topFrame() {
        const { currentThread } = this;
        return currentThread && currentThread.topFrame;
    }
    getFunctionBreakpoints(session = this.currentSession) {
        if (session && session.state > debug_session_1.DebugState.Initializing) {
            return session.getFunctionBreakpoints();
        }
        const { labelProvider, breakpoints, editorManager } = this;
        return this.breakpoints.getFunctionBreakpoints().map(origin => new debug_function_breakpoint_1.DebugFunctionBreakpoint(origin, { labelProvider, breakpoints, editorManager }));
    }
    getInstructionBreakpoints(session = this.currentSession) {
        if (session && session.state > debug_session_1.DebugState.Initializing) {
            return session.getInstructionBreakpoints();
        }
        const { labelProvider, breakpoints, editorManager } = this;
        return this.breakpoints.getInstructionBreakpoints().map(origin => new debug_instruction_breakpoint_1.DebugInstructionBreakpoint(origin, { labelProvider, breakpoints, editorManager }));
    }
    getBreakpoints(arg, arg2) {
        const uri = arg instanceof uri_1.default ? arg : undefined;
        const session = arg instanceof debug_session_1.DebugSession ? arg : arg2 instanceof debug_session_1.DebugSession ? arg2 : this.currentSession;
        if (session && session.state > debug_session_1.DebugState.Initializing) {
            return session.getSourceBreakpoints(uri);
        }
        const { labelProvider, breakpoints, editorManager } = this;
        return this.breakpoints.findMarkers({ uri }).map(({ data }) => new debug_source_breakpoint_1.DebugSourceBreakpoint(data, { labelProvider, breakpoints, editorManager }));
    }
    getLineBreakpoints(uri, line) {
        const session = this.currentSession;
        if (session && session.state > debug_session_1.DebugState.Initializing) {
            return session.getSourceBreakpoints(uri).filter(breakpoint => breakpoint.line === line);
        }
        const { labelProvider, breakpoints, editorManager } = this;
        return this.breakpoints.getLineBreakpoints(uri, line).map(origin => new debug_source_breakpoint_1.DebugSourceBreakpoint(origin, { labelProvider, breakpoints, editorManager }));
    }
    getInlineBreakpoint(uri, line, column) {
        const session = this.currentSession;
        if (session && session.state > debug_session_1.DebugState.Initializing) {
            return session.getSourceBreakpoints(uri).filter(breakpoint => breakpoint.line === line && breakpoint.column === column)[0];
        }
        const origin = this.breakpoints.getInlineBreakpoint(uri, line, column);
        const { labelProvider, breakpoints, editorManager } = this;
        return origin && new debug_source_breakpoint_1.DebugSourceBreakpoint(origin, { labelProvider, breakpoints, editorManager });
    }
    /**
     * Runs the given tasks.
     * @param taskName the task name to run, see [TaskNameResolver](#TaskNameResolver)
     * @return true if it allowed to continue debugging otherwise it returns false
     */
    async runTask(workspaceFolderUri, taskName, checkErrors) {
        if (!taskName) {
            return true;
        }
        const taskInfo = await this.taskService.runWorkspaceTask(this.taskService.startUserAction(), workspaceFolderUri, taskName);
        if (!checkErrors) {
            return true;
        }
        if (!taskInfo) {
            return this.doPostTaskAction(`Could not run the task '${taskName}'.`);
        }
        const getExitCodePromise = this.taskService.getExitCode(taskInfo.taskId).then(result => ({ taskEndedType: task_service_1.TaskEndedTypes.TaskExited, value: result }));
        const isBackgroundTaskEndedPromise = this.taskService.isBackgroundTaskEnded(taskInfo.taskId).then(result => ({ taskEndedType: task_service_1.TaskEndedTypes.BackgroundTaskEnded, value: result }));
        // After start running the task, we wait for the task process to exit and if it is a background task, we also wait for a feedback
        // that a background task is active, as soon as one of the promises fulfills, we can continue and analyze the results.
        const taskEndedInfo = await Promise.race([getExitCodePromise, isBackgroundTaskEndedPromise]);
        if (taskEndedInfo.taskEndedType === task_service_1.TaskEndedTypes.BackgroundTaskEnded && taskEndedInfo.value) {
            return true;
        }
        if (taskEndedInfo.taskEndedType === task_service_1.TaskEndedTypes.TaskExited && taskEndedInfo.value === 0) {
            return true;
        }
        else if (taskEndedInfo.taskEndedType === task_service_1.TaskEndedTypes.TaskExited && taskEndedInfo.value !== undefined) {
            return this.doPostTaskAction(`Task '${taskName}' terminated with exit code ${taskEndedInfo.value}.`);
        }
        else {
            const signal = await this.taskService.getTerminateSignal(taskInfo.taskId);
            if (signal !== undefined) {
                return this.doPostTaskAction(`Task '${taskName}' terminated by signal ${signal}.`);
            }
            else {
                return this.doPostTaskAction(`Task '${taskName}' terminated for unknown reason.`);
            }
        }
    }
    async doPostTaskAction(errorMessage) {
        const actions = ['Open launch.json', 'Cancel', 'Configure Task', 'Debug Anyway'];
        const result = await this.messageService.error(errorMessage, ...actions);
        switch (result) {
            case actions[0]: // open launch.json
                this.debugConfigurationManager.openConfiguration();
                return false;
            case actions[1]: // cancel
                return false;
            case actions[2]: // configure tasks
                this.quickOpenTask.configure();
                return false;
            default: // continue debugging
                return true;
        }
    }
};
exports.DebugSessionManager = DebugSessionManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_contribution_1.DebugSessionFactory),
    tslib_1.__metadata("design:type", Object)
], DebugSessionManager.prototype, "debugSessionFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_service_1.DebugService),
    tslib_1.__metadata("design:type", Object)
], DebugSessionManager.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], DebugSessionManager.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], DebugSessionManager.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugSessionManager.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.VariableResolverService),
    tslib_1.__metadata("design:type", browser_3.VariableResolverService)
], DebugSessionManager.prototype, "variableResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_contribution_1.DebugSessionContributionRegistry),
    tslib_1.__metadata("design:type", Object)
], DebugSessionManager.prototype, "sessionContributionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MessageService),
    tslib_1.__metadata("design:type", core_1.MessageService)
], DebugSessionManager.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ProgressService),
    tslib_1.__metadata("design:type", core_1.ProgressService)
], DebugSessionManager.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], DebugSessionManager.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_service_1.TaskService),
    tslib_1.__metadata("design:type", task_service_1.TaskService)
], DebugSessionManager.prototype, "taskService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], DebugSessionManager.prototype, "debugConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(quick_open_task_1.QuickOpenTask),
    tslib_1.__metadata("design:type", quick_open_task_1.QuickOpenTask)
], DebugSessionManager.prototype, "quickOpenTask", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], DebugSessionManager.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_configuration_label_provider_1.DebugSessionConfigurationLabelProvider),
    tslib_1.__metadata("design:type", debug_session_configuration_label_provider_1.DebugSessionConfigurationLabelProvider)
], DebugSessionManager.prototype, "sessionConfigurationLabelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugSessionManager.prototype, "init", null);
exports.DebugSessionManager = DebugSessionManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugSessionManager);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session-options.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session-options.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalDebugSessionOptions = exports.DebugSessionOptions = exports.DebugCompoundRoot = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class DebugCompoundRoot {
    constructor() {
        this.stopped = false;
        this.stopEmitter = new core_1.Emitter();
        this.onDidSessionStop = this.stopEmitter.event;
    }
    stopSession() {
        if (!this.stopped) { // avoid sending extraneous terminate events
            this.stopped = true;
            this.stopEmitter.fire();
        }
    }
}
exports.DebugCompoundRoot = DebugCompoundRoot;
var DebugSessionOptions;
(function (DebugSessionOptions) {
    function isConfiguration(options) {
        return !!options && 'configuration' in options && !!options.configuration;
    }
    DebugSessionOptions.isConfiguration = isConfiguration;
    function isDynamic(options) {
        return isConfiguration(options) && 'providerType' in options && !!options.providerType;
    }
    DebugSessionOptions.isDynamic = isDynamic;
    function isCompound(options) {
        return !!options && 'compound' in options && !!options.compound;
    }
    DebugSessionOptions.isCompound = isCompound;
})(DebugSessionOptions || (exports.DebugSessionOptions = DebugSessionOptions = {}));
var InternalDebugSessionOptions;
(function (InternalDebugSessionOptions) {
    const SEPARATOR = '__CONF__';
    const SEPARATOR_CONFIGS = '__COMP__';
    function is(options) {
        return 'id' in options;
    }
    InternalDebugSessionOptions.is = is;
    /** @deprecated Please use `JSON.stringify` to serialize the options. */
    function toValue(options) {
        var _a;
        if (DebugSessionOptions.isCompound(options)) {
            return options.compound.name + SEPARATOR +
                options.workspaceFolderUri + SEPARATOR +
                ((_a = options.compound) === null || _a === void 0 ? void 0 : _a.configurations.join(SEPARATOR_CONFIGS));
        }
        return options.configuration.name + SEPARATOR +
            options.configuration.type + SEPARATOR +
            options.configuration.request + SEPARATOR +
            options.workspaceFolderUri + SEPARATOR +
            options.providerType;
    }
    InternalDebugSessionOptions.toValue = toValue;
    /** @deprecated Please use `JSON.parse` to restore previously serialized debug session options. */
    // eslint-disable-next-line deprecation/deprecation
    function parseValue(value) {
        const split = value.split(SEPARATOR);
        if (split.length === 5) {
            return { name: split[0], type: split[1], request: split[2], workspaceFolderUri: split[3], providerType: split[4] };
        }
        if (split.length === 3) {
            return { name: split[0], workspaceFolderUri: split[1], configurations: split[2].split(SEPARATOR_CONFIGS) };
        }
        throw new Error('Unexpected argument, the argument is expected to have been generated by the \'toValue\' function');
    }
    InternalDebugSessionOptions.parseValue = parseValue;
})(InternalDebugSessionOptions || (exports.InternalDebugSessionOptions = InternalDebugSessionOptions = {}));


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-session.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-session.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSession = exports.debugStateContextValue = exports.DebugState = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const debug_thread_1 = __webpack_require__(/*! ./model/debug-thread */ "../node_modules/@theia/debug/lib/browser/model/debug-thread.js");
const debug_source_1 = __webpack_require__(/*! ./model/debug-source */ "../node_modules/@theia/debug/lib/browser/model/debug-source.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! ./model/debug-source-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const breakpoint_manager_1 = __webpack_require__(/*! ./breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_session_options_1 = __webpack_require__(/*! ./debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const debug_common_1 = __webpack_require__(/*! ../common/debug-common */ "../node_modules/@theia/debug/lib/common/debug-common.js");
const breakpoint_marker_1 = __webpack_require__(/*! ./breakpoint/breakpoint-marker */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js");
const debug_function_breakpoint_1 = __webpack_require__(/*! ./model/debug-function-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const debug_instruction_breakpoint_1 = __webpack_require__(/*! ./model/debug-instruction-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-instruction-breakpoint.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
var DebugState;
(function (DebugState) {
    DebugState[DebugState["Inactive"] = 0] = "Inactive";
    DebugState[DebugState["Initializing"] = 1] = "Initializing";
    DebugState[DebugState["Running"] = 2] = "Running";
    DebugState[DebugState["Stopped"] = 3] = "Stopped";
})(DebugState || (exports.DebugState = DebugState = {}));
/**
 * The mapped string values must not change as they are used for the `debugState` when context closure.
 * For more details see the `Debugger contexts` section of the [official doc](https://code.visualstudio.com/api/references/when-clause-contexts#available-contexts).
 */
function debugStateContextValue(state) {
    switch (state) {
        case DebugState.Initializing: return 'initializing';
        case DebugState.Stopped: return 'stopped';
        case DebugState.Running: return 'running';
        default: return 'inactive';
    }
}
exports.debugStateContextValue = debugStateContextValue;
// FIXME: make injectable to allow easily inject services
class DebugSession {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    get onDidFocusStackFrame() {
        return this.onDidFocusStackFrameEmitter.event;
    }
    get onDidFocusThread() {
        return this.onDidFocusThreadEmitter.event;
    }
    fireDidChangeBreakpoints(uri) {
        this.onDidChangeBreakpointsEmitter.fire(uri);
    }
    constructor(id, options, parentSession, testService, testRun, sessionManager, connection, terminalServer, editorManager, breakpoints, labelProvider, messages, fileService, debugContributionProvider, workspaceService, 
    /**
     * Number of millis after a `stop` request times out. It's 5 seconds by default.
     */
    stopTimeout = 5000) {
        this.id = id;
        this.options = options;
        this.parentSession = parentSession;
        this.connection = connection;
        this.terminalServer = terminalServer;
        this.editorManager = editorManager;
        this.breakpoints = breakpoints;
        this.labelProvider = labelProvider;
        this.messages = messages;
        this.fileService = fileService;
        this.debugContributionProvider = debugContributionProvider;
        this.workspaceService = workspaceService;
        this.stopTimeout = stopTimeout;
        this.deferredOnDidConfigureCapabilities = new promise_util_1.Deferred();
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.onDidFocusStackFrameEmitter = new common_1.Emitter();
        this.onDidFocusThreadEmitter = new common_1.Emitter();
        this.onDidChangeBreakpointsEmitter = new common_1.Emitter();
        this.onDidChangeBreakpoints = this.onDidChangeBreakpointsEmitter.event;
        this.childSessions = new Map();
        this.toDispose = new common_1.DisposableCollection();
        this.isStopping = false;
        this._capabilities = {};
        this.sources = new Map();
        this._threads = new Map();
        this.toDisposeOnCurrentThread = new common_1.DisposableCollection();
        /**
         * The `send('initialize')` request could resolve later than `on('initialized')` emits the event.
         * Hence, the `configure` would use the empty object `capabilities`.
         * Using the empty `capabilities` could result in missing exception breakpoint filters, as
         * always `capabilities.exceptionBreakpointFilters` is falsy. This deferred promise works
         * around this timing issue. https://github.com/eclipse-theia/theia/issues/11886
         */
        this.didReceiveCapabilities = new promise_util_1.Deferred();
        this.initialized = false;
        this.scheduleUpdateThreads = debounce(() => this.updateThreads(undefined), 100);
        this.pendingThreads = Promise.resolve();
        this._breakpoints = new Map();
        this.updatingBreakpoints = false;
        this.connection.onRequest('runInTerminal', (request) => this.runInTerminal(request));
        this.connection.onDidClose(() => {
            this.toDispose.dispose();
        });
        this.registerDebugContributions(options.configuration.type, this.connection);
        if (parentSession) {
            parentSession.childSessions.set(id, this);
            this.toDispose.push(common_1.Disposable.create(() => {
                var _a, _b;
                (_b = (_a = this.parentSession) === null || _a === void 0 ? void 0 : _a.childSessions) === null || _b === void 0 ? void 0 : _b.delete(id);
            }));
        }
        if (testRun) {
            try {
                const run = test_service_1.TestServices.withTestRun(testService, testRun.controllerId, testRun.runId);
                run.onDidChangeProperty(evt => {
                    if (evt.isRunning === false) {
                        sessionManager.terminateSession(this);
                    }
                });
            }
            catch (err) {
                console.error(err);
            }
        }
        this.connection.onDidClose(() => this.toDispose.dispose());
        this.toDispose.pushAll([
            this.onDidChangeEmitter,
            this.onDidChangeBreakpointsEmitter,
            common_1.Disposable.create(() => {
                this.clearBreakpoints();
                this.doUpdateThreads([]);
            }),
            this.connection,
            this.connection.on('initialized', () => this.configure()),
            this.connection.on('breakpoint', ({ body }) => this.updateBreakpoint(body)),
            this.connection.on('continued', e => this.handleContinued(e)),
            this.connection.on('stopped', e => this.handleStopped(e)),
            this.connection.on('thread', e => this.handleThread(e)),
            this.connection.on('capabilities', event => this.updateCapabilities(event.body.capabilities)),
            this.breakpoints.onDidChangeMarkers(uri => this.updateBreakpoints({ uri, sourceModified: true }))
        ]);
    }
    get onDispose() {
        return this.toDispose.onDispose;
    }
    get configuration() {
        return this.options.configuration;
    }
    get capabilities() {
        return this._capabilities;
    }
    getSource(raw) {
        const uri = debug_source_1.DebugSource.toUri(raw).toString();
        const source = this.sources.get(uri) || new debug_source_1.DebugSource(this, this.editorManager, this.labelProvider);
        source.update({ raw });
        this.sources.set(uri, source);
        return source;
    }
    getSourceForUri(uri) {
        return this.sources.get(uri.toString());
    }
    async toSource(uri) {
        const source = this.getSourceForUri(uri);
        if (source) {
            return source;
        }
        return this.getSource(await this.toDebugSource(uri));
    }
    async toDebugSource(uri) {
        if (uri.scheme === debug_source_1.DebugSource.SCHEME) {
            return {
                name: uri.path.toString(),
                sourceReference: Number(uri.query)
            };
        }
        const name = uri.displayName;
        let path;
        const underlying = await this.fileService.toUnderlyingResource(uri);
        if (underlying.scheme === 'file') {
            path = await this.fileService.fsPath(underlying);
        }
        else {
            path = uri.toString();
        }
        return { name, path };
    }
    get threads() {
        return this._threads.values();
    }
    get threadCount() {
        return this._threads.size;
    }
    *getThreads(filter) {
        for (const thread of this.threads) {
            if (filter(thread)) {
                yield thread;
            }
        }
    }
    get runningThreads() {
        return this.getThreads(thread => !thread.stopped);
    }
    get stoppedThreads() {
        return this.getThreads(thread => thread.stopped);
    }
    async pauseAll() {
        const promises = [];
        for (const thread of this.runningThreads) {
            promises.push((async () => {
                try {
                    await thread.pause();
                }
                catch (e) {
                    console.error('pauseAll failed:', e);
                }
            })());
        }
        await Promise.all(promises);
    }
    async continueAll() {
        const promises = [];
        for (const thread of this.stoppedThreads) {
            promises.push((async () => {
                try {
                    await thread.continue();
                }
                catch (e) {
                    console.error('continueAll failed:', e);
                }
            })());
        }
        await Promise.all(promises);
    }
    get currentFrame() {
        return this.currentThread && this.currentThread.currentFrame;
    }
    get currentThread() {
        return this._currentThread;
    }
    set currentThread(thread) {
        var _a;
        if (((_a = this._currentThread) === null || _a === void 0 ? void 0 : _a.id) === (thread === null || thread === void 0 ? void 0 : thread.id)) {
            return;
        }
        this.toDisposeOnCurrentThread.dispose();
        this._currentThread = thread;
        this.onDidFocusThreadEmitter.fire(thread);
        this.fireDidChange();
        if (thread) {
            this.toDisposeOnCurrentThread.push(thread.onDidChanged(() => this.fireDidChange()));
            this.toDisposeOnCurrentThread.push(thread.onDidFocusStackFrame(frame => this.onDidFocusStackFrameEmitter.fire(frame)));
            // If this thread is missing stack frame information, then load that.
            this.updateFrames();
        }
    }
    get state() {
        if (this.connection.disposed) {
            return DebugState.Inactive;
        }
        if (!this.initialized) {
            return DebugState.Initializing;
        }
        const thread = this.currentThread;
        if (thread) {
            return thread.stopped ? DebugState.Stopped : DebugState.Running;
        }
        return !!this.stoppedThreads.next().value ? DebugState.Stopped : DebugState.Running;
    }
    async getScopes() {
        const { currentFrame } = this;
        return currentFrame ? currentFrame.getScopes() : [];
    }
    showMessage(messageType, message) {
        this.messages.showMessage({
            type: messageType,
            text: message,
            options: {
                timeout: 10000
            }
        });
    }
    async start() {
        await this.initialize();
        await this.launchOrAttach();
    }
    async initialize() {
        try {
            const response = await this.connection.sendRequest('initialize', {
                clientID: 'Theia',
                clientName: 'Theia IDE',
                adapterID: this.configuration.type,
                locale: 'en-US',
                linesStartAt1: true,
                columnsStartAt1: true,
                pathFormat: 'path',
                supportsVariableType: false,
                supportsVariablePaging: false,
                supportsRunInTerminalRequest: true
            });
            this.updateCapabilities((response === null || response === void 0 ? void 0 : response.body) || {});
            this.didReceiveCapabilities.resolve();
        }
        catch (err) {
            this.didReceiveCapabilities.reject(err);
            throw err;
        }
    }
    async launchOrAttach() {
        try {
            await this.sendRequest(this.configuration.request, this.configuration);
        }
        catch (reason) {
            this.showMessage(common_1.MessageType.Error, reason.message || 'Debug session initialization failed. See console for details.');
            throw reason;
        }
    }
    async configure() {
        await this.didReceiveCapabilities.promise;
        if (this.capabilities.exceptionBreakpointFilters) {
            const exceptionBreakpoints = [];
            for (const filter of this.capabilities.exceptionBreakpointFilters) {
                const origin = this.breakpoints.getExceptionBreakpoint(filter.filter);
                exceptionBreakpoints.push(breakpoint_marker_1.ExceptionBreakpoint.create(filter, origin));
            }
            this.breakpoints.setExceptionBreakpoints(exceptionBreakpoints);
        }
        // mark as initialized, so updated breakpoints are shown in editor
        this.initialized = true;
        await this.updateBreakpoints({ sourceModified: false });
        if (this.capabilities.supportsConfigurationDoneRequest) {
            await this.sendRequest('configurationDone', {});
        }
        await this.updateThreads(undefined);
    }
    canTerminate() {
        return !!this.capabilities.supportsTerminateRequest;
    }
    canRestart() {
        return !!this.capabilities.supportsRestartRequest;
    }
    async restart() {
        if (this.canRestart()) {
            await this.sendRequest('restart', {});
        }
    }
    async stop(isRestart, callback) {
        if (!this.isStopping) {
            this.isStopping = true;
            if (this.canTerminate()) {
                const terminated = this.waitFor('terminated', this.stopTimeout);
                try {
                    await this.connection.sendRequest('terminate', { restart: isRestart }, this.stopTimeout);
                    await terminated;
                }
                catch (e) {
                    this.handleTerminateError(e);
                }
            }
            else {
                const terminateDebuggee = this.initialized && this.capabilities.supportTerminateDebuggee;
                try {
                    await this.sendRequest('disconnect', { restart: isRestart, terminateDebuggee }, this.stopTimeout);
                }
                catch (e) {
                    this.handleDisconnectError(e);
                }
            }
            callback();
        }
    }
    /**
     * Invoked when sending the `terminate` request to the debugger is rejected or timed out.
     */
    handleTerminateError(err) {
        console.error('Did not receive terminated event in time', err);
    }
    /**
     * Invoked when sending the `disconnect` request to the debugger is rejected or timed out.
     */
    handleDisconnectError(err) {
        console.error('Error on disconnect', err);
    }
    async disconnect(isRestart, callback) {
        if (!this.isStopping) {
            this.isStopping = true;
            await this.sendRequest('disconnect', { restart: isRestart });
            callback();
        }
    }
    async completions(text, column, line) {
        const frameId = this.currentFrame && this.currentFrame.raw.id;
        const response = await this.sendRequest('completions', { frameId, text, column, line });
        return response.body.targets;
    }
    async evaluate(expression, context) {
        const frameId = this.currentFrame && this.currentFrame.raw.id;
        const response = await this.sendRequest('evaluate', { expression, frameId, context });
        return response.body;
    }
    sendRequest(command, args, timeout) {
        return this.connection.sendRequest(command, args, timeout);
    }
    sendCustomRequest(command, args) {
        return this.connection.sendCustomRequest(command, args);
    }
    on(kind, listener) {
        return this.connection.on(kind, listener);
    }
    waitFor(kind, ms) {
        return (0, promise_util_1.waitForEvent)(this.connection.onEvent(kind), ms).then();
    }
    get onDidCustomEvent() {
        return this.connection.onDidCustomEvent;
    }
    async runInTerminal({ arguments: { title, cwd, args, env } }) {
        const terminal = await this.doCreateTerminal({ title, cwd, env, useServerTitle: false });
        const { processId } = terminal;
        await terminal.executeCommand({ cwd, args, env });
        return { processId: await processId };
    }
    async doCreateTerminal(options) {
        let terminal = undefined;
        for (const t of this.terminalServer.all) {
            if ((t.title.label === options.title || t.title.caption === options.title) && (await t.hasChildProcesses()) === false) {
                terminal = t;
                break;
            }
        }
        if (!terminal) {
            terminal = await this.terminalServer.newTerminal(options);
            await terminal.start();
        }
        this.terminalServer.open(terminal);
        return terminal;
    }
    clearThreads() {
        for (const thread of this.threads) {
            thread.clear();
        }
        this.updateCurrentThread();
    }
    clearThread(threadId) {
        const thread = this._threads.get(threadId);
        if (thread) {
            thread.clear();
        }
        this.updateCurrentThread();
    }
    updateThreads(stoppedDetails) {
        return this.pendingThreads = this.pendingThreads.then(async () => {
            try {
                const response = await this.sendRequest('threads', {});
                // java debugger returns an empty body sometimes
                const threads = response && response.body && response.body.threads || [];
                this.doUpdateThreads(threads, stoppedDetails);
            }
            catch (e) {
                console.error('updateThreads failed:', e);
            }
        });
    }
    doUpdateThreads(threads, stoppedDetails) {
        const existing = this._threads;
        this._threads = new Map();
        for (const raw of threads) {
            const id = raw.id;
            const thread = existing.get(id) || new debug_thread_1.DebugThread(this);
            this._threads.set(id, thread);
            const data = { raw };
            if (stoppedDetails) {
                if (stoppedDetails.threadId === id) {
                    data.stoppedDetails = stoppedDetails;
                }
                else if (stoppedDetails.allThreadsStopped) {
                    data.stoppedDetails = {
                        // When a debug adapter notifies us that all threads are stopped,
                        // we do not know why the others are stopped, so we should default
                        // to something generic.
                        reason: '',
                    };
                }
            }
            thread.update(data);
        }
        this.updateCurrentThread(stoppedDetails);
    }
    updateCurrentThread(stoppedDetails) {
        const { currentThread } = this;
        let threadId = currentThread && currentThread.raw.id;
        if (stoppedDetails && !stoppedDetails.preserveFocusHint && !!stoppedDetails.threadId) {
            threadId = stoppedDetails.threadId;
        }
        this.currentThread = typeof threadId === 'number' && this._threads.get(threadId)
            || this._threads.values().next().value;
    }
    async updateFrames() {
        const thread = this._currentThread;
        if (!thread || thread.pendingFrameCount || thread.frameCount) {
            return;
        }
        if (this.capabilities.supportsDelayedStackTraceLoading) {
            await thread.fetchFrames(1);
            await thread.fetchFrames(19);
        }
        else {
            await thread.fetchFrames();
        }
    }
    updateCapabilities(capabilities) {
        Object.assign(this._capabilities, capabilities);
        this.deferredOnDidConfigureCapabilities.resolve();
    }
    get breakpointUris() {
        return this._breakpoints.keys();
    }
    getSourceBreakpoints(uri) {
        const breakpoints = [];
        for (const breakpoint of this.getBreakpoints(uri)) {
            if (breakpoint instanceof debug_source_breakpoint_1.DebugSourceBreakpoint) {
                breakpoints.push(breakpoint);
            }
        }
        return breakpoints;
    }
    getFunctionBreakpoints() {
        return this.getBreakpoints(breakpoint_manager_1.BreakpointManager.FUNCTION_URI).filter((breakpoint) => breakpoint instanceof debug_function_breakpoint_1.DebugFunctionBreakpoint);
    }
    getInstructionBreakpoints() {
        if (this.capabilities.supportsInstructionBreakpoints) {
            return this.getBreakpoints(breakpoint_manager_1.BreakpointManager.INSTRUCTION_URI)
                .filter((breakpoint) => breakpoint instanceof debug_instruction_breakpoint_1.DebugInstructionBreakpoint);
        }
        return this.breakpoints.getInstructionBreakpoints().map(origin => new debug_instruction_breakpoint_1.DebugInstructionBreakpoint(origin, this.asDebugBreakpointOptions()));
    }
    getBreakpoints(uri) {
        if (uri) {
            return this._breakpoints.get(uri.toString()) || [];
        }
        const result = [];
        for (const breakpoints of this._breakpoints.values()) {
            result.push(...breakpoints);
        }
        return result;
    }
    getBreakpoint(id) {
        for (const breakpoints of this._breakpoints.values()) {
            const breakpoint = breakpoints.find(b => b.id === id);
            if (breakpoint) {
                return breakpoint;
            }
        }
        return undefined;
    }
    clearBreakpoints() {
        const uris = [...this._breakpoints.keys()];
        this._breakpoints.clear();
        for (const uri of uris) {
            this.fireDidChangeBreakpoints(new uri_1.default(uri));
        }
    }
    updateBreakpoint(body) {
        this.updatingBreakpoints = true;
        try {
            const raw = body.breakpoint;
            if (body.reason === 'new') {
                if (raw.source && typeof raw.line === 'number') {
                    const uri = debug_source_1.DebugSource.toUri(raw.source);
                    const origin = breakpoint_marker_1.SourceBreakpoint.create(uri, { line: raw.line, column: raw.column });
                    if (this.breakpoints.addBreakpoint(origin)) {
                        const breakpoints = this.getSourceBreakpoints(uri);
                        const breakpoint = new debug_source_breakpoint_1.DebugSourceBreakpoint(origin, this.asDebugBreakpointOptions());
                        breakpoint.update({ raw });
                        breakpoints.push(breakpoint);
                        this.setSourceBreakpoints(uri, breakpoints);
                    }
                }
            }
            if (body.reason === 'removed' && typeof raw.id === 'number') {
                const toRemove = this.findBreakpoint(b => b.idFromAdapter === raw.id);
                if (toRemove) {
                    toRemove.remove();
                    const breakpoints = this.getBreakpoints(toRemove.uri);
                    const index = breakpoints.indexOf(toRemove);
                    if (index !== -1) {
                        breakpoints.splice(index, 1);
                        this.setBreakpoints(toRemove.uri, breakpoints);
                    }
                }
            }
            if (body.reason === 'changed' && typeof raw.id === 'number') {
                const toUpdate = this.findBreakpoint(b => b.idFromAdapter === raw.id);
                if (toUpdate) {
                    toUpdate.update({ raw });
                    if (toUpdate instanceof debug_source_breakpoint_1.DebugSourceBreakpoint) {
                        const sourceBreakpoints = this.getSourceBreakpoints(toUpdate.uri);
                        // in order to dedup again if a debugger converted line breakpoint to inline breakpoint
                        // i.e. assigned a column to a line breakpoint
                        this.setSourceBreakpoints(toUpdate.uri, sourceBreakpoints);
                    }
                    else {
                        this.fireDidChangeBreakpoints(toUpdate.uri);
                    }
                }
            }
        }
        finally {
            this.updatingBreakpoints = false;
        }
    }
    findBreakpoint(match) {
        for (const [, breakpoints] of this._breakpoints) {
            for (const breakpoint of breakpoints) {
                if (match(breakpoint)) {
                    return breakpoint;
                }
            }
        }
        return undefined;
    }
    async updateBreakpoints(options) {
        if (this.updatingBreakpoints) {
            return;
        }
        const { uri, sourceModified } = options;
        await this.deferredOnDidConfigureCapabilities.promise;
        for (const affectedUri of this.getAffectedUris(uri)) {
            if (affectedUri.toString() === breakpoint_manager_1.BreakpointManager.EXCEPTION_URI.toString()) {
                await this.sendExceptionBreakpoints();
            }
            else if (affectedUri.toString() === breakpoint_manager_1.BreakpointManager.FUNCTION_URI.toString()) {
                await this.sendFunctionBreakpoints(affectedUri);
            }
            else if (affectedUri.toString() === breakpoint_manager_1.BreakpointManager.INSTRUCTION_URI.toString()) {
                await this.sendInstructionBreakpoints();
            }
            else {
                await this.sendSourceBreakpoints(affectedUri, sourceModified);
            }
        }
    }
    async sendExceptionBreakpoints() {
        const filters = [];
        const filterOptions = this.capabilities.supportsExceptionFilterOptions ? [] : undefined;
        for (const breakpoint of this.breakpoints.getExceptionBreakpoints()) {
            if (breakpoint.enabled) {
                if (filterOptions) {
                    filterOptions.push({
                        filterId: breakpoint.raw.filter,
                        condition: breakpoint.condition
                    });
                }
                else {
                    filters.push(breakpoint.raw.filter);
                }
            }
        }
        await this.sendRequest('setExceptionBreakpoints', { filters, filterOptions });
    }
    async sendFunctionBreakpoints(affectedUri) {
        const all = this.breakpoints.getFunctionBreakpoints().map(origin => new debug_function_breakpoint_1.DebugFunctionBreakpoint(origin, this.asDebugBreakpointOptions()));
        const enabled = all.filter(b => b.enabled);
        if (this.capabilities.supportsFunctionBreakpoints) {
            try {
                const response = await this.sendRequest('setFunctionBreakpoints', {
                    breakpoints: enabled.map(b => b.origin.raw)
                });
                // Apparently, `body` and `breakpoints` can be missing.
                // https://github.com/eclipse-theia/theia/issues/11885
                // https://github.com/microsoft/vscode/blob/80004351ccf0884b58359f7c8c801c91bb827d83/src/vs/workbench/contrib/debug/browser/debugSession.ts#L448-L449
                if (response && response.body) {
                    response.body.breakpoints.forEach((raw, index) => {
                        // node debug adapter returns more breakpoints sometimes
                        if (enabled[index]) {
                            enabled[index].update({ raw });
                        }
                    });
                }
            }
            catch (error) {
                // could be error or promise rejection of DebugProtocol.SetFunctionBreakpoints
                if (error instanceof Error) {
                    console.error(`Error setting breakpoints: ${error.message}`);
                }
                else {
                    // handle adapters that send failed DebugProtocol.SetFunctionBreakpoints for invalid breakpoints
                    const genericMessage = 'Function breakpoint not valid for current debug session';
                    const message = error.message ? `${error.message}` : genericMessage;
                    console.warn(`Could not handle function breakpoints: ${message}, disabling...`);
                    enabled.forEach(b => b.update({
                        raw: {
                            verified: false,
                            message
                        }
                    }));
                }
            }
        }
        this.setBreakpoints(affectedUri, all);
    }
    async sendSourceBreakpoints(affectedUri, sourceModified) {
        const source = await this.toSource(affectedUri);
        const all = this.breakpoints.findMarkers({ uri: affectedUri }).map(({ data }) => new debug_source_breakpoint_1.DebugSourceBreakpoint(data, this.asDebugBreakpointOptions()));
        const enabled = all.filter(b => b.enabled);
        try {
            const breakpoints = enabled.map(({ origin }) => origin.raw);
            const response = await this.sendRequest('setBreakpoints', {
                source: source.raw,
                sourceModified,
                breakpoints,
                lines: breakpoints.map(({ line }) => line)
            });
            response.body.breakpoints.forEach((raw, index) => {
                // node debug adapter returns more breakpoints sometimes
                if (enabled[index]) {
                    enabled[index].update({ raw });
                }
            });
        }
        catch (error) {
            // could be error or promise rejection of DebugProtocol.SetBreakpointsResponse
            if (error instanceof Error) {
                console.error(`Error setting breakpoints: ${error.message}`);
            }
            else {
                // handle adapters that send failed DebugProtocol.SetBreakpointsResponse for invalid breakpoints
                const genericMessage = 'Breakpoint not valid for current debug session';
                const message = error.message ? `${error.message}` : genericMessage;
                console.warn(`Could not handle breakpoints for ${affectedUri}: ${message}, disabling...`);
                enabled.forEach(b => b.update({
                    raw: {
                        verified: false,
                        message
                    }
                }));
            }
        }
        this.setSourceBreakpoints(affectedUri, all);
    }
    async sendInstructionBreakpoints() {
        if (!this.capabilities.supportsInstructionBreakpoints) {
            return;
        }
        const all = this.breakpoints.getInstructionBreakpoints().map(breakpoint => new debug_instruction_breakpoint_1.DebugInstructionBreakpoint(breakpoint, this.asDebugBreakpointOptions()));
        const enabled = all.filter(breakpoint => breakpoint.enabled);
        try {
            const response = await this.sendRequest('setInstructionBreakpoints', {
                breakpoints: enabled.map(renderable => renderable.origin),
            });
            response.body.breakpoints.forEach((raw, index) => { var _a; return (_a = enabled[index]) === null || _a === void 0 ? void 0 : _a.update({ raw }); });
        }
        catch {
            enabled.forEach(breakpoint => breakpoint.update({ raw: { verified: false } }));
        }
        this.setBreakpoints(breakpoint_manager_1.BreakpointManager.INSTRUCTION_URI, all);
    }
    setBreakpoints(uri, breakpoints) {
        this._breakpoints.set(uri.toString(), breakpoints);
        this.fireDidChangeBreakpoints(uri);
    }
    setSourceBreakpoints(uri, breakpoints) {
        const distinct = this.dedupSourceBreakpoints(breakpoints);
        this.setBreakpoints(uri, distinct);
    }
    dedupSourceBreakpoints(all) {
        const positions = new Map();
        for (const breakpoint of all) {
            let primary = positions.get(breakpoint.renderPosition()) || breakpoint;
            if (primary !== breakpoint) {
                let secondary = breakpoint;
                if (secondary.raw && secondary.raw.line === secondary.origin.raw.line && secondary.raw.column === secondary.origin.raw.column) {
                    [primary, secondary] = [breakpoint, primary];
                }
                primary.origins.push(...secondary.origins);
            }
            positions.set(primary.renderPosition(), primary);
        }
        return [...positions.values()];
    }
    *getAffectedUris(uri) {
        if (uri) {
            yield uri;
        }
        else {
            for (const uriString of this.breakpoints.getUris()) {
                yield new uri_1.default(uriString);
            }
            yield breakpoint_manager_1.BreakpointManager.FUNCTION_URI;
            yield breakpoint_manager_1.BreakpointManager.EXCEPTION_URI;
        }
    }
    asDebugBreakpointOptions() {
        const { labelProvider, breakpoints, editorManager } = this;
        return { labelProvider, breakpoints, editorManager, session: this };
    }
    get label() {
        const suffixes = [];
        if (debug_session_options_1.InternalDebugSessionOptions.is(this.options) && this.options.id) {
            suffixes.push(String(this.options.id + 1));
        }
        if (this.workspaceService.isMultiRootWorkspaceOpened && this.options.workspaceFolderUri) {
            suffixes.push(this.labelProvider.getName(new uri_1.default(this.options.workspaceFolderUri)));
        }
        return suffixes.length === 0 ? this.configuration.name : this.configuration.name + ` (${suffixes.join(' - ')})`;
    }
    get visible() {
        return this.state > DebugState.Inactive;
    }
    render() {
        let label = '';
        const state = this.state === DebugState.Stopped ? core_1.nls.localizeByDefault('Paused') : core_1.nls.localizeByDefault('Running');
        const child = this.getSingleChildSession();
        if (child && child.configuration.compact) {
            // Inlines the name of the child debug session
            label = `: ${child.label}`;
        }
        return React.createElement("div", { className: 'theia-debug-session', title: 'Session' },
            React.createElement("span", { className: 'label' }, this.label + label),
            React.createElement("span", { className: 'status' }, state));
    }
    *getElements() {
        const child = this.getSingleChildSession();
        if (child && child.configuration.compact) {
            // Inlines the elements of the child debug session
            return yield* child.getElements();
        }
        yield* this.threads;
        yield* this.childSessions.values();
    }
    getSingleChildSession() {
        if (this._threads.size === 0 && this.childSessions.size === 1) {
            const child = this.childSessions.values().next().value;
            return child;
        }
        return undefined;
    }
    async handleContinued({ body: { allThreadsContinued, threadId } }) {
        if (allThreadsContinued !== false) {
            this.clearThreads();
        }
        else {
            this.clearThread(threadId);
        }
    }
    ;
    async handleStopped({ body }) {
        // Update thread list
        await this.updateThreads(body);
        // Update current thread's frames immediately
        await this.updateFrames();
    }
    ;
    async handleThread({ body: { reason, threadId } }) {
        if (reason === 'started') {
            this.scheduleUpdateThreads();
        }
        else if (reason === 'exited') {
            this._threads.delete(threadId);
            this.updateCurrentThread();
        }
    }
    ;
    registerDebugContributions(configType, connection) {
        for (const contrib of this.debugContributionProvider.getContributions()) {
            contrib.register(configType, connection);
        }
    }
    ;
    /**
     * Returns the top-most parent session that is responsible for the console. If this session uses a {@link DebugConsoleMode.Separate separate console}
     * or does not have any parent session, undefined is returned.
     */
    findConsoleParent() {
        if (this.configuration.consoleMode !== debug_common_1.DebugConsoleMode.MergeWithParent) {
            return undefined;
        }
        let debugSession = this;
        do {
            debugSession = debugSession.parentSession;
        } while ((debugSession === null || debugSession === void 0 ? void 0 : debugSession.parentSession) && debugSession.configuration.consoleMode === debug_common_1.DebugConsoleMode.MergeWithParent);
        return debugSession;
    }
}
exports.DebugSession = DebugSession;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/debug-watch-manager.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/debug-watch-manager.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugWatchManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const storage_service_1 = __webpack_require__(/*! @theia/core/lib/browser/storage-service */ "../node_modules/@theia/core/lib/browser/storage-service.js");
let DebugWatchManager = class DebugWatchManager {
    constructor() {
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.idSequence = 0;
        this._watchExpressions = new Map();
    }
    get watchExpressions() {
        return this._watchExpressions.entries();
    }
    addWatchExpression(expression) {
        const id = this.idSequence++;
        this._watchExpressions.set(id, expression);
        this.onDidChangeEmitter.fire(undefined);
        return id;
    }
    removeWatchExpression(id) {
        if (!this._watchExpressions.has(id)) {
            return false;
        }
        this._watchExpressions.delete(id);
        this.onDidChangeEmitter.fire(undefined);
        return true;
    }
    removeWatchExpressions() {
        if (this._watchExpressions.size) {
            this.idSequence = 0;
            this._watchExpressions.clear();
            this.onDidChangeEmitter.fire(undefined);
        }
    }
    async load() {
        const data = await this.storage.getData(this.storageKey, {
            expressions: []
        });
        this.restoreState(data);
    }
    save() {
        const data = this.storeState();
        this.storage.setData(this.storageKey, data);
    }
    get storageKey() {
        return 'debug:watch';
    }
    storeState() {
        return {
            expressions: [...this._watchExpressions.values()]
        };
    }
    restoreState(state) {
        for (const expression of state.expressions) {
            this.addWatchExpression(expression);
        }
    }
};
exports.DebugWatchManager = DebugWatchManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(storage_service_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], DebugWatchManager.prototype, "storage", void 0);
exports.DebugWatchManager = DebugWatchManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugWatchManager);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-breakpoint-widget.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-breakpoint-widget.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugBreakpointWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugBreakpointWidget = exports.BREAKPOINT_INPUT_SCHEME = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const client_1 = __webpack_require__(/*! @theia/core/shared/react-dom/client */ "../node_modules/@theia/core/shared/react-dom/client/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const monaco_editor_zone_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-zone-widget */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js");
const debug_editor_1 = __webpack_require__(/*! ./debug-editor */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! ../model/debug-source-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const suggest_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/contrib/suggest/browser/suggest */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/contrib/suggest/browser/suggest.js");
const languageFeatures_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const select_component_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/select-component */ "../node_modules/@theia/core/lib/browser/widgets/select-component.js");
exports.BREAKPOINT_INPUT_SCHEME = 'breakpointinput';
let DebugBreakpointWidget = DebugBreakpointWidget_1 = class DebugBreakpointWidget {
    constructor() {
        this.toDispose = new core_1.DisposableCollection();
        this.context = 'condition';
        this._values = {};
        this.selectComponentRef = React.createRef();
        this.updateInput = (option) => {
            if (this._input) {
                this._values[this.context] = this._input.getControl().getValue();
            }
            this.context = option.value;
            this.render();
            if (this._input) {
                this._input.focus();
            }
        };
    }
    get values() {
        if (!this._input) {
            return undefined;
        }
        return {
            ...this._values,
            [this.context]: this._input.getControl().getValue()
        };
    }
    get input() {
        return this._input;
    }
    // eslint-disable-next-line no-null/no-null
    set inputSize(dimension) {
        if (this._input) {
            if (dimension) {
                this._input.setSize(dimension);
            }
            else {
                this._input.resizeToFit();
            }
        }
    }
    init() {
        this.doInit();
    }
    async doInit() {
        this.uri = new uri_1.default().withScheme(exports.BREAKPOINT_INPUT_SCHEME).withPath(this.editor.getControl().getId());
        this.toDispose.push(this.resources.add(this.uri, ''));
        this.toDispose.push(this.zone = new monaco_editor_zone_widget_1.MonacoEditorZoneWidget(this.editor.getControl()));
        this.zone.containerNode.classList.add('theia-debug-breakpoint-widget');
        const selectNode = this.selectNode = document.createElement('div');
        selectNode.classList.add('theia-debug-breakpoint-select');
        this.zone.containerNode.appendChild(selectNode);
        this.selectNodeRoot = (0, client_1.createRoot)(this.selectNode);
        this.toDispose.push(core_1.Disposable.create(() => this.selectNodeRoot.unmount()));
        const inputNode = document.createElement('div');
        inputNode.classList.add('theia-debug-breakpoint-input');
        this.zone.containerNode.appendChild(inputNode);
        const input = this._input = await this.createInput(inputNode);
        if (this.toDispose.disposed) {
            input.dispose();
            return;
        }
        this.toDispose.push(input);
        this.toDispose.push(monaco.languages.registerCompletionItemProvider({ scheme: input.uri.scheme }, {
            provideCompletionItems: async (model, position, context, token) => {
                const editor = this.editor.getControl();
                const editorModel = editor.getModel();
                const suggestions = [];
                if (editorModel && (this.context === 'condition' || this.context === 'logMessage')
                    && input.uri.toString() === model.uri.toString()) {
                    const completions = await (0, suggest_1.provideSuggestionItems)(standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).completionProvider, editorModel, new monaco.Position(editor.getPosition().lineNumber, 1), new suggest_1.CompletionOptions(undefined, new Set().add(27 /* CompletionItemKind.Snippet */)), context, token);
                    let overwriteBefore = 0;
                    if (this.context === 'condition') {
                        overwriteBefore = position.column - 1;
                    }
                    else {
                        // Inside the curly brackets, need to count how many useful characters are behind the position so they would all be taken into account
                        const value = editor.getModel().getValue();
                        while ((position.column - 2 - overwriteBefore >= 0)
                            && value[position.column - 2 - overwriteBefore] !== '{' && value[position.column - 2 - overwriteBefore] !== ' ') {
                            overwriteBefore++;
                        }
                    }
                    for (const { completion } of completions.items) {
                        completion.range = monaco.Range.fromPositions(position.delta(0, -overwriteBefore), position);
                        suggestions.push(completion);
                    }
                }
                return { suggestions };
            }
        }));
        this.toDispose.push(this.zone.onDidLayoutChange(dimension => this.layout(dimension)));
        this.toDispose.push(input.getControl().onDidChangeModelContent(() => {
            var _a;
            const heightInLines = ((_a = input.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getLineCount()) || 0 + 1;
            this.zone.layout(heightInLines);
            this.updatePlaceholder();
        }));
        this._input.getControl().createContextKey('breakpointWidgetFocus', true);
    }
    dispose() {
        this.toDispose.dispose();
    }
    get position() {
        const options = this.zone.options;
        return options && new monaco.Position(options.afterLineNumber, options.afterColumn || -1);
    }
    show(options) {
        if (!this._input) {
            return;
        }
        const breakpoint = options instanceof debug_source_breakpoint_1.DebugSourceBreakpoint ? options : 'breakpoint' in options ? options.breakpoint : undefined;
        this._values = breakpoint ? {
            condition: breakpoint.condition,
            hitCondition: breakpoint.hitCondition,
            logMessage: breakpoint.logMessage
        } : {};
        if (options instanceof debug_source_breakpoint_1.DebugSourceBreakpoint) {
            if (options.logMessage) {
                this.context = 'logMessage';
            }
            else if (options.hitCondition && !options.condition) {
                this.context = 'hitCondition';
            }
            else {
                this.context = 'condition';
            }
        }
        else {
            this.context = options.context;
        }
        this.render();
        const position = 'position' in options ? options.position : undefined;
        const afterLineNumber = breakpoint ? breakpoint.line : position.lineNumber;
        const afterColumn = breakpoint ? breakpoint.column : position.column;
        const editor = this._input.getControl();
        const editorModel = editor.getModel();
        const heightInLines = ((editorModel === null || editorModel === void 0 ? void 0 : editorModel.getLineCount()) || 0) + 1;
        this.zone.show({ afterLineNumber, afterColumn, heightInLines, frameWidth: 1 });
        if (editorModel) {
            editor.setPosition(editorModel.getPositionAt(editorModel.getValueLength()));
        }
        this._input.focus();
        this.editor.getControl().createContextKey('isBreakpointWidgetVisible', true);
    }
    hide() {
        this.zone.hide();
        this.editor.getControl().createContextKey('isBreakpointWidgetVisible', false);
        this.editor.focus();
    }
    layout(dimension) {
        if (this._input) {
            this._input.getControl().layout(dimension);
        }
    }
    createInput(node) {
        return this.editorProvider.createInline(this.uri, node, {
            autoSizing: false
        });
    }
    render() {
        const value = this._values[this.context] || '';
        this.resources.update(this.uri, value);
        if (this._input) {
            this._input.getControl().setValue(value);
        }
        const selectComponent = this.selectComponentRef.current;
        if (selectComponent && selectComponent.value !== this.context) {
            selectComponent.value = this.context;
        }
        this.selectNodeRoot.render(React.createElement(select_component_1.SelectComponent, { defaultValue: this.context, onChange: this.updateInput, options: [
                { value: 'condition', label: core_1.nls.localizeByDefault('Expression') },
                { value: 'hitCondition', label: core_1.nls.localizeByDefault('Hit Count') },
                { value: 'logMessage', label: core_1.nls.localizeByDefault('Log Message') },
            ], ref: this.selectComponentRef }));
    }
    updatePlaceholder() {
        if (!this._input) {
            return;
        }
        const value = this._input.getControl().getValue();
        const decorations = !!value ? [] : [{
                range: {
                    startLineNumber: 0,
                    endLineNumber: 0,
                    startColumn: 0,
                    endColumn: 1
                },
                renderOptions: {
                    after: {
                        contentText: this.placeholder,
                        opacity: '0.4'
                    }
                }
            }];
        this._input.getControl()
            .setDecorationsByType('Debug breakpoint placeholder', DebugBreakpointWidget_1.PLACEHOLDER_DECORATION, decorations);
    }
    get placeholder() {
        const acceptString = 'Enter';
        const closeString = 'Escape';
        if (this.context === 'logMessage') {
            return core_1.nls.localizeByDefault("Message to log when breakpoint is hit. Expressions within {} are interpolated. '{0}' to accept, '{1}' to cancel.", acceptString, closeString);
        }
        if (this.context === 'hitCondition') {
            return core_1.nls.localizeByDefault("Break when hit count condition is met. '{0}' to accept, '{1}' to cancel.", acceptString, closeString);
        }
        return core_1.nls.localizeByDefault("Break when expression evaluates to true. '{0}' to accept, '{1}' to cancel.", acceptString, closeString);
    }
};
exports.DebugBreakpointWidget = DebugBreakpointWidget;
DebugBreakpointWidget.PLACEHOLDER_DECORATION = 'placeholderDecoration';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_1.DebugEditor),
    tslib_1.__metadata("design:type", Object)
], DebugBreakpointWidget.prototype, "editor", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider),
    tslib_1.__metadata("design:type", monaco_editor_provider_1.MonacoEditorProvider)
], DebugBreakpointWidget.prototype, "editorProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.InMemoryResources),
    tslib_1.__metadata("design:type", core_1.InMemoryResources)
], DebugBreakpointWidget.prototype, "resources", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugBreakpointWidget.prototype, "init", null);
exports.DebugBreakpointWidget = DebugBreakpointWidget = DebugBreakpointWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugBreakpointWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-editor-model.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-editor-model.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugEditorModel_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugEditorModel = exports.DebugEditorModelFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const configuration_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/configuration/common/configuration */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/configuration/common/configuration.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const breakpoint_marker_1 = __webpack_require__(/*! ../breakpoint/breakpoint-marker */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-marker.js");
const debug_editor_1 = __webpack_require__(/*! ./debug-editor */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor.js");
const debug_hover_widget_1 = __webpack_require__(/*! ./debug-hover-widget */ "../node_modules/@theia/debug/lib/browser/editor/debug-hover-widget.js");
const debug_breakpoint_widget_1 = __webpack_require__(/*! ./debug-breakpoint-widget */ "../node_modules/@theia/debug/lib/browser/editor/debug-breakpoint-widget.js");
const debug_exception_widget_1 = __webpack_require__(/*! ./debug-exception-widget */ "../node_modules/@theia/debug/lib/browser/editor/debug-exception-widget.js");
const debug_inline_value_decorator_1 = __webpack_require__(/*! ./debug-inline-value-decorator */ "../node_modules/@theia/debug/lib/browser/editor/debug-inline-value-decorator.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
exports.DebugEditorModelFactory = Symbol('DebugEditorModelFactory');
let DebugEditorModel = DebugEditorModel_1 = class DebugEditorModel {
    constructor() {
        this.toDispose = new core_1.DisposableCollection();
        this.toDisposeOnUpdate = new core_1.DisposableCollection();
        this.breakpointDecorations = [];
        this.breakpointRanges = new Map();
        this.currentBreakpointDecorations = [];
        this.editorDecorations = [];
        this.updatingDecorations = false;
        this.toDisposeOnModelChange = new core_1.DisposableCollection();
        this.update = debounce(async () => {
            if (this.toDispose.disposed) {
                return;
            }
            this.toDisposeOnUpdate.dispose();
            this.toggleExceptionWidget();
            await this.updateEditorDecorations();
            this.updateEditorHover();
        }, 100);
        this.hintDecorations = [];
    }
    static createContainer(parent, editor) {
        const child = (0, debug_hover_widget_1.createDebugHoverWidgetContainer)(parent, editor);
        child.bind(DebugEditorModel_1).toSelf();
        child.bind(debug_breakpoint_widget_1.DebugBreakpointWidget).toSelf();
        child.bind(debug_exception_widget_1.DebugExceptionWidget).toSelf();
        return child;
    }
    static createModel(parent, editor) {
        return DebugEditorModel_1.createContainer(parent, editor).get(DebugEditorModel_1);
    }
    init() {
        this.uri = new uri_1.default(this.editor.getResourceUri().toString());
        this.toDispose.pushAll([
            this.hover,
            this.breakpointWidget,
            this.exceptionWidget,
            this.editor.getControl().onMouseDown(event => this.handleMouseDown(event)),
            this.editor.getControl().onMouseMove(event => this.handleMouseMove(event)),
            this.editor.getControl().onMouseLeave(event => this.handleMouseLeave(event)),
            this.editor.getControl().onKeyDown(() => this.hover.hide({ immediate: false })),
            this.editor.getControl().onDidChangeModelContent(() => this.update()),
            this.editor.getControl().onDidChangeModel(e => this.updateModel()),
            this.editor.onDidResize(e => this.breakpointWidget.inputSize = e),
            this.sessions.onDidChange(() => this.update()),
            this.toDisposeOnUpdate,
            this.sessionManager.onDidChangeBreakpoints(({ session, uri }) => {
                if ((!session || session === this.sessionManager.currentSession) && uri.isEqual(this.uri)) {
                    this.render();
                }
            }),
            this.breakpoints.onDidChangeBreakpoints(event => this.closeBreakpointIfAffected(event)),
        ]);
        this.update();
        this.render();
    }
    updateModel() {
        this.toDisposeOnModelChange.dispose();
        this.toDisposeOnModelChange = new core_1.DisposableCollection();
        const model = this.editor.getControl().getModel();
        if (model) {
            this.toDisposeOnModelChange.push(model.onDidChangeDecorations(() => this.updateBreakpoints()));
        }
        this.render();
    }
    dispose() {
        this.toDispose.dispose();
    }
    /**
     * To disable the default editor-contribution hover from Code when
     * the editor has the `currentFrame`. Otherwise, both `textdocument/hover`
     * and the debug hovers are visible at the same time when hovering over a symbol.
     */
    async updateEditorHover() {
        if (this.sessions.isCurrentEditorFrame(this.uri)) {
            const codeEditor = this.editor.getControl();
            codeEditor.updateOptions({ hover: { enabled: false } });
            this.toDisposeOnUpdate.push(core_1.Disposable.create(() => {
                const model = codeEditor.getModel();
                const overrides = {
                    resource: vscode_uri_1.URI.parse(this.editor.getResourceUri().toString()),
                    overrideIdentifier: model === null || model === void 0 ? void 0 : model.getLanguageId(),
                };
                const { enabled, delay, sticky } = standaloneServices_1.StandaloneServices.get(configuration_1.IConfigurationService).getValue('editor.hover', overrides);
                codeEditor.updateOptions({
                    hover: {
                        enabled,
                        delay,
                        sticky
                    }
                });
            }));
        }
    }
    async updateEditorDecorations() {
        const [newFrameDecorations, inlineValueDecorations] = await Promise.all([
            this.createFrameDecorations(),
            this.createInlineValueDecorations()
        ]);
        const codeEditor = this.editor.getControl();
        codeEditor.removeDecorations([debug_inline_value_decorator_1.INLINE_VALUE_DECORATION_KEY]);
        codeEditor.setDecorationsByType('Inline debug decorations', debug_inline_value_decorator_1.INLINE_VALUE_DECORATION_KEY, inlineValueDecorations);
        this.editorDecorations = this.deltaDecorations(this.editorDecorations, newFrameDecorations);
    }
    async createInlineValueDecorations() {
        if (!this.sessions.isCurrentEditorFrame(this.uri)) {
            return [];
        }
        const { currentFrame } = this.sessions;
        return this.inlineValueDecorator.calculateDecorations(this, currentFrame);
    }
    createFrameDecorations() {
        const { currentFrame, topFrame } = this.sessions;
        if (!currentFrame) {
            return [];
        }
        if (!currentFrame.thread.stopped) {
            return [];
        }
        if (!this.sessions.isCurrentEditorFrame(this.uri)) {
            return [];
        }
        const decorations = [];
        const columnUntilEOLRange = new monaco.Range(currentFrame.raw.line, currentFrame.raw.column, currentFrame.raw.line, 1 << 30);
        const range = new monaco.Range(currentFrame.raw.line, currentFrame.raw.column, currentFrame.raw.line, currentFrame.raw.column + 1);
        if (topFrame === currentFrame) {
            decorations.push({
                options: DebugEditorModel_1.TOP_STACK_FRAME_MARGIN,
                range
            });
            decorations.push({
                options: DebugEditorModel_1.TOP_STACK_FRAME_DECORATION,
                range: columnUntilEOLRange
            });
            const { topFrameRange } = this;
            if (topFrameRange && topFrameRange.startLineNumber === currentFrame.raw.line && topFrameRange.startColumn !== currentFrame.raw.column) {
                decorations.push({
                    options: DebugEditorModel_1.TOP_STACK_FRAME_INLINE_DECORATION,
                    range: columnUntilEOLRange
                });
            }
            this.topFrameRange = columnUntilEOLRange;
        }
        else {
            decorations.push({
                options: DebugEditorModel_1.FOCUSED_STACK_FRAME_MARGIN,
                range
            });
            decorations.push({
                options: DebugEditorModel_1.FOCUSED_STACK_FRAME_DECORATION,
                range: columnUntilEOLRange
            });
        }
        return decorations;
    }
    async toggleExceptionWidget() {
        const { currentFrame } = this.sessions;
        if (!currentFrame) {
            return;
        }
        if (!this.sessions.isCurrentEditorFrame(this.uri)) {
            this.exceptionWidget.hide();
            return;
        }
        const info = await currentFrame.thread.getExceptionInfo();
        if (!info) {
            this.exceptionWidget.hide();
            return;
        }
        this.exceptionWidget.show({
            info,
            lineNumber: currentFrame.raw.line,
            column: currentFrame.raw.column
        });
    }
    render() {
        this.renderBreakpoints();
        this.renderCurrentBreakpoints();
    }
    renderBreakpoints() {
        const breakpoints = this.breakpoints.getBreakpoints(this.uri);
        const decorations = this.createBreakpointDecorations(breakpoints);
        this.breakpointDecorations = this.deltaDecorations(this.breakpointDecorations, decorations);
        this.updateBreakpointRanges(breakpoints);
    }
    createBreakpointDecorations(breakpoints) {
        return breakpoints.map(breakpoint => this.createBreakpointDecoration(breakpoint));
    }
    createBreakpointDecoration(breakpoint) {
        const lineNumber = breakpoint.raw.line;
        const column = breakpoint.raw.column;
        const range = typeof column === 'number' ? new monaco.Range(lineNumber, column, lineNumber, column + 1) : new monaco.Range(lineNumber, 1, lineNumber, 2);
        return {
            range,
            options: {
                stickiness: DebugEditorModel_1.STICKINESS
            }
        };
    }
    updateBreakpointRanges(breakpoints) {
        var _a;
        this.breakpointRanges.clear();
        for (let i = 0; i < this.breakpointDecorations.length; i++) {
            const decoration = this.breakpointDecorations[i];
            const breakpoint = breakpoints[i];
            const range = (_a = this.editor.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getDecorationRange(decoration);
            if (range) {
                this.breakpointRanges.set(decoration, [range, breakpoint]);
            }
        }
    }
    renderCurrentBreakpoints() {
        const decorations = this.createCurrentBreakpointDecorations();
        this.currentBreakpointDecorations = this.deltaDecorations(this.currentBreakpointDecorations, decorations);
    }
    createCurrentBreakpointDecorations() {
        const breakpoints = this.sessions.getBreakpoints(this.uri);
        return breakpoints.map(breakpoint => this.createCurrentBreakpointDecoration(breakpoint));
    }
    createCurrentBreakpointDecoration(breakpoint) {
        var _a;
        const lineNumber = breakpoint.line;
        const column = breakpoint.column;
        const range = typeof column === 'number' ? new monaco.Range(lineNumber, column, lineNumber, column + 1) : new monaco.Range(lineNumber, 1, lineNumber, 1);
        const { className, message } = breakpoint.getDecoration();
        const renderInline = typeof column === 'number' && (column > (((_a = this.editor.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getLineFirstNonWhitespaceColumn(lineNumber)) || 0));
        return {
            range,
            options: {
                glyphMarginClassName: className,
                glyphMarginHoverMessage: message.map(value => ({ value })),
                stickiness: DebugEditorModel_1.STICKINESS,
                beforeContentClassName: renderInline ? `theia-debug-breakpoint-column codicon ${className}` : undefined
            }
        };
    }
    updateBreakpoints() {
        if (this.areBreakpointsAffected()) {
            const breakpoints = this.createBreakpoints();
            this.breakpoints.setBreakpoints(this.uri, breakpoints);
        }
    }
    areBreakpointsAffected() {
        var _a;
        if (this.updatingDecorations || !this.editor.getControl().getModel()) {
            return false;
        }
        for (const decoration of this.breakpointDecorations) {
            const range = (_a = this.editor.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getDecorationRange(decoration);
            const oldRange = this.breakpointRanges.get(decoration)[0];
            if (!range || !range.equalsRange(oldRange)) {
                return true;
            }
        }
        return false;
    }
    createBreakpoints() {
        var _a, _b;
        const { uri } = this;
        const lines = new Set();
        const breakpoints = [];
        for (const decoration of this.breakpointDecorations) {
            const range = (_a = this.editor.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getDecorationRange(decoration);
            if (range && !lines.has(range.startLineNumber)) {
                const line = range.startLineNumber;
                const column = range.startColumn;
                const oldBreakpoint = (_b = this.breakpointRanges.get(decoration)) === null || _b === void 0 ? void 0 : _b[1];
                const isLineBreakpoint = (oldBreakpoint === null || oldBreakpoint === void 0 ? void 0 : oldBreakpoint.raw.line) !== undefined && (oldBreakpoint === null || oldBreakpoint === void 0 ? void 0 : oldBreakpoint.raw.column) === undefined;
                const change = isLineBreakpoint ? { line } : { line, column };
                const breakpoint = breakpoint_marker_1.SourceBreakpoint.create(uri, change, oldBreakpoint);
                breakpoints.push(breakpoint);
                lines.add(line);
            }
        }
        return breakpoints;
    }
    get position() {
        return this.editor.getControl().getPosition();
    }
    getBreakpoint(position = this.position) {
        return this.getInlineBreakpoint(position) || this.getLineBreakpoints(position)[0];
    }
    getInlineBreakpoint(position = this.position) {
        return this.sessions.getInlineBreakpoint(this.uri, position.lineNumber, position.column);
    }
    getLineBreakpoints(position = this.position) {
        return this.sessions.getLineBreakpoints(this.uri, position.lineNumber);
    }
    addBreakpoint(raw) {
        this.breakpoints.addBreakpoint(breakpoint_marker_1.SourceBreakpoint.create(this.uri, raw));
    }
    toggleBreakpoint(position = this.position) {
        const { lineNumber } = position;
        const breakpoints = this.getLineBreakpoints(position);
        if (breakpoints.length) {
            for (const breakpoint of breakpoints) {
                breakpoint.remove();
            }
        }
        else {
            this.addBreakpoint({ line: lineNumber });
        }
    }
    addInlineBreakpoint() {
        const { position } = this;
        const { lineNumber, column } = position;
        const breakpoint = this.getInlineBreakpoint(position);
        if (breakpoint) {
            return;
        }
        this.addBreakpoint({ line: lineNumber, column });
    }
    acceptBreakpoint() {
        const { position, values } = this.breakpointWidget;
        if (position && values) {
            const breakpoint = position.column > 0 ? this.getInlineBreakpoint(position) : this.getLineBreakpoints(position)[0];
            if (breakpoint) {
                breakpoint.updateOrigins(values);
            }
            else {
                const { lineNumber } = position;
                const column = position.column > 0 ? position.column : undefined;
                this.addBreakpoint({ line: lineNumber, column, ...values });
            }
            this.breakpointWidget.hide();
        }
    }
    handleMouseDown(event) {
        if (event.target && event.target.type === monaco.editor.MouseTargetType.GUTTER_GLYPH_MARGIN) {
            if (!event.event.rightButton) {
                this.toggleBreakpoint(event.target.position);
            }
        }
        this.hintBreakpoint(event);
    }
    handleMouseMove(event) {
        this.showHover(event);
        this.hintBreakpoint(event);
    }
    handleMouseLeave(event) {
        this.hideHover(event);
        this.deltaHintDecorations([]);
    }
    hintBreakpoint(event) {
        const hintDecorations = this.createHintDecorations(event);
        this.deltaHintDecorations(hintDecorations);
    }
    deltaHintDecorations(hintDecorations) {
        this.hintDecorations = this.deltaDecorations(this.hintDecorations, hintDecorations);
    }
    createHintDecorations(event) {
        if (event.target && event.target.type === monaco.editor.MouseTargetType.GUTTER_GLYPH_MARGIN && event.target.position) {
            const lineNumber = event.target.position.lineNumber;
            if (this.getLineBreakpoints(event.target.position).length) {
                return [];
            }
            return [{
                    range: new monaco.Range(lineNumber, 1, lineNumber, 1),
                    options: DebugEditorModel_1.BREAKPOINT_HINT_DECORATION
                }];
        }
        return [];
    }
    closeBreakpointIfAffected({ uri, removed }) {
        if (!uri.isEqual(this.uri)) {
            return;
        }
        const position = this.breakpointWidget.position;
        if (!position) {
            return;
        }
        for (const breakpoint of removed) {
            if (breakpoint.raw.line === position.lineNumber) {
                this.breakpointWidget.hide();
                break;
            }
        }
    }
    showHover(mouseEvent) {
        const targetType = mouseEvent.target.type;
        const stopKey = core_1.isOSX ? 'metaKey' : 'ctrlKey';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (targetType === monaco.editor.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === this.hover.getId() && !mouseEvent.event[stopKey]) {
            // mouse moved on top of debug hover widget
            return;
        }
        if (targetType === monaco.editor.MouseTargetType.CONTENT_TEXT) {
            this.hover.show({
                selection: mouseEvent.target.range,
                immediate: false
            });
        }
        else {
            this.hover.hide({ immediate: false });
        }
    }
    hideHover({ event }) {
        const rect = this.hover.getDomNode().getBoundingClientRect();
        if (event.posx < rect.left || event.posx > rect.right || event.posy < rect.top || event.posy > rect.bottom) {
            this.hover.hide({ immediate: false });
        }
    }
    deltaDecorations(oldDecorations, newDecorations) {
        this.updatingDecorations = true;
        try {
            return this.editor.getControl().deltaDecorations(oldDecorations, newDecorations);
        }
        finally {
            this.updatingDecorations = false;
        }
    }
};
exports.DebugEditorModel = DebugEditorModel;
DebugEditorModel.CONTEXT_MENU = ['debug-editor-context-menu'];
DebugEditorModel.STICKINESS = monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
DebugEditorModel.BREAKPOINT_HINT_DECORATION = {
    glyphMarginClassName: 'codicon-debug-hint',
    stickiness: DebugEditorModel_1.STICKINESS
};
DebugEditorModel.TOP_STACK_FRAME_MARGIN = {
    glyphMarginClassName: 'codicon-debug-stackframe',
    stickiness: DebugEditorModel_1.STICKINESS
};
DebugEditorModel.FOCUSED_STACK_FRAME_MARGIN = {
    glyphMarginClassName: 'codicon-debug-stackframe-focused',
    stickiness: DebugEditorModel_1.STICKINESS
};
DebugEditorModel.TOP_STACK_FRAME_DECORATION = {
    isWholeLine: true,
    className: 'theia-debug-top-stack-frame-line',
    stickiness: DebugEditorModel_1.STICKINESS
};
DebugEditorModel.TOP_STACK_FRAME_INLINE_DECORATION = {
    beforeContentClassName: 'theia-debug-top-stack-frame-column'
};
DebugEditorModel.FOCUSED_STACK_FRAME_DECORATION = {
    isWholeLine: true,
    className: 'theia-debug-focused-stack-frame-line',
    stickiness: DebugEditorModel_1.STICKINESS
};
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_hover_widget_1.DebugHoverWidget),
    tslib_1.__metadata("design:type", debug_hover_widget_1.DebugHoverWidget)
], DebugEditorModel.prototype, "hover", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_1.DebugEditor),
    tslib_1.__metadata("design:type", Object)
], DebugEditorModel.prototype, "editor", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugEditorModel.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugEditorModel.prototype, "sessions", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_1.ContextMenuRenderer)
], DebugEditorModel.prototype, "contextMenu", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_breakpoint_widget_1.DebugBreakpointWidget),
    tslib_1.__metadata("design:type", debug_breakpoint_widget_1.DebugBreakpointWidget)
], DebugEditorModel.prototype, "breakpointWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_exception_widget_1.DebugExceptionWidget),
    tslib_1.__metadata("design:type", debug_exception_widget_1.DebugExceptionWidget)
], DebugEditorModel.prototype, "exceptionWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_inline_value_decorator_1.DebugInlineValueDecorator),
    tslib_1.__metadata("design:type", debug_inline_value_decorator_1.DebugInlineValueDecorator)
], DebugEditorModel.prototype, "inlineValueDecorator", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugEditorModel.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugEditorModel.prototype, "init", null);
exports.DebugEditorModel = DebugEditorModel = DebugEditorModel_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugEditorModel);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-editor-service.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-editor-service.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugEditorService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_editor_model_1 = __webpack_require__(/*! ./debug-editor-model */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor-model.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
let DebugEditorService = class DebugEditorService {
    constructor() {
        this.models = new Map();
    }
    init() {
        this.editors.all.forEach(widget => this.push(widget));
        this.editors.onCreated(widget => this.push(widget));
    }
    push(widget) {
        const { editor } = widget;
        if (!(editor instanceof monaco_editor_1.MonacoEditor)) {
            return;
        }
        const uri = editor.getResourceUri().toString();
        const debugModel = this.factory(editor);
        this.models.set(uri, debugModel);
        editor.getControl().onDidDispose(() => {
            debugModel.dispose();
            this.models.delete(uri);
        });
    }
    get model() {
        const { currentEditor } = this.editors;
        const uri = currentEditor && currentEditor.getResourceUri();
        return uri && this.models.get(uri.toString());
    }
    get currentUri() {
        const { currentEditor } = this.editors;
        return currentEditor && currentEditor.getResourceUri();
    }
    getLogpoint(position) {
        const logpoint = this.anyBreakpoint(position);
        return logpoint && logpoint.logMessage ? logpoint : undefined;
    }
    getLogpointEnabled(position) {
        const logpoint = this.getLogpoint(position);
        return logpoint && logpoint.enabled;
    }
    getBreakpoint(position) {
        const breakpoint = this.anyBreakpoint(position);
        return breakpoint && breakpoint.logMessage ? undefined : breakpoint;
    }
    getBreakpointEnabled(position) {
        const breakpoint = this.getBreakpoint(position);
        return breakpoint && breakpoint.enabled;
    }
    anyBreakpoint(position) {
        return this.model && this.model.getBreakpoint(position);
    }
    getInlineBreakpoint(position) {
        return this.model && this.model.getInlineBreakpoint(position);
    }
    toggleBreakpoint(position) {
        const { model } = this;
        if (model) {
            model.toggleBreakpoint(position);
        }
    }
    setBreakpointEnabled(position, enabled) {
        const breakpoint = this.anyBreakpoint(position);
        if (breakpoint) {
            breakpoint.setEnabled(enabled);
        }
    }
    addInlineBreakpoint() {
        const { model } = this;
        if (model) {
            model.addInlineBreakpoint();
        }
    }
    showHover() {
        const { model } = this;
        if (model) {
            const selection = model.editor.getControl().getSelection();
            model.hover.show({ selection, focus: true });
        }
    }
    canShowHover() {
        var _a;
        const { model } = this;
        if (model) {
            const selection = model.editor.getControl().getSelection();
            return !!((_a = model.editor.getControl().getModel()) === null || _a === void 0 ? void 0 : _a.getWordAtPosition(selection.getStartPosition()));
        }
        return false;
    }
    addBreakpoint(context, position) {
        const { model } = this;
        if (model) {
            position = position || model.position;
            const breakpoint = model.getBreakpoint(position);
            if (breakpoint) {
                model.breakpointWidget.show({ breakpoint, context });
            }
            else {
                model.breakpointWidget.show({
                    position,
                    context
                });
            }
        }
    }
    async editBreakpoint(breakpointOrPosition) {
        if (breakpointOrPosition instanceof monaco.Position) {
            breakpointOrPosition = this.anyBreakpoint(breakpointOrPosition);
        }
        if (breakpointOrPosition) {
            await breakpointOrPosition.open();
            const model = this.models.get(breakpointOrPosition.uri.toString());
            if (model) {
                model.breakpointWidget.show(breakpointOrPosition);
            }
        }
    }
    closeBreakpoint() {
        const { model } = this;
        if (model) {
            model.breakpointWidget.hide();
        }
    }
    acceptBreakpoint() {
        const { model } = this;
        if (model) {
            model.acceptBreakpoint();
        }
    }
    closeBreakpointIfAffected({ uri, removed }) {
        const model = this.models.get(uri.toString());
        if (!model) {
            return;
        }
        const position = model.breakpointWidget.position;
        if (!position) {
            return;
        }
        for (const breakpoint of removed) {
            if (breakpoint.raw.line === position.lineNumber) {
                model.breakpointWidget.hide();
            }
        }
    }
};
exports.DebugEditorService = DebugEditorService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.EditorManager),
    tslib_1.__metadata("design:type", browser_1.EditorManager)
], DebugEditorService.prototype, "editors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugEditorService.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugEditorService.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_2.ContextMenuRenderer)
], DebugEditorService.prototype, "contextMenu", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_model_1.DebugEditorModelFactory),
    tslib_1.__metadata("design:type", Function)
], DebugEditorService.prototype, "factory", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugEditorService.prototype, "init", null);
exports.DebugEditorService = DebugEditorService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugEditorService);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-editor.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-editor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugEditor = void 0;
exports.DebugEditor = Symbol('DebugEditor');


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-exception-widget.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-exception-widget.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugExceptionWidget = exports.DebugExceptionMonacoEditorZoneWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const client_1 = __webpack_require__(/*! @theia/core/shared/react-dom/client */ "../node_modules/@theia/core/shared/react-dom/client/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const monaco_editor_zone_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-zone-widget */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js");
const debug_editor_1 = __webpack_require__(/*! ./debug-editor */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const widgets_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets */ "../node_modules/@theia/core/lib/browser/widgets/index.js");
class DebugExceptionMonacoEditorZoneWidget extends monaco_editor_zone_widget_1.MonacoEditorZoneWidget {
    computeContainerHeight(zoneHeight) {
        // reset height to match it to the content
        this.containerNode.style.height = 'initial';
        const height = this.containerNode.offsetHeight;
        const result = super.computeContainerHeight(zoneHeight);
        result.height = height;
        return result;
    }
}
exports.DebugExceptionMonacoEditorZoneWidget = DebugExceptionMonacoEditorZoneWidget;
let DebugExceptionWidget = class DebugExceptionWidget {
    constructor() {
        this.toDispose = new disposable_1.DisposableCollection();
    }
    init() {
        this.doInit();
    }
    async doInit() {
        this.toDispose.push(this.zone = new DebugExceptionMonacoEditorZoneWidget(this.editor.getControl()));
        this.zone.containerNode.classList.add('theia-debug-exception-widget');
        this.containerNodeRoot = (0, client_1.createRoot)(this.zone.containerNode);
        this.toDispose.push(disposable_1.Disposable.create(() => this.containerNodeRoot.unmount()));
        this.toDispose.push(this.editor.getControl().onDidLayoutChange(() => this.layout()));
    }
    dispose() {
        this.toDispose.dispose();
    }
    show({ info, lineNumber, column }) {
        this.render(info, () => {
            const fontInfo = this.editor.getControl().getOption(monaco.editor.EditorOption.fontInfo);
            this.zone.containerNode.style.fontSize = `${fontInfo.fontSize}px`;
            this.zone.containerNode.style.lineHeight = `${fontInfo.lineHeight}px`;
            if (lineNumber !== undefined && column !== undefined) {
                const afterLineNumber = lineNumber;
                const afterColumn = column;
                this.zone.show({ showFrame: true, afterLineNumber, afterColumn, heightInLines: 0, frameWidth: 1 });
            }
            this.layout();
        });
    }
    hide() {
        this.zone.hide();
    }
    render(info, cb) {
        const stackTrace = info.details && info.details.stackTrace;
        const exceptionTitle = info.id ?
            nls_1.nls.localizeByDefault('Exception has occurred: {0}', info.id) :
            nls_1.nls.localizeByDefault('Exception has occurred.');
        this.containerNodeRoot.render(React.createElement(React.Fragment, null,
            React.createElement("div", { className: 'title', ref: cb },
                exceptionTitle,
                React.createElement("span", { id: "exception-close", className: (0, widgets_1.codicon)('close', true), onClick: () => this.hide(), title: nls_1.nls.localizeByDefault('Close') })),
            info.description && React.createElement("div", { className: 'description' }, info.description),
            stackTrace && React.createElement("div", { className: 'stack-trace' }, stackTrace)));
    }
    layout() {
        // reset height to match it to the content
        this.zone.containerNode.style.height = 'initial';
        const lineHeight = this.editor.getControl().getOption(monaco.editor.EditorOption.lineHeight);
        const heightInLines = Math.ceil(this.zone.containerNode.offsetHeight / lineHeight);
        this.zone.layout(heightInLines);
    }
};
exports.DebugExceptionWidget = DebugExceptionWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_1.DebugEditor),
    tslib_1.__metadata("design:type", Object)
], DebugExceptionWidget.prototype, "editor", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugExceptionWidget.prototype, "init", null);
exports.DebugExceptionWidget = DebugExceptionWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugExceptionWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-expression-provider.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-expression-provider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and others. All rights reserved.
 *  Licensed under the MIT License. See https://github.com/Microsoft/vscode/blob/master/LICENSE.txt for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugExpressionProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
/**
 * TODO: introduce a new request to LSP to look up an expression range: https://github.com/Microsoft/language-server-protocol/issues/462
 */
let DebugExpressionProvider = class DebugExpressionProvider {
    get(model, selection) {
        const lineContent = model.getLineContent(selection.startLineNumber);
        const { start, end } = this.getExactExpressionStartAndEnd(lineContent, selection.startColumn, selection.endColumn);
        return lineContent.substring(start - 1, end);
    }
    getExactExpressionStartAndEnd(lineContent, looseStart, looseEnd) {
        let matchingExpression = undefined;
        let startOffset = 0;
        // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar
        // Match any character except a set of characters which often break interesting sub-expressions
        const expression = /([^()\[\]{}<>\s+\-/%~#^;=|,`!]|\->)+/g;
        // eslint-disable-next-line no-null/no-null
        let result = null;
        // First find the full expression under the cursor
        while (result = expression.exec(lineContent)) {
            const start = result.index + 1;
            const end = start + result[0].length;
            if (start <= looseStart && end >= looseEnd) {
                matchingExpression = result[0];
                startOffset = start;
                break;
            }
        }
        // If there are non-word characters after the cursor, we want to truncate the expression then.
        // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.
        if (matchingExpression) {
            const subExpression = /\w+/g;
            // eslint-disable-next-line no-null/no-null
            let subExpressionResult = null;
            while (subExpressionResult = subExpression.exec(matchingExpression)) {
                const subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;
                if (subEnd >= looseEnd) {
                    break;
                }
            }
            if (subExpressionResult) {
                matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);
            }
        }
        return matchingExpression ?
            { start: startOffset, end: startOffset + matchingExpression.length - 1 } :
            { start: 0, end: 0 };
    }
};
exports.DebugExpressionProvider = DebugExpressionProvider;
exports.DebugExpressionProvider = DebugExpressionProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugExpressionProvider);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-hover-source.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-hover-source.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugHoverSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_console_items_1 = __webpack_require__(/*! ../console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let DebugHoverSource = class DebugHoverSource extends source_tree_1.TreeSource {
    constructor() {
        super(...arguments);
        this.elements = [];
    }
    get expression() {
        return this._expression;
    }
    getElements() {
        return this.elements[Symbol.iterator]();
    }
    renderTitle(element) {
        return React.createElement("div", { className: 'theia-debug-hover-title', title: element.value }, element.value);
    }
    reset() {
        this._expression = undefined;
        this.elements = [];
        this.fireDidChange();
    }
    async evaluate(expression) {
        const evaluated = await this.doEvaluate(expression);
        const elements = evaluated && await evaluated.getElements();
        this._expression = evaluated;
        this.elements = elements ? [...elements] : [];
        this.fireDidChange();
        return evaluated;
    }
    async doEvaluate(expression) {
        const { currentSession } = this.sessions;
        if (!currentSession) {
            return undefined;
        }
        if (currentSession.capabilities.supportsEvaluateForHovers) {
            const item = new debug_console_items_1.ExpressionItem(expression, () => currentSession);
            await item.evaluate('hover');
            return item.available && item || undefined;
        }
        return this.findVariable(expression.split('.').map(word => word.trim()).filter(word => !!word));
    }
    async findVariable(namesToFind) {
        const { currentFrame } = this.sessions;
        if (!currentFrame) {
            return undefined;
        }
        let variable;
        const scopes = await currentFrame.getScopes();
        for (const scope of scopes) {
            const found = await this.doFindVariable(scope, namesToFind);
            if (!variable) {
                variable = found;
            }
            else if (found && found.value !== variable.value) {
                // only show if all expressions found have the same value
                return undefined;
            }
        }
        return variable;
    }
    async doFindVariable(owner, namesToFind) {
        const elements = await owner.getElements();
        const variables = [];
        for (const element of elements) {
            if (element instanceof debug_console_items_1.DebugVariable && element.name === namesToFind[0]) {
                variables.push(element);
            }
        }
        if (variables.length !== 1) {
            return undefined;
        }
        if (namesToFind.length === 1) {
            return variables[0];
        }
        else {
            return this.doFindVariable(variables[0], namesToFind.slice(1));
        }
    }
};
exports.DebugHoverSource = DebugHoverSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugHoverSource.prototype, "sessions", void 0);
exports.DebugHoverSource = DebugHoverSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugHoverSource);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-hover-widget.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-hover-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugHoverWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugHoverWidget = exports.createDebugHoverWidgetContainer = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const widgets_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/widgets */ "../node_modules/@theia/core/shared/@phosphor/widgets/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_editor_1 = __webpack_require__(/*! ./debug-editor */ "../node_modules/@theia/debug/lib/browser/editor/debug-editor.js");
const debug_expression_provider_1 = __webpack_require__(/*! ./debug-expression-provider */ "../node_modules/@theia/debug/lib/browser/editor/debug-expression-provider.js");
const debug_hover_source_1 = __webpack_require__(/*! ./debug-hover-source */ "../node_modules/@theia/debug/lib/browser/editor/debug-hover-source.js");
const debug_console_items_1 = __webpack_require__(/*! ../console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const languageFeatures_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures.js");
const cancellation_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/cancellation */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/cancellation.js");
const position_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/core/position */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/core/position.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
function createDebugHoverWidgetContainer(parent, editor) {
    const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
        virtualized: false
    });
    child.bind(debug_editor_1.DebugEditor).toConstantValue(editor);
    child.bind(debug_hover_source_1.DebugHoverSource).toSelf();
    child.unbind(source_tree_1.SourceTreeWidget);
    child.bind(debug_expression_provider_1.DebugExpressionProvider).toSelf();
    child.bind(DebugHoverWidget).toSelf();
    return child;
}
exports.createDebugHoverWidgetContainer = createDebugHoverWidgetContainer;
let DebugHoverWidget = DebugHoverWidget_1 = class DebugHoverWidget extends source_tree_1.SourceTreeWidget {
    constructor() {
        super(...arguments);
        this.allowEditorOverflow = true;
        this.domNode = document.createElement('div');
        this.titleNode = document.createElement('div');
        this.contentNode = document.createElement('div');
        this.doSchedule = debounce((fn) => fn(), 300);
    }
    getId() {
        return DebugHoverWidget_1.ID;
    }
    getDomNode() {
        return this.domNode;
    }
    init() {
        super.init();
        this.domNode.className = 'theia-debug-hover';
        this.titleNode.className = 'theia-debug-hover-title';
        this.domNode.appendChild(this.titleNode);
        this.contentNode.className = 'theia-debug-hover-content';
        this.domNode.appendChild(this.contentNode);
        // for stopping scroll events from contentNode going to the editor
        this.contentNode.addEventListener('wheel', e => e.stopPropagation());
        this.editor.getControl().addContentWidget(this);
        this.source = this.hoverSource;
        this.toDispose.pushAll([
            this.hoverSource,
            disposable_1.Disposable.create(() => this.editor.getControl().removeContentWidget(this)),
            disposable_1.Disposable.create(() => this.hide()),
            this.sessions.onDidChange(() => {
                if (!this.isEditorFrame()) {
                    this.hide();
                }
            })
        ]);
    }
    dispose() {
        this.toDispose.dispose();
    }
    show(options) {
        this.schedule(() => this.doShow(options), options && options.immediate);
    }
    hide(options) {
        this.schedule(() => this.doHide(), options && options.immediate);
    }
    schedule(fn, immediate = true) {
        if (immediate) {
            this.doSchedule.cancel();
            fn();
        }
        else {
            this.doSchedule(fn);
        }
    }
    doHide() {
        if (!this.isVisible) {
            return;
        }
        if (this.domNode.contains(document.activeElement)) {
            this.editor.getControl().focus();
        }
        if (this.isAttached) {
            widgets_1.Widget.detach(this);
        }
        this.hoverSource.reset();
        super.hide();
        this.options = undefined;
        this.editor.getControl().layoutContentWidget(this);
    }
    async doShow(options = this.options) {
        const cancellationSource = new cancellation_1.CancellationTokenSource();
        if (!this.isEditorFrame()) {
            this.hide();
            return;
        }
        if (!options) {
            this.hide();
            return;
        }
        if (this.options && this.options.selection.equalsRange(options.selection)) {
            return;
        }
        if (!this.isAttached) {
            widgets_1.Widget.attach(this, this.contentNode);
        }
        this.options = options;
        let matchingExpression;
        const pluginExpressionProvider = standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).evaluatableExpressionProvider;
        const textEditorModel = this.editor.document.textEditorModel;
        if (pluginExpressionProvider && pluginExpressionProvider.has(textEditorModel)) {
            const registeredProviders = pluginExpressionProvider.ordered(textEditorModel);
            const position = new position_1.Position(this.options.selection.startLineNumber, this.options.selection.startColumn);
            const promises = registeredProviders.map(support => Promise.resolve(support.provideEvaluatableExpression(textEditorModel, position, cancellationSource.token)));
            const results = await Promise.all(promises).then(core_1.ArrayUtils.coalesce);
            if (results.length > 0) {
                matchingExpression = results[0].expression;
                const range = results[0].range;
                if (!matchingExpression) {
                    const lineContent = textEditorModel.getLineContent(position.lineNumber);
                    matchingExpression = lineContent.substring(range.startColumn - 1, range.endColumn - 1);
                }
            }
        }
        else { // use fallback if no provider was registered
            const model = this.editor.getControl().getModel();
            if (model) {
                matchingExpression = this.expressionProvider.get(model, options.selection);
                if (matchingExpression) {
                    const expressionLineContent = model.getLineContent(this.options.selection.startLineNumber);
                    const startColumn = expressionLineContent.indexOf(matchingExpression, this.options.selection.startColumn - matchingExpression.length) + 1;
                    const endColumn = startColumn + matchingExpression.length;
                    this.options.selection = new monaco.Range(this.options.selection.startLineNumber, startColumn, this.options.selection.startLineNumber, endColumn);
                }
            }
        }
        if (!matchingExpression) {
            this.hide();
            return;
        }
        const toFocus = new disposable_1.DisposableCollection();
        if (this.options.focus === true) {
            toFocus.push(this.model.onNodeRefreshed(() => {
                toFocus.dispose();
                this.activate();
            }));
        }
        const expression = await this.hoverSource.evaluate(matchingExpression);
        if (!expression) {
            toFocus.dispose();
            this.hide();
            return;
        }
        this.contentNode.hidden = false;
        ['number', 'boolean', 'string'].forEach(token => this.titleNode.classList.remove(token));
        this.domNode.classList.remove('complex-value');
        if (expression.hasElements) {
            this.domNode.classList.add('complex-value');
        }
        else {
            this.contentNode.hidden = true;
            if (expression.type === 'number' || expression.type === 'boolean' || expression.type === 'string') {
                this.titleNode.classList.add(expression.type);
            }
            else if (!isNaN(+expression.value)) {
                this.titleNode.classList.add('number');
            }
            else if (debug_console_items_1.DebugVariable.booleanRegex.test(expression.value)) {
                this.titleNode.classList.add('boolean');
            }
            else if (debug_console_items_1.DebugVariable.stringRegex.test(expression.value)) {
                this.titleNode.classList.add('string');
            }
        }
        super.show();
        await new Promise(resolve => {
            setTimeout(() => window.requestAnimationFrame(() => {
                this.editor.getControl().layoutContentWidget(this);
                resolve();
            }), 0);
        });
    }
    isEditorFrame() {
        return this.sessions.isCurrentEditorFrame(this.editor.getResourceUri());
    }
    getPosition() {
        if (!this.isVisible) {
            return undefined;
        }
        const position = this.options && this.options.selection.getStartPosition();
        return position
            ? {
                position: new monaco.Position(position.lineNumber, position.column),
                preference: [
                    monaco.editor.ContentWidgetPositionPreference.ABOVE,
                    monaco.editor.ContentWidgetPositionPreference.BELOW,
                ],
            }
            : undefined;
    }
    onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        const { expression } = this.hoverSource;
        const value = expression && expression.value || '';
        this.titleNode.textContent = value;
        this.titleNode.title = value;
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.addKeyListener(this.domNode, browser_1.Key.ESCAPE, () => this.hide());
    }
};
exports.DebugHoverWidget = DebugHoverWidget;
DebugHoverWidget.ID = 'debug.editor.hover';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_editor_1.DebugEditor),
    tslib_1.__metadata("design:type", Object)
], DebugHoverWidget.prototype, "editor", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugHoverWidget.prototype, "sessions", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_hover_source_1.DebugHoverSource),
    tslib_1.__metadata("design:type", debug_hover_source_1.DebugHoverSource)
], DebugHoverWidget.prototype, "hoverSource", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_expression_provider_1.DebugExpressionProvider),
    tslib_1.__metadata("design:type", debug_expression_provider_1.DebugExpressionProvider)
], DebugHoverWidget.prototype, "expressionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugHoverWidget.prototype, "init", null);
exports.DebugHoverWidget = DebugHoverWidget = DebugHoverWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugHoverWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/editor/debug-inline-value-decorator.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/editor/debug-inline-value-decorator.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugInlineValueDecorator = exports.INLINE_VALUE_DECORATION_KEY = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const cancellation_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/cancellation */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/cancellation.js");
const wordHelper_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/core/wordHelper */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/core/wordHelper.js");
const languageFeatures_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const debug_console_items_1 = __webpack_require__(/*! ../console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const debug_preferences_1 = __webpack_require__(/*! ../debug-preferences */ "../node_modules/@theia/debug/lib/browser/debug-preferences.js");
const codeEditorService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService.js");
// https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/browser/debugEditorContribution.ts#L40-L43
exports.INLINE_VALUE_DECORATION_KEY = 'inlinevaluedecoration';
const MAX_NUM_INLINE_VALUES = 100; // JS Global scope can have 700+ entries. We want to limit ourselves for perf reasons
const MAX_INLINE_DECORATOR_LENGTH = 150; // Max string length of each inline decorator when debugging. If exceeded ... is added
const MAX_TOKENIZATION_LINE_LEN = 500; // If line is too long, then inline values for the line are skipped
/**
 * MAX SMI (SMall Integer) as defined in v8.
 * one bit is lost for boxing/unboxing flag.
 * one bit is lost for sign flag.
 * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
 */
// https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/base/common/uint.ts#L7-L13
const MAX_SAFE_SMALL_INTEGER = 1 << 30;
class InlineSegment {
    constructor(column, text) {
        this.column = column;
        this.text = text;
    }
}
let DebugInlineValueDecorator = class DebugInlineValueDecorator {
    constructor() {
        this.enabled = false;
        this.wordToLineNumbersMap = new Map();
    }
    onStart() {
        standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService).registerDecorationType('Inline debug decorations', exports.INLINE_VALUE_DECORATION_KEY, {});
        this.enabled = !!this.preferences['debug.inlineValues'];
        this.preferences.onPreferenceChanged(({ preferenceName, newValue }) => {
            if (preferenceName === 'debug.inlineValues' && !!newValue !== this.enabled) {
                this.enabled = !!newValue;
            }
        });
    }
    async calculateDecorations(debugEditorModel, stackFrame) {
        this.wordToLineNumbersMap = undefined;
        const model = debugEditorModel.editor.getControl().getModel() || undefined;
        return this.updateInlineValueDecorations(debugEditorModel, model, stackFrame);
    }
    // https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/browser/debugEditorContribution.ts#L382-L408
    async updateInlineValueDecorations(debugEditorModel, model, stackFrame) {
        if (!this.enabled || !model || !stackFrame || !stackFrame.source || model.uri.toString() !== stackFrame.source.uri.toString()) {
            return [];
        }
        // XXX: Here is a difference between the VS Code's `IStackFrame` and the `DebugProtocol.StackFrame`.
        // In DAP, `source` is optional, hence `range` is optional too.
        const { range: stackFrameRange } = stackFrame;
        if (!stackFrameRange) {
            return [];
        }
        const scopes = await stackFrame.getMostSpecificScopes(stackFrameRange);
        // Get all top level children in the scope chain
        const decorationsPerScope = await Promise.all(scopes.map(async (scope) => {
            const children = Array.from(await scope.getElements());
            let range = new monaco.Range(0, 0, stackFrameRange.startLineNumber, stackFrameRange.startColumn);
            if (scope.range) {
                range = range.setStartPosition(scope.range.startLineNumber, scope.range.startColumn);
            }
            return this.createInlineValueDecorationsInsideRange(children, range, model, debugEditorModel, stackFrame);
        }));
        return decorationsPerScope.reduce((previous, current) => previous.concat(current), []);
    }
    // https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/browser/debugEditorContribution.ts#L410-L452
    async createInlineValueDecorationsInsideRange(expressions, range, model, debugEditorModel, stackFrame) {
        const decorations = [];
        const inlineValuesProvider = standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).inlineValuesProvider;
        const textEditorModel = debugEditorModel.editor.document.textEditorModel;
        if (inlineValuesProvider && inlineValuesProvider.has(textEditorModel)) {
            const findVariable = async (variableName, caseSensitiveLookup) => {
                const scopes = await stackFrame.getMostSpecificScopes(stackFrame.range);
                const key = caseSensitiveLookup ? variableName : variableName.toLowerCase();
                for (const scope of scopes) {
                    const expressionContainers = await scope.getElements();
                    let container = expressionContainers.next();
                    while (!container.done) {
                        const debugVariable = container.value;
                        if (debugVariable && debugVariable instanceof debug_console_items_1.DebugVariable) {
                            if (caseSensitiveLookup) {
                                if (debugVariable.name === key) {
                                    return debugVariable;
                                }
                            }
                            else {
                                if (debugVariable.name.toLowerCase() === key) {
                                    return debugVariable;
                                }
                            }
                        }
                        container = expressionContainers.next();
                    }
                }
                return undefined;
            };
            const context = {
                frameId: stackFrame.raw.id,
                stoppedLocation: range
            };
            const cancellationToken = new cancellation_1.CancellationTokenSource().token;
            const registeredProviders = inlineValuesProvider.ordered(textEditorModel).reverse();
            const visibleRanges = debugEditorModel.editor.getControl().getVisibleRanges();
            const lineDecorations = new Map();
            for (const provider of registeredProviders) {
                for (const visibleRange of visibleRanges) {
                    const result = await provider.provideInlineValues(textEditorModel, visibleRange, context, cancellationToken);
                    if (result) {
                        for (const inlineValue of result) {
                            let text = undefined;
                            switch (inlineValue.type) {
                                case 'text':
                                    text = inlineValue.text;
                                    break;
                                case 'variable': {
                                    let varName = inlineValue.variableName;
                                    if (!varName) {
                                        const lineContent = model.getLineContent(inlineValue.range.startLineNumber);
                                        varName = lineContent.substring(inlineValue.range.startColumn - 1, inlineValue.range.endColumn - 1);
                                    }
                                    const variable = await findVariable(varName, inlineValue.caseSensitiveLookup);
                                    if (variable) {
                                        text = this.formatInlineValue(varName, variable.value);
                                    }
                                    break;
                                }
                                case 'expression': {
                                    let expr = inlineValue.expression;
                                    if (!expr) {
                                        const lineContent = model.getLineContent(inlineValue.range.startLineNumber);
                                        expr = lineContent.substring(inlineValue.range.startColumn - 1, inlineValue.range.endColumn - 1);
                                    }
                                    if (expr) {
                                        const expression = new debug_console_items_1.ExpressionItem(expr, () => stackFrame.thread.session);
                                        await expression.evaluate('watch');
                                        if (expression.available) {
                                            text = this.formatInlineValue(expr, expression.value);
                                        }
                                    }
                                    break;
                                }
                            }
                            if (text) {
                                const line = inlineValue.range.startLineNumber;
                                let lineSegments = lineDecorations.get(line);
                                if (!lineSegments) {
                                    lineSegments = [];
                                    lineDecorations.set(line, lineSegments);
                                }
                                if (!lineSegments.some(segment => segment.text === text)) {
                                    lineSegments.push(new InlineSegment(inlineValue.range.startColumn, text));
                                }
                            }
                        }
                    }
                }
            }
            ;
            // sort line segments and concatenate them into a decoration
            const separator = ', ';
            lineDecorations.forEach((segments, line) => {
                if (segments.length > 0) {
                    segments = segments.sort((a, b) => a.column - b.column);
                    const text = segments.map(s => s.text).join(separator);
                    decorations.push(this.createInlineValueDecoration(line, text));
                }
            });
        }
        else { // use fallback if no provider was registered
            const lineToNamesMap = new Map();
            const nameValueMap = new Map();
            for (const expr of expressions) {
                if (expr instanceof debug_console_items_1.DebugVariable) { // XXX: VS Code uses `IExpression` that has `name` and `value`.
                    nameValueMap.set(expr.name, expr.value);
                }
                // Limit the size of map. Too large can have a perf impact
                if (nameValueMap.size >= MAX_NUM_INLINE_VALUES) {
                    break;
                }
            }
            const wordToPositionsMap = this.getWordToPositionsMap(model);
            // Compute unique set of names on each line
            nameValueMap.forEach((_, name) => {
                const positions = wordToPositionsMap.get(name);
                if (positions) {
                    for (const position of positions) {
                        if (range.containsPosition(position)) {
                            if (!lineToNamesMap.has(position.lineNumber)) {
                                lineToNamesMap.set(position.lineNumber, []);
                            }
                            if (lineToNamesMap.get(position.lineNumber).indexOf(name) === -1) {
                                lineToNamesMap.get(position.lineNumber).push(name);
                            }
                        }
                    }
                }
            });
            // Compute decorators for each line
            lineToNamesMap.forEach((names, line) => {
                const contentText = names.sort((first, second) => {
                    const content = model.getLineContent(line);
                    return content.indexOf(first) - content.indexOf(second);
                }).map(name => `${name} = ${nameValueMap.get(name)}`).join(', ');
                decorations.push(this.createInlineValueDecoration(line, contentText));
            });
        }
        return decorations;
    }
    formatInlineValue(...args) {
        const valuePattern = '{0} = {1}';
        const formatRegExp = /{(\d+)}/g;
        if (args.length === 0) {
            return valuePattern;
        }
        return valuePattern.replace(formatRegExp, (match, group) => {
            const idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    // https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/browser/debugEditorContribution.ts#L454-L485
    createInlineValueDecoration(lineNumber, contentText) {
        // If decoratorText is too long, trim and add ellipses. This could happen for minified files with everything on a single line
        if (contentText.length > MAX_INLINE_DECORATOR_LENGTH) {
            contentText = contentText.substring(0, MAX_INLINE_DECORATOR_LENGTH) + '...';
        }
        return {
            range: {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: MAX_SAFE_SMALL_INTEGER,
                endColumn: MAX_SAFE_SMALL_INTEGER
            },
            renderOptions: {
                after: {
                    contentText,
                    backgroundColor: 'rgba(255, 200, 0, 0.2)',
                    margin: '10px'
                },
                dark: {
                    after: {
                        color: 'rgba(255, 255, 255, 0.5)',
                    }
                },
                light: {
                    after: {
                        color: 'rgba(0, 0, 0, 0.5)',
                    }
                }
            }
        };
    }
    // https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/browser/debugEditorContribution.ts#L487-L531
    getWordToPositionsMap(model) {
        model = model;
        if (!this.wordToLineNumbersMap) {
            this.wordToLineNumbersMap = new Map();
            if (!model) {
                return this.wordToLineNumbersMap;
            }
            // For every word in every line, map its ranges for fast lookup
            for (let lineNumber = 1, len = model.getLineCount(); lineNumber <= len; ++lineNumber) {
                const lineContent = model.getLineContent(lineNumber);
                // If line is too long then skip the line
                if (lineContent.length > MAX_TOKENIZATION_LINE_LEN) {
                    continue;
                }
                model.tokenization.forceTokenization(lineNumber);
                const lineTokens = model.tokenization.getLineTokens(lineNumber);
                for (let tokenIndex = 0, tokenCount = lineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
                    const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                    const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                    const tokenType = lineTokens.getStandardTokenType(tokenIndex);
                    const tokenStr = lineContent.substring(tokenStartOffset, tokenEndOffset);
                    // Token is a word and not a comment
                    if (tokenType === 0 /* StandardTokenType.Other */) {
                        wordHelper_1.DEFAULT_WORD_REGEXP.lastIndex = 0; // We assume tokens will usually map 1:1 to words if they match
                        const wordMatch = wordHelper_1.DEFAULT_WORD_REGEXP.exec(tokenStr);
                        if (wordMatch) {
                            const word = wordMatch[0];
                            if (!this.wordToLineNumbersMap.has(word)) {
                                this.wordToLineNumbersMap.set(word, []);
                            }
                            this.wordToLineNumbersMap.get(word).push(new monaco.Position(lineNumber, tokenStartOffset));
                        }
                    }
                }
            }
        }
        return this.wordToLineNumbersMap;
    }
};
exports.DebugInlineValueDecorator = DebugInlineValueDecorator;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_preferences_1.DebugPreferences),
    tslib_1.__metadata("design:type", Object)
], DebugInlineValueDecorator.prototype, "preferences", void 0);
exports.DebugInlineValueDecorator = DebugInlineValueDecorator = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugInlineValueDecorator);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugBreakpoint = exports.DebugBreakpointDecoration = exports.DebugBreakpointOptions = exports.DebugBreakpointData = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
class DebugBreakpointData {
}
exports.DebugBreakpointData = DebugBreakpointData;
class DebugBreakpointOptions {
}
exports.DebugBreakpointOptions = DebugBreakpointOptions;
class DebugBreakpointDecoration {
}
exports.DebugBreakpointDecoration = DebugBreakpointDecoration;
class DebugBreakpoint extends DebugBreakpointOptions {
    constructor(uri, options) {
        super();
        this.uri = uri;
        this.setBreakpointEnabled = (event) => {
            this.setEnabled(event.target.checked);
        };
        Object.assign(this, options);
    }
    update(data) {
        Object.assign(this, data);
    }
    get idFromAdapter() {
        return this.raw && this.raw.id;
    }
    get id() {
        return this.origin.id;
    }
    get enabled() {
        return this.breakpoints.breakpointsEnabled && this.origin.enabled;
    }
    get installed() {
        return !!this.raw;
    }
    get verified() {
        return !!this.raw ? this.raw.verified : true;
    }
    get message() {
        return this.raw && this.raw.message || '';
    }
    render() {
        const classNames = ['theia-source-breakpoint'];
        if (!this.isEnabled()) {
            classNames.push(browser_1.DISABLED_CLASS);
        }
        const decoration = this.getDecoration();
        return React.createElement("div", { title: decoration.message.join('\n'), className: classNames.join(' ') },
            React.createElement("span", { className: 'theia-debug-breakpoint-icon codicon ' + decoration.className }),
            React.createElement("input", { className: 'theia-input', type: 'checkbox', checked: this.origin.enabled, onChange: this.setBreakpointEnabled }),
            this.doRender());
    }
    isEnabled() {
        return this.breakpoints.breakpointsEnabled && this.verified;
    }
    getDecoration() {
        if (!this.enabled) {
            return this.getDisabledBreakpointDecoration();
        }
        if (this.installed && !this.verified) {
            return this.getUnverifiedBreakpointDecoration();
        }
        return this.doGetDecoration();
    }
    getUnverifiedBreakpointDecoration() {
        const decoration = this.getBreakpointDecoration();
        return {
            className: decoration.className + '-unverified',
            message: [this.message || 'Unverified ' + decoration.message[0]]
        };
    }
    getDisabledBreakpointDecoration(message) {
        const decoration = this.getBreakpointDecoration();
        return {
            className: decoration.className + '-disabled',
            message: [message || ('Disabled ' + decoration.message[0])]
        };
    }
    doGetDecoration(messages = []) {
        if (this.message) {
            if (messages.length) {
                messages[messages.length - 1].concat(', ' + this.message);
            }
            else {
                messages.push(this.message);
            }
        }
        return this.getBreakpointDecoration(messages);
    }
}
exports.DebugBreakpoint = DebugBreakpoint;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugFunctionBreakpoint = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_breakpoint_1 = __webpack_require__(/*! ./debug-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js");
const dialogs_1 = __webpack_require__(/*! @theia/core/lib/browser/dialogs */ "../node_modules/@theia/core/lib/browser/dialogs.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class DebugFunctionBreakpoint extends debug_breakpoint_1.DebugBreakpoint {
    constructor(origin, options) {
        super(breakpoint_manager_1.BreakpointManager.FUNCTION_URI, options);
        this.origin = origin;
    }
    setEnabled(enabled) {
        const breakpoints = this.breakpoints.getFunctionBreakpoints();
        const breakpoint = breakpoints.find(b => b.id === this.id);
        if (breakpoint && breakpoint.enabled !== enabled) {
            breakpoint.enabled = enabled;
            this.breakpoints.setFunctionBreakpoints(breakpoints);
        }
    }
    isEnabled() {
        return super.isEnabled() && this.isSupported();
    }
    isSupported() {
        const { session } = this;
        return !session || !!session.capabilities.supportsFunctionBreakpoints;
    }
    remove() {
        const breakpoints = this.breakpoints.getFunctionBreakpoints();
        const newBreakpoints = breakpoints.filter(b => b.id !== this.id);
        if (breakpoints.length !== newBreakpoints.length) {
            this.breakpoints.setFunctionBreakpoints(newBreakpoints);
        }
    }
    get name() {
        return this.origin.raw.name;
    }
    doRender() {
        return React.createElement("span", { className: 'line-info' }, this.name);
    }
    doGetDecoration() {
        if (!this.isSupported()) {
            return this.getDisabledBreakpointDecoration(core_1.nls.localizeByDefault('Function breakpoints are not supported by this debug type'));
        }
        return super.doGetDecoration();
    }
    getBreakpointDecoration(message) {
        return {
            className: 'codicon-debug-breakpoint-function',
            message: message || [core_1.nls.localizeByDefault('Function Breakpoint')]
        };
    }
    async open() {
        const input = new dialogs_1.SingleTextInputDialog({
            title: core_1.nls.localizeByDefault('Add Function Breakpoint'),
            initialValue: this.name
        });
        const newValue = await input.open();
        if (newValue !== undefined && newValue !== this.name) {
            const breakpoints = this.breakpoints.getFunctionBreakpoints();
            const breakpoint = breakpoints.find(b => b.id === this.id);
            if (breakpoint) {
                if (breakpoint.raw.name !== newValue) {
                    breakpoint.raw.name = newValue;
                    this.breakpoints.setFunctionBreakpoints(breakpoints);
                }
            }
            else {
                this.origin.raw.name = newValue;
                breakpoints.push(this.origin);
                this.breakpoints.setFunctionBreakpoints(breakpoints);
            }
        }
    }
}
exports.DebugFunctionBreakpoint = DebugFunctionBreakpoint;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-instruction-breakpoint.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-instruction-breakpoint.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugInstructionBreakpoint = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_breakpoint_1 = __webpack_require__(/*! ./debug-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js");
class DebugInstructionBreakpoint extends debug_breakpoint_1.DebugBreakpoint {
    constructor(origin, options) {
        super(breakpoint_manager_1.BreakpointManager.INSTRUCTION_URI, options);
        this.origin = origin;
    }
    setEnabled(enabled) {
        if (enabled !== this.origin.enabled) {
            this.breakpoints.updateInstructionBreakpoint(this.origin.id, { enabled });
        }
    }
    isEnabled() {
        return super.isEnabled() && this.isSupported();
    }
    isSupported() {
        var _a;
        return Boolean((_a = this.session) === null || _a === void 0 ? void 0 : _a.capabilities.supportsInstructionBreakpoints);
    }
    remove() {
        this.breakpoints.removeInstructionBreakpoint(this.origin.instructionReference);
    }
    doRender() {
        return React.createElement("span", { className: "line-info" }, this.origin.instructionReference);
    }
    getBreakpointDecoration(message) {
        if (!this.isSupported()) {
            return {
                className: 'codicon-debug-breakpoint-unsupported',
                message: message !== null && message !== void 0 ? message : [core_1.nls.localize('theia/debug/instruction-breakpoint', 'Instruction Breakpoint')],
            };
        }
        if (this.origin.condition || this.origin.hitCondition) {
            return {
                className: 'codicon-debug-breakpoint-conditional',
                message: message || [core_1.nls.localizeByDefault('Conditional Breakpoint...')]
            };
        }
        return {
            className: 'codicon-debug-breakpoint',
            message: message || [core_1.nls.localize('theia/debug/instruction-breakpoint', 'Instruction Breakpoint')]
        };
    }
}
exports.DebugInstructionBreakpoint = DebugInstructionBreakpoint;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSourceBreakpoint = exports.DebugSourceBreakpointData = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const debug_breakpoint_1 = __webpack_require__(/*! ./debug-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-breakpoint.js");
class DebugSourceBreakpointData extends debug_breakpoint_1.DebugBreakpointData {
}
exports.DebugSourceBreakpointData = DebugSourceBreakpointData;
class DebugSourceBreakpoint extends debug_breakpoint_1.DebugBreakpoint {
    constructor(origin, options) {
        super(new uri_1.default(origin.uri), options);
        this.setBreakpointEnabled = (event) => {
            this.setEnabled(event.target.checked);
        };
        this.origins = [origin];
    }
    update(data) {
        super.update(data);
    }
    get origin() {
        return this.origins[0];
    }
    setEnabled(enabled) {
        const { uri, raw } = this;
        let shouldUpdate = false;
        let breakpoints = raw && this.doRemove(this.origins.filter(origin => !(origin.raw.line === raw.line && origin.raw.column === raw.column)));
        // Check for breakpoints array with at least one entry
        if (breakpoints && breakpoints.length) {
            shouldUpdate = true;
        }
        else {
            breakpoints = this.breakpoints.getBreakpoints(uri);
        }
        for (const breakpoint of breakpoints) {
            if (breakpoint.raw.line === this.origin.raw.line && breakpoint.raw.column === this.origin.raw.column && breakpoint.enabled !== enabled) {
                breakpoint.enabled = enabled;
                shouldUpdate = true;
            }
        }
        if (shouldUpdate) {
            this.breakpoints.setBreakpoints(this.uri, breakpoints);
        }
    }
    updateOrigins(data) {
        const breakpoints = this.breakpoints.getBreakpoints(this.uri);
        let shouldUpdate = false;
        const originPositions = new Set();
        this.origins.forEach(origin => originPositions.add(origin.raw.line + ':' + origin.raw.column));
        for (const breakpoint of breakpoints) {
            if (originPositions.has(breakpoint.raw.line + ':' + breakpoint.raw.column)) {
                Object.assign(breakpoint.raw, data);
                shouldUpdate = true;
            }
        }
        if (shouldUpdate) {
            this.breakpoints.setBreakpoints(this.uri, breakpoints);
        }
    }
    /** 1-based */
    get line() {
        return this.raw && this.raw.line || this.origins[0].raw.line;
    }
    get column() {
        return this.raw && this.raw.column || this.origins[0].raw.column;
    }
    get endLine() {
        return this.raw && this.raw.endLine;
    }
    get endColumn() {
        return this.raw && this.raw.endColumn;
    }
    get condition() {
        return this.origin.raw.condition;
    }
    get hitCondition() {
        return this.origin.raw.hitCondition;
    }
    get logMessage() {
        return this.origin.raw.logMessage;
    }
    get source() {
        return this.raw && this.raw.source && this.session && this.session.getSource(this.raw.source);
    }
    async open(options = {
        mode: 'reveal'
    }) {
        const { line, column, endLine, endColumn } = this;
        const selection = {
            start: {
                line: line - 1,
                character: typeof column === 'number' ? column - 1 : undefined
            }
        };
        if (typeof endLine === 'number') {
            selection.end = {
                line: endLine - 1,
                character: typeof endColumn === 'number' ? endColumn - 1 : undefined
            };
        }
        if (this.source) {
            await this.source.open({
                ...options,
                selection
            });
        }
        else {
            await this.editorManager.open(this.uri, {
                ...options,
                selection
            });
        }
    }
    doRender() {
        return React.createElement(React.Fragment, null,
            React.createElement("span", { className: 'line-info', title: this.labelProvider.getLongName(this.uri) },
                React.createElement("span", { className: 'name' },
                    this.labelProvider.getName(this.uri),
                    " "),
                React.createElement("span", { className: 'path ' + browser_1.TREE_NODE_INFO_CLASS },
                    this.labelProvider.getLongName(this.uri.parent),
                    " ")),
            React.createElement("span", { className: 'line' }, this.renderPosition()));
    }
    renderPosition() {
        return this.line + (typeof this.column === 'number' ? ':' + this.column : '');
    }
    doGetDecoration(messages = []) {
        if (this.logMessage || this.condition || this.hitCondition) {
            const { session } = this;
            if (this.logMessage) {
                if (session && !session.capabilities.supportsLogPoints) {
                    return this.getUnsupportedBreakpointDecoration('Logpoints not supported by this debug type');
                }
                messages.push('Log Message: ' + this.logMessage);
            }
            if (this.condition) {
                if (session && !session.capabilities.supportsConditionalBreakpoints) {
                    return this.getUnsupportedBreakpointDecoration('Conditional breakpoints not supported by this debug type');
                }
                messages.push('Expression: ' + this.condition);
            }
            if (this.hitCondition) {
                if (session && !session.capabilities.supportsHitConditionalBreakpoints) {
                    return this.getUnsupportedBreakpointDecoration('Hit conditional breakpoints not supported by this debug type');
                }
                messages.push('Hit Count: ' + this.hitCondition);
            }
        }
        return super.doGetDecoration(messages);
    }
    getUnsupportedBreakpointDecoration(message) {
        return {
            className: 'codicon-debug-breakpoint-unsupported',
            message: [message]
        };
    }
    getBreakpointDecoration(message) {
        if (this.logMessage) {
            return {
                className: 'codicon-debug-breakpoint-log',
                message: message || ['Logpoint']
            };
        }
        if (this.condition || this.hitCondition) {
            return {
                className: 'codicon-debug-breakpoint-conditional',
                message: message || ['Conditional Breakpoint']
            };
        }
        return {
            className: 'codicon-debug-breakpoint',
            message: message || ['Breakpoint']
        };
    }
    remove() {
        const breakpoints = this.doRemove(this.origins);
        if (breakpoints) {
            this.breakpoints.setBreakpoints(this.uri, breakpoints);
        }
    }
    doRemove(origins) {
        if (!origins.length) {
            return undefined;
        }
        const { uri } = this;
        const toRemove = new Set();
        origins.forEach(origin => toRemove.add(origin.raw.line + ':' + origin.raw.column));
        let shouldUpdate = false;
        const breakpoints = this.breakpoints.findMarkers({
            uri,
            dataFilter: data => {
                const result = !toRemove.has(data.raw.line + ':' + data.raw.column);
                shouldUpdate = shouldUpdate || !result;
                return result;
            }
        }).map(({ data }) => data);
        return shouldUpdate && breakpoints || undefined;
    }
}
exports.DebugSourceBreakpoint = DebugSourceBreakpoint;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-source.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-source.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSource = exports.DebugSourceData = void 0;
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const debug_uri_utils_1 = __webpack_require__(/*! ../../common/debug-uri-utils */ "../node_modules/@theia/debug/lib/common/debug-uri-utils.js");
class DebugSourceData {
}
exports.DebugSourceData = DebugSourceData;
class DebugSource extends DebugSourceData {
    constructor(session, editorManager, labelProvider) {
        super();
        this.session = session;
        this.editorManager = editorManager;
        this.labelProvider = labelProvider;
    }
    get uri() {
        return DebugSource.toUri(this.raw);
    }
    update(data) {
        Object.assign(this, data);
    }
    open(options) {
        return this.editorManager.open(this.uri, options);
    }
    async load() {
        const source = this.raw;
        const sourceReference = source.sourceReference;
        const response = await this.session.sendRequest('source', {
            sourceReference,
            source
        });
        return response.body.content;
    }
    get inMemory() {
        return this.uri.scheme === debug_uri_utils_1.DEBUG_SCHEME;
    }
    get name() {
        if (this.inMemory) {
            return this.raw.name || this.uri.path.base || this.uri.path.fsPath();
        }
        return this.labelProvider.getName(this.uri);
    }
    get longName() {
        if (this.inMemory) {
            return this.name;
        }
        return this.labelProvider.getLongName(this.uri);
    }
    static toUri(raw) {
        if (raw.sourceReference && raw.sourceReference > 0) {
            return new uri_1.default().withScheme(debug_uri_utils_1.DEBUG_SCHEME).withPath(raw.name).withQuery(String(raw.sourceReference));
        }
        if (!raw.path) {
            throw new Error('Unrecognized source type: ' + JSON.stringify(raw));
        }
        if (raw.path.match(debug_uri_utils_1.SCHEME_PATTERN)) {
            return new uri_1.default(raw.path);
        }
        return new uri_1.default(vscode_uri_1.URI.file(raw.path));
    }
}
exports.DebugSource = DebugSource;
DebugSource.SCHEME = debug_uri_utils_1.DEBUG_SCHEME;
DebugSource.SCHEME_PATTERN = debug_uri_utils_1.SCHEME_PATTERN;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-stack-frame.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-stack-frame.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugStackFrame = exports.DebugStackFrameData = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Based on https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/common/debugModel.ts
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const debug_console_items_1 = __webpack_require__(/*! ../console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
class DebugStackFrameData {
}
exports.DebugStackFrameData = DebugStackFrameData;
class DebugStackFrame extends DebugStackFrameData {
    constructor(thread, session) {
        super();
        this.thread = thread;
        this.session = session;
    }
    get id() {
        return this.session.id + ':' + this.thread.id + ':' + this.raw.id;
    }
    /**
     * Returns the frame identifier from the debug protocol.
     */
    get frameId() {
        return this.raw.id;
    }
    get source() {
        return this._source;
    }
    update(data) {
        Object.assign(this, data);
        this._source = this.raw.source && this.session.getSource(this.raw.source);
    }
    async restart() {
        await this.session.sendRequest('restartFrame', this.toArgs({
            threadId: this.thread.id
        }));
    }
    async open(options) {
        if (!this.source) {
            return undefined;
        }
        const { line, column, endLine, endColumn } = this.raw;
        const selection = {
            start: browser_2.Position.create(this.clampPositive(line - 1), this.clampPositive(column - 1))
        };
        if (typeof endLine === 'number') {
            selection.end = {
                line: this.clampPositive(endLine - 1),
                character: typeof endColumn === 'number' ? this.clampPositive(endColumn - 1) : undefined
            };
        }
        this.source.open({
            mode: 'reveal',
            ...options,
            selection
        });
    }
    /**
     * Debugger can send `column: 0` value despite of initializing the debug session with `columnsStartAt1: true`.
     * This method can be used to ensure that neither `column` nor `column` are negative numbers.
     * See https://github.com/microsoft/vscode-mock-debug/issues/85.
     */
    clampPositive(value) {
        return Math.max(value, 0);
    }
    getScopes() {
        return this.scopes || (this.scopes = this.doGetScopes());
    }
    async doGetScopes() {
        let response;
        try {
            response = await this.session.sendRequest('scopes', this.toArgs());
        }
        catch {
            // no-op: ignore debug adapter errors
        }
        if (!response) {
            return [];
        }
        return response.body.scopes.map(raw => new debug_console_items_1.DebugScope(raw, () => this.session));
    }
    // https://github.com/theia-ide/vscode/blob/standalone/0.19.x/src/vs/workbench/contrib/debug/common/debugModel.ts#L324-L335
    async getMostSpecificScopes(range) {
        const scopes = await this.getScopes();
        const nonExpensiveScopes = scopes.filter(s => !s.expensive);
        const haveRangeInfo = nonExpensiveScopes.some(s => !!s.range);
        if (!haveRangeInfo) {
            return nonExpensiveScopes;
        }
        const scopesContainingRange = nonExpensiveScopes.filter(scope => scope.range && monaco.Range.containsRange(scope.range, range))
            .sort((first, second) => (first.range.endLineNumber - first.range.startLineNumber) - (second.range.endLineNumber - second.range.startLineNumber));
        return scopesContainingRange.length ? scopesContainingRange : nonExpensiveScopes;
    }
    toArgs(arg) {
        return Object.assign({}, arg, {
            frameId: this.raw.id
        });
    }
    render() {
        const classNames = ['theia-debug-stack-frame'];
        if (this.raw.presentationHint === 'label') {
            classNames.push('label');
        }
        if (this.raw.presentationHint === 'subtle') {
            classNames.push('subtle');
        }
        if (!this.source || this.source.raw.presentationHint === 'deemphasize') {
            classNames.push(browser_1.DISABLED_CLASS);
        }
        return React.createElement("div", { className: classNames.join(' ') },
            React.createElement("span", { className: 'expression', title: this.raw.name }, this.raw.name),
            this.renderFile());
    }
    renderFile() {
        const { source } = this;
        if (!source) {
            return undefined;
        }
        const origin = source.raw.origin && `\n${source.raw.origin}` || '';
        return React.createElement("span", { className: 'file', title: source.longName + origin },
            React.createElement("span", { className: 'name' }, source.name),
            React.createElement("span", { className: 'line' },
                this.raw.line,
                ":",
                this.raw.column));
    }
    get range() {
        const { source, line: startLine, column: startColumn, endLine, endColumn } = this.raw;
        if (source) {
            return new monaco.Range(startLine, startColumn, endLine || startLine, endColumn || startColumn);
        }
        return undefined;
    }
}
exports.DebugStackFrame = DebugStackFrame;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/model/debug-thread.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/model/debug-thread.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugThread = exports.DebugThreadData = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const debug_stack_frame_1 = __webpack_require__(/*! ./debug-stack-frame */ "../node_modules/@theia/debug/lib/browser/model/debug-stack-frame.js");
class DebugThreadData {
}
exports.DebugThreadData = DebugThreadData;
class DebugThread extends DebugThreadData {
    get onDidFocusStackFrame() {
        return this.onDidFocusStackFrameEmitter.event;
    }
    constructor(session) {
        super();
        this.session = session;
        this.onDidChangedEmitter = new core_1.Emitter();
        this.onDidChanged = this.onDidChangedEmitter.event;
        this.onDidFocusStackFrameEmitter = new core_1.Emitter();
        this._frames = new Map();
        this.pendingFetch = Promise.resolve([]);
        this._pendingFetchCount = 0;
        this.pendingFetchCancel = new core_1.CancellationTokenSource();
    }
    get id() {
        return this.session.id + ':' + this.raw.id;
    }
    get threadId() {
        return this.raw.id;
    }
    get currentFrame() {
        return this._currentFrame;
    }
    set currentFrame(frame) {
        var _a;
        if (((_a = this._currentFrame) === null || _a === void 0 ? void 0 : _a.id) === (frame === null || frame === void 0 ? void 0 : frame.id)) {
            return;
        }
        this._currentFrame = frame;
        this.onDidChangedEmitter.fire(undefined);
        this.onDidFocusStackFrameEmitter.fire(frame);
    }
    get stopped() {
        return !!this.stoppedDetails;
    }
    update(data) {
        Object.assign(this, data);
        if ('stoppedDetails' in data) {
            this.clearFrames();
        }
    }
    clear() {
        this.update({
            raw: this.raw,
            stoppedDetails: undefined
        });
    }
    continue() {
        return this.session.sendRequest('continue', this.toArgs());
    }
    stepOver() {
        return this.session.sendRequest('next', this.toArgs());
    }
    stepIn() {
        return this.session.sendRequest('stepIn', this.toArgs());
    }
    stepOut() {
        return this.session.sendRequest('stepOut', this.toArgs());
    }
    pause() {
        return this.session.sendRequest('pause', this.toArgs());
    }
    get supportsGoto() {
        return !!this.session.capabilities.supportsGotoTargetsRequest;
    }
    async jumpToCursor(uri, position) {
        var _a;
        const source = await ((_a = this.session) === null || _a === void 0 ? void 0 : _a.toDebugSource(uri));
        if (!source) {
            return undefined;
        }
        const response = await this.session.sendRequest('gotoTargets', { source, line: position.lineNumber, column: position.column });
        if (response && response.body.targets.length === 0) {
            this.session.showMessage(core_1.MessageType.Warning, 'No executable code is associated at the current cursor position.');
            return;
        }
        const targetId = response.body.targets[0].id;
        return this.session.sendRequest('goto', this.toArgs({ targetId }));
    }
    async getExceptionInfo() {
        if (this.stoppedDetails && this.stoppedDetails.reason === 'exception') {
            if (this.session.capabilities.supportsExceptionInfoRequest) {
                const response = await this.session.sendRequest('exceptionInfo', this.toArgs());
                return {
                    id: response.body.exceptionId,
                    description: response.body.description,
                    details: response.body.details
                };
            }
            return {
                description: this.stoppedDetails.text
            };
        }
        return undefined;
    }
    get supportsTerminate() {
        return !!this.session.capabilities.supportsTerminateThreadsRequest;
    }
    async terminate() {
        if (this.supportsTerminate) {
            await this.session.sendRequest('terminateThreads', {
                threadIds: [this.raw.id]
            });
        }
    }
    get frames() {
        return this._frames.values();
    }
    get topFrame() {
        return this.frames.next().value;
    }
    get frameCount() {
        return this._frames.size;
    }
    async fetchFrames(levels = 20) {
        const cancel = this.pendingFetchCancel.token;
        this._pendingFetchCount += 1;
        return this.pendingFetch = this.pendingFetch.then(async () => {
            try {
                const start = this.frameCount;
                const frames = await this.doFetchFrames(start, levels);
                if (cancel.isCancellationRequested) {
                    return [];
                }
                return this.doUpdateFrames(frames);
            }
            catch (e) {
                console.error('fetchFrames failed:', e);
                return [];
            }
            finally {
                if (!cancel.isCancellationRequested) {
                    this._pendingFetchCount -= 1;
                }
            }
        });
    }
    get pendingFrameCount() {
        return this._pendingFetchCount;
    }
    async doFetchFrames(startFrame, levels) {
        try {
            const response = await this.session.sendRequest('stackTrace', this.toArgs({ startFrame, levels }));
            if (this.stoppedDetails) {
                this.stoppedDetails.totalFrames = response.body.totalFrames;
            }
            return response.body.stackFrames;
        }
        catch (e) {
            if (this.stoppedDetails) {
                this.stoppedDetails.framesErrorMessage = e.message;
            }
            return [];
        }
    }
    doUpdateFrames(frames) {
        const result = new Set();
        for (const raw of frames) {
            const id = raw.id;
            const frame = this._frames.get(id) || new debug_stack_frame_1.DebugStackFrame(this, this.session);
            this._frames.set(id, frame);
            frame.update({ raw });
            result.add(frame);
        }
        this.updateCurrentFrame();
        return [...result.values()];
    }
    clearFrames() {
        // Clear all frames
        this._frames.clear();
        // Cancel all request promises
        this.pendingFetchCancel.cancel();
        this.pendingFetchCancel = new core_1.CancellationTokenSource();
        // Empty all current requests
        this.pendingFetch = Promise.resolve([]);
        this._pendingFetchCount = 0;
        this.updateCurrentFrame();
    }
    updateCurrentFrame() {
        const { currentFrame } = this;
        const frameId = currentFrame && currentFrame.raw.id;
        this.currentFrame = typeof frameId === 'number' &&
            this._frames.get(frameId) ||
            this._frames.values().next().value;
    }
    toArgs(arg) {
        return Object.assign({}, arg, {
            threadId: this.raw.id
        });
    }
    render() {
        return (React.createElement("div", { className: "theia-debug-thread", title: core_1.nls.localizeByDefault('Session') },
            React.createElement("span", { className: "label" }, this.raw.name),
            React.createElement("span", { className: "status" }, this.threadStatus())));
    }
    threadStatus() {
        if (!this.stoppedDetails) {
            return core_1.nls.localizeByDefault('Running');
        }
        const description = this.stoppedDetails.description;
        if (description) {
            // According to DAP we must show description as is. Translation is made by debug adapter
            return description;
        }
        const reason = this.stoppedDetails.reason;
        const localizedReason = this.getLocalizedReason(reason);
        return reason
            ? core_1.nls.localizeByDefault('Paused on {0}', localizedReason)
            : core_1.nls.localizeByDefault('Paused');
    }
    getLocalizedReason(reason) {
        switch (reason) {
            case 'step':
                return core_1.nls.localize('theia/debug/step', 'step');
            case 'breakpoint':
                return core_1.nls.localize('theia/debug/breakpoint', 'breakpoint');
            case 'exception':
                return core_1.nls.localize('theia/debug/exception', 'exception');
            case 'pause':
                return core_1.nls.localize('theia/debug/pause', 'pause');
            case 'entry':
                return core_1.nls.localize('theia/debug/entry', 'entry');
            case 'goto':
                return core_1.nls.localize('theia/debug/goto', 'goto');
            case 'function breakpoint':
                return core_1.nls.localize('theia/debug/functionBreakpoint', 'function breakpoint');
            case 'data breakpoint':
                return core_1.nls.localize('theia/debug/dataBreakpoint', 'data breakpoint');
            case 'instruction breakpoint':
                return core_1.nls.localize('theia/debug/instructionBreakpoint', 'instruction breakpoint');
            default:
                return '';
        }
    }
}
exports.DebugThread = DebugThread;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-action.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-action.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugAction = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
class DebugAction extends React.Component {
    constructor() {
        super(...arguments);
        this.setRef = (ref) => this.ref = ref || undefined;
    }
    render() {
        const { enabled, label, iconClass } = this.props;
        const classNames = ['debug-action'];
        if (iconClass) {
            classNames.push(...(0, browser_1.codiconArray)(iconClass, true));
        }
        if (enabled === false) {
            classNames.push(browser_1.DISABLED_CLASS);
        }
        return React.createElement("span", { tabIndex: 0, className: classNames.join(' '), title: label, onClick: this.props.run, ref: this.setRef }, !iconClass && React.createElement("div", null, label));
    }
    focus() {
        if (this.ref) {
            this.ref.focus();
        }
    }
}
exports.DebugAction = DebugAction;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-source.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-source.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugBreakpointsSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_exception_breakpoint_1 = __webpack_require__(/*! ./debug-exception-breakpoint */ "../node_modules/@theia/debug/lib/browser/view/debug-exception-breakpoint.js");
let DebugBreakpointsSource = class DebugBreakpointsSource extends source_tree_1.TreeSource {
    init() {
        this.fireDidChange();
        this.toDispose.push(this.model.onDidChangeBreakpoints(() => this.fireDidChange()));
    }
    *getElements() {
        for (const exceptionBreakpoint of this.breakpoints.getExceptionBreakpoints()) {
            yield new debug_exception_breakpoint_1.DebugExceptionBreakpoint(exceptionBreakpoint, this.breakpoints);
        }
        for (const functionBreakpoint of this.model.functionBreakpoints) {
            yield functionBreakpoint;
        }
        for (const instructionBreakpoint of this.model.instructionBreakpoints) {
            yield instructionBreakpoint;
        }
        for (const breakpoint of this.model.breakpoints) {
            yield breakpoint;
        }
    }
};
exports.DebugBreakpointsSource = DebugBreakpointsSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugBreakpointsSource.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugBreakpointsSource.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugBreakpointsSource.prototype, "init", null);
exports.DebugBreakpointsSource = DebugBreakpointsSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugBreakpointsSource);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-widget.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-widget.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugBreakpointsWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugBreakpointsWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_breakpoints_source_1 = __webpack_require__(/*! ./debug-breakpoints-source */ "../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-source.js");
const breakpoint_manager_1 = __webpack_require__(/*! ../breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugBreakpointsWidget = DebugBreakpointsWidget_1 = class DebugBreakpointsWidget extends source_tree_1.SourceTreeWidget {
    static createContainer(parent) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: DebugBreakpointsWidget_1.CONTEXT_MENU,
            virtualized: false,
            scrollIfActive: true
        });
        child.bind(debug_breakpoints_source_1.DebugBreakpointsSource).toSelf();
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(DebugBreakpointsWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugBreakpointsWidget_1.createContainer(parent).get(DebugBreakpointsWidget_1);
    }
    init() {
        super.init();
        this.id = DebugBreakpointsWidget_1.FACTORY_ID + ':' + this.viewModel.id;
        this.title.label = nls_1.nls.localizeByDefault('Breakpoints');
        this.toDispose.push(this.breakpointsSource);
        this.source = this.breakpointsSource;
    }
    getDefaultNodeStyle(node, props) {
        return undefined;
    }
};
exports.DebugBreakpointsWidget = DebugBreakpointsWidget;
DebugBreakpointsWidget.CONTEXT_MENU = ['debug-breakpoints-context-menu'];
DebugBreakpointsWidget.EDIT_MENU = [...DebugBreakpointsWidget_1.CONTEXT_MENU, 'a_edit'];
DebugBreakpointsWidget.REMOVE_MENU = [...DebugBreakpointsWidget_1.CONTEXT_MENU, 'b_remove'];
DebugBreakpointsWidget.ENABLE_MENU = [...DebugBreakpointsWidget_1.CONTEXT_MENU, 'c_enable'];
DebugBreakpointsWidget.FACTORY_ID = 'debug:breakpoints';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugBreakpointsWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(breakpoint_manager_1.BreakpointManager),
    tslib_1.__metadata("design:type", breakpoint_manager_1.BreakpointManager)
], DebugBreakpointsWidget.prototype, "breakpoints", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_breakpoints_source_1.DebugBreakpointsSource),
    tslib_1.__metadata("design:type", debug_breakpoints_source_1.DebugBreakpointsSource)
], DebugBreakpointsWidget.prototype, "breakpointsSource", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugBreakpointsWidget.prototype, "init", null);
exports.DebugBreakpointsWidget = DebugBreakpointsWidget = DebugBreakpointsWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugBreakpointsWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-configuration-select.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-configuration-select.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (C) 2021 Ericsson and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConfigurationSelect = void 0;
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const debug_session_options_1 = __webpack_require__(/*! ../debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const select_component_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/select-component */ "../node_modules/@theia/core/lib/browser/widgets/select-component.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
class DebugConfigurationSelect extends React.Component {
    constructor(props) {
        super(props);
        this.selectRef = React.createRef();
        this.setCurrentConfiguration = (option) => {
            const value = option.value;
            if (!value) {
                return false;
            }
            else if (value === DebugConfigurationSelect.ADD_CONFIGURATION) {
                setTimeout(() => this.manager.addConfiguration());
            }
            else if (value.startsWith(DebugConfigurationSelect.PICK)) {
                const providerType = this.parsePickValue(value);
                this.selectDynamicConfigFromQuickPick(providerType);
            }
            else {
                const data = JSON.parse(value);
                this.manager.current = data;
                this.refreshDebugConfigurations();
            }
        };
        this.refreshDebugConfigurations = async () => {
            const configsOptionsPerType = await this.manager.provideDynamicDebugConfigurations();
            const providerTypes = [];
            for (const [type, configurationsOptions] of Object.entries(configsOptionsPerType)) {
                if (configurationsOptions.length > 0) {
                    providerTypes.push(type);
                }
            }
            const value = this.currentValue;
            this.selectRef.current.value = value;
            this.setState({ providerTypes, currentValue: value });
        };
        this.manager = props.manager;
        this.quickInputService = props.quickInputService;
        this.state = {
            providerTypes: [],
            currentValue: undefined
        };
        this.manager.onDidChangeConfigurationProviders(() => {
            this.refreshDebugConfigurations();
        });
    }
    componentDidUpdate() {
        var _a;
        // synchronize the currentValue with the selectComponent value
        if (((_a = this.selectRef.current) === null || _a === void 0 ? void 0 : _a.value) !== this.currentValue) {
            this.refreshDebugConfigurations();
        }
    }
    componentDidMount() {
        this.refreshDebugConfigurations();
    }
    render() {
        return React.createElement(select_component_1.SelectComponent, { options: this.renderOptions(), defaultValue: this.state.currentValue, onChange: option => this.setCurrentConfiguration(option), onFocus: () => this.refreshDebugConfigurations(), onBlur: () => this.refreshDebugConfigurations(), ref: this.selectRef });
    }
    get currentValue() {
        const { current } = this.manager;
        const matchingOption = this.getCurrentOption(current);
        return matchingOption ? matchingOption.value : current ? JSON.stringify(current) : DebugConfigurationSelect.NO_CONFIGURATION;
    }
    getCurrentOption(current) {
        if (!current || !this.selectRef.current) {
            return;
        }
        const matchingOption = this.selectRef.current.options.find(option => option.userData === DebugConfigurationSelect.CONFIG_MARKER
            && this.matchesOption(JSON.parse(option.value), current));
        return matchingOption;
    }
    matchesOption(sessionOption, current) {
        const matchesNameAndWorkspace = sessionOption.name === current.name && sessionOption.workspaceFolderUri === current.workspaceFolderUri;
        return debug_session_options_1.DebugSessionOptions.isConfiguration(sessionOption) && debug_session_options_1.DebugSessionOptions.isConfiguration(current)
            ? matchesNameAndWorkspace && sessionOption.providerType === current.providerType
            : matchesNameAndWorkspace;
    }
    toPickValue(providerType) {
        return DebugConfigurationSelect.PICK + providerType;
    }
    parsePickValue(value) {
        return value.slice(DebugConfigurationSelect.PICK.length);
    }
    async resolveDynamicConfigurationPicks(providerType) {
        const configurationsOfProviderType = (await this.manager.provideDynamicDebugConfigurations())[providerType];
        if (!configurationsOfProviderType) {
            return [];
        }
        return configurationsOfProviderType.map(options => ({
            label: options.configuration.name,
            configurationType: options.configuration.type,
            request: options.configuration.request,
            providerType: options.providerType,
            description: this.toBaseName(options.workspaceFolderUri),
            workspaceFolderUri: options.workspaceFolderUri
        }));
    }
    async selectDynamicConfigFromQuickPick(providerType) {
        const picks = await this.resolveDynamicConfigurationPicks(providerType);
        if (picks.length === 0) {
            return;
        }
        const selected = await this.quickInputService.showQuickPick(picks, {
            placeholder: nls_1.nls.localizeByDefault('Select Launch Configuration')
        });
        if (!selected) {
            return;
        }
        const selectedConfiguration = {
            name: selected.label,
            type: selected.configurationType,
            request: selected.request
        };
        this.manager.current = this.manager.find(selectedConfiguration, selected.workspaceFolderUri, selected.providerType);
        this.refreshDebugConfigurations();
    }
    renderOptions() {
        const options = [];
        // Add non dynamic debug configurations
        for (const config of this.manager.all) {
            const value = JSON.stringify(config);
            options.push({
                value,
                label: this.toName(config, this.props.isMultiRoot),
                userData: DebugConfigurationSelect.CONFIG_MARKER
            });
        }
        // Add recently used dynamic debug configurations
        const { recentDynamicOptions } = this.manager;
        if (recentDynamicOptions.length > 0) {
            if (options.length > 0) {
                options.push({
                    separator: true
                });
            }
            for (const dynamicOption of recentDynamicOptions) {
                const value = JSON.stringify(dynamicOption);
                options.push({
                    value,
                    label: this.toName(dynamicOption, this.props.isMultiRoot) + ' (' + dynamicOption.providerType + ')',
                    userData: DebugConfigurationSelect.CONFIG_MARKER
                });
            }
        }
        // Placing a 'No Configuration' entry enables proper functioning of the 'onChange' event, by
        // having an entry to switch from (E.g. a case where only one dynamic configuration type is available)
        if (options.length === 0) {
            const value = DebugConfigurationSelect.NO_CONFIGURATION;
            options.push({
                value,
                label: nls_1.nls.localizeByDefault('No Configurations')
            });
        }
        // Add dynamic configuration types for quick pick selection
        const types = this.state.providerTypes;
        if (types.length > 0) {
            options.push({
                separator: true
            });
            for (const type of types) {
                const value = this.toPickValue(type);
                options.push({
                    value,
                    label: type + '...'
                });
            }
        }
        options.push({
            separator: true
        });
        options.push({
            value: DebugConfigurationSelect.ADD_CONFIGURATION,
            label: nls_1.nls.localizeByDefault('Add Configuration...')
        });
        return options;
    }
    toName(options, multiRoot) {
        return this.props.labelProvider.getLabel(options, multiRoot);
    }
    toBaseName(uri) {
        return uri ? new uri_1.default(uri).path.base : '';
    }
}
exports.DebugConfigurationSelect = DebugConfigurationSelect;
DebugConfigurationSelect.SEPARATOR = '──────────';
DebugConfigurationSelect.PICK = '__PICK__';
DebugConfigurationSelect.NO_CONFIGURATION = '__NO_CONF__';
DebugConfigurationSelect.ADD_CONFIGURATION = '__ADD_CONF__';
DebugConfigurationSelect.CONFIG_MARKER = '__CONFIG__';


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-configuration-widget.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-configuration-widget.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConfigurationWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const debug_console_contribution_1 = __webpack_require__(/*! ../console/debug-console-contribution */ "../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js");
const debug_configuration_manager_1 = __webpack_require__(/*! ../debug-configuration-manager */ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const debug_frontend_application_contribution_1 = __webpack_require__(/*! ../debug-frontend-application-contribution */ "../node_modules/@theia/debug/lib/browser/debug-frontend-application-contribution.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_action_1 = __webpack_require__(/*! ./debug-action */ "../node_modules/@theia/debug/lib/browser/view/debug-action.js");
const debug_configuration_select_1 = __webpack_require__(/*! ./debug-configuration-select */ "../node_modules/@theia/debug/lib/browser/view/debug-configuration-select.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const debug_session_options_1 = __webpack_require__(/*! ../debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const debug_session_configuration_label_provider_1 = __webpack_require__(/*! ../debug-session-configuration-label-provider */ "../node_modules/@theia/debug/lib/browser/debug-session-configuration-label-provider.js");
let DebugConfigurationWidget = class DebugConfigurationWidget extends browser_1.ReactWidget {
    constructor() {
        super(...arguments);
        this.onRender = new common_1.DisposableCollection();
        this.setStepRef = (stepRef) => {
            this.stepRef = stepRef || undefined;
            this.onRender.dispose();
        };
        this.start = async () => {
            let configuration;
            try {
                configuration = await this.manager.getSelectedConfiguration();
            }
            catch (e) {
                this.messageService.error(e.message);
                return;
            }
            if (debug_session_options_1.DebugSessionOptions.isConfiguration(configuration)) {
                configuration.startedByUser = true;
            }
            this.commandRegistry.executeCommand(debug_frontend_application_contribution_1.DebugCommands.START.id, configuration);
        };
        this.openConfiguration = () => this.manager.openConfiguration();
        this.openConsole = () => this.debugConsole.openView({
            activate: true
        });
    }
    init() {
        this.addClass('debug-toolbar');
        this.toDispose.push(this.manager.onDidChange(() => this.update()));
        this.toDispose.push(this.workspaceService.onWorkspaceChanged(() => this.update()));
        this.toDispose.push(this.workspaceService.onWorkspaceLocationChanged(() => this.update()));
        this.scrollOptions = undefined;
        this.update();
    }
    focus() {
        if (!this.doFocus()) {
            this.onRender.push(common_1.Disposable.create(() => this.doFocus()));
            this.update();
        }
    }
    doFocus() {
        if (!this.stepRef) {
            return false;
        }
        this.stepRef.focus();
        return true;
    }
    render() {
        return React.createElement(React.Fragment, null,
            React.createElement(debug_action_1.DebugAction, { run: this.start, label: nls_1.nls.localizeByDefault('Start Debugging'), iconClass: 'debug-start', ref: this.setStepRef }),
            React.createElement(debug_configuration_select_1.DebugConfigurationSelect, { manager: this.manager, quickInputService: this.quickInputService, isMultiRoot: this.workspaceService.isMultiRootWorkspaceOpened, labelProvider: this.sessionConfigurationLabelProvider }),
            React.createElement(debug_action_1.DebugAction, { run: this.openConfiguration, label: nls_1.nls.localizeByDefault('Open {0}', '"launch.json"'), iconClass: 'settings-gear' }),
            React.createElement(debug_action_1.DebugAction, { run: this.openConsole, label: nls_1.nls.localizeByDefault('Debug Console'), iconClass: 'terminal' }));
    }
};
exports.DebugConfigurationWidget = DebugConfigurationWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], DebugConfigurationWidget.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugConfigurationWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], DebugConfigurationWidget.prototype, "manager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugConfigurationWidget.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_console_contribution_1.DebugConsoleContribution),
    tslib_1.__metadata("design:type", debug_console_contribution_1.DebugConsoleContribution)
], DebugConfigurationWidget.prototype, "debugConsole", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    tslib_1.__metadata("design:type", Object)
], DebugConfigurationWidget.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], DebugConfigurationWidget.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MessageService),
    tslib_1.__metadata("design:type", common_1.MessageService)
], DebugConfigurationWidget.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_configuration_label_provider_1.DebugSessionConfigurationLabelProvider),
    tslib_1.__metadata("design:type", debug_session_configuration_label_provider_1.DebugSessionConfigurationLabelProvider)
], DebugConfigurationWidget.prototype, "sessionConfigurationLabelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugConfigurationWidget.prototype, "init", null);
exports.DebugConfigurationWidget = DebugConfigurationWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugConfigurationWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-exception-breakpoint.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-exception-breakpoint.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugExceptionBreakpoint = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const dialogs_1 = __webpack_require__(/*! @theia/core/lib/browser/dialogs */ "../node_modules/@theia/core/lib/browser/dialogs.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class DebugExceptionBreakpoint {
    constructor(data, breakpoints) {
        this.data = data;
        this.breakpoints = breakpoints;
        this.toggle = () => this.breakpoints.toggleExceptionBreakpoint(this.data.raw.filter);
        this.id = data.raw.filter + ':' + data.raw.label;
    }
    render() {
        return React.createElement("div", { title: this.data.raw.description || this.data.raw.label, className: 'theia-source-breakpoint' },
            React.createElement("span", { className: 'theia-debug-breakpoint-icon' }),
            React.createElement("input", { type: 'checkbox', checked: this.data.enabled, onChange: this.toggle }),
            React.createElement("span", { className: 'line-info' },
                React.createElement("span", { className: 'name' },
                    this.data.raw.label,
                    " "),
                this.data.condition &&
                    React.createElement("span", { title: core_1.nls.localizeByDefault('Expression condition: {0}', this.data.condition), className: 'path ' + browser_1.TREE_NODE_INFO_CLASS },
                        this.data.condition,
                        " ")));
    }
    async editCondition() {
        const inputDialog = new dialogs_1.SingleTextInputDialog({
            title: this.data.raw.label,
            placeholder: this.data.raw.conditionDescription,
            initialValue: this.data.condition
        });
        let condition = await inputDialog.open();
        if (condition === undefined) {
            return;
        }
        if (condition === '') {
            condition = undefined;
        }
        if (condition !== this.data.condition) {
            this.breakpoints.updateExceptionBreakpoint(this.data.raw.filter, { condition });
        }
    }
}
exports.DebugExceptionBreakpoint = DebugExceptionBreakpoint;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-session-widget.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-session-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugSessionWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugSessionWidget = exports.DEBUG_VIEW_CONTAINER_TITLE_OPTIONS = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const debug_threads_widget_1 = __webpack_require__(/*! ./debug-threads-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js");
const debug_stack_frames_widget_1 = __webpack_require__(/*! ./debug-stack-frames-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js");
const debug_breakpoints_widget_1 = __webpack_require__(/*! ./debug-breakpoints-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-breakpoints-widget.js");
const debug_variables_widget_1 = __webpack_require__(/*! ./debug-variables-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js");
const debug_toolbar_widget_1 = __webpack_require__(/*! ./debug-toolbar-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-toolbar-widget.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debug_watch_widget_1 = __webpack_require__(/*! ./debug-watch-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-watch-widget.js");
const frontend_application_state_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-state */ "../node_modules/@theia/core/lib/browser/frontend-application-state.js");
exports.DEBUG_VIEW_CONTAINER_TITLE_OPTIONS = {
    label: 'debug',
    iconClass: (0, browser_1.codicon)('debug-alt'),
    closeable: true
};
let DebugSessionWidget = DebugSessionWidget_1 = class DebugSessionWidget extends browser_1.BaseWidget {
    static createContainer(parent) {
        const child = new inversify_1.Container({ defaultScope: 'Singleton' });
        child.parent = parent;
        child.bind(debug_view_model_1.DebugViewModel).toSelf();
        child.bind(debug_toolbar_widget_1.DebugToolBar).toSelf();
        child.bind(DebugSessionWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugSessionWidget_1.createContainer(parent).get(DebugSessionWidget_1);
    }
    init() {
        this.id = 'debug:session:' + this.model.id;
        this.title.label = this.model.label;
        this.title.caption = this.model.label;
        this.title.closable = true;
        this.title.iconClass = (0, browser_1.codicon)('debug-alt');
        this.addClass('theia-session-container');
        this.viewContainer = this.viewContainerFactory({
            id: 'debug:view-container:' + this.model.id
        });
        this.viewContainer.setTitleOptions(exports.DEBUG_VIEW_CONTAINER_TITLE_OPTIONS);
        this.stateService.reachedState('initialized_layout').then(() => {
            for (const subwidget of DebugSessionWidget_1.subwidgets) {
                const widgetPromises = [];
                const existingWidget = this.widgetManager.tryGetPendingWidget(subwidget.FACTORY_ID);
                // No other view container instantiated this widget during startup.
                if (!existingWidget) {
                    widgetPromises.push(this.widgetManager.getOrCreateWidget(subwidget.FACTORY_ID));
                }
                Promise.all(widgetPromises).then(widgets => widgets.forEach(widget => this.viewContainer.addWidget(widget)));
            }
        });
        this.toDispose.pushAll([
            this.toolbar,
            this.viewContainer
        ]);
        const layout = this.layout = new browser_1.PanelLayout();
        layout.addWidget(this.toolbar);
        layout.addWidget(this.viewContainer);
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.toolbar.focus();
    }
    onAfterShow(msg) {
        super.onAfterShow(msg);
        this.getTrackableWidgets().forEach(w => w.update());
    }
    getTrackableWidgets() {
        return [this.viewContainer];
    }
    storeState() {
        return this.viewContainer.storeState();
    }
    restoreState(oldState) {
        this.viewContainer.restoreState(oldState);
    }
};
exports.DebugSessionWidget = DebugSessionWidget;
DebugSessionWidget.subwidgets = [debug_threads_widget_1.DebugThreadsWidget, debug_stack_frames_widget_1.DebugStackFramesWidget, debug_variables_widget_1.DebugVariablesWidget, debug_watch_widget_1.DebugWatchWidget, debug_breakpoints_widget_1.DebugBreakpointsWidget];
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ViewContainer.Factory),
    tslib_1.__metadata("design:type", Function)
], DebugSessionWidget.prototype, "viewContainerFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugSessionWidget.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_toolbar_widget_1.DebugToolBar),
    tslib_1.__metadata("design:type", debug_toolbar_widget_1.DebugToolBar)
], DebugSessionWidget.prototype, "toolbar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], DebugSessionWidget.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(frontend_application_state_1.FrontendApplicationStateService),
    tslib_1.__metadata("design:type", frontend_application_state_1.FrontendApplicationStateService)
], DebugSessionWidget.prototype, "stateService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugSessionWidget.prototype, "init", null);
exports.DebugSessionWidget = DebugSessionWidget = DebugSessionWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugSessionWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-source.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-source.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadMoreStackFrames = exports.DebugStackFramesSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
let DebugStackFramesSource = class DebugStackFramesSource extends source_tree_1.TreeSource {
    constructor() {
        super(...arguments);
        this.refresh = debounce(() => this.fireDidChange(), 100);
    }
    init() {
        this.refresh();
        this.toDispose.push(this.model.onDidChange(() => this.refresh()));
    }
    *getElements() {
        const thread = this.model.currentThread;
        if (!thread) {
            return;
        }
        yield* thread.frames;
        if (thread.stoppedDetails) {
            const { framesErrorMessage, totalFrames } = thread.stoppedDetails;
            if (framesErrorMessage) {
                yield {
                    render: () => React.createElement("span", { title: framesErrorMessage }, framesErrorMessage)
                };
            }
            if (totalFrames && totalFrames > thread.frameCount) {
                yield new LoadMoreStackFrames(thread);
            }
        }
    }
};
exports.DebugStackFramesSource = DebugStackFramesSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugStackFramesSource.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugStackFramesSource.prototype, "init", null);
exports.DebugStackFramesSource = DebugStackFramesSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugStackFramesSource);
class LoadMoreStackFrames {
    constructor(thread) {
        this.thread = thread;
    }
    render() {
        return React.createElement("span", { className: 'theia-load-more-frames' }, "Load More Stack Frames");
    }
    async open() {
        const frames = await this.thread.fetchFrames();
        if (frames[0]) {
            this.thread.currentFrame = frames[0];
        }
    }
}
exports.LoadMoreStackFrames = LoadMoreStackFrames;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugStackFramesWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugStackFramesWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_stack_frames_source_1 = __webpack_require__(/*! ./debug-stack-frames-source */ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-source.js");
const debug_stack_frame_1 = __webpack_require__(/*! ../model/debug-stack-frame */ "../node_modules/@theia/debug/lib/browser/model/debug-stack-frame.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debug_call_stack_item_type_key_1 = __webpack_require__(/*! ../debug-call-stack-item-type-key */ "../node_modules/@theia/debug/lib/browser/debug-call-stack-item-type-key.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugStackFramesWidget = DebugStackFramesWidget_1 = class DebugStackFramesWidget extends source_tree_1.SourceTreeWidget {
    constructor() {
        super(...arguments);
        this.updatingSelection = false;
    }
    static createContainer(parent) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: DebugStackFramesWidget_1.CONTEXT_MENU,
            virtualized: false,
            scrollIfActive: true
        });
        child.bind(debug_stack_frames_source_1.DebugStackFramesSource).toSelf();
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(DebugStackFramesWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugStackFramesWidget_1.createContainer(parent).get(DebugStackFramesWidget_1);
    }
    init() {
        super.init();
        this.id = DebugStackFramesWidget_1.FACTORY_ID + ':' + this.viewModel.id;
        this.title.label = nls_1.nls.localizeByDefault('Call Stack');
        this.toDispose.push(this.frames);
        this.source = this.frames;
        this.toDispose.push(this.viewModel.onDidChange(() => this.updateWidgetSelection()));
        this.toDispose.push(this.model.onNodeRefreshed(() => this.updateWidgetSelection()));
        this.toDispose.push(this.model.onSelectionChanged(() => this.updateModelSelection()));
    }
    async updateWidgetSelection() {
        if (this.updatingSelection) {
            return;
        }
        this.updatingSelection = true;
        try {
            const { currentFrame } = this.viewModel;
            if (currentFrame) {
                const node = this.model.getNode(currentFrame.id);
                if (browser_1.SelectableTreeNode.is(node)) {
                    this.model.selectNode(node);
                }
            }
        }
        finally {
            this.updatingSelection = false;
        }
    }
    async updateModelSelection() {
        if (this.updatingSelection) {
            return;
        }
        this.updatingSelection = true;
        try {
            const node = this.model.selectedNodes[0];
            if (source_tree_1.TreeElementNode.is(node)) {
                if (node.element instanceof debug_stack_frame_1.DebugStackFrame) {
                    node.element.thread.currentFrame = node.element;
                    this.debugCallStackItemTypeKey.set('stackFrame');
                }
            }
        }
        finally {
            this.updatingSelection = false;
        }
    }
    toContextMenuArgs(node) {
        if (source_tree_1.TreeElementNode.is(node)) {
            if (node.element instanceof debug_stack_frame_1.DebugStackFrame) {
                const source = node.element.source;
                if (source) {
                    if (source.inMemory) {
                        const path = source.raw.path || source.raw.sourceReference;
                        if (path !== undefined) {
                            return [path];
                        }
                    }
                    else {
                        return [source.uri.toString()];
                    }
                }
            }
        }
        return undefined;
    }
    tapNode(node) {
        if (source_tree_1.TreeElementNode.is(node) && node.element instanceof debug_stack_frames_source_1.LoadMoreStackFrames) {
            node.element.open();
        }
        super.tapNode(node);
    }
    getDefaultNodeStyle(node, props) {
        return undefined;
    }
};
exports.DebugStackFramesWidget = DebugStackFramesWidget;
DebugStackFramesWidget.CONTEXT_MENU = ['debug-frames-context-menu'];
DebugStackFramesWidget.FACTORY_ID = 'debug:frames';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_stack_frames_source_1.DebugStackFramesSource),
    tslib_1.__metadata("design:type", debug_stack_frames_source_1.DebugStackFramesSource)
], DebugStackFramesWidget.prototype, "frames", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugStackFramesWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_call_stack_item_type_key_1.DebugCallStackItemTypeKey),
    tslib_1.__metadata("design:type", Object)
], DebugStackFramesWidget.prototype, "debugCallStackItemTypeKey", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugStackFramesWidget.prototype, "init", null);
exports.DebugStackFramesWidget = DebugStackFramesWidget = DebugStackFramesWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugStackFramesWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-threads-source.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-threads-source.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugThreadsSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
let DebugThreadsSource = class DebugThreadsSource extends source_tree_1.TreeSource {
    init() {
        this.fireDidChange();
        this.toDispose.push(this.model.onDidChange(() => this.fireDidChange()));
    }
    get multiSession() {
        return this.model.sessionCount > 1;
    }
    *getElements() {
        if (this.model.sessionCount === 1 && this.model.session && this.model.session.threadCount) {
            return yield* this.model.session.threads;
        }
        for (const session of this.model.sessions) {
            if (!session.parentSession) {
                yield session;
            }
        }
    }
};
exports.DebugThreadsSource = DebugThreadsSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugThreadsSource.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugThreadsSource.prototype, "init", null);
exports.DebugThreadsSource = DebugThreadsSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugThreadsSource);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugThreadsWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugThreadsWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_threads_source_1 = __webpack_require__(/*! ./debug-threads-source */ "../node_modules/@theia/debug/lib/browser/view/debug-threads-source.js");
const debug_session_1 = __webpack_require__(/*! ../debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_thread_1 = __webpack_require__(/*! ../model/debug-thread */ "../node_modules/@theia/debug/lib/browser/model/debug-thread.js");
const debug_view_model_1 = __webpack_require__(/*! ../view/debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debug_call_stack_item_type_key_1 = __webpack_require__(/*! ../debug-call-stack-item-type-key */ "../node_modules/@theia/debug/lib/browser/debug-call-stack-item-type-key.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugThreadsWidget = DebugThreadsWidget_1 = class DebugThreadsWidget extends source_tree_1.SourceTreeWidget {
    constructor() {
        super(...arguments);
        this.updatingSelection = false;
    }
    static createContainer(parent) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: DebugThreadsWidget_1.CONTEXT_MENU,
            virtualized: false,
            scrollIfActive: true
        });
        child.bind(debug_threads_source_1.DebugThreadsSource).toSelf();
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(DebugThreadsWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugThreadsWidget_1.createContainer(parent).get(DebugThreadsWidget_1);
    }
    init() {
        super.init();
        this.id = DebugThreadsWidget_1.FACTORY_ID + ':' + this.viewModel.id;
        this.title.label = nls_1.nls.localize('theia/debug/threads', 'Threads');
        this.toDispose.push(this.threads);
        this.source = this.threads;
        this.toDispose.push(this.viewModel.onDidChange(() => this.updateWidgetSelection()));
        this.toDispose.push(this.model.onSelectionChanged(() => this.updateModelSelection()));
    }
    updateWidgetSelection() {
        if (this.updatingSelection) {
            return;
        }
        this.updatingSelection = true;
        try {
            const { currentThread } = this.viewModel;
            if (currentThread) {
                const node = this.model.getNode(currentThread.id);
                if (browser_1.SelectableTreeNode.is(node)) {
                    this.model.selectNode(node);
                }
            }
        }
        finally {
            this.updatingSelection = false;
        }
    }
    updateModelSelection() {
        if (this.updatingSelection) {
            return;
        }
        this.updatingSelection = true;
        try {
            const node = this.model.selectedNodes[0];
            if (source_tree_1.TreeElementNode.is(node)) {
                if (node.element instanceof debug_session_1.DebugSession) {
                    this.viewModel.currentSession = node.element;
                    this.debugCallStackItemTypeKey.set('session');
                }
                else if (node.element instanceof debug_thread_1.DebugThread) {
                    this.viewModel.currentSession = node.element.session;
                    node.element.session.currentThread = node.element;
                    this.debugCallStackItemTypeKey.set('thread');
                }
            }
        }
        finally {
            this.updatingSelection = false;
        }
    }
    toContextMenuArgs(node) {
        if (source_tree_1.TreeElementNode.is(node) && node.element instanceof debug_thread_1.DebugThread) {
            return [node.element.raw.id];
        }
        return undefined;
    }
    getDefaultNodeStyle(node, props) {
        if (this.threads.multiSession) {
            return super.getDefaultNodeStyle(node, props);
        }
        return undefined;
    }
};
exports.DebugThreadsWidget = DebugThreadsWidget;
DebugThreadsWidget.CONTEXT_MENU = ['debug-threads-context-menu'];
DebugThreadsWidget.CONTROL_MENU = [...DebugThreadsWidget_1.CONTEXT_MENU, 'a_control'];
DebugThreadsWidget.TERMINATE_MENU = [...DebugThreadsWidget_1.CONTEXT_MENU, 'b_terminate'];
DebugThreadsWidget.OPEN_MENU = [...DebugThreadsWidget_1.CONTEXT_MENU, 'c_open'];
DebugThreadsWidget.FACTORY_ID = 'debug:threads';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_threads_source_1.DebugThreadsSource),
    tslib_1.__metadata("design:type", debug_threads_source_1.DebugThreadsSource)
], DebugThreadsWidget.prototype, "threads", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugThreadsWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_call_stack_item_type_key_1.DebugCallStackItemTypeKey),
    tslib_1.__metadata("design:type", Object)
], DebugThreadsWidget.prototype, "debugCallStackItemTypeKey", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugThreadsWidget.prototype, "init", null);
exports.DebugThreadsWidget = DebugThreadsWidget = DebugThreadsWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugThreadsWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-toolbar-widget.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-toolbar-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugToolBar_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugToolBar = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const widgets_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets */ "../node_modules/@theia/core/lib/browser/widgets/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debug_session_1 = __webpack_require__(/*! ../debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_action_1 = __webpack_require__(/*! ./debug-action */ "../node_modules/@theia/debug/lib/browser/view/debug-action.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugToolBar = DebugToolBar_1 = class DebugToolBar extends widgets_1.ReactWidget {
    constructor() {
        super(...arguments);
        this.onRender = new core_1.DisposableCollection();
        this.setStepRef = (stepRef) => {
            this.stepRef = stepRef || undefined;
            this.onRender.dispose();
        };
        this.start = () => this.model.start({ startedByUser: true });
        this.restart = () => this.model.restart();
        this.stop = () => this.model.terminate();
        this.continue = () => this.model.currentThread && this.model.currentThread.continue();
        this.pause = () => this.model.currentThread && this.model.currentThread.pause();
        this.stepOver = () => this.model.currentThread && this.model.currentThread.stepOver();
        this.stepIn = () => this.model.currentThread && this.model.currentThread.stepIn();
        this.stepOut = () => this.model.currentThread && this.model.currentThread.stepOut();
    }
    init() {
        this.id = 'debug:toolbar:' + this.model.id;
        this.addClass('debug-toolbar');
        this.toDispose.push(this.model);
        this.toDispose.push(this.model.onDidChange(() => this.update()));
        this.scrollOptions = undefined;
        this.update();
    }
    focus() {
        if (!this.doFocus()) {
            this.onRender.push(core_1.Disposable.create(() => this.doFocus()));
            this.update();
        }
    }
    doFocus() {
        if (!this.stepRef) {
            return false;
        }
        this.stepRef.focus();
        return true;
    }
    render() {
        const { state } = this.model;
        return React.createElement(React.Fragment, null,
            this.renderContributedCommands(),
            this.renderContinue(),
            React.createElement(debug_action_1.DebugAction, { enabled: state === debug_session_1.DebugState.Stopped, run: this.stepOver, label: nls_1.nls.localizeByDefault('Step Over'), iconClass: 'debug-step-over', ref: this.setStepRef }),
            React.createElement(debug_action_1.DebugAction, { enabled: state === debug_session_1.DebugState.Stopped, run: this.stepIn, label: nls_1.nls.localizeByDefault('Step Into'), iconClass: 'debug-step-into' }),
            React.createElement(debug_action_1.DebugAction, { enabled: state === debug_session_1.DebugState.Stopped, run: this.stepOut, label: nls_1.nls.localizeByDefault('Step Out'), iconClass: 'debug-step-out' }),
            React.createElement(debug_action_1.DebugAction, { enabled: state !== debug_session_1.DebugState.Inactive, run: this.restart, label: nls_1.nls.localizeByDefault('Restart'), iconClass: 'debug-restart' }),
            this.renderStart());
    }
    renderContributedCommands() {
        const debugActions = [];
        // first, search for CompoundMenuNodes:
        this.menuModelRegistry.getMenu(DebugToolBar_1.MENU).children.forEach(compoundMenuNode => {
            if (core_1.CompoundMenuNode.is(compoundMenuNode) && this.matchContext(compoundMenuNode.when)) {
                // second, search for nested CommandMenuNodes:
                compoundMenuNode.children.forEach(commandMenuNode => {
                    if (core_1.CommandMenuNode.is(commandMenuNode) && this.matchContext(commandMenuNode.when)) {
                        debugActions.push(this.debugAction(commandMenuNode));
                    }
                });
            }
        });
        return debugActions;
    }
    matchContext(when) {
        return !when || this.contextKeyService.match(when);
    }
    debugAction(commandMenuNode) {
        const { command, icon = '', label = '' } = commandMenuNode;
        if (!label && !icon) {
            const { when } = commandMenuNode;
            console.warn(`Neither 'label' nor 'icon' properties were defined for the command menu node. (${JSON.stringify({ command, when })}}. Skipping.`);
            return;
        }
        const run = () => this.commandRegistry.executeCommand(command);
        return React.createElement(debug_action_1.DebugAction, { key: command, enabled: true, label: label, iconClass: icon, run: run });
    }
    renderStart() {
        const { state } = this.model;
        if (state === debug_session_1.DebugState.Inactive && this.model.sessionCount === 1) {
            return React.createElement(debug_action_1.DebugAction, { run: this.start, label: nls_1.nls.localizeByDefault('Start'), iconClass: 'debug-start' });
        }
        return React.createElement(debug_action_1.DebugAction, { enabled: state !== debug_session_1.DebugState.Inactive, run: this.stop, label: nls_1.nls.localizeByDefault('Stop'), iconClass: 'debug-stop' });
    }
    renderContinue() {
        const { state } = this.model;
        if (state === debug_session_1.DebugState.Stopped) {
            return React.createElement(debug_action_1.DebugAction, { run: this.continue, label: nls_1.nls.localizeByDefault('Continue'), iconClass: 'debug-continue' });
        }
        return React.createElement(debug_action_1.DebugAction, { enabled: state === debug_session_1.DebugState.Running, run: this.pause, label: nls_1.nls.localizeByDefault('Pause'), iconClass: 'debug-pause' });
    }
};
exports.DebugToolBar = DebugToolBar;
DebugToolBar.MENU = ['debug-toolbar-menu'];
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], DebugToolBar.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], DebugToolBar.prototype, "menuModelRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], DebugToolBar.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugToolBar.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugToolBar.prototype, "init", null);
exports.DebugToolBar = DebugToolBar = DebugToolBar_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugToolBar);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-variables-source.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-variables-source.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugVariablesSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
let DebugVariablesSource = class DebugVariablesSource extends source_tree_1.TreeSource {
    constructor() {
        super(...arguments);
        this.refresh = debounce(() => this.fireDidChange(), 400);
    }
    init() {
        this.refresh();
        this.toDispose.push(this.model.onDidChange(() => this.refresh()));
    }
    async getElements() {
        const { currentSession } = this.model;
        const scopes = currentSession ? await currentSession.getScopes() : [];
        return scopes[Symbol.iterator]();
    }
};
exports.DebugVariablesSource = DebugVariablesSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugVariablesSource.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugVariablesSource.prototype, "init", null);
exports.DebugVariablesSource = DebugVariablesSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugVariablesSource);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugVariablesWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugVariablesWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_variables_source_1 = __webpack_require__(/*! ./debug-variables-source */ "../node_modules/@theia/debug/lib/browser/view/debug-variables-source.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugVariablesWidget = DebugVariablesWidget_1 = class DebugVariablesWidget extends source_tree_1.SourceTreeWidget {
    static createContainer(parent) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: DebugVariablesWidget_1.CONTEXT_MENU,
            virtualized: false,
            scrollIfActive: true
        });
        child.bind(debug_variables_source_1.DebugVariablesSource).toSelf();
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(DebugVariablesWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugVariablesWidget_1.createContainer(parent).get(DebugVariablesWidget_1);
    }
    init() {
        super.init();
        this.id = DebugVariablesWidget_1.FACTORY_ID + ':' + this.viewModel.id;
        this.title.label = nls_1.nls.localizeByDefault('Variables');
        this.toDispose.push(this.variables);
        this.source = this.variables;
    }
};
exports.DebugVariablesWidget = DebugVariablesWidget;
DebugVariablesWidget.CONTEXT_MENU = ['debug-variables-context-menu'];
DebugVariablesWidget.EDIT_MENU = [...DebugVariablesWidget_1.CONTEXT_MENU, 'a_edit'];
DebugVariablesWidget.WATCH_MENU = [...DebugVariablesWidget_1.CONTEXT_MENU, 'b_watch'];
DebugVariablesWidget.FACTORY_ID = 'debug:variables';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugVariablesWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_variables_source_1.DebugVariablesSource),
    tslib_1.__metadata("design:type", debug_variables_source_1.DebugVariablesSource)
], DebugVariablesWidget.prototype, "variables", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugVariablesWidget.prototype, "init", null);
exports.DebugVariablesWidget = DebugVariablesWidget = DebugVariablesWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugVariablesWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-view-model.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugViewModel = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const p_debounce_1 = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const debug_session_1 = __webpack_require__(/*! ../debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_watch_expression_1 = __webpack_require__(/*! ./debug-watch-expression */ "../node_modules/@theia/debug/lib/browser/view/debug-watch-expression.js");
const debug_watch_manager_1 = __webpack_require__(/*! ../debug-watch-manager */ "../node_modules/@theia/debug/lib/browser/debug-watch-manager.js");
let DebugViewModel = class DebugViewModel {
    constructor() {
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.onDidChangeBreakpointsEmitter = new common_1.Emitter();
        this.onDidChangeBreakpoints = this.onDidChangeBreakpointsEmitter.event;
        this._watchExpressions = new Map();
        this.onDidChangeWatchExpressionsEmitter = new common_1.Emitter();
        this.onDidChangeWatchExpressions = this.onDidChangeWatchExpressionsEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter, this.onDidChangeBreakpointsEmitter, this.onDidChangeWatchExpressionsEmitter);
        this.refreshWatchExpressionsQueue = Promise.resolve();
        this.refreshWatchExpressions = (0, p_debounce_1.default)(() => {
            this.refreshWatchExpressionsQueue = this.refreshWatchExpressionsQueue.then(async () => {
                try {
                    await Promise.all(Array.from(this.watchExpressions).map(expr => expr.evaluate()));
                }
                catch (e) {
                    console.error('Failed to refresh watch expressions: ', e);
                }
            });
        }, 50);
    }
    fireDidChange() {
        this.refreshWatchExpressions();
        this.onDidChangeEmitter.fire(undefined);
    }
    fireDidChangeBreakpoints(uri) {
        this.onDidChangeBreakpointsEmitter.fire(uri);
    }
    fireDidChangeWatchExpressions() {
        this.onDidChangeWatchExpressionsEmitter.fire(undefined);
    }
    get sessions() {
        return this.manager.sessions[Symbol.iterator]();
    }
    get sessionCount() {
        return this.manager.sessions.length;
    }
    get session() {
        return this.currentSession;
    }
    get id() {
        return this.session && this.session.id || '-1';
    }
    get label() {
        return this.session && this.session.label || 'Unknown Session';
    }
    init() {
        this.toDispose.push(this.manager.onDidChangeActiveDebugSession(() => {
            this.fireDidChange();
        }));
        this.toDispose.push(this.manager.onDidChange(current => {
            if (current === this.currentSession) {
                this.fireDidChange();
            }
        }));
        this.toDispose.push(this.manager.onDidChangeBreakpoints(({ session, uri }) => {
            if (!session || session === this.currentSession) {
                this.fireDidChangeBreakpoints(uri);
            }
        }));
        this.updateWatchExpressions();
        this.toDispose.push(this.watch.onDidChange(() => this.updateWatchExpressions()));
    }
    dispose() {
        this.toDispose.dispose();
    }
    get currentSession() {
        const { currentSession } = this.manager;
        return currentSession;
    }
    set currentSession(currentSession) {
        this.manager.currentSession = currentSession;
    }
    get state() {
        const { currentSession } = this;
        return currentSession && currentSession.state || debug_session_1.DebugState.Inactive;
    }
    get currentThread() {
        const { currentSession } = this;
        return currentSession && currentSession.currentThread;
    }
    get currentFrame() {
        const { currentThread } = this;
        return currentThread && currentThread.currentFrame;
    }
    get breakpoints() {
        return this.manager.getBreakpoints(this.currentSession);
    }
    get functionBreakpoints() {
        return this.manager.getFunctionBreakpoints(this.currentSession);
    }
    get instructionBreakpoints() {
        return this.manager.getInstructionBreakpoints(this.currentSession);
    }
    async start(options = {}) {
        const { session } = this;
        if (!session) {
            return;
        }
        const optionsCopy = (0, common_1.deepClone)(session.options);
        const newSession = await this.manager.start(Object.assign(optionsCopy, options));
        if (newSession) {
            this.fireDidChange();
        }
    }
    async restart() {
        const { session } = this;
        if (!session) {
            return;
        }
        await this.manager.restartSession(session);
        this.fireDidChange();
    }
    async terminate() {
        this.manager.terminateSession();
    }
    get watchExpressions() {
        return this._watchExpressions.values();
    }
    async addWatchExpression(expression = '') {
        const watchExpression = new debug_watch_expression_1.DebugWatchExpression({
            id: Number.MAX_SAFE_INTEGER,
            expression,
            session: () => this.currentSession,
            remove: () => this.removeWatchExpression(watchExpression),
            onDidChange: () => { },
        });
        await watchExpression.open();
        if (!watchExpression.expression) {
            return undefined;
        }
        const id = this.watch.addWatchExpression(watchExpression.expression);
        return this._watchExpressions.get(id);
    }
    removeWatchExpressions() {
        this.watch.removeWatchExpressions();
    }
    removeWatchExpression(expression) {
        this.watch.removeWatchExpression(expression.id);
    }
    updateWatchExpressions() {
        let added = false;
        const toRemove = new Set(this._watchExpressions.keys());
        for (const [id, expression] of this.watch.watchExpressions) {
            toRemove.delete(id);
            if (!this._watchExpressions.has(id)) {
                added = true;
                const watchExpression = new debug_watch_expression_1.DebugWatchExpression({
                    id,
                    expression,
                    session: () => this.currentSession,
                    remove: () => this.removeWatchExpression(watchExpression),
                    onDidChange: () => this.fireDidChangeWatchExpressions()
                });
                this._watchExpressions.set(id, watchExpression);
                watchExpression.evaluate();
            }
        }
        for (const id of toRemove) {
            this._watchExpressions.delete(id);
        }
        if (added || toRemove.size) {
            this.fireDidChangeWatchExpressions();
        }
    }
};
exports.DebugViewModel = DebugViewModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugViewModel.prototype, "manager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_watch_manager_1.DebugWatchManager),
    tslib_1.__metadata("design:type", debug_watch_manager_1.DebugWatchManager)
], DebugViewModel.prototype, "watch", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugViewModel.prototype, "init", null);
exports.DebugViewModel = DebugViewModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugViewModel);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-watch-expression.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-watch-expression.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugWatchExpression = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const dialogs_1 = __webpack_require__(/*! @theia/core/lib/browser/dialogs */ "../node_modules/@theia/core/lib/browser/dialogs.js");
const debug_console_items_1 = __webpack_require__(/*! ../console/debug-console-items */ "../node_modules/@theia/debug/lib/browser/console/debug-console-items.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class DebugWatchExpression extends debug_console_items_1.ExpressionItem {
    constructor(options) {
        super(options.expression, options.session);
        this.options = options;
        this.setValueRef = (valueRef) => this.valueRef = valueRef || undefined;
        this.id = options.id;
    }
    async evaluate() {
        await super.evaluate('watch');
    }
    setResult(body, error) {
        const session = this.options.session();
        this.isNotAvailable = false;
        this.isError = false;
        // not available must be set regardless of the session's availability.
        // not available is used when there is no session or the current stack frame is not available.
        if (error === debug_console_items_1.ExpressionItem.notAvailable) {
            super.setResult(undefined, error);
            this.isNotAvailable = true;
        }
        else if (session) {
            super.setResult(body, error);
            this.isError = !!error;
        }
        this.options.onDidChange();
    }
    render() {
        const valueClass = this.valueClass();
        return React.createElement("div", { className: 'theia-debug-console-variable theia-debug-watch-expression' },
            React.createElement("div", { className: browser_1.TREE_NODE_SEGMENT_GROW_CLASS },
                React.createElement("span", { title: this.type || this._expression, className: 'name' },
                    this._expression,
                    ": "),
                React.createElement("span", { title: this._value, ref: this.setValueRef, className: valueClass }, this._value)),
            React.createElement("div", { className: (0, browser_1.codicon)('close', true), title: core_1.nls.localizeByDefault('Remove Expression'), onClick: this.options.remove }));
    }
    valueClass() {
        if (this.isError) {
            return 'watch-error';
        }
        if (this.isNotAvailable) {
            return 'watch-not-available';
        }
        return '';
    }
    async open() {
        const input = new dialogs_1.SingleTextInputDialog({
            title: core_1.nls.localizeByDefault('Edit Expression'),
            initialValue: this.expression,
            placeholder: core_1.nls.localizeByDefault('Expression to watch')
        });
        const newValue = await input.open();
        if (newValue !== undefined) {
            this._expression = newValue;
            await this.evaluate();
        }
    }
    get supportCopyValue() {
        return !!this.valueRef && document.queryCommandSupported('copy');
    }
    copyValue() {
        const selection = document.getSelection();
        if (this.valueRef && selection) {
            selection.selectAllChildren(this.valueRef);
            document.execCommand('copy');
        }
    }
}
exports.DebugWatchExpression = DebugWatchExpression;


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-watch-source.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-watch-source.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugWatchSource = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
let DebugWatchSource = class DebugWatchSource extends source_tree_1.TreeSource {
    constructor() {
        super(...arguments);
        this.refresh = debounce(() => this.fireDidChange(), 100);
    }
    init() {
        this.refresh();
        this.toDispose.push(this.model.onDidChangeWatchExpressions(() => this.refresh()));
    }
    async getElements() {
        return this.model.watchExpressions[Symbol.iterator]();
    }
};
exports.DebugWatchSource = DebugWatchSource;
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugWatchSource.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugWatchSource.prototype, "init", null);
exports.DebugWatchSource = DebugWatchSource = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugWatchSource);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-watch-widget.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-watch-widget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugWatchWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugWatchWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const source_tree_1 = __webpack_require__(/*! @theia/core/lib/browser/source-tree */ "../node_modules/@theia/core/lib/browser/source-tree/index.js");
const debug_watch_source_1 = __webpack_require__(/*! ./debug-watch-source */ "../node_modules/@theia/debug/lib/browser/view/debug-watch-source.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugWatchWidget = DebugWatchWidget_1 = class DebugWatchWidget extends source_tree_1.SourceTreeWidget {
    static createContainer(parent) {
        const child = source_tree_1.SourceTreeWidget.createContainer(parent, {
            contextMenuPath: DebugWatchWidget_1.CONTEXT_MENU,
            virtualized: false,
            scrollIfActive: true
        });
        child.bind(debug_watch_source_1.DebugWatchSource).toSelf();
        child.unbind(source_tree_1.SourceTreeWidget);
        child.bind(DebugWatchWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugWatchWidget_1.createContainer(parent).get(DebugWatchWidget_1);
    }
    init() {
        super.init();
        this.id = DebugWatchWidget_1.FACTORY_ID + ':' + this.viewModel.id;
        this.title.label = nls_1.nls.localizeByDefault('Watch');
        this.toDispose.push(this.variables);
        this.source = this.variables;
    }
};
exports.DebugWatchWidget = DebugWatchWidget;
DebugWatchWidget.CONTEXT_MENU = ['debug-watch-context-menu'];
DebugWatchWidget.EDIT_MENU = [...DebugWatchWidget_1.CONTEXT_MENU, 'a_edit'];
DebugWatchWidget.REMOVE_MENU = [...DebugWatchWidget_1.CONTEXT_MENU, 'b_remove'];
DebugWatchWidget.FACTORY_ID = 'debug:watch';
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugWatchWidget.prototype, "viewModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_watch_source_1.DebugWatchSource),
    tslib_1.__metadata("design:type", debug_watch_source_1.DebugWatchSource)
], DebugWatchWidget.prototype, "variables", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugWatchWidget.prototype, "init", null);
exports.DebugWatchWidget = DebugWatchWidget = DebugWatchWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugWatchWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/browser/view/debug-widget.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/browser/view/debug-widget.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DebugWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const debug_session_widget_1 = __webpack_require__(/*! ./debug-session-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-session-widget.js");
const debug_configuration_widget_1 = __webpack_require__(/*! ./debug-configuration-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-configuration-widget.js");
const debug_view_model_1 = __webpack_require__(/*! ./debug-view-model */ "../node_modules/@theia/debug/lib/browser/view/debug-view-model.js");
const debug_session_manager_1 = __webpack_require__(/*! ../debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const progress_bar_factory_1 = __webpack_require__(/*! @theia/core/lib/browser/progress-bar-factory */ "../node_modules/@theia/core/lib/browser/progress-bar-factory.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let DebugWidget = DebugWidget_1 = class DebugWidget extends browser_1.BaseWidget {
    static createContainer(parent) {
        const child = debug_session_widget_1.DebugSessionWidget.createContainer(parent);
        child.bind(debug_configuration_widget_1.DebugConfigurationWidget).toSelf();
        child.bind(DebugWidget_1).toSelf();
        return child;
    }
    static createWidget(parent) {
        return DebugWidget_1.createContainer(parent).get(DebugWidget_1);
    }
    init() {
        this.id = DebugWidget_1.ID;
        this.title.label = DebugWidget_1.LABEL;
        this.title.caption = DebugWidget_1.LABEL;
        this.title.closable = true;
        this.title.iconClass = (0, browser_1.codicon)('debug-alt');
        this.addClass('theia-debug-container');
        this.toDispose.pushAll([
            this.toolbar,
            this.sessionWidget,
        ]);
        const layout = this.layout = new browser_1.PanelLayout();
        layout.addWidget(this.toolbar);
        layout.addWidget(this.sessionWidget);
        this.toDispose.push(this.progressBarFactory({ container: this.node, insertMode: 'prepend', locationId: 'debug' }));
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.toolbar.focus();
    }
    getTrackableWidgets() {
        return [this.sessionWidget];
    }
    storeState() {
        return this.sessionWidget.storeState();
    }
    restoreState(oldState) {
        this.sessionWidget.restoreState(oldState);
    }
};
exports.DebugWidget = DebugWidget;
DebugWidget.ID = 'debug';
DebugWidget.LABEL = nls_1.nls.localizeByDefault('Debug');
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_view_model_1.DebugViewModel),
    tslib_1.__metadata("design:type", debug_view_model_1.DebugViewModel)
], DebugWidget.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], DebugWidget.prototype, "sessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_widget_1.DebugConfigurationWidget),
    tslib_1.__metadata("design:type", debug_configuration_widget_1.DebugConfigurationWidget)
], DebugWidget.prototype, "toolbar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_widget_1.DebugSessionWidget),
    tslib_1.__metadata("design:type", debug_session_widget_1.DebugSessionWidget)
], DebugWidget.prototype, "sessionWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(progress_bar_factory_1.ProgressBarFactory),
    tslib_1.__metadata("design:type", Function)
], DebugWidget.prototype, "progressBarFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DebugWidget.prototype, "init", null);
exports.DebugWidget = DebugWidget = DebugWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DebugWidget);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/common/debug-common.js":
/*!***************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/common/debug-common.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// FIXME: refactor extensions to get rid of this file and remove it
tslib_1.__exportStar(__webpack_require__(/*! ./debug-configuration */ "../node_modules/@theia/debug/lib/common/debug-configuration.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/debug/lib/common/debug-compound.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/common/debug-compound.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 EclipseSource and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugCompound = exports.defaultCompound = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
exports.defaultCompound = { name: 'Compound', configurations: [] };
var DebugCompound;
(function (DebugCompound) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'name' in arg && 'configurations' in arg;
    }
    DebugCompound.is = is;
})(DebugCompound || (exports.DebugCompound = DebugCompound = {}));


/***/ }),

/***/ "../node_modules/@theia/debug/lib/common/debug-configuration.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/common/debug-configuration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConsoleMode = exports.DebugConfiguration = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
var DebugConfiguration;
(function (DebugConfiguration) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'type' in arg && 'name' in arg && 'request' in arg;
    }
    DebugConfiguration.is = is;
})(DebugConfiguration || (exports.DebugConfiguration = DebugConfiguration = {}));
var DebugConsoleMode;
(function (DebugConsoleMode) {
    DebugConsoleMode[DebugConsoleMode["Separate"] = 0] = "Separate";
    DebugConsoleMode[DebugConsoleMode["MergeWithParent"] = 1] = "MergeWithParent";
})(DebugConsoleMode || (exports.DebugConsoleMode = DebugConsoleMode = {}));


/***/ }),

/***/ "../node_modules/@theia/debug/lib/common/debug-service.js":
/*!****************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/common/debug-service.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForwardingDebugChannel = exports.DebugError = exports.DebugAdapterPath = exports.DebugService = exports.DebugPath = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const application_error_1 = __webpack_require__(/*! @theia/core/lib/common/application-error */ "../node_modules/@theia/core/lib/common/application-error.js");
/**
 * The WS endpoint path to the Debug service.
 */
exports.DebugPath = '/services/debug';
/**
 * DebugService symbol for DI.
 */
exports.DebugService = Symbol('DebugService');
/**
 * The endpoint path to the debug adapter session.
 */
exports.DebugAdapterPath = '/services/debug-adapter';
var DebugError;
(function (DebugError) {
    DebugError.NotFound = application_error_1.ApplicationError.declare(-41000, (type) => ({
        message: `'${type}' debugger type is not supported.`,
        data: { type }
    }));
})(DebugError || (exports.DebugError = DebugError = {}));
/**
 * A {@link DebugChannel} wrapper implementation that sends and receives messages to/from an underlying {@link Channel}.
 */
class ForwardingDebugChannel {
    constructor(underlyingChannel) {
        this.underlyingChannel = underlyingChannel;
        this.onMessageEmitter = new core_1.Emitter();
        this.underlyingChannel.onMessage(msg => this.onMessageEmitter.fire(msg().readString()));
    }
    send(content) {
        this.underlyingChannel.getWriteBuffer().writeString(content).commit();
    }
    onMessage(cb) {
        this.onMessageEmitter.event(cb);
    }
    onError(cb) {
        this.underlyingChannel.onError(cb);
    }
    onClose(cb) {
        this.underlyingChannel.onClose(event => { var _a; return cb((_a = event.code) !== null && _a !== void 0 ? _a : -1, event.reason); });
    }
    close() {
        this.underlyingChannel.close();
        this.onMessageEmitter.dispose();
    }
}
exports.ForwardingDebugChannel = ForwardingDebugChannel;


/***/ }),

/***/ "../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorPreviewWidget = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const PREVIEW_TITLE_CLASS = 'theia-editor-preview-title-unpinned';
class EditorPreviewWidget extends browser_2.EditorWidget {
    get isPreview() {
        return this._isPreview;
    }
    constructor(editor, selectionService) {
        super(editor, selectionService);
        this._isPreview = false;
        this.onDidChangePreviewStateEmitter = new common_1.Emitter();
        this.onDidChangePreviewState = this.onDidChangePreviewStateEmitter.event;
        this.toDispose.push(this.onDidChangePreviewStateEmitter);
    }
    initializePreview() {
        const oneTimeListeners = new common_1.DisposableCollection();
        this._isPreview = true;
        this.title.className += ` ${PREVIEW_TITLE_CLASS}`;
        const oneTimeDirtyChangeListener = this.saveable.onDirtyChanged(() => {
            this.convertToNonPreview();
            oneTimeListeners.dispose();
        });
        oneTimeListeners.push(oneTimeDirtyChangeListener);
        const oneTimeTitleChangeHandler = () => {
            if (this.title.className.includes(browser_1.PINNED_CLASS)) {
                this.convertToNonPreview();
                oneTimeListeners.dispose();
            }
        };
        this.title.changed.connect(oneTimeTitleChangeHandler);
        oneTimeListeners.push(common_1.Disposable.create(() => this.title.changed.disconnect(oneTimeTitleChangeHandler)));
        this.toDispose.push(oneTimeListeners);
    }
    convertToNonPreview() {
        if (this._isPreview) {
            this._isPreview = false;
            this.currentTabbar = undefined;
            this.title.className = this.title.className.replace(PREVIEW_TITLE_CLASS, '');
            this.onDidChangePreviewStateEmitter.fire();
            this.onDidChangePreviewStateEmitter.dispose();
        }
    }
    handleTabBarChange(oldTabBar, newTabBar) {
        super.handleTabBarChange(oldTabBar, newTabBar);
        if (this._isPreview) {
            if (oldTabBar && newTabBar) {
                this.convertToNonPreview();
            }
        }
    }
    storeState() {
        var _a;
        if (((_a = this.getResourceUri()) === null || _a === void 0 ? void 0 : _a.scheme) !== common_1.UNTITLED_SCHEME) {
            const { _isPreview: isPreview } = this;
            return { isPreview, editorState: this.editor.storeViewState() };
        }
    }
    restoreState(oldState) {
        if (!oldState.isPreview) {
            this.convertToNonPreview();
        }
        this.editor.restoreViewState(oldState.editorState);
    }
}
exports.EditorPreviewWidget = EditorPreviewWidget;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoEditorPeekViewWidget = exports.peekViewTitleInfoForeground = exports.peekViewTitleForeground = exports.peekViewTitleBackground = exports.peekViewBorder = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const peekView_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView.js");
const actions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/actions */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/actions.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const instantiation_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation.js");
const themeService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/theme/common/themeService */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/theme/common/themeService.js");
const color_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/color */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/color.js");
var peekView_2 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView.js");
Object.defineProperty(exports, "peekViewBorder", ({ enumerable: true, get: function () { return peekView_2.peekViewBorder; } }));
Object.defineProperty(exports, "peekViewTitleBackground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleBackground; } }));
Object.defineProperty(exports, "peekViewTitleForeground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleForeground; } }));
Object.defineProperty(exports, "peekViewTitleInfoForeground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleInfoForeground; } }));
class MonacoEditorPeekViewWidget {
    constructor(editor, options = {}, styles = {}) {
        this.editor = editor;
        this.styles = styles;
        this.toDispose = new core_1.DisposableCollection();
        this.onDidClose = this.toDispose.onDispose;
        this.themeService = standaloneServices_1.StandaloneServices.get(themeService_1.IThemeService);
        const that = this;
        this.toDispose.push(this.delegate = new class extends peekView_1.PeekViewWidget {
            get actionBar() {
                return this._actionbarWidget;
            }
            fillHead(container, noCloseAction) {
                super._fillHead(container, noCloseAction);
            }
            _fillHead(container, noCloseAction) {
                that.fillHead(container, noCloseAction);
            }
            fillBody(container) {
                // super._fillBody is an abstract method
            }
            _fillBody(container) {
                that.fillBody(container);
            }
            ;
            doLayoutHead(heightInPixel, widthInPixel) {
                super._doLayoutHead(heightInPixel, widthInPixel);
            }
            _doLayoutHead(heightInPixel, widthInPixel) {
                that.doLayoutHead(heightInPixel, widthInPixel);
            }
            doLayoutBody(heightInPixel, widthInPixel) {
                super._doLayoutBody(heightInPixel, widthInPixel);
            }
            _doLayoutBody(heightInPixel, widthInPixel) {
                that.doLayoutBody(heightInPixel, widthInPixel);
            }
            onWidth(widthInPixel) {
                super._onWidth(widthInPixel);
            }
            _onWidth(widthInPixel) {
                that.onWidth(widthInPixel);
            }
            doRevealRange(range, isLastLine) {
                super.revealRange(range, isLastLine);
            }
            revealRange(range, isLastLine) {
                that.doRevealRange(that.editor['m2p'].asRange(range), isLastLine);
            }
        }(editor.getControl(), Object.assign({}, options, this.convertStyles(styles)), standaloneServices_1.StandaloneServices.get(instantiation_1.IInstantiationService)));
        this.toDispose.push(this.themeService.onDidColorThemeChange(() => this.style(this.styles)));
    }
    dispose() {
        this.toDispose.dispose();
    }
    create() {
        this.delegate.create();
    }
    setTitle(primaryHeading, secondaryHeading) {
        this.delegate.setTitle(primaryHeading, secondaryHeading);
    }
    style(styles) {
        this.delegate.style(this.convertStyles(this.styles = styles));
    }
    show(rangeOrPos, heightInLines) {
        this.delegate.show(this.convertRangeOrPosition(rangeOrPos), heightInLines);
    }
    hide() {
        this.delegate.hide();
    }
    clearActions() {
        var _a;
        (_a = this.delegate.actionBar) === null || _a === void 0 ? void 0 : _a.clear();
    }
    addAction(id, label, cssClass, enabled, actionCallback, options) {
        options = cssClass ? { icon: true, label: false, ...options } : { icon: false, label: true, ...options };
        const { actionBar } = this.delegate;
        if (!actionBar) {
            throw new Error('Action bar has not been created.');
        }
        const action = new actions_1.Action(id, label, cssClass, enabled, actionCallback);
        actionBar.push(action, options);
        return action;
    }
    fillHead(container, noCloseAction) {
        this.delegate.fillHead(container, noCloseAction);
    }
    fillBody(container) {
        this.delegate.fillBody(container);
    }
    doLayoutHead(heightInPixel, widthInPixel) {
        this.delegate.doLayoutHead(heightInPixel, widthInPixel);
    }
    doLayoutBody(heightInPixel, widthInPixel) {
        this.delegate.doLayoutBody(heightInPixel, widthInPixel);
    }
    onWidth(widthInPixel) {
        this.delegate.onWidth(widthInPixel);
    }
    doRevealRange(range, isLastLine) {
        this.delegate.doRevealRange(this.editor['p2m'].asRange(range), isLastLine);
    }
    convertStyles(styles) {
        return {
            frameColor: this.convertColor(styles.frameColor),
            arrowColor: this.convertColor(styles.arrowColor),
            headerBackgroundColor: this.convertColor(styles.headerBackgroundColor),
            primaryHeadingColor: this.convertColor(styles.primaryHeadingColor),
            secondaryHeadingColor: this.convertColor(styles.secondaryHeadingColor),
        };
    }
    convertColor(color) {
        if (color === undefined) {
            return undefined;
        }
        return this.themeService.getColorTheme().getColor(color) || color_1.Color.fromHex(color);
    }
    convertRangeOrPosition(arg) {
        const p2m = this.editor['p2m'];
        return vscode_languageserver_protocol_1.Range.is(arg) ? p2m.asRange(arg) : p2m.asPosition(arg);
    }
}
exports.MonacoEditorPeekViewWidget = MonacoEditorPeekViewWidget;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and others. All rights reserved.
 *  Licensed under the MIT License. See https://github.com/Microsoft/vscode/blob/master/LICENSE.txt for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoEditorZoneWidget = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
class MonacoEditorZoneWidget {
    constructor(editorInstance, showArrow = true) {
        this.showArrow = showArrow;
        this.zoneNode = document.createElement('div');
        this.containerNode = document.createElement('div');
        this.onDidLayoutChangeEmitter = new core_1.Emitter();
        this.onDidLayoutChange = this.onDidLayoutChangeEmitter.event;
        this.toHide = new core_1.DisposableCollection();
        this.toDispose = new core_1.DisposableCollection(this.onDidLayoutChangeEmitter, this.toHide);
        this.editor = editorInstance;
        this.zoneNode.classList.add('zone-widget');
        this.containerNode.classList.add('zone-widget-container');
        this.zoneNode.appendChild(this.containerNode);
        this.updateWidth();
        this.toDispose.push(this.editor.onDidLayoutChange(info => this.updateWidth(info)));
    }
    dispose() {
        this.toDispose.dispose();
        this.hide();
    }
    get options() {
        return this.viewZone ? this._options : undefined;
    }
    hide() {
        this.toHide.dispose();
    }
    show(options) {
        let { afterLineNumber, afterColumn, heightInLines } = this._options = { showFrame: true, ...options };
        const lineHeight = this.editor.getOption(monaco.editor.EditorOption.lineHeight);
        // adjust heightInLines to viewport
        const maxHeightInLines = Math.max(12, (this.editor.getLayoutInfo().height / lineHeight) * 0.8);
        heightInLines = Math.min(heightInLines, maxHeightInLines);
        let arrowHeight = 0;
        this.toHide.dispose();
        this.editor.changeViewZones(accessor => {
            this.zoneNode.style.top = '-1000px';
            const domNode = document.createElement('div');
            domNode.style.overflow = 'hidden';
            const zone = {
                domNode,
                afterLineNumber,
                afterColumn,
                heightInLines,
                onDomNodeTop: zoneTop => this.updateTop(zoneTop),
                onComputedHeight: zoneHeight => this.updateHeight(zoneHeight)
            };
            this.viewZone = Object.assign(zone, {
                id: accessor.addZone(zone)
            });
            const id = this.viewZone.id;
            this.toHide.push(core_1.Disposable.create(() => {
                this.editor.changeViewZones(a => a.removeZone(id));
                this.viewZone = undefined;
            }));
            if (this.showArrow) {
                this.arrow = new Arrow(this.editor);
                arrowHeight = Math.round(lineHeight / 3);
                this.arrow.height = arrowHeight;
                this.arrow.show({ lineNumber: options.afterLineNumber, column: 0 });
                this.toHide.push(this.arrow);
            }
            const widget = {
                getId: () => 'editor-zone-widget-' + id,
                getDomNode: () => this.zoneNode,
                // eslint-disable-next-line no-null/no-null
                getPosition: () => null
            };
            this.editor.addOverlayWidget(widget);
            this.toHide.push(core_1.Disposable.create(() => this.editor.removeOverlayWidget(widget)));
        });
        this.containerNode.style.overflow = 'hidden';
        this.updateContainerHeight(heightInLines * lineHeight);
        const model = this.editor.getModel();
        if (model) {
            const revealLineNumber = Math.min(model.getLineCount(), Math.max(1, afterLineNumber + 1));
            this.editor.revealLine(revealLineNumber, monaco.editor.ScrollType.Smooth);
        }
    }
    layout(heightInLines) {
        if (this.viewZone && this.viewZone.heightInLines !== heightInLines) {
            this.viewZone.heightInLines = heightInLines;
            const id = this.viewZone.id;
            this.editor.changeViewZones(accessor => accessor.layoutZone(id));
        }
    }
    updateTop(top) {
        this.zoneNode.style.top = top + (this.showArrow ? 6 : 0) + 'px';
    }
    updateHeight(zoneHeight) {
        this.zoneNode.style.height = zoneHeight + 'px';
        this.updateContainerHeight(zoneHeight);
    }
    updateContainerHeight(zoneHeight) {
        const { frameWidth, height } = this.computeContainerHeight(zoneHeight);
        this.containerNode.style.height = height + 'px';
        this.containerNode.style.borderTopWidth = frameWidth + 'px';
        this.containerNode.style.borderBottomWidth = frameWidth + 'px';
        const width = this.computeWidth();
        this.onDidLayoutChangeEmitter.fire({ height, width });
    }
    computeContainerHeight(zoneHeight) {
        const lineHeight = this.editor.getOption(monaco.editor.EditorOption.lineHeight);
        const frameWidth = this._options && this._options.frameWidth;
        const frameThickness = this._options && this._options.showFrame ? Math.round(lineHeight / 9) : 0;
        return {
            frameWidth: frameWidth !== undefined ? frameWidth : frameThickness,
            height: zoneHeight - 2 * frameThickness
        };
    }
    updateWidth(info = this.editor.getLayoutInfo()) {
        const width = this.computeWidth(info);
        this.zoneNode.style.width = width + 'px';
        this.zoneNode.style.left = this.computeLeft(info) + 'px';
    }
    computeWidth(info = this.editor.getLayoutInfo()) {
        return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
    }
    computeLeft(info = this.editor.getLayoutInfo()) {
        // If minimap is to the left, we move beyond it
        if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
            return info.minimap.minimapWidth;
        }
        return 0;
    }
}
exports.MonacoEditorZoneWidget = MonacoEditorZoneWidget;
class IdGenerator {
    constructor(prefix) {
        this.prefix = prefix;
        this.lastId = 0;
    }
    nextId() {
        return this.prefix + (++this.lastId);
    }
}
class Arrow {
    constructor(_editor) {
        this._editor = _editor;
        this.idGenerator = new IdGenerator('.arrow-decoration-');
        this.ruleName = this.idGenerator.nextId();
        this.decorations = [];
        this._height = -1;
    }
    dispose() {
        this.hide();
    }
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this._updateStyle();
        }
    }
    _updateStyle() {
        const style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        document.getElementsByTagName('head')[0].appendChild(style);
        const selector = `.monaco-editor ${this.ruleName}`;
        const cssText = `border-style: solid; border-color: transparent transparent var(--theia-peekView-border); border-width:
            ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `;
        style.sheet.insertRule(selector + '{' + cssText + '}', 0);
    }
    show(where) {
        this.decorations = this._editor.deltaDecorations(this.decorations, [{ range: monaco.Range.fromPositions(where), options: { className: this.ruleName, stickiness: browser_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges } }]);
    }
    hide() {
        this._editor.deltaDecorations(this.decorations, []);
    }
}


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/simple-monaco-editor.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/simple-monaco-editor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleMonacoEditor = void 0;
const monaco_editor_1 = __webpack_require__(/*! ./monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const codeEditorWidget_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/widget/codeEditor/codeEditorWidget */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/widget/codeEditor/codeEditorWidget.js");
const instantiation_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const serviceCollection_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/instantiation/common/serviceCollection */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/instantiation/common/serviceCollection.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const domutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/domutils */ "../node_modules/@theia/core/shared/@phosphor/domutils/index.js");
const editorOptions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/config/editorOptions */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/config/editorOptions.js");
class SimpleMonacoEditor extends monaco_editor_1.MonacoEditorServices {
    constructor(uri, document, node, services, options, override, widgetOptions) {
        super(services);
        this.uri = uri;
        this.document = document;
        this.node = node;
        this.toDispose = new core_1.DisposableCollection();
        this.onCursorPositionChangedEmitter = new core_1.Emitter();
        this.onFocusChangedEmitter = new core_1.Emitter();
        this.onDocumentContentChangedEmitter = new core_1.Emitter();
        this.onDocumentContentChanged = this.onDocumentContentChangedEmitter.event;
        this.onMouseDownEmitter = new core_1.Emitter();
        this.onLanguageChangedEmitter = new core_1.Emitter();
        this.onLanguageChanged = this.onLanguageChangedEmitter.event;
        this.onScrollChangedEmitter = new core_1.Emitter();
        this.onEncodingChanged = this.document.onDidChangeEncoding;
        this.onResizeEmitter = new core_1.Emitter();
        this.onDidResize = this.onResizeEmitter.event;
        this.onDidChangeReadOnly = this.document.onDidChangeReadOnly;
        this.toDispose.pushAll([
            this.onCursorPositionChangedEmitter,
            this.onFocusChangedEmitter,
            this.onDocumentContentChangedEmitter,
            this.onMouseDownEmitter,
            this.onLanguageChangedEmitter,
            this.onScrollChangedEmitter
        ]);
        this.toDispose.push(this.create({
            ...monaco_editor_1.MonacoEditor.createReadOnlyOptions(document.readOnly),
            ...options
        }, override, widgetOptions));
        this.addHandlers(this.editor);
        this.editor.setModel(document.textEditorModel);
    }
    getControl() {
        return this.editor;
    }
    onSelectionChanged(listener) {
        return this.editor.onDidChangeCursorSelection(event => listener({
            ...this.m2p.asRange(event.selection),
            direction: event.selection.getDirection() === 0 /* SelectionDirection.LTR */ ? 'ltr' : 'rtl'
        }));
    }
    create(options, override, widgetOptions) {
        const combinedOptions = {
            ...options,
            lightbulb: { enabled: editorOptions_1.ShowLightbulbIconMode.On },
            fixedOverflowWidgets: true,
            automaticLayout: true,
            scrollbar: {
                useShadows: false,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                verticalScrollbarSize: 10,
                horizontalScrollbarSize: 10,
                ...options === null || options === void 0 ? void 0 : options.scrollbar,
            }
        };
        const instantiator = this.getInstantiatorWithOverrides(override);
        return this.editor = instantiator.createInstance(codeEditorWidget_1.CodeEditorWidget, this.node, {
            ...combinedOptions,
            dimension: {
                width: 0,
                height: 0
            },
        }, widgetOptions !== null && widgetOptions !== void 0 ? widgetOptions : {});
    }
    addHandlers(codeEditor) {
        this.toDispose.push(codeEditor.onDidChangeModelLanguage(e => this.fireLanguageChanged(e.newLanguage)));
        this.toDispose.push(codeEditor.onDidChangeConfiguration(() => this.refresh()));
        this.toDispose.push(codeEditor.onDidChangeModel(() => this.refresh()));
        this.toDispose.push(codeEditor.onDidChangeModelContent(e => {
            this.refresh();
            this.onDocumentContentChangedEmitter.fire({ document: this.document, contentChanges: e.changes.map(this.mapModelContentChange.bind(this)) });
        }));
        this.toDispose.push(codeEditor.onMouseDown(e => {
            const { element, position, range } = e.target;
            this.onMouseDownEmitter.fire({
                target: {
                    ...e.target,
                    element: element || undefined,
                    mouseColumn: this.m2p.asPosition(undefined, e.target.mouseColumn).character,
                    range: range && this.m2p.asRange(range) || undefined,
                    position: position && this.m2p.asPosition(position.lineNumber, position.column) || undefined,
                    detail: undefined
                },
                event: e.event.browserEvent
            });
        }));
        this.toDispose.push(codeEditor.onDidScrollChange(e => {
            this.onScrollChangedEmitter.fire(undefined);
        }));
        this.toDispose.push(this.onDidChangeReadOnly(readOnly => {
            codeEditor.updateOptions(monaco_editor_1.MonacoEditor.createReadOnlyOptions(readOnly));
        }));
    }
    setLanguage(languageId) {
        monaco.editor.setModelLanguage(this.document.textEditorModel, languageId);
    }
    fireLanguageChanged(languageId) {
        this.onLanguageChangedEmitter.fire(languageId);
    }
    getInstantiatorWithOverrides(override) {
        const instantiator = standaloneServices_1.StandaloneServices.get(instantiation_1.IInstantiationService);
        if (override) {
            const overrideServices = new serviceCollection_1.ServiceCollection(...override);
            return instantiator.createChild(overrideServices);
        }
        return instantiator;
    }
    mapModelContentChange(change) {
        return {
            range: this.m2p.asRange(change.range),
            rangeLength: change.rangeLength,
            text: change.text
        };
    }
    focus() {
        this.editor.focus();
    }
    refresh() {
        this.autoresize();
    }
    resizeToFit() {
        this.autoresize();
        // eslint-disable-next-line no-null/no-null
        this.onResizeEmitter.fire(null);
    }
    setSize(dimension) {
        this.resize(dimension);
        this.onResizeEmitter.fire(dimension);
    }
    autoresize() {
        this.resize();
    }
    resize(dimension) {
        if (this.node) {
            const layoutSize = this.computeLayoutSize(this.node, dimension);
            this.editor.layout(layoutSize);
        }
    }
    computeLayoutSize(hostNode, dimension) {
        if (dimension && dimension.width >= 0 && dimension.height >= 0) {
            return dimension;
        }
        const boxSizing = domutils_1.ElementExt.boxSizing(hostNode);
        const width = (!dimension || dimension.width < 0) ?
            this.getWidth(hostNode, boxSizing) :
            dimension.width;
        const height = (!dimension || dimension.height < 0) ?
            this.getHeight(hostNode, boxSizing) :
            dimension.height;
        return { width, height };
    }
    getWidth(hostNode, boxSizing) {
        return hostNode.offsetWidth - boxSizing.horizontalSum;
    }
    getHeight(hostNode, boxSizing) {
        return this.editor.getContentHeight();
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.SimpleMonacoEditor = SimpleMonacoEditor;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/textmate/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/textmate/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./textmate-registry */ "../node_modules/@theia/monaco/lib/browser/textmate/textmate-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./textmate-contribution */ "../node_modules/@theia/monaco/lib/browser/textmate/textmate-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./monaco-textmate-service */ "../node_modules/@theia/monaco/lib/browser/textmate/monaco-textmate-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./monaco-textmate-frontend-bindings */ "../node_modules/@theia/monaco/lib/browser/textmate/monaco-textmate-frontend-bindings.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/navigator/lib/browser/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@theia/navigator/lib/browser/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./navigator-model */ "../node_modules/@theia/navigator/lib/browser/navigator-model.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./navigator-widget */ "../node_modules/@theia/navigator/lib/browser/navigator-widget.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./navigator-widget-factory */ "../node_modules/@theia/navigator/lib/browser/navigator-widget-factory.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./navigator-decorator-service */ "../node_modules/@theia/navigator/lib/browser/navigator-decorator-service.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/contributions/cell-operations.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/contributions/cell-operations.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.changeCellType = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
/**
 * a collection of different reusable notbook cell operations
 */
function changeCellType(notebookModel, cell, type, language) {
    if (cell.cellKind === type) {
        return;
    }
    if (type === common_1.CellKind.Markup) {
        language = 'markdown';
    }
    else {
        language !== null && language !== void 0 ? language : (language = cell.language);
    }
    notebookModel.applyEdits([{
            editType: 1 /* CellEditType.Replace */,
            index: notebookModel.cells.indexOf(cell),
            count: 1,
            cells: [{
                    ...cell.getData(),
                    cellKind: type,
                    language
                }]
        }], true);
}
exports.changeCellType = changeCellType;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMenus = exports.NotebookActionsContribution = exports.CellChangeDirection = exports.NotebookCommands = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_service_1 = __webpack_require__(/*! ../service/notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_kernel_quick_pick_service_1 = __webpack_require__(/*! ../service/notebook-kernel-quick-pick-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-quick-pick-service.js");
const notebook_execution_service_1 = __webpack_require__(/*! ../service/notebook-execution-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-service.js");
const notebook_editor_widget_service_1 = __webpack_require__(/*! ../service/notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js");
const notebook_context_keys_1 = __webpack_require__(/*! ./notebook-context-keys */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
const notebook_clipboard_service_1 = __webpack_require__(/*! ../service/notebook-clipboard-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-clipboard-service.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
var NotebookCommands;
(function (NotebookCommands) {
    NotebookCommands.ADD_NEW_CELL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.add-new-cell',
        iconClass: (0, browser_1.codicon)('add')
    });
    NotebookCommands.ADD_NEW_MARKDOWN_CELL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.add-new-markdown-cell',
        iconClass: (0, browser_1.codicon)('add'),
        tooltip: core_1.nls.localizeByDefault('Add Markdown Cell')
    });
    NotebookCommands.ADD_NEW_CODE_CELL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.add-new-code-cell',
        iconClass: (0, browser_1.codicon)('add'),
        tooltip: core_1.nls.localizeByDefault('Add Code Cell')
    });
    NotebookCommands.SELECT_KERNEL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.selectKernel',
        category: 'Notebook',
        iconClass: (0, browser_1.codicon)('server-environment')
    });
    NotebookCommands.EXECUTE_NOTEBOOK_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.execute',
        category: 'Notebook',
        iconClass: (0, browser_1.codicon)('run-all')
    });
    NotebookCommands.CLEAR_ALL_OUTPUTS_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.clear-all-outputs',
        category: 'Notebook',
        iconClass: (0, browser_1.codicon)('clear-all')
    });
    NotebookCommands.CHANGE_SELECTED_CELL = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.change-selected-cell',
        category: 'Notebook',
    });
    NotebookCommands.CUT_SELECTED_CELL = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.cut',
        category: 'Notebook',
    });
    NotebookCommands.COPY_SELECTED_CELL = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.copy',
        category: 'Notebook',
    });
    NotebookCommands.PASTE_CELL = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.paste',
        category: 'Notebook',
    });
    NotebookCommands.NOTEBOOK_FIND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.find',
        category: 'Notebook',
    });
    NotebookCommands.CENTER_ACTIVE_CELL = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.centerActiveCell',
        category: 'Notebook',
    });
})(NotebookCommands || (exports.NotebookCommands = NotebookCommands = {}));
var CellChangeDirection;
(function (CellChangeDirection) {
    CellChangeDirection["Up"] = "up";
    CellChangeDirection["Down"] = "down";
})(CellChangeDirection || (exports.CellChangeDirection = CellChangeDirection = {}));
let NotebookActionsContribution = class NotebookActionsContribution {
    registerCommands(commands) {
        commands.registerCommand(NotebookCommands.ADD_NEW_CELL_COMMAND, {
            execute: (notebookModel, cellKind = common_1.CellKind.Markup, index, focusContainer) => {
                var _a, _b;
                notebookModel = notebookModel !== null && notebookModel !== void 0 ? notebookModel : (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                let insertIndex = 0;
                if (typeof index === 'number' && index >= 0) {
                    insertIndex = index;
                }
                else if (notebookModel.selectedCell && typeof index === 'string') {
                    // if index is -1 insert below otherwise at the index of the selected cell which is above the selected.
                    insertIndex = notebookModel.cells.indexOf(notebookModel.selectedCell) + (index === 'below' ? 1 : 0);
                }
                let cellLanguage = 'markdown';
                if (cellKind === common_1.CellKind.Code) {
                    cellLanguage = this.notebookService.getCodeCellLanguage(notebookModel);
                }
                notebookModel.applyEdits([{
                        editType: 1 /* CellEditType.Replace */,
                        index: insertIndex,
                        count: 0,
                        cells: [{
                                cellKind,
                                language: cellLanguage,
                                source: '',
                                outputs: [],
                                metadata: {},
                            }]
                    }], true);
                if (focusContainer) {
                    (_b = notebookModel.selectedCell) === null || _b === void 0 ? void 0 : _b.requestBlurEditor();
                }
            }
        });
        commands.registerCommand(NotebookCommands.ADD_NEW_MARKDOWN_CELL_COMMAND, this.editableCommandHandler(notebookModel => commands.executeCommand(NotebookCommands.ADD_NEW_CELL_COMMAND.id, notebookModel, common_1.CellKind.Markup, 'below')));
        commands.registerCommand(NotebookCommands.ADD_NEW_CODE_CELL_COMMAND, this.editableCommandHandler(notebookModel => commands.executeCommand(NotebookCommands.ADD_NEW_CELL_COMMAND.id, notebookModel, common_1.CellKind.Code, 'below')));
        commands.registerCommand(NotebookCommands.SELECT_KERNEL_COMMAND, this.editableCommandHandler(notebookModel => this.notebookKernelQuickPickService.showQuickPick(notebookModel)));
        commands.registerCommand(NotebookCommands.EXECUTE_NOTEBOOK_COMMAND, this.editableCommandHandler(notebookModel => this.notebookExecutionService.executeNotebookCells(notebookModel, notebookModel.cells)));
        commands.registerCommand(NotebookCommands.CLEAR_ALL_OUTPUTS_COMMAND, this.editableCommandHandler(notebookModel => notebookModel.applyEdits(notebookModel.cells.map(cell => ({
            editType: 2 /* CellEditType.Output */,
            handle: cell.handle, deleteCount: cell.outputs.length, outputs: []
        })), false)));
        commands.registerCommand(NotebookCommands.CHANGE_SELECTED_CELL, {
            execute: (change) => {
                var _a, _b, _c, _d, _e, _f;
                const focusedEditor = this.notebookEditorWidgetService.focusedEditor;
                const model = focusedEditor === null || focusedEditor === void 0 ? void 0 : focusedEditor.model;
                if (model && typeof change === 'number') {
                    model.setSelectedCell(model.cells[change]);
                }
                else if (model && model.selectedCell) {
                    const currentIndex = model.cells.indexOf(model.selectedCell);
                    const shouldFocusEditor = this.contextKeyService.match('editorTextFocus');
                    if (change === CellChangeDirection.Up && currentIndex > 0) {
                        model.setSelectedCell(model.cells[currentIndex - 1]);
                        if ((((_a = model.selectedCell) === null || _a === void 0 ? void 0 : _a.cellKind) === common_1.CellKind.Code
                            || (((_b = model.selectedCell) === null || _b === void 0 ? void 0 : _b.cellKind) === common_1.CellKind.Markup && ((_c = model.selectedCell) === null || _c === void 0 ? void 0 : _c.editing))) && shouldFocusEditor) {
                            model.selectedCell.requestFocusEditor('lastLine');
                        }
                    }
                    else if (change === CellChangeDirection.Down && currentIndex < model.cells.length - 1) {
                        model.setSelectedCell(model.cells[currentIndex + 1]);
                        if ((((_d = model.selectedCell) === null || _d === void 0 ? void 0 : _d.cellKind) === common_1.CellKind.Code
                            || (((_e = model.selectedCell) === null || _e === void 0 ? void 0 : _e.cellKind) === common_1.CellKind.Markup && ((_f = model.selectedCell) === null || _f === void 0 ? void 0 : _f.editing))) && shouldFocusEditor) {
                            model.selectedCell.requestFocusEditor();
                        }
                    }
                    if (model.selectedCell.cellKind === common_1.CellKind.Markup) {
                        // since were losing focus from the cell editor, we need to focus the notebook editor again
                        focusedEditor === null || focusedEditor === void 0 ? void 0 : focusedEditor.node.focus();
                    }
                }
            }
        });
        commands.registerCommand({ id: 'list.focusUp' }, {
            execute: () => commands.executeCommand(NotebookCommands.CHANGE_SELECTED_CELL.id, CellChangeDirection.Up)
        });
        commands.registerCommand({ id: 'list.focusDown' }, {
            execute: () => commands.executeCommand(NotebookCommands.CHANGE_SELECTED_CELL.id, CellChangeDirection.Down)
        });
        commands.registerCommand(NotebookCommands.CUT_SELECTED_CELL, this.editableCommandHandler(() => {
            var _a;
            const model = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
            const selectedCell = model === null || model === void 0 ? void 0 : model.selectedCell;
            if (selectedCell) {
                model.applyEdits([{ editType: 1 /* CellEditType.Replace */, index: model.cells.indexOf(selectedCell), count: 1, cells: [] }], true);
                this.notebookClipboardService.copyCell(selectedCell);
            }
        }));
        commands.registerCommand(NotebookCommands.COPY_SELECTED_CELL, {
            execute: () => {
                var _a;
                const model = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                const selectedCell = model === null || model === void 0 ? void 0 : model.selectedCell;
                if (selectedCell) {
                    this.notebookClipboardService.copyCell(selectedCell);
                }
            }
        });
        commands.registerCommand(NotebookCommands.PASTE_CELL, {
            isEnabled: () => { var _a, _b; return !Boolean((_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.readOnly); },
            isVisible: () => { var _a, _b; return !Boolean((_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.readOnly); },
            execute: (position) => {
                var _a;
                const copiedCell = this.notebookClipboardService.getCell();
                if (copiedCell) {
                    const model = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                    const insertIndex = (model === null || model === void 0 ? void 0 : model.selectedCell) ? model.cells.indexOf(model.selectedCell) + (position === 'above' ? 0 : 1) : 0;
                    model === null || model === void 0 ? void 0 : model.applyEdits([{ editType: 1 /* CellEditType.Replace */, index: insertIndex, count: 0, cells: [copiedCell] }], true);
                }
            }
        });
        commands.registerCommand(NotebookCommands.NOTEBOOK_FIND, {
            execute: () => {
                var _a;
                (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.showFindWidget();
            }
        });
        commands.registerCommand(NotebookCommands.CENTER_ACTIVE_CELL, {
            execute: (editor) => {
                var _a, _b;
                const model = editor ? editor.model : (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                (_b = model === null || model === void 0 ? void 0 : model.selectedCell) === null || _b === void 0 ? void 0 : _b.requestCenterEditor();
            }
        });
    }
    editableCommandHandler(execute) {
        return {
            isEnabled: (item) => this.withModel(item, model => !Boolean(model === null || model === void 0 ? void 0 : model.readOnly), false),
            isVisible: (item) => this.withModel(item, model => !Boolean(model === null || model === void 0 ? void 0 : model.readOnly), false),
            execute: (uri) => {
                this.withModel(uri, execute, undefined);
            }
        };
    }
    withModel(item, execute, defaultValue) {
        if (item instanceof core_1.URI) {
            const model = this.notebookService.getNotebookEditorModel(item);
            if (!model) {
                return defaultValue;
            }
            item = model;
        }
        return execute(item);
    }
    registerMenus(menus) {
        // independent submenu for plugins to add commands
        menus.registerIndependentSubmenu(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR, 'Notebook Main Toolbar');
        // Add Notebook Cell items
        menus.registerSubmenu(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP, 'Add Notebook Cell', { role: 1 /* CompoundMenuNodeRole.Group */ });
        menus.registerMenuAction(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP, {
            commandId: NotebookCommands.ADD_NEW_CODE_CELL_COMMAND.id,
            label: core_1.nls.localizeByDefault('Code'),
            icon: (0, browser_1.codicon)('add'),
        });
        menus.registerMenuAction(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP, {
            commandId: NotebookCommands.ADD_NEW_MARKDOWN_CELL_COMMAND.id,
            label: core_1.nls.localizeByDefault('Markdown'),
            icon: (0, browser_1.codicon)('add'),
        });
        // Execution related items
        menus.registerSubmenu(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP, 'Cell Execution', { role: 1 /* CompoundMenuNodeRole.Group */ });
        menus.registerMenuAction(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP, {
            commandId: NotebookCommands.EXECUTE_NOTEBOOK_COMMAND.id,
            label: core_1.nls.localizeByDefault('Run All'),
            icon: (0, browser_1.codicon)('run-all'),
            order: '10'
        });
        menus.registerMenuAction(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP, {
            commandId: NotebookCommands.CLEAR_ALL_OUTPUTS_COMMAND.id,
            label: core_1.nls.localizeByDefault('Clear All Outputs'),
            icon: (0, browser_1.codicon)('clear-all'),
            order: '30',
            when: notebook_context_keys_1.NOTEBOOK_HAS_OUTPUTS
        });
        menus.registerIndependentSubmenu(NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_HIDDEN_ITEMS_CONTEXT_MENU, '');
    }
    registerKeybindings(keybindings) {
        keybindings.registerKeybindings({
            command: NotebookCommands.CHANGE_SELECTED_CELL.id,
            keybinding: 'up',
            args: CellChangeDirection.Up,
            when: `(!editorTextFocus || ${notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE}) && !suggestWidgetVisible && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`
        }, {
            command: NotebookCommands.CHANGE_SELECTED_CELL.id,
            keybinding: 'down',
            args: CellChangeDirection.Down,
            when: `(!editorTextFocus || ${notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE}) && !suggestWidgetVisible && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`
        }, {
            command: NotebookCommands.CUT_SELECTED_CELL.id,
            keybinding: 'ctrlcmd+x',
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && !inputFocus`
        }, {
            command: NotebookCommands.COPY_SELECTED_CELL.id,
            keybinding: 'ctrlcmd+c',
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && !inputFocus`
        }, {
            command: NotebookCommands.PASTE_CELL.id,
            keybinding: 'ctrlcmd+v',
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && !inputFocus`
        }, {
            command: NotebookCommands.NOTEBOOK_FIND.id,
            keybinding: 'ctrlcmd+f',
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED}`
        }, {
            command: NotebookCommands.CENTER_ACTIVE_CELL.id,
            keybinding: 'ctrlcmd+l',
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED}`
        });
    }
};
exports.NotebookActionsContribution = NotebookActionsContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_service_1.NotebookService),
    tslib_1.__metadata("design:type", notebook_service_1.NotebookService)
], NotebookActionsContribution.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_quick_pick_service_1.NotebookKernelQuickPickService),
    tslib_1.__metadata("design:type", notebook_kernel_quick_pick_service_1.NotebookKernelQuickPickService)
], NotebookActionsContribution.prototype, "notebookKernelQuickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_execution_service_1.NotebookExecutionService),
    tslib_1.__metadata("design:type", notebook_execution_service_1.NotebookExecutionService)
], NotebookActionsContribution.prototype, "notebookExecutionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], NotebookActionsContribution.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_editor_widget_service_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", notebook_editor_widget_service_1.NotebookEditorWidgetService)
], NotebookActionsContribution.prototype, "notebookEditorWidgetService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_clipboard_service_1.NotebookClipboardService),
    tslib_1.__metadata("design:type", notebook_clipboard_service_1.NotebookClipboardService)
], NotebookActionsContribution.prototype, "notebookClipboardService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookActionsContribution.prototype, "contextKeyService", void 0);
exports.NotebookActionsContribution = NotebookActionsContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookActionsContribution);
var NotebookMenus;
(function (NotebookMenus) {
    NotebookMenus.NOTEBOOK_MAIN_TOOLBAR = 'notebook/toolbar';
    NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP = [NotebookMenus.NOTEBOOK_MAIN_TOOLBAR, 'cell-add-group'];
    NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP = [NotebookMenus.NOTEBOOK_MAIN_TOOLBAR, 'cell-execution-group'];
    NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_HIDDEN_ITEMS_CONTEXT_MENU = 'notebook-main-toolbar-hidden-items-context-menu';
})(NotebookMenus || (exports.NotebookMenus = NotebookMenus = {}));


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-cell-actions-contribution.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/contributions/notebook-cell-actions-contribution.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var NotebookCellActionContribution_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellActionContribution = exports.NotebookCellCommands = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_context_keys_1 = __webpack_require__(/*! ./notebook-context-keys */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const notebook_execution_service_1 = __webpack_require__(/*! ../service/notebook-execution-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_editor_widget_service_1 = __webpack_require__(/*! ../service/notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js");
const notebook_actions_contribution_1 = __webpack_require__(/*! ./notebook-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js");
const cell_operations_1 = __webpack_require__(/*! ./cell-operations */ "../node_modules/@theia/notebook/lib/browser/contributions/cell-operations.js");
const editor_language_quick_pick_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-language-quick-pick-service */ "../node_modules/@theia/editor/lib/browser/editor-language-quick-pick-service.js");
const notebook_service_1 = __webpack_require__(/*! ../service/notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js");
const selection_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/core/selection */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/core/selection.js");
const notebook_editor_widget_1 = __webpack_require__(/*! ../notebook-editor-widget */ "../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js");
var NotebookCellCommands;
(function (NotebookCellCommands) {
    /** Parameters: notebookModel: NotebookModel | undefined, cell: NotebookCellModel */
    NotebookCellCommands.EDIT_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.edit',
        category: 'Notebook',
        iconClass: (0, browser_1.codicon)('edit')
    });
    /** Parameters: notebookModel: NotebookModel | undefined, cell: NotebookCellModel */
    NotebookCellCommands.STOP_EDIT_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.stop-edit',
        category: 'Notebook',
        iconClass: (0, browser_1.codicon)('check')
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.DELETE_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.delete',
        iconClass: (0, browser_1.codicon)('trash')
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.SPLIT_CELL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.split',
        iconClass: (0, browser_1.codicon)('split-vertical'),
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.execute-cell',
        category: 'Notebook',
        label: 'Execute Cell',
        iconClass: (0, browser_1.codicon)('play'),
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_FOCUS_NEXT_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.execute-cell-and-focus-next',
        label: 'Execute Notebook Cell and Select Below',
        category: 'Notebook',
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_INSERT_BELOW_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.execute-cell-and-insert-below',
        label: 'Execute Notebook Cell and Insert Below',
        category: 'Notebook',
    });
    NotebookCellCommands.EXECUTE_ABOVE_CELLS_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebookActions.executeAbove',
        label: 'Execute Above Cells',
        iconClass: (0, browser_1.codicon)('run-above')
    });
    NotebookCellCommands.EXECUTE_CELL_AND_BELOW_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebookActions.executeBelow',
        label: 'Execute Cell and Below',
        iconClass: (0, browser_1.codicon)('run-below')
    });
    /** Parameters: notebookModel: NotebookModel, cell: NotebookCellModel */
    NotebookCellCommands.STOP_CELL_EXECUTION_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.stop-cell-execution',
        iconClass: (0, browser_1.codicon)('stop'),
    });
    /** Parameters: notebookModel: NotebookModel | undefined, cell: NotebookCellModel */
    NotebookCellCommands.CLEAR_OUTPUTS_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.clear-outputs',
        category: 'Notebook',
        label: 'Clear Cell Outputs',
    });
    /** Parameters: notebookModel: NotebookModel | undefined, cell: NotebookCellModel | undefined, output: NotebookCellOutputModel */
    NotebookCellCommands.CHANGE_OUTPUT_PRESENTATION_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.change-presentation',
        category: 'Notebook',
        label: 'Change Presentation',
    });
    NotebookCellCommands.INSERT_NEW_CELL_ABOVE_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.insertCodeCellAboveAndFocusContainer',
        label: 'Insert Code Cell Above and Focus Container'
    });
    NotebookCellCommands.INSERT_NEW_CELL_BELOW_COMMAND = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.insertCodeCellBelowAndFocusContainer',
        label: 'Insert Code Cell Below and Focus Container'
    });
    NotebookCellCommands.INSERT_MARKDOWN_CELL_ABOVE_COMMAND = core_1.Command.toLocalizedCommand({
        id: 'notebook.cell.insertMarkdownCellAbove',
        label: 'Insert Markdown Cell Above'
    });
    NotebookCellCommands.INSERT_MARKDOWN_CELL_BELOW_COMMAND = core_1.Command.toLocalizedCommand({
        id: 'notebook.cell.insertMarkdownCellBelow',
        label: 'Insert Markdown Cell Below'
    });
    NotebookCellCommands.TO_CODE_CELL_COMMAND = core_1.Command.toLocalizedCommand({
        id: 'notebook.cell.changeToCode',
        category: 'Notebook',
        label: 'Change Cell to Code'
    });
    NotebookCellCommands.TO_MARKDOWN_CELL_COMMAND = core_1.Command.toLocalizedCommand({
        id: 'notebook.cell.changeToMarkdown',
        category: 'Notebook',
        label: 'Change Cell to Markdown'
    });
    NotebookCellCommands.TOGGLE_CELL_OUTPUT = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.toggleOutputs',
        category: 'Notebook',
        label: 'Collapse Cell Output',
    });
    NotebookCellCommands.CHANGE_CELL_LANGUAGE = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.changeLanguage',
        category: 'Notebook',
        label: 'Change Cell Language',
    });
    NotebookCellCommands.TOGGLE_LINE_NUMBERS = core_1.Command.toDefaultLocalizedCommand({
        id: 'notebook.cell.toggleLineNumbers',
        category: 'Notebook',
        label: 'Show Cell Line Numbers',
    });
})(NotebookCellCommands || (exports.NotebookCellCommands = NotebookCellCommands = {}));
let NotebookCellActionContribution = NotebookCellActionContribution_1 = class NotebookCellActionContribution {
    init() {
        notebook_context_keys_1.NotebookContextKeys.initNotebookContextKeys(this.contextKeyService);
    }
    registerMenus(menus) {
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.EDIT_COMMAND.id,
            icon: NotebookCellCommands.EDIT_COMMAND.iconClass,
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'markdown' && !${notebook_context_keys_1.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE}`,
            label: core_1.nls.localizeByDefault('Edit Cell'),
            order: '10'
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.STOP_EDIT_COMMAND.id,
            icon: NotebookCellCommands.STOP_EDIT_COMMAND.iconClass,
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'markdown' && ${notebook_context_keys_1.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE}`,
            label: core_1.nls.localizeByDefault('Stop Editing Cell'),
            order: '10'
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.EXECUTE_ABOVE_CELLS_COMMAND.id,
            icon: NotebookCellCommands.EXECUTE_ABOVE_CELLS_COMMAND.iconClass,
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
            label: core_1.nls.localizeByDefault('Execute Above Cells'),
            order: '10'
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.EXECUTE_CELL_AND_BELOW_COMMAND.id,
            icon: NotebookCellCommands.EXECUTE_CELL_AND_BELOW_COMMAND.iconClass,
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
            label: core_1.nls.localizeByDefault('Execute Cell and Below'),
            order: '20'
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.SPLIT_CELL_COMMAND.id,
            icon: NotebookCellCommands.SPLIT_CELL_COMMAND.iconClass,
            label: core_1.nls.localizeByDefault('Split Cell'),
            order: '20'
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ACTION_MENU, {
            commandId: NotebookCellCommands.DELETE_COMMAND.id,
            icon: NotebookCellCommands.DELETE_COMMAND.iconClass,
            label: core_1.nls.localizeByDefault('Delete Cell'),
            order: '999'
        });
        menus.registerSubmenu(NotebookCellActionContribution_1.ADDITIONAL_ACTION_MENU, core_1.nls.localizeByDefault('More'), {
            icon: (0, browser_1.codicon)('ellipsis'),
            role: 0 /* CompoundMenuNodeRole.Submenu */,
            order: '30'
        });
        menus.registerIndependentSubmenu(NotebookCellActionContribution_1.CONTRIBUTED_CELL_ACTION_MENU, '', { role: 2 /* CompoundMenuNodeRole.Flat */ });
        // since contributions are adding to an independent submenu we have to manually add it to the more submenu
        menus.getMenu(NotebookCellActionContribution_1.ADDITIONAL_ACTION_MENU).addNode(menus.getMenuNode(NotebookCellActionContribution_1.CONTRIBUTED_CELL_ACTION_MENU));
        // code cell sidebar menu
        menus.registerMenuAction(NotebookCellActionContribution_1.CODE_CELL_SIDEBAR_MENU, {
            commandId: NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND.id,
            icon: NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND.iconClass,
            label: core_1.nls.localizeByDefault('Execute Cell'),
            when: `!${notebook_context_keys_1.NOTEBOOK_CELL_EXECUTING}`
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.CODE_CELL_SIDEBAR_MENU, {
            commandId: NotebookCellCommands.STOP_CELL_EXECUTION_COMMAND.id,
            icon: NotebookCellCommands.STOP_CELL_EXECUTION_COMMAND.iconClass,
            label: core_1.nls.localizeByDefault('Stop Cell Execution'),
            when: notebook_context_keys_1.NOTEBOOK_CELL_EXECUTING
        });
        // Notebook Cell extra execution options
        menus.registerIndependentSubmenu(NotebookCellActionContribution_1.CONTRIBUTED_CELL_EXECUTION_MENU, core_1.nls.localizeByDefault('More...'), { role: 2 /* CompoundMenuNodeRole.Flat */, icon: (0, browser_1.codicon)('chevron-down') });
        // menus.getMenu(NotebookCellActionContribution.CODE_CELL_SIDEBAR_MENU).addNode(menus.getMenuNode(NotebookCellActionContribution.CONTRIBUTED_CELL_EXECUTION_MENU));
        // code cell output sidebar menu
        menus.registerSubmenu(NotebookCellActionContribution_1.ADDITIONAL_OUTPUT_SIDEBAR_MENU, core_1.nls.localizeByDefault('More'), {
            icon: (0, browser_1.codicon)('ellipsis'),
            role: 0 /* CompoundMenuNodeRole.Submenu */
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ADDITIONAL_OUTPUT_SIDEBAR_MENU, {
            commandId: NotebookCellCommands.CLEAR_OUTPUTS_COMMAND.id,
            label: core_1.nls.localizeByDefault('Clear Cell Outputs'),
        });
        menus.registerMenuAction(NotebookCellActionContribution_1.ADDITIONAL_OUTPUT_SIDEBAR_MENU, {
            commandId: NotebookCellCommands.CHANGE_OUTPUT_PRESENTATION_COMMAND.id,
            label: core_1.nls.localizeByDefault('Change Presentation'),
        });
    }
    registerCommands(commands) {
        commands.registerCommand(NotebookCellCommands.EDIT_COMMAND, this.editableCellCommandHandler((_, cell) => cell.requestFocusEditor()));
        commands.registerCommand(NotebookCellCommands.STOP_EDIT_COMMAND, { execute: (_, cell) => (cell !== null && cell !== void 0 ? cell : this.getSelectedCell()).requestBlurEditor() });
        commands.registerCommand(NotebookCellCommands.DELETE_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            notebookModel.applyEdits([{
                    editType: 1 /* CellEditType.Replace */,
                    index: notebookModel.cells.indexOf(cell),
                    count: 1,
                    cells: []
                }], true);
        }));
        commands.registerCommand(NotebookCellCommands.SPLIT_CELL_COMMAND, this.editableCellCommandHandler(async (notebookModel, cell) => {
            var _a;
            // selection (0,0,0,0) should also be used in !cell.editing mode, but `cell.editing`
            // is not properly implemented for Code cells.
            const cellSelection = (_a = cell.selection) !== null && _a !== void 0 ? _a : { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } };
            const textModel = await cell.resolveTextModel();
            // Create new cell with the text after the cursor
            const splitOffset = textModel.offsetAt({
                line: cellSelection.start.line,
                character: cellSelection.start.character
            });
            const newCell = {
                cellKind: cell.cellKind,
                language: cell.language,
                outputs: [],
                source: textModel.getText().substring(splitOffset),
            };
            // add new cell below
            const index = notebookModel.cells.indexOf(cell);
            notebookModel.applyEdits([{ editType: 1 /* CellEditType.Replace */, index: index + 1, count: 0, cells: [newCell] }], true);
            // update current cell text (undo-able)
            const selection = new selection_1.Selection(cellSelection.start.line + 1, cellSelection.start.character + 1, cellSelection.end.line + 1, cellSelection.end.character + 1);
            const endPosition = textModel.positionAt(textModel.getText().length);
            const deleteOp = {
                range: {
                    startLineNumber: selection.startLineNumber,
                    startColumn: selection.startColumn,
                    endLineNumber: endPosition.line + 1,
                    endColumn: endPosition.character + 1
                },
                // eslint-disable-next-line no-null/no-null
                text: null
            };
            // Create a new undo/redo stack entry
            textModel.textEditorModel.pushStackElement();
            textModel.textEditorModel.pushEditOperations([selection], [deleteOp], () => [selection]);
        }));
        commands.registerCommand(NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            this.notebookExecutionService.executeNotebookCells(notebookModel, [cell]);
        }));
        commands.registerCommand(NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_FOCUS_NEXT_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            if (cell.cellKind === common_1.CellKind.Code) {
                commands.executeCommand(NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND.id, notebookModel, cell);
            }
            else {
                commands.executeCommand(NotebookCellCommands.STOP_EDIT_COMMAND.id, notebookModel, cell);
            }
            const index = notebookModel.cells.indexOf(cell);
            if (index < notebookModel.cells.length - 1) {
                notebookModel.setSelectedCell(notebookModel.cells[index + 1]);
            }
            else if (cell.cellKind === common_1.CellKind.Code) {
                commands.executeCommand(NotebookCellCommands.INSERT_NEW_CELL_BELOW_COMMAND.id);
            }
            else {
                commands.executeCommand(NotebookCellCommands.INSERT_MARKDOWN_CELL_BELOW_COMMAND.id);
            }
        }));
        commands.registerCommand(NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_INSERT_BELOW_COMMAND, this.editableCellCommandHandler(async (notebookModel, cell) => {
            if (cell.cellKind === common_1.CellKind.Code) {
                await commands.executeCommand(NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND.id, notebookModel, cell);
            }
            await commands.executeCommand(NotebookCellCommands.STOP_EDIT_COMMAND.id, notebookModel, cell);
            if (cell.cellKind === common_1.CellKind.Code) {
                await commands.executeCommand(NotebookCellCommands.INSERT_NEW_CELL_BELOW_COMMAND.id);
            }
            else {
                await commands.executeCommand(NotebookCellCommands.INSERT_MARKDOWN_CELL_BELOW_COMMAND.id);
            }
            const index = notebookModel.cells.indexOf(cell);
            notebookModel.setSelectedCell(notebookModel.cells[index + 1]);
        }));
        commands.registerCommand(NotebookCellCommands.EXECUTE_ABOVE_CELLS_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            const index = notebookModel.cells.indexOf(cell);
            if (index > 0) {
                this.notebookExecutionService.executeNotebookCells(notebookModel, notebookModel.cells.slice(0, index).filter(c => c.cellKind === common_1.CellKind.Code));
            }
        }));
        commands.registerCommand(NotebookCellCommands.EXECUTE_CELL_AND_BELOW_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            const index = notebookModel.cells.indexOf(cell);
            if (index >= 0) {
                this.notebookExecutionService.executeNotebookCells(notebookModel, notebookModel.cells.slice(index).filter(c => c.cellKind === common_1.CellKind.Code));
            }
        }));
        commands.registerCommand(NotebookCellCommands.STOP_CELL_EXECUTION_COMMAND, {
            execute: (notebookModel, cell) => {
                var _a;
                notebookModel = notebookModel !== null && notebookModel !== void 0 ? notebookModel : (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                cell = cell !== null && cell !== void 0 ? cell : this.getSelectedCell();
                this.notebookExecutionService.cancelNotebookCells(notebookModel, [cell]);
            }
        });
        commands.registerCommand(NotebookCellCommands.CLEAR_OUTPUTS_COMMAND, this.editableCellCommandHandler((notebook, cell) => {
            var _a, _b;
            return (_b = (notebook !== null && notebook !== void 0 ? notebook : (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model)) === null || _b === void 0 ? void 0 : _b.applyEdits([{
                    editType: 2 /* CellEditType.Output */,
                    handle: cell.handle,
                    outputs: [],
                    deleteCount: cell.outputs.length,
                    append: false
                }], true);
        }));
        commands.registerCommand(NotebookCellCommands.CHANGE_OUTPUT_PRESENTATION_COMMAND, this.editableCellCommandHandler((notebook, cell, output) => {
            var _a;
            (_a = this.notebookEditorWidgetService.getNotebookEditor(notebook_editor_widget_1.NOTEBOOK_EDITOR_ID_PREFIX + notebook.uri.toString())) === null || _a === void 0 ? void 0 : _a.requestOuputPresentationChange(cell.handle, output);
        }));
        const insertCommand = (type, index, focusContainer) => this.editableCellCommandHandler(() => commands.executeCommand(notebook_actions_contribution_1.NotebookCommands.ADD_NEW_CELL_COMMAND.id, undefined, type, index, focusContainer));
        commands.registerCommand(NotebookCellCommands.INSERT_NEW_CELL_ABOVE_COMMAND, insertCommand(common_1.CellKind.Code, 'above', true));
        commands.registerCommand(NotebookCellCommands.INSERT_NEW_CELL_BELOW_COMMAND, insertCommand(common_1.CellKind.Code, 'below', true));
        commands.registerCommand(NotebookCellCommands.INSERT_MARKDOWN_CELL_ABOVE_COMMAND, insertCommand(common_1.CellKind.Markup, 'above', false));
        commands.registerCommand(NotebookCellCommands.INSERT_MARKDOWN_CELL_BELOW_COMMAND, insertCommand(common_1.CellKind.Markup, 'below', false));
        commands.registerCommand(NotebookCellCommands.TO_CODE_CELL_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            (0, cell_operations_1.changeCellType)(notebookModel, cell, common_1.CellKind.Code, this.notebookService.getCodeCellLanguage(notebookModel));
        }));
        commands.registerCommand(NotebookCellCommands.TO_MARKDOWN_CELL_COMMAND, this.editableCellCommandHandler((notebookModel, cell) => {
            (0, cell_operations_1.changeCellType)(notebookModel, cell, common_1.CellKind.Markup);
        }));
        commands.registerCommand(NotebookCellCommands.TOGGLE_CELL_OUTPUT, {
            execute: () => {
                var _a, _b;
                const selectedCell = (_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.selectedCell;
                if (selectedCell) {
                    selectedCell.outputVisible = !selectedCell.outputVisible;
                }
            }
        });
        commands.registerCommand(NotebookCellCommands.CHANGE_CELL_LANGUAGE, {
            isVisible: () => { var _a, _b; return !!((_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.selectedCell); },
            execute: async (notebook, cell) => {
                var _a, _b, _c, _d, _e;
                const selectedCell = cell !== null && cell !== void 0 ? cell : (_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.selectedCell;
                const activeNotebook = notebook !== null && notebook !== void 0 ? notebook : (_c = this.notebookEditorWidgetService.focusedEditor) === null || _c === void 0 ? void 0 : _c.model;
                if (!selectedCell || !activeNotebook) {
                    return;
                }
                const language = await this.languageQuickPickService.pickEditorLanguage(selectedCell.language);
                if (!(language === null || language === void 0 ? void 0 : language.value) || language.value === 'autoDetect' || language.value.id === selectedCell.language) {
                    return;
                }
                const isMarkdownCell = selectedCell.cellKind === common_1.CellKind.Markup;
                const isMarkdownLanguage = language.value.id === 'markdown';
                if (isMarkdownLanguage) {
                    (0, cell_operations_1.changeCellType)(activeNotebook, selectedCell, common_1.CellKind.Markup, language.value.id);
                }
                else {
                    if (isMarkdownCell) {
                        (0, cell_operations_1.changeCellType)(activeNotebook, selectedCell, common_1.CellKind.Code, language.value.id);
                    }
                    else {
                        (_e = (_d = this.notebookEditorWidgetService.focusedEditor) === null || _d === void 0 ? void 0 : _d.model) === null || _e === void 0 ? void 0 : _e.applyEdits([{
                                editType: 4 /* CellEditType.CellLanguage */,
                                index: activeNotebook.cells.indexOf(selectedCell),
                                language: language.value.id
                            }], true);
                    }
                }
            }
        });
        commands.registerCommand(NotebookCellCommands.TOGGLE_LINE_NUMBERS, {
            execute: () => {
                var _a, _b, _c;
                const selectedCell = (_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.selectedCell;
                if (selectedCell) {
                    const currentLineNumber = (_c = selectedCell.editorOptions) === null || _c === void 0 ? void 0 : _c.lineNumbers;
                    selectedCell.editorOptions = { ...selectedCell.editorOptions, lineNumbers: !currentLineNumber || currentLineNumber === 'off' ? 'on' : 'off' };
                }
            }
        });
    }
    editableCellCommandHandler(execute) {
        return {
            isEnabled: (notebookModel) => !Boolean(notebookModel === null || notebookModel === void 0 ? void 0 : notebookModel.readOnly),
            isVisible: (notebookModel) => !Boolean(notebookModel === null || notebookModel === void 0 ? void 0 : notebookModel.readOnly),
            execute: (notebookModel, cell, output) => {
                var _a;
                notebookModel = notebookModel !== null && notebookModel !== void 0 ? notebookModel : (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model;
                cell = cell !== null && cell !== void 0 ? cell : this.getSelectedCell();
                execute(notebookModel, cell, output);
            }
        };
    }
    getSelectedCell() {
        var _a, _b;
        return (_b = (_a = this.notebookEditorWidgetService.focusedEditor) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.selectedCell;
    }
    registerKeybindings(keybindings) {
        keybindings.registerKeybindings({
            command: NotebookCellCommands.EDIT_COMMAND.id,
            keybinding: 'Enter',
            when: `!editorTextFocus && !inputFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`,
        }, {
            command: NotebookCellCommands.STOP_EDIT_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.ENTER, modifiers: [browser_1.KeyModifier.Alt, browser_1.KeyModifier.CtrlCmd] }).toString(),
            when: `editorTextFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'markdown'`,
        }, {
            command: NotebookCellCommands.STOP_EDIT_COMMAND.id,
            keybinding: 'esc',
            when: `editorTextFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && !suggestWidgetVisible`,
        }, {
            command: NotebookCellCommands.EXECUTE_SINGLE_CELL_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.ENTER, modifiers: [browser_1.KeyModifier.CtrlCmd] }).toString(),
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_LIST_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
        }, {
            command: NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_FOCUS_NEXT_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.ENTER, modifiers: [browser_1.KeyModifier.Shift] }).toString(),
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_LIST_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`,
        }, {
            command: NotebookCellCommands.EXECUTE_SINGLE_CELL_AND_INSERT_BELOW_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.ENTER, modifiers: [browser_1.KeyModifier.Alt] }).toString(),
            when: `${notebook_context_keys_1.NOTEBOOK_CELL_LIST_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`,
        }, {
            command: NotebookCellCommands.CLEAR_OUTPUTS_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.KEY_O, modifiers: [browser_1.KeyModifier.Alt] }).toString(),
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
        }, {
            command: NotebookCellCommands.CHANGE_OUTPUT_PRESENTATION_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.KEY_P, modifiers: [browser_1.KeyModifier.Alt] }).toString(),
            when: `${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
        }, {
            command: NotebookCellCommands.TO_CODE_CELL_COMMAND.id,
            keybinding: 'Y',
            when: `!editorTextFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'markdown'`,
        }, {
            command: NotebookCellCommands.TO_MARKDOWN_CELL_COMMAND.id,
            keybinding: 'M',
            when: `!editorTextFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_TYPE} == 'code'`,
        }, {
            command: NotebookCellCommands.SPLIT_CELL_COMMAND.id,
            keybinding: browser_1.KeyCode.createKeyCode({ first: browser_1.Key.MINUS, modifiers: [browser_1.KeyModifier.CtrlCmd, browser_1.KeyModifier.Shift] }).toString(),
            when: `editorTextFocus && ${notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED} && ${notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED}`,
        });
    }
};
exports.NotebookCellActionContribution = NotebookCellActionContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookCellActionContribution.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_service_1.NotebookService),
    tslib_1.__metadata("design:type", notebook_service_1.NotebookService)
], NotebookCellActionContribution.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_execution_service_1.NotebookExecutionService),
    tslib_1.__metadata("design:type", notebook_execution_service_1.NotebookExecutionService)
], NotebookCellActionContribution.prototype, "notebookExecutionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_editor_widget_service_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", notebook_editor_widget_service_1.NotebookEditorWidgetService)
], NotebookCellActionContribution.prototype, "notebookEditorWidgetService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_language_quick_pick_service_1.EditorLanguageQuickPickService),
    tslib_1.__metadata("design:type", editor_language_quick_pick_service_1.EditorLanguageQuickPickService)
], NotebookCellActionContribution.prototype, "languageQuickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookCellActionContribution.prototype, "init", null);
exports.NotebookCellActionContribution = NotebookCellActionContribution = NotebookCellActionContribution_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellActionContribution);
(function (NotebookCellActionContribution) {
    NotebookCellActionContribution.ACTION_MENU = ['notebook-cell-actions-menu'];
    NotebookCellActionContribution.ADDITIONAL_ACTION_MENU = [...NotebookCellActionContribution.ACTION_MENU, 'more'];
    NotebookCellActionContribution.CONTRIBUTED_CELL_ACTION_MENU = 'notebook/cell/title';
    NotebookCellActionContribution.CONTRIBUTED_CELL_EXECUTION_MENU = 'notebook/cell/execute';
    NotebookCellActionContribution.CODE_CELL_SIDEBAR_MENU = ['code-cell-sidebar-menu'];
    NotebookCellActionContribution.OUTPUT_SIDEBAR_MENU = ['code-cell-output-sidebar-menu'];
    NotebookCellActionContribution.ADDITIONAL_OUTPUT_SIDEBAR_MENU = [...NotebookCellActionContribution.OUTPUT_SIDEBAR_MENU, 'more'];
})(NotebookCellActionContribution || (exports.NotebookCellActionContribution = NotebookCellActionContribution = {}));


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookContextKeys = exports.NOTEBOOK_CELL_CURSOR_LAST_LINE = exports.NOTEBOOK_CELL_CURSOR_FIRST_LINE = exports.NOTEBOOK_HAS_OUTPUTS = exports.NOTEBOOK_MISSING_KERNEL_EXTENSION = exports.NOTEBOOK_INTERRUPTIBLE_KERNEL = exports.NOTEBOOK_KERNEL_SELECTED = exports.NOTEBOOK_KERNEL_SOURCE_COUNT = exports.NOTEBOOK_KERNEL_COUNT = exports.NOTEBOOK_KERNEL = exports.NOTEBOOK_CELL_RESOURCE = exports.NOTEBOOK_CELL_OUTPUT_COLLAPSED = exports.NOTEBOOK_CELL_INPUT_COLLAPSED = exports.NOTEBOOK_CELL_HAS_OUTPUTS = exports.NOTEBOOK_CELL_EXECUTING = exports.NOTEBOOK_CELL_EXECUTION_STATE = exports.NOTEBOOK_CELL_LINE_NUMBERS = exports.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE = exports.NOTEBOOK_CELL_EDITOR_FOCUSED = exports.NOTEBOOK_CELL_FOCUSED = exports.NOTEBOOK_CELL_EDITABLE = exports.NOTEBOOK_CELL_TYPE = exports.NOTEBOOK_VIEW_TYPE = exports.NOTEBOOK_LAST_CELL_FAILED = exports.NOTEBOOK_CURSOR_NAVIGATION_MODE = exports.NOTEBOOK_CELL_TOOLBAR_LOCATION = exports.NOTEBOOK_BREAKPOINT_MARGIN_ACTIVE = exports.NOTEBOOK_USE_CONSOLIDATED_OUTPUT_BUTTON = exports.NOTEBOOK_HAS_RUNNING_CELL = exports.NOTEBOOK_EDITOR_EDITABLE = exports.NOTEBOOK_OUTPUT_INPUT_FOCUSED = exports.NOTEBOOK_OUTPUT_FOCUSED = exports.NOTEBOOK_CELL_LIST_FOCUSED = exports.NOTEBOOK_EDITOR_FOCUSED = exports.KEYBINDING_CONTEXT_NOTEBOOK_FIND_WIDGET_FOCUSED = exports.HAS_OPENED_NOTEBOOK = void 0;
/**
 * Context Keys for the Notebook Editor as defined by vscode in https://github.com/microsoft/vscode/blob/main/src/vs/workbench/contrib/notebook/common/notebookContextKeys.ts
 */
exports.HAS_OPENED_NOTEBOOK = 'userHasOpenedNotebook';
exports.KEYBINDING_CONTEXT_NOTEBOOK_FIND_WIDGET_FOCUSED = 'notebookFindWidgetFocused';
exports.NOTEBOOK_EDITOR_FOCUSED = 'notebookEditorFocused';
exports.NOTEBOOK_CELL_LIST_FOCUSED = 'notebookCellListFocused';
exports.NOTEBOOK_OUTPUT_FOCUSED = 'notebookOutputFocused';
exports.NOTEBOOK_OUTPUT_INPUT_FOCUSED = 'notebookOutputInputFocused';
exports.NOTEBOOK_EDITOR_EDITABLE = 'notebookEditable';
exports.NOTEBOOK_HAS_RUNNING_CELL = 'notebookHasRunningCell';
exports.NOTEBOOK_USE_CONSOLIDATED_OUTPUT_BUTTON = 'notebookUseConsolidatedOutputButton';
exports.NOTEBOOK_BREAKPOINT_MARGIN_ACTIVE = 'notebookBreakpointMargin';
exports.NOTEBOOK_CELL_TOOLBAR_LOCATION = 'notebookCellToolbarLocation';
exports.NOTEBOOK_CURSOR_NAVIGATION_MODE = 'notebookCursorNavigationMode';
exports.NOTEBOOK_LAST_CELL_FAILED = 'notebookLastCellFailed';
exports.NOTEBOOK_VIEW_TYPE = 'notebookType';
exports.NOTEBOOK_CELL_TYPE = 'notebookCellType';
exports.NOTEBOOK_CELL_EDITABLE = 'notebookCellEditable';
exports.NOTEBOOK_CELL_FOCUSED = 'notebookCellFocused';
exports.NOTEBOOK_CELL_EDITOR_FOCUSED = 'notebookCellEditorFocused';
exports.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE = 'notebookCellMarkdownEditMode';
exports.NOTEBOOK_CELL_LINE_NUMBERS = 'notebookCellLineNumbers';
exports.NOTEBOOK_CELL_EXECUTION_STATE = 'notebookCellExecutionState';
exports.NOTEBOOK_CELL_EXECUTING = 'notebookCellExecuting';
exports.NOTEBOOK_CELL_HAS_OUTPUTS = 'notebookCellHasOutputs';
exports.NOTEBOOK_CELL_INPUT_COLLAPSED = 'notebookCellInputIsCollapsed';
exports.NOTEBOOK_CELL_OUTPUT_COLLAPSED = 'notebookCellOutputIsCollapsed';
exports.NOTEBOOK_CELL_RESOURCE = 'notebookCellResource';
exports.NOTEBOOK_KERNEL = 'notebookKernel';
exports.NOTEBOOK_KERNEL_COUNT = 'notebookKernelCount';
exports.NOTEBOOK_KERNEL_SOURCE_COUNT = 'notebookKernelSourceCount';
exports.NOTEBOOK_KERNEL_SELECTED = 'notebookKernelSelected';
exports.NOTEBOOK_INTERRUPTIBLE_KERNEL = 'notebookInterruptibleKernel';
exports.NOTEBOOK_MISSING_KERNEL_EXTENSION = 'notebookMissingKernelExtension';
exports.NOTEBOOK_HAS_OUTPUTS = 'notebookHasOutputs';
exports.NOTEBOOK_CELL_CURSOR_FIRST_LINE = 'cellEditorCursorPositionFirstLine';
exports.NOTEBOOK_CELL_CURSOR_LAST_LINE = 'cellEditorCursorPositionLastLine';
var NotebookContextKeys;
(function (NotebookContextKeys) {
    function initNotebookContextKeys(service) {
        service.createKey(exports.HAS_OPENED_NOTEBOOK, false);
        service.createKey(exports.KEYBINDING_CONTEXT_NOTEBOOK_FIND_WIDGET_FOCUSED, false);
        // // Is Notebook
        // export const NOTEBOOK_IS_ACTIVE_EDITOR = ContextKeyExpr.equals('activeEditor', NOTEBOOK_EDITOR_ID);
        // export const INTERACTIVE_WINDOW_IS_ACTIVE_EDITOR = ContextKeyExpr.equals('activeEditor', INTERACTIVE_WINDOW_EDITOR_ID);
        // Editor keys
        service.createKey(exports.NOTEBOOK_EDITOR_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_CELL_LIST_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_OUTPUT_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_OUTPUT_INPUT_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_EDITOR_EDITABLE, true);
        service.createKey(exports.NOTEBOOK_HAS_RUNNING_CELL, false);
        service.createKey(exports.NOTEBOOK_USE_CONSOLIDATED_OUTPUT_BUTTON, false);
        service.createKey(exports.NOTEBOOK_BREAKPOINT_MARGIN_ACTIVE, false);
        service.createKey(exports.NOTEBOOK_CELL_TOOLBAR_LOCATION, 'left');
        service.createKey(exports.NOTEBOOK_CURSOR_NAVIGATION_MODE, false);
        service.createKey(exports.NOTEBOOK_LAST_CELL_FAILED, false);
        // Cell keys
        service.createKey(exports.NOTEBOOK_VIEW_TYPE, undefined);
        service.createKey(exports.NOTEBOOK_CELL_TYPE, undefined);
        service.createKey(exports.NOTEBOOK_CELL_EDITABLE, false);
        service.createKey(exports.NOTEBOOK_CELL_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_CELL_EDITOR_FOCUSED, false);
        service.createKey(exports.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE, false);
        service.createKey(exports.NOTEBOOK_CELL_LINE_NUMBERS, 'inherit');
        service.createKey(exports.NOTEBOOK_CELL_EXECUTION_STATE, undefined);
        service.createKey(exports.NOTEBOOK_CELL_EXECUTING, false);
        service.createKey(exports.NOTEBOOK_CELL_HAS_OUTPUTS, false);
        service.createKey(exports.NOTEBOOK_CELL_INPUT_COLLAPSED, false);
        service.createKey(exports.NOTEBOOK_CELL_OUTPUT_COLLAPSED, false);
        service.createKey(exports.NOTEBOOK_CELL_RESOURCE, '');
        service.createKey(exports.NOTEBOOK_CELL_CURSOR_FIRST_LINE, false);
        service.createKey(exports.NOTEBOOK_CELL_CURSOR_LAST_LINE, false);
        // Kernels
        service.createKey(exports.NOTEBOOK_KERNEL, undefined);
        service.createKey(exports.NOTEBOOK_KERNEL_COUNT, 0);
        service.createKey(exports.NOTEBOOK_KERNEL_SOURCE_COUNT, 0);
        service.createKey(exports.NOTEBOOK_KERNEL_SELECTED, false);
        service.createKey(exports.NOTEBOOK_INTERRUPTIBLE_KERNEL, false);
        service.createKey(exports.NOTEBOOK_MISSING_KERNEL_EXTENSION, false);
        service.createKey(exports.NOTEBOOK_HAS_OUTPUTS, false);
    }
    NotebookContextKeys.initNotebookContextKeys = initNotebookContextKeys;
})(NotebookContextKeys || (exports.NotebookContextKeys = NotebookContextKeys = {}));


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-preferences.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/contributions/notebook-preferences.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindNotebookPreferences = exports.NotebookPreferenceContribution = exports.notebookPreferenceSchema = exports.NotebookPreferences = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
var NotebookPreferences;
(function (NotebookPreferences) {
    NotebookPreferences.NOTEBOOK_LINE_NUMBERS = 'notebook.lineNumbers';
    NotebookPreferences.OUTPUT_LINE_HEIGHT = 'notebook.output.lineHeight';
    NotebookPreferences.OUTPUT_FONT_SIZE = 'notebook.output.fontSize';
    NotebookPreferences.OUTPUT_FONT_FAMILY = 'notebook.output.fontFamily';
    NotebookPreferences.OUTPUT_SCROLLING = 'notebook.output.scrolling';
    NotebookPreferences.OUTPUT_WORD_WRAP = 'notebook.output.wordWrap';
    NotebookPreferences.OUTPUT_LINE_LIMIT = 'notebook.output.textLineLimit';
})(NotebookPreferences || (exports.NotebookPreferences = NotebookPreferences = {}));
exports.notebookPreferenceSchema = {
    properties: {
        [NotebookPreferences.NOTEBOOK_LINE_NUMBERS]: {
            type: 'string',
            enum: ['on', 'off'],
            default: 'off',
            description: core_1.nls.localizeByDefault('Controls the display of line numbers in the cell editor.')
        },
        [NotebookPreferences.OUTPUT_LINE_HEIGHT]: {
            // eslint-disable-next-line max-len
            markdownDescription: core_1.nls.localizeByDefault('Line height of the output text within notebook cells.\n - When set to 0, editor line height is used.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.'),
            type: 'number',
            default: 0,
            tags: ['notebookLayout', 'notebookOutputLayout']
        },
        [NotebookPreferences.OUTPUT_FONT_SIZE]: {
            markdownDescription: core_1.nls.localizeByDefault('Font size for the output text within notebook cells. When set to 0, {0} is used.', '`#editor.fontSize#`'),
            type: 'number',
            default: 0,
            tags: ['notebookLayout', 'notebookOutputLayout']
        },
        [NotebookPreferences.OUTPUT_FONT_FAMILY]: {
            markdownDescription: core_1.nls.localizeByDefault('The font family of the output text within notebook cells. When set to empty, the {0} is used.', '`#editor.fontFamily#`'),
            type: 'string',
            tags: ['notebookLayout', 'notebookOutputLayout']
        },
        [NotebookPreferences.OUTPUT_SCROLLING]: {
            markdownDescription: core_1.nls.localizeByDefault('Initially render notebook outputs in a scrollable region when longer than the limit.'),
            type: 'boolean',
            tags: ['notebookLayout', 'notebookOutputLayout'],
            default: false
        },
        [NotebookPreferences.OUTPUT_WORD_WRAP]: {
            markdownDescription: core_1.nls.localizeByDefault('Controls whether the lines in output should wrap.'),
            type: 'boolean',
            tags: ['notebookLayout', 'notebookOutputLayout'],
            default: false
        },
        [NotebookPreferences.OUTPUT_LINE_LIMIT]: {
            markdownDescription: core_1.nls.localizeByDefault('Controls how many lines of text are displayed in a text output. If {0} is enabled, this setting is used to determine the scroll height of the output.', '`#notebook.output.scrolling#`'),
            type: 'number',
            default: 30,
            tags: ['notebookLayout', 'notebookOutputLayout'],
            minimum: 1,
        },
    }
};
exports.NotebookPreferenceContribution = Symbol('NotebookPreferenceContribution');
function bindNotebookPreferences(bind) {
    // We don't need a NotebookPreferenceConfiguration class, so there's no preference proxy to bind
    bind(exports.NotebookPreferenceContribution).toConstantValue({ schema: exports.notebookPreferenceSchema });
    bind(browser_1.PreferenceContribution).toService(exports.NotebookPreferenceContribution);
}
exports.bindNotebookPreferences = bindNotebookPreferences;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/index.js":
/*!************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-type-registry */ "../node_modules/@theia/notebook/lib/browser/notebook-type-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-renderer-registry */ "../node_modules/@theia/notebook/lib/browser/notebook-renderer-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-editor-widget */ "../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-execution-state-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-model-resolver-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-model-resolver-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-renderer-messaging-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-renderer-messaging-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-cell-editor-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./renderers/cell-output-webview */ "../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-types */ "../node_modules/@theia/notebook/lib/browser/notebook-types.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorWidget = exports.NOTEBOOK_EDITOR_ID_PREFIX = exports.NotebookEditorProps = exports.createNotebookEditorWidgetContainer = exports.NotebookEditorWidgetContainerFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_cell_list_view_1 = __webpack_require__(/*! ./view/notebook-cell-list-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-list-view.js");
const notebook_code_cell_view_1 = __webpack_require__(/*! ./view/notebook-code-cell-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-code-cell-view.js");
const notebook_markdown_cell_view_1 = __webpack_require__(/*! ./view/notebook-markdown-cell-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-markdown-cell-view.js");
const notebook_cell_toolbar_factory_1 = __webpack_require__(/*! ./view/notebook-cell-toolbar-factory */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar-factory.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const notebook_editor_widget_service_1 = __webpack_require__(/*! ./service/notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js");
const notebook_main_toolbar_1 = __webpack_require__(/*! ./view/notebook-main-toolbar */ "../node_modules/@theia/notebook/lib/browser/view/notebook-main-toolbar.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const notebook_context_manager_1 = __webpack_require__(/*! ./service/notebook-context-manager */ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js");
const notebook_viewport_service_1 = __webpack_require__(/*! ./view/notebook-viewport-service */ "../node_modules/@theia/notebook/lib/browser/view/notebook-viewport-service.js");
const notebook_cell_actions_contribution_1 = __webpack_require__(/*! ./contributions/notebook-cell-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-cell-actions-contribution.js");
const notebook_find_widget_1 = __webpack_require__(/*! ./view/notebook-find-widget */ "../node_modules/@theia/notebook/lib/browser/view/notebook-find-widget.js");
const debounce = __webpack_require__(/*! lodash/debounce */ "../node_modules/lodash/debounce.js");
const cell_output_webview_1 = __webpack_require__(/*! ./renderers/cell-output-webview */ "../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js");
const PerfectScrollbar = __webpack_require__(/*! react-perfect-scrollbar */ "../node_modules/react-perfect-scrollbar/lib/index.js");
exports.NotebookEditorWidgetContainerFactory = Symbol('NotebookEditorWidgetContainerFactory');
function createNotebookEditorWidgetContainer(parent, props) {
    const child = parent.createChild();
    child.bind(exports.NotebookEditorProps).toConstantValue(props);
    const cellOutputWebviewFactory = parent.get(cell_output_webview_1.CellOutputWebviewFactory);
    child.bind(cell_output_webview_1.CellOutputWebview).toConstantValue(cellOutputWebviewFactory());
    child.bind(notebook_context_manager_1.NotebookContextManager).toSelf().inSingletonScope();
    child.bind(notebook_main_toolbar_1.NotebookMainToolbarRenderer).toSelf().inSingletonScope();
    child.bind(notebook_cell_toolbar_factory_1.NotebookCellToolbarFactory).toSelf().inSingletonScope();
    child.bind(notebook_code_cell_view_1.NotebookCodeCellRenderer).toSelf().inSingletonScope();
    child.bind(notebook_markdown_cell_view_1.NotebookMarkdownCellRenderer).toSelf().inSingletonScope();
    child.bind(notebook_viewport_service_1.NotebookViewportService).toSelf().inSingletonScope();
    child.bind(NotebookEditorWidget).toSelf();
    return child;
}
exports.createNotebookEditorWidgetContainer = createNotebookEditorWidgetContainer;
exports.NotebookEditorProps = Symbol('NotebookEditorProps');
exports.NOTEBOOK_EDITOR_ID_PREFIX = 'notebook:';
let NotebookEditorWidget = class NotebookEditorWidget extends browser_1.ReactWidget {
    constructor() {
        super(...arguments);
        this.saveable = new browser_1.DelegatingSaveable();
        this.onDidChangeModelEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeModel = this.onDidChangeModelEmitter.event;
        this.onDidChangeReadOnlyEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeReadOnly = this.onDidChangeReadOnlyEmitter.event;
        this.onPostKernelMessageEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onPostKernelMessage = this.onPostKernelMessageEmitter.event;
        this.onDidPostKernelMessageEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidPostKernelMessage = this.onDidPostKernelMessageEmitter.event;
        this.onPostRendererMessageEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onPostRendererMessage = this.onPostRendererMessageEmitter.event;
        this.onDidReceiveKernelMessageEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidReceiveKernelMessage = this.onDidReceiveKernelMessageEmitter.event;
        this.onDidChangeOutputInputFocusEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeOutputInputFocus = this.onDidChangeOutputInputFocusEmitter.event;
        this.renderers = new Map();
        this._ready = new promise_util_1.Deferred();
        this._findWidgetVisible = false;
        this._findWidgetRef = React.createRef();
        this.scrollBarRef = React.createRef();
        this.debounceFind = debounce(() => {
            var _a;
            (_a = this._findWidgetRef.current) === null || _a === void 0 ? void 0 : _a.search({});
        }, 30, {
            trailing: true,
            maxWait: 100,
            leading: false
        });
    }
    get notebookType() {
        return this.props.notebookType;
    }
    get ready() {
        return this._ready.promise;
    }
    get model() {
        return this._model;
    }
    init() {
        var _a;
        this.id = exports.NOTEBOOK_EDITOR_ID_PREFIX + this.props.uri.toString();
        this.scrollOptions = {
            suppressScrollY: true
        };
        this.title.closable = true;
        this.update();
        this.toDispose.push(this.onDidChangeModelEmitter);
        this.toDispose.push(this.onDidChangeReadOnlyEmitter);
        this.renderers.set(common_1.CellKind.Markup, this.markdownCellRenderer);
        this.renderers.set(common_1.CellKind.Code, this.codeCellRenderer);
        this._ready.resolve(this.waitForData());
        this.ready.then(model => {
            if (model.cells.length === 1 && model.cells[0].source === '') {
                this.commandRegistry.executeCommand(notebook_cell_actions_contribution_1.NotebookCellCommands.EDIT_COMMAND.id, model, model.cells[0]);
                model.setSelectedCell(model.cells[0]);
            }
            model.onDidChangeContent(changeEvents => {
                const cellEvent = changeEvents.filter(event => event.kind === common_1.NotebookCellsChangeType.Move || event.kind === common_1.NotebookCellsChangeType.ModelChange);
                if (cellEvent.length > 0) {
                    this.cellOutputWebview.cellsChanged(cellEvent);
                }
            });
        });
        (_a = this.props.error) === null || _a === void 0 ? void 0 : _a.then(error => {
            this.error = error;
            this.update();
        });
    }
    async waitForData() {
        this._model = await this.props.notebookData;
        this.cellOutputWebview.init(this._model, this);
        this.saveable.delegate = this._model;
        this.toDispose.push(this._model);
        this.toDispose.push(this._model.onDidChangeContent(() => {
            // Update the scroll bar content after the content has changed
            // Wait one frame to ensure that the content has been rendered
            (0, browser_1.animationFrame)().then(() => { var _a; return (_a = this.scrollBarRef.current) === null || _a === void 0 ? void 0 : _a.updateScroll(); });
        }));
        this.toDispose.push(this._model.onContentChanged(() => {
            if (this._findWidgetVisible) {
                this.debounceFind();
            }
        }));
        this.toDispose.push(this._model.onDidChangeReadOnly(readOnly => {
            if (readOnly) {
                (0, browser_1.lock)(this.title);
            }
            else {
                (0, browser_1.unlock)(this.title);
            }
            this.onDidChangeReadOnlyEmitter.fire(readOnly);
            this.update();
        }));
        if (this._model.readOnly) {
            (0, browser_1.lock)(this.title);
        }
        // Ensure that the model is loaded before adding the editor
        this.notebookEditorService.addNotebookEditor(this);
        this._model.selectedCell = this._model.cells[0];
        this.update();
        this.notebookContextManager.init(this);
        return this._model;
    }
    onActivateRequest(msg) {
        var _a;
        super.onActivateRequest(msg);
        (_a = this.node.getElementsByClassName('theia-notebook-main-container')[0]) === null || _a === void 0 ? void 0 : _a.focus();
    }
    getResourceUri() {
        return this.props.uri;
    }
    createMoveToUri(resourceUri) {
        var _a;
        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.uri.withPath(resourceUri.path);
    }
    undo() {
        var _a;
        (_a = this._model) === null || _a === void 0 ? void 0 : _a.undo();
    }
    redo() {
        var _a;
        (_a = this._model) === null || _a === void 0 ? void 0 : _a.redo();
    }
    render() {
        if (this._model) {
            return React.createElement("div", { className: 'theia-notebook-main-container', tabIndex: -1 },
                React.createElement("div", { className: 'theia-notebook-overlay' },
                    React.createElement(notebook_find_widget_1.NotebookFindWidget, { ref: this._findWidgetRef, hidden: !this._findWidgetVisible, onClose: () => {
                            var _a;
                            this._findWidgetVisible = false;
                            (_a = this._model) === null || _a === void 0 ? void 0 : _a.findMatches({
                                activeFilters: [],
                                matchCase: false,
                                regex: false,
                                search: '',
                                wholeWord: false
                            });
                            this.update();
                        }, onSearch: options => { var _a, _b; return (_b = (_a = this._model) === null || _a === void 0 ? void 0 : _a.findMatches(options)) !== null && _b !== void 0 ? _b : []; }, onReplace: (matches, replaceText) => { var _a; return (_a = this._model) === null || _a === void 0 ? void 0 : _a.replaceAll(matches, replaceText); } })),
                this.notebookMainToolbarRenderer.render(this._model, this.node),
                React.createElement("div", { className: 'theia-notebook-viewport', ref: (ref) => this.viewportService.viewportElement = ref },
                    React.createElement(PerfectScrollbar, { className: 'theia-notebook-scroll-container', ref: this.scrollBarRef, onScrollY: (e) => this.viewportService.onScroll(e) },
                        React.createElement("div", { className: 'theia-notebook-scroll-area' },
                            this.cellOutputWebview.render(),
                            React.createElement(notebook_cell_list_view_1.NotebookCellListView, { renderers: this.renderers, notebookModel: this._model, notebookContext: this.notebookContextManager, toolbarRenderer: this.cellToolbarFactory, commandRegistry: this.commandRegistry, menuRegistry: this.menuRegistry })))));
        }
        else if (this.error) {
            return React.createElement("div", { className: 'theia-notebook-main-container error-message', tabIndex: -1 },
                React.createElement("span", { className: (0, browser_1.codicon)('error') }),
                React.createElement("h3", null, core_1.nls.localizeByDefault('The editor could not be opened because the file was not found.')));
        }
        else {
            return React.createElement("div", { className: 'theia-notebook-main-container', tabIndex: -1 },
                React.createElement("div", { className: 'theia-notebook-main-loading-indicator' }));
        }
    }
    onCloseRequest(msg) {
        super.onCloseRequest(msg);
        this.notebookEditorService.removeNotebookEditor(this);
    }
    requestOuputPresentationChange(cellHandle, output) {
        if (output) {
            this.cellOutputWebview.requestOutputPresentationUpdate(cellHandle, output);
        }
    }
    postKernelMessage(message) {
        this.onDidPostKernelMessageEmitter.fire(message);
    }
    postRendererMessage(rendererId, message) {
        this.onPostRendererMessageEmitter.fire({ rendererId, message });
    }
    recieveKernelMessage(message) {
        this.onDidReceiveKernelMessageEmitter.fire(message);
    }
    outputInputFocusChanged(focused) {
        this.onDidChangeOutputInputFocusEmitter.fire(focused);
    }
    showFindWidget() {
        var _a, _b;
        if (!this._findWidgetVisible) {
            this._findWidgetVisible = true;
            this.update();
        }
        (_a = this._findWidgetRef.current) === null || _a === void 0 ? void 0 : _a.focusSearch((_b = this._model) === null || _b === void 0 ? void 0 : _b.selectedText);
    }
    dispose() {
        var _a;
        this.cellOutputWebview.dispose();
        this.notebookContextManager.dispose();
        this.onDidChangeModelEmitter.dispose();
        this.onDidPostKernelMessageEmitter.dispose();
        this.onDidReceiveKernelMessageEmitter.dispose();
        this.onPostRendererMessageEmitter.dispose();
        this.onDidChangeOutputInputFocusEmitter.dispose();
        this.viewportService.dispose();
        (_a = this._model) === null || _a === void 0 ? void 0 : _a.dispose();
        super.dispose();
    }
    onAfterShow(msg) {
        super.onAfterShow(msg);
        this.notebookEditorService.notebookEditorFocusChanged(this, true);
    }
    onAfterHide(msg) {
        super.onAfterHide(msg);
        this.notebookEditorService.notebookEditorFocusChanged(this, false);
    }
};
exports.NotebookEditorWidget = NotebookEditorWidget;
NotebookEditorWidget.ID = 'notebook';
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_toolbar_factory_1.NotebookCellToolbarFactory),
    tslib_1.__metadata("design:type", notebook_cell_toolbar_factory_1.NotebookCellToolbarFactory)
], NotebookEditorWidget.prototype, "cellToolbarFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], NotebookEditorWidget.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], NotebookEditorWidget.prototype, "menuRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_editor_widget_service_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", notebook_editor_widget_service_1.NotebookEditorWidgetService)
], NotebookEditorWidget.prototype, "notebookEditorService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_main_toolbar_1.NotebookMainToolbarRenderer),
    tslib_1.__metadata("design:type", notebook_main_toolbar_1.NotebookMainToolbarRenderer)
], NotebookEditorWidget.prototype, "notebookMainToolbarRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_context_manager_1.NotebookContextManager),
    tslib_1.__metadata("design:type", notebook_context_manager_1.NotebookContextManager)
], NotebookEditorWidget.prototype, "notebookContextManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_code_cell_view_1.NotebookCodeCellRenderer),
    tslib_1.__metadata("design:type", notebook_code_cell_view_1.NotebookCodeCellRenderer)
], NotebookEditorWidget.prototype, "codeCellRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_markdown_cell_view_1.NotebookMarkdownCellRenderer),
    tslib_1.__metadata("design:type", notebook_markdown_cell_view_1.NotebookMarkdownCellRenderer)
], NotebookEditorWidget.prototype, "markdownCellRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.NotebookEditorProps),
    tslib_1.__metadata("design:type", Object)
], NotebookEditorWidget.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_viewport_service_1.NotebookViewportService),
    tslib_1.__metadata("design:type", notebook_viewport_service_1.NotebookViewportService)
], NotebookEditorWidget.prototype, "viewportService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(cell_output_webview_1.CellOutputWebview),
    tslib_1.__metadata("design:type", Object)
], NotebookEditorWidget.prototype, "cellOutputWebview", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookEditorWidget.prototype, "init", null);
exports.NotebookEditorWidget = NotebookEditorWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookEditorWidget);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookOpenHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_editor_widget_1 = __webpack_require__(/*! ./notebook-editor-widget */ "../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js");
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../node_modules/@theia/core/lib/common/glob.js");
let NotebookOpenHandler = class NotebookOpenHandler extends browser_1.NavigatableWidgetOpenHandler {
    constructor() {
        super(...arguments);
        this.id = notebook_editor_widget_1.NotebookEditorWidget.ID;
        this.notebookTypes = [];
    }
    registerNotebookType(notebookType) {
        this.notebookTypes.push(notebookType);
        return core_1.Disposable.create(() => {
            this.notebookTypes.splice(this.notebookTypes.indexOf(notebookType), 1);
        });
    }
    canHandle(uri, options) {
        const defaultHandler = (0, browser_1.getDefaultHandler)(uri, this.preferenceService);
        if (options === null || options === void 0 ? void 0 : options.notebookType) {
            return this.canHandleType(uri, this.notebookTypes.find(type => type.type === options.notebookType), defaultHandler);
        }
        return Math.max(...this.notebookTypes.map(type => this.canHandleType(uri, type), defaultHandler));
    }
    canHandleType(uri, notebookType, defaultHandler) {
        if ((notebookType === null || notebookType === void 0 ? void 0 : notebookType.selector) && this.matches(notebookType.selector, uri)) {
            return notebookType.type === defaultHandler ? browser_1.defaultHandlerPriority : this.calculatePriority(notebookType);
        }
        else {
            return 0;
        }
    }
    calculatePriority(notebookType) {
        if (!notebookType) {
            return 0;
        }
        return notebookType.priority === 'option' ? 100 : 200;
    }
    findHighestPriorityType(uri) {
        const matchingTypes = this.notebookTypes
            .filter(notebookType => notebookType.selector && this.matches(notebookType.selector, uri))
            .map(notebookType => ({ descriptor: notebookType, priority: this.calculatePriority(notebookType) }));
        if (matchingTypes.length === 0) {
            return undefined;
        }
        let type = matchingTypes[0];
        for (let i = 1; i < matchingTypes.length; i++) {
            const notebookType = matchingTypes[i];
            if (notebookType.priority > type.priority) {
                type = notebookType;
            }
        }
        return type.descriptor;
    }
    // Override for better options typing
    open(uri, options) {
        return super.open(uri, options);
    }
    createWidgetOptions(uri, options) {
        const widgetOptions = super.createWidgetOptions(uri, options);
        if (options === null || options === void 0 ? void 0 : options.notebookType) {
            return {
                notebookType: options.notebookType,
                ...widgetOptions
            };
        }
        const defaultHandler = (0, browser_1.getDefaultHandler)(uri, this.preferenceService);
        const notebookType = this.notebookTypes.find(type => type.type === defaultHandler)
            || this.findHighestPriorityType(uri);
        if (!notebookType) {
            throw new Error('No notebook types registered for uri: ' + uri.toString());
        }
        return {
            notebookType: notebookType.type,
            ...widgetOptions
        };
    }
    matches(selectors, resource) {
        return selectors.some(selector => this.selectorMatches(selector, resource));
    }
    selectorMatches(selector, resource) {
        return !!selector.filenamePattern
            && (0, glob_1.match)(selector.filenamePattern, resource.path.name + resource.path.ext);
    }
};
exports.NotebookOpenHandler = NotebookOpenHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], NotebookOpenHandler.prototype, "preferenceService", void 0);
exports.NotebookOpenHandler = NotebookOpenHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookOpenHandler);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-output-utils.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-output-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *  Copied from commit 18b2c92451b076943e5b508380e0eba66ba7d934 from file src\vs\workbench\contrib\notebook\common\notebookCommon.ts
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MOVE_CURSOR_1_LINE_COMMAND = exports.compressOutputItemStreams = void 0;
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const textDecoder = new TextDecoder();
/**
 * Given a stream of individual stdout outputs, this function will return the compressed lines, escaping some of the common terminal escape codes.
 * E.g. some terminal escape codes would result in the previous line getting cleared, such if we had 3 lines and
 * last line contained such a code, then the result string would be just the first two lines.
 * @returns a single VSBuffer with the concatenated and compressed data, and whether any compression was done.
 */
function compressOutputItemStreams(outputs) {
    const buffers = [];
    let startAppending = false;
    // Pick the first set of outputs with the same mime type.
    for (const output of outputs) {
        if ((buffers.length === 0 || startAppending)) {
            buffers.push(output);
            startAppending = true;
        }
    }
    let didCompression = compressStreamBuffer(buffers);
    const concatenated = buffer_1.BinaryBuffer.concat(buffers.map(buffer => buffer_1.BinaryBuffer.wrap(buffer)));
    const data = formatStreamText(concatenated);
    didCompression = didCompression || data.byteLength !== concatenated.byteLength;
    return { data, didCompression };
}
exports.compressOutputItemStreams = compressOutputItemStreams;
exports.MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;
const MOVE_CURSOR_1_LINE_COMMAND_BYTES = exports.MOVE_CURSOR_1_LINE_COMMAND.split('').map(c => c.charCodeAt(0));
const LINE_FEED = 10;
function compressStreamBuffer(streams) {
    let didCompress = false;
    streams.forEach((stream, index) => {
        if (index === 0 || stream.length < exports.MOVE_CURSOR_1_LINE_COMMAND.length) {
            return;
        }
        const previousStream = streams[index - 1];
        // Remove the previous line if required.
        const command = stream.subarray(0, exports.MOVE_CURSOR_1_LINE_COMMAND.length);
        if (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {
            const lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);
            if (lastIndexOfLineFeed === -1) {
                return;
            }
            didCompress = true;
            streams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);
            streams[index] = stream.subarray(exports.MOVE_CURSOR_1_LINE_COMMAND.length);
        }
    });
    return didCompress;
}
const BACKSPACE_CHARACTER = '\b'.charCodeAt(0);
const CARRIAGE_RETURN_CHARACTER = '\r'.charCodeAt(0);
function formatStreamText(buffer) {
    // We have special handling for backspace and carriage return characters.
    // Don't unnecessary decode the bytes if we don't need to perform any processing.
    if (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {
        return buffer;
    }
    // Do the same thing jupyter is doing
    return buffer_1.BinaryBuffer.fromString(fixCarriageReturn(fixBackspace(textDecoder.decode(buffer.buffer))));
}
/**
 * Took this from jupyter/notebook
 * https://github.com/jupyter/notebook/blob/b8b66332e2023e83d2ee04f83d8814f567e01a4e/notebook/static/base/js/utils.js
 * Remove characters that are overridden by backspace characters
 */
function fixBackspace(txt) {
    let tmp = txt;
    do {
        txt = tmp;
        // Cancel out anything-but-newline followed by backspace
        tmp = txt.replace(/[^\n]\x08/gm, '');
    } while (tmp.length < txt.length);
    return txt;
}
/**
 * Remove chunks that should be overridden by the effect of carriage return characters
 * From https://github.com/jupyter/notebook/blob/master/notebook/static/base/js/utils.js
 */
function fixCarriageReturn(txt) {
    txt = txt.replace(/\r+\n/gm, '\n'); // \r followed by \n --> newline
    while (txt.search(/\r[^$]/g) > -1) {
        const base = txt.match(/^(.*)\r+/m)[1];
        let insert = txt.match(/\r+(.*)$/m)[1];
        insert = insert + base.slice(insert.length, base.length);
        txt = txt.replace(/\r+.*$/m, '\r').replace(/^.*\r/m, insert);
    }
    return txt;
}


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-renderer-registry.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-renderer-registry.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRendererRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let NotebookRendererRegistry = class NotebookRendererRegistry {
    constructor() {
        this._notebookRenderers = [];
        this._staticNotebookPreloads = [];
    }
    get notebookRenderers() {
        return this._notebookRenderers;
    }
    get staticNotebookPreloads() {
        return this._staticNotebookPreloads;
    }
    registerNotebookRenderer(type, basePath) {
        let entrypoint;
        if (typeof type.entrypoint === 'string') {
            entrypoint = {
                uri: new core_1.Path(basePath).join(type.entrypoint).toString()
            };
        }
        else {
            entrypoint = {
                uri: new core_1.Path(basePath).join(type.entrypoint.path).toString(),
                extends: type.entrypoint.extends
            };
        }
        this._notebookRenderers.push({
            ...type,
            mimeTypes: type.mimeTypes || [],
            requiresMessaging: type.requiresMessaging === 'always' || type.requiresMessaging === 'optional',
            entrypoint
        });
        return core_1.Disposable.create(() => {
            this._notebookRenderers.splice(this._notebookRenderers.findIndex(renderer => renderer.id === type.id), 1);
        });
    }
    registerStaticNotebookPreload(type, entrypoint, basePath) {
        const staticPreload = { type, entrypoint: new core_1.Path(basePath).join(entrypoint).toString() };
        this._staticNotebookPreloads.push(staticPreload);
        return core_1.Disposable.create(() => {
            this._staticNotebookPreloads.splice(this._staticNotebookPreloads.indexOf(staticPreload), 1);
        });
    }
};
exports.NotebookRendererRegistry = NotebookRendererRegistry;
exports.NotebookRendererRegistry = NotebookRendererRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookRendererRegistry);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-type-registry.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-type-registry.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookTypeRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_open_handler_1 = __webpack_require__(/*! ./notebook-open-handler */ "../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js");
let NotebookTypeRegistry = class NotebookTypeRegistry {
    constructor() {
        this._notebookTypes = [];
    }
    get notebookTypes() {
        return this._notebookTypes;
    }
    registerNotebookType(type, providerName) {
        const toDispose = new core_1.DisposableCollection();
        toDispose.push(core_1.Disposable.create(() => {
            this._notebookTypes.splice(this._notebookTypes.indexOf(type), 1);
        }));
        this._notebookTypes.push(type);
        toDispose.push(this.notebookOpenHandler.registerNotebookType(type));
        toDispose.push(this.openWithService.registerHandler({
            id: type.type,
            label: type.displayName,
            providerName,
            canHandle: uri => this.notebookOpenHandler.canHandleType(uri, type),
            open: uri => this.notebookOpenHandler.open(uri, { notebookType: type.type })
        }));
        return toDispose;
    }
};
exports.NotebookTypeRegistry = NotebookTypeRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenWithService),
    tslib_1.__metadata("design:type", browser_1.OpenWithService)
], NotebookTypeRegistry.prototype, "openWithService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_open_handler_1.NotebookOpenHandler),
    tslib_1.__metadata("design:type", notebook_open_handler_1.NotebookOpenHandler)
], NotebookTypeRegistry.prototype, "notebookOpenHandler", void 0);
exports.NotebookTypeRegistry = NotebookTypeRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookTypeRegistry);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/notebook-types.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/notebook-types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionStateType = void 0;
;
;
var SelectionStateType;
(function (SelectionStateType) {
    SelectionStateType[SelectionStateType["Handle"] = 0] = "Handle";
    SelectionStateType[SelectionStateType["Index"] = 1] = "Index";
})(SelectionStateType || (exports.SelectionStateType = SelectionStateType = {}));
;
;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellOutputWebview = exports.CellOutputWebviewFactory = void 0;
exports.CellOutputWebviewFactory = Symbol('outputWebviewFactory');
exports.CellOutputWebview = Symbol('outputWebview');


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 Typefox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellEditorService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_editor_widget_service_1 = __webpack_require__(/*! ./notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
let NotebookCellEditorService = class NotebookCellEditorService {
    constructor() {
        this.onDidChangeCellEditorsEmitter = new core_1.Emitter();
        this.onDidChangeCellEditors = this.onDidChangeCellEditorsEmitter.event;
        this.onDidChangeFocusedCellEditorEmitter = new core_1.Emitter();
        this.onDidChangeFocusedCellEditor = this.onDidChangeFocusedCellEditorEmitter.event;
        this.currentCellEditors = new Map();
    }
    init() {
        this.notebookEditorWidgetService.onDidChangeCurrentEditor(editor => {
            var _a, _b;
            // if defocus notebook editor or another notebook editor is focused, clear the active cell
            if (!editor || (this.currentActiveCell && ((_a = common_1.CellUri.parse(this.currentActiveCell.uri)) === null || _a === void 0 ? void 0 : _a.notebook.toString()) !== ((_b = editor === null || editor === void 0 ? void 0 : editor.model) === null || _b === void 0 ? void 0 : _b.uri.toString()))) {
                this.currentActiveCell = undefined;
                this.onDidChangeFocusedCellEditorEmitter.fire(undefined);
            }
        });
    }
    get allCellEditors() {
        return Array.from(this.currentCellEditors.values());
    }
    editorCreated(uri, editor) {
        this.currentCellEditors.set(uri.toString(), editor);
        this.onDidChangeCellEditorsEmitter.fire();
    }
    editorDisposed(uri) {
        this.currentCellEditors.delete(uri.toString());
        this.onDidChangeCellEditorsEmitter.fire();
    }
    editorFocusChanged(editor) {
        if (editor) {
            this.currentActiveCell = editor;
            this.onDidChangeFocusedCellEditorEmitter.fire(editor);
        }
    }
    getActiveCell() {
        return this.currentActiveCell;
    }
};
exports.NotebookCellEditorService = NotebookCellEditorService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_editor_widget_service_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", notebook_editor_widget_service_1.NotebookEditorWidgetService)
], NotebookCellEditorService.prototype, "notebookEditorWidgetService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookCellEditorService.prototype, "init", null);
exports.NotebookCellEditorService = NotebookCellEditorService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellEditorService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellStatusBarService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let NotebookCellStatusBarService = class NotebookCellStatusBarService {
    constructor() {
        this.onDidChangeProvidersEmitter = new core_1.Emitter();
        this.onDidChangeProviders = this.onDidChangeProvidersEmitter.event;
        this.onDidChangeItemsEmitter = new core_1.Emitter();
        this.onDidChangeItems = this.onDidChangeItemsEmitter.event;
        this.providers = [];
    }
    registerCellStatusBarItemProvider(provider) {
        this.providers.push(provider);
        let changeListener;
        if (provider.onDidChangeStatusBarItems) {
            changeListener = provider.onDidChangeStatusBarItems(() => this.onDidChangeItemsEmitter.fire());
        }
        this.onDidChangeProvidersEmitter.fire();
        return core_1.Disposable.create(() => {
            changeListener === null || changeListener === void 0 ? void 0 : changeListener.dispose();
            const idx = this.providers.findIndex(p => p === provider);
            this.providers.splice(idx, 1);
        });
    }
    async getStatusBarItemsForCell(notebookUri, cellIndex, viewType, token) {
        const providers = this.providers.filter(p => p.viewType === viewType || p.viewType === '*');
        return Promise.all(providers.map(async (p) => {
            var _a;
            try {
                return (_a = await p.provideCellStatusBarItems(notebookUri, cellIndex, token)) !== null && _a !== void 0 ? _a : { items: [] };
            }
            catch (e) {
                console.error(e);
                return { items: [] };
            }
        }));
    }
    dispose() {
        this.onDidChangeItemsEmitter.dispose();
        this.onDidChangeProvidersEmitter.dispose();
    }
};
exports.NotebookCellStatusBarService = NotebookCellStatusBarService;
exports.NotebookCellStatusBarService = NotebookCellStatusBarService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellStatusBarService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-clipboard-service.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-clipboard-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 Typefox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookClipboardService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const clipboard_service_1 = __webpack_require__(/*! @theia/core/lib/browser/clipboard-service */ "../node_modules/@theia/core/lib/browser/clipboard-service.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
let NotebookClipboardService = class NotebookClipboardService {
    copyCell(cell) {
        this.copiedCell = cell.getData();
        if (core_1.environment.electron.is()) {
            this.clipboardService.writeText(cell.text);
        }
    }
    getCell() {
        return this.copiedCell;
    }
};
exports.NotebookClipboardService = NotebookClipboardService;
tslib_1.__decorate([
    (0, inversify_1.inject)(clipboard_service_1.ClipboardService),
    tslib_1.__metadata("design:type", Object)
], NotebookClipboardService.prototype, "clipboardService", void 0);
exports.NotebookClipboardService = NotebookClipboardService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookClipboardService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookContextManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_kernel_service_1 = __webpack_require__(/*! ./notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js");
const notebook_context_keys_1 = __webpack_require__(/*! ../contributions/notebook-context-keys */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_execution_state_service_1 = __webpack_require__(/*! ./notebook-execution-state-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js");
let NotebookContextManager = class NotebookContextManager {
    constructor() {
        this.toDispose = new core_1.DisposableCollection();
        this.onDidChangeContextEmitter = new core_1.Emitter();
        this.onDidChangeContext = this.onDidChangeContextEmitter.event;
        this.cellContexts = new Map();
        this.cellDisposables = new core_1.DisposableCollection();
    }
    get context() {
        return this._context;
    }
    init(widget) {
        var _a, _b, _c, _d;
        this._context = widget.node;
        this.scopedStore = this.contextKeyService.createScoped(widget.node);
        this.toDispose.dispose();
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_VIEW_TYPE, widget === null || widget === void 0 ? void 0 : widget.notebookType);
        // Kernel related keys
        const kernel = (widget === null || widget === void 0 ? void 0 : widget.model) ? this.notebookKernelService.getSelectedNotebookKernel(widget.model) : undefined;
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_KERNEL_SELECTED, !!kernel);
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_KERNEL, kernel === null || kernel === void 0 ? void 0 : kernel.id);
        this.toDispose.push(this.notebookKernelService.onDidChangeSelectedKernel(e => {
            var _a;
            if (e.notebook.toString() === ((_a = widget === null || widget === void 0 ? void 0 : widget.getResourceUri()) === null || _a === void 0 ? void 0 : _a.toString())) {
                this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_KERNEL_SELECTED, !!e.newKernel);
                this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_KERNEL, e.newKernel);
                this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_KERNEL_SELECTED, notebook_context_keys_1.NOTEBOOK_KERNEL]));
            }
        }));
        (_a = widget.model) === null || _a === void 0 ? void 0 : _a.onDidChangeContent(events => {
            var _a;
            if (events.some(e => e.kind === common_1.NotebookCellsChangeType.ModelChange || e.kind === common_1.NotebookCellsChangeType.Output)) {
                this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_HAS_OUTPUTS, (_a = widget.model) === null || _a === void 0 ? void 0 : _a.cells.some(cell => cell.outputs.length > 0));
                this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_HAS_OUTPUTS]));
            }
        });
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_HAS_OUTPUTS, !!((_b = widget.model) === null || _b === void 0 ? void 0 : _b.cells.find(cell => cell.outputs.length > 0)));
        // Cell Selection related keys
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED, !!((_c = widget.model) === null || _c === void 0 ? void 0 : _c.selectedCell));
        (_d = widget.model) === null || _d === void 0 ? void 0 : _d.onDidChangeSelectedCell(e => {
            this.selectedCellChanged(e.cell);
            this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED, !!e);
            this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED]));
        });
        this.toDispose.push(this.executionStateService.onDidChangeExecution(e => {
            var _a, _b, _c;
            if (e.notebook.toString() === ((_a = widget.model) === null || _a === void 0 ? void 0 : _a.uri.toString())) {
                this.setCellContext(e.cellHandle, notebook_context_keys_1.NOTEBOOK_CELL_EXECUTING, !!e.changed);
                this.setCellContext(e.cellHandle, notebook_context_keys_1.NOTEBOOK_CELL_EXECUTION_STATE, (_c = (_b = e.changed) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : 'idle');
                this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_CELL_EXECUTING, notebook_context_keys_1.NOTEBOOK_CELL_EXECUTION_STATE]));
            }
        }));
        widget.onDidChangeOutputInputFocus(focus => {
            this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_OUTPUT_INPUT_FOCUSED, focus);
            this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_OUTPUT_INPUT_FOCUSED]));
        });
        this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_VIEW_TYPE, notebook_context_keys_1.NOTEBOOK_KERNEL_SELECTED, notebook_context_keys_1.NOTEBOOK_KERNEL]));
    }
    selectedCellChanged(cell) {
        this.cellDisposables.dispose();
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_TYPE, cell ? cell.cellKind === common_1.CellKind.Code ? 'code' : 'markdown' : undefined);
        if (cell) {
            this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE, cell.editing);
            this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_EDITABLE, cell.cellKind === common_1.CellKind.Markup && !cell.editing);
            this.cellDisposables.push(cell.onDidRequestCellEditChange(cellEdit => {
                this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE, cellEdit);
                this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_EDITABLE, cell.cellKind === common_1.CellKind.Markup && !cellEdit);
                this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_CELL_MARKDOWN_EDIT_MODE]));
            }));
        }
        this.onDidChangeContextEmitter.fire(this.createContextKeyChangedEvent([notebook_context_keys_1.NOTEBOOK_CELL_TYPE]));
    }
    setCellContext(cellHandle, key, value) {
        let cellContext = this.cellContexts.get(cellHandle);
        if (!cellContext) {
            cellContext = {};
            this.cellContexts.set(cellHandle, cellContext);
        }
        cellContext[key] = value;
    }
    getCellContext(cellHandle) {
        var _a;
        return this.contextKeyService.createOverlay(Object.entries((_a = this.cellContexts.get(cellHandle)) !== null && _a !== void 0 ? _a : {}));
    }
    changeCellFocus(focus) {
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_FOCUSED, focus);
    }
    changeCellListFocus(focus) {
        this.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_LIST_FOCUSED, focus);
    }
    createContextKeyChangedEvent(affectedKeys) {
        return { affects: keys => affectedKeys.some(key => keys.has(key)) };
    }
    dispose() {
        this.toDispose.dispose();
    }
};
exports.NotebookContextManager = NotebookContextManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookContextManager.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_service_1.NotebookKernelService),
    tslib_1.__metadata("design:type", notebook_kernel_service_1.NotebookKernelService)
], NotebookContextManager.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_execution_state_service_1.NotebookExecutionStateService),
    tslib_1.__metadata("design:type", notebook_execution_state_service_1.NotebookExecutionStateService)
], NotebookContextManager.prototype, "executionStateService", void 0);
exports.NotebookContextManager = NotebookContextManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookContextManager);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorWidgetService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_editor_widget_1 = __webpack_require__(/*! ../notebook-editor-widget */ "../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const notebook_context_keys_1 = __webpack_require__(/*! ../contributions/notebook-context-keys */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
let NotebookEditorWidgetService = class NotebookEditorWidgetService {
    constructor() {
        this.notebookEditors = new Map();
        this.onNotebookEditorAddEmitter = new core_1.Emitter();
        this.onNotebookEditorRemoveEmitter = new core_1.Emitter();
        this.onDidAddNotebookEditor = this.onNotebookEditorAddEmitter.event;
        this.onDidRemoveNotebookEditor = this.onNotebookEditorRemoveEmitter.event;
        this.onDidChangeFocusedEditorEmitter = new core_1.Emitter();
        this.onDidChangeFocusedEditor = this.onDidChangeFocusedEditorEmitter.event;
        this.onDidChangeCurrentEditorEmitter = new core_1.Emitter();
        this.onDidChangeCurrentEditor = this.onDidChangeCurrentEditorEmitter.event;
        this.focusedEditor = undefined;
        this.currentEditor = undefined;
    }
    init() {
        this.applicationShell.onDidChangeActiveWidget(event => {
            this.notebookEditorFocusChanged(event.newValue, event.newValue instanceof notebook_editor_widget_1.NotebookEditorWidget);
        });
        this.applicationShell.onDidChangeCurrentWidget(event => {
            if (event.newValue instanceof notebook_editor_widget_1.NotebookEditorWidget || event.oldValue instanceof notebook_editor_widget_1.NotebookEditorWidget) {
                this.currentNotebookEditorChanged(event.newValue);
            }
        });
    }
    // --- editor management
    addNotebookEditor(editor) {
        if (this.notebookEditors.has(editor.id)) {
            console.warn('Attempting to add duplicated notebook editor: ' + editor.id);
        }
        this.notebookEditors.set(editor.id, editor);
        this.onNotebookEditorAddEmitter.fire(editor);
        if (editor.isVisible) {
            this.notebookEditorFocusChanged(editor, true);
        }
    }
    removeNotebookEditor(editor) {
        if (this.notebookEditors.has(editor.id)) {
            this.notebookEditors.delete(editor.id);
            this.onNotebookEditorRemoveEmitter.fire(editor);
        }
        else {
            console.warn('Attempting to remove not registered editor: ' + editor.id);
        }
    }
    getNotebookEditor(editorId) {
        return this.notebookEditors.get(editorId);
    }
    getNotebookEditors() {
        return Array.from(this.notebookEditors.values());
    }
    notebookEditorFocusChanged(editor, focus) {
        if (focus) {
            if (editor !== this.focusedEditor) {
                this.focusedEditor = editor;
                this.contextKeyService.setContext(notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED, true);
                this.onDidChangeFocusedEditorEmitter.fire(this.focusedEditor);
            }
        }
        else if (this.focusedEditor) {
            this.focusedEditor = undefined;
            this.contextKeyService.setContext(notebook_context_keys_1.NOTEBOOK_EDITOR_FOCUSED, false);
            this.onDidChangeFocusedEditorEmitter.fire(undefined);
        }
    }
    currentNotebookEditorChanged(newEditor) {
        var _a, _b;
        if (newEditor instanceof notebook_editor_widget_1.NotebookEditorWidget) {
            this.currentEditor = newEditor;
            this.onDidChangeCurrentEditorEmitter.fire(newEditor);
        }
        else if (((_a = this.currentEditor) === null || _a === void 0 ? void 0 : _a.isDisposed) || !((_b = this.currentEditor) === null || _b === void 0 ? void 0 : _b.isVisible)) {
            this.currentEditor = undefined;
            this.onDidChangeCurrentEditorEmitter.fire(undefined);
        }
    }
};
exports.NotebookEditorWidgetService = NotebookEditorWidgetService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], NotebookEditorWidgetService.prototype, "applicationShell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookEditorWidgetService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookEditorWidgetService.prototype, "init", null);
exports.NotebookEditorWidgetService = NotebookEditorWidgetService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookEditorWidgetService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-service.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-execution-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookExecutionService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_execution_state_service_1 = __webpack_require__(/*! ../service/notebook-execution-state-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_kernel_service_1 = __webpack_require__(/*! ./notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_kernel_quick_pick_service_1 = __webpack_require__(/*! ./notebook-kernel-quick-pick-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-quick-pick-service.js");
const notebook_kernel_history_service_1 = __webpack_require__(/*! ./notebook-kernel-history-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-history-service.js");
let NotebookExecutionService = class NotebookExecutionService {
    constructor() {
        this.cellExecutionParticipants = new Set();
    }
    async executeNotebookCells(notebook, cells) {
        const cellsArr = Array.from(cells)
            .filter(c => c.cellKind === common_1.CellKind.Code);
        if (!cellsArr.length) {
            return;
        }
        this.logger.debug('Executing notebook cells', {
            notebook: notebook.uri.toString(),
            cells: cellsArr.map(c => c.handle)
        });
        // create cell executions
        const cellExecutions = [];
        for (const cell of cellsArr) {
            const cellExe = this.notebookExecutionStateService.getCellExecution(cell.uri);
            if (!cellExe) {
                cellExecutions.push([cell, this.notebookExecutionStateService.getOrCreateCellExecution(notebook.uri, cell.handle)]);
            }
        }
        const kernel = await this.notebookKernelHistoryService.resolveSelectedKernel(notebook);
        if (!kernel) {
            this.logger.debug('Failed to resolve kernel for execution', notebook.uri.toString());
            // clear all pending cell executions
            cellExecutions.forEach(cellExe => cellExe[1].complete({}));
            return;
        }
        // filter cell executions based on selected kernel
        const validCellExecutions = [];
        for (const [cell, cellExecution] of cellExecutions) {
            if (!kernel.supportedLanguages.includes(cell.language)) {
                cellExecution.complete({});
            }
            else {
                validCellExecutions.push(cellExecution);
            }
        }
        // request execution
        if (validCellExecutions.length > 0) {
            const cellRemoveListener = notebook.onDidAddOrRemoveCell(e => {
                if (e.rawEvent.changes.some(c => c.deleteCount > 0)) {
                    const executionsToCancel = validCellExecutions.filter(exec => !notebook.cells.find(cell => cell.handle === exec.cellHandle));
                    if (executionsToCancel.length > 0) {
                        kernel.cancelNotebookCellExecution(notebook.uri, executionsToCancel.map(c => c.cellHandle));
                        executionsToCancel.forEach(exec => exec.complete({}));
                    }
                }
            });
            await this.runExecutionParticipants(validCellExecutions);
            this.logger.debug('Selecting kernel for cell execution', {
                notebook: notebook.uri.toString(),
                kernel: kernel.id
            });
            this.notebookKernelService.selectKernelForNotebook(kernel, notebook);
            this.logger.debug('Running cell execution request', {
                notebook: notebook.uri.toString(),
                cells: validCellExecutions.map(c => c.cellHandle)
            });
            await kernel.executeNotebookCellsRequest(notebook.uri, validCellExecutions.map(c => c.cellHandle));
            // the connecting state can change before the kernel resolves executeNotebookCellsRequest
            const unconfirmed = validCellExecutions.filter(exe => exe.state === common_1.NotebookCellExecutionState.Unconfirmed);
            if (unconfirmed.length) {
                unconfirmed.forEach(exe => exe.complete({}));
            }
            cellRemoveListener.dispose();
        }
    }
    registerExecutionParticipant(participant) {
        this.cellExecutionParticipants.add(participant);
        return core_1.Disposable.create(() => this.cellExecutionParticipants.delete(participant));
    }
    async runExecutionParticipants(executions) {
        for (const participant of this.cellExecutionParticipants) {
            await participant.onWillExecuteCell(executions);
        }
        return;
    }
    async cancelNotebookCellHandles(notebook, cells) {
        const cellsArr = Array.from(cells);
        const kernel = this.notebookKernelService.getSelectedOrSuggestedKernel(notebook);
        if (kernel) {
            await kernel.cancelNotebookCellExecution(notebook.uri, cellsArr);
        }
    }
    async cancelNotebookCells(notebook, cells) {
        this.cancelNotebookCellHandles(notebook, Array.from(cells, cell => cell.handle));
    }
};
exports.NotebookExecutionService = NotebookExecutionService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_execution_state_service_1.NotebookExecutionStateService),
    tslib_1.__metadata("design:type", notebook_execution_state_service_1.NotebookExecutionStateService)
], NotebookExecutionService.prototype, "notebookExecutionStateService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_service_1.NotebookKernelService),
    tslib_1.__metadata("design:type", notebook_kernel_service_1.NotebookKernelService)
], NotebookExecutionService.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_history_service_1.NotebookKernelHistoryService),
    tslib_1.__metadata("design:type", notebook_kernel_history_service_1.NotebookKernelHistoryService)
], NotebookExecutionService.prototype, "notebookKernelHistoryService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], NotebookExecutionService.prototype, "commandService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_quick_pick_service_1.NotebookKernelQuickPickService),
    tslib_1.__metadata("design:type", notebook_kernel_quick_pick_service_1.NotebookKernelQuickPickService)
], NotebookExecutionService.prototype, "notebookKernelQuickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    (0, inversify_1.named)('notebook'),
    tslib_1.__metadata("design:type", Object)
], NotebookExecutionService.prototype, "logger", void 0);
exports.NotebookExecutionService = NotebookExecutionService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookExecutionService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateToEdit = exports.CellExecutionStateChangedEvent = exports.CellExecution = exports.NotebookExecutionStateService = exports.NotebookExecutionType = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_service_1 = __webpack_require__(/*! ./notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
var NotebookExecutionType;
(function (NotebookExecutionType) {
    NotebookExecutionType[NotebookExecutionType["cell"] = 0] = "cell";
    NotebookExecutionType[NotebookExecutionType["notebook"] = 1] = "notebook";
})(NotebookExecutionType || (exports.NotebookExecutionType = NotebookExecutionType = {}));
let NotebookExecutionStateService = class NotebookExecutionStateService {
    constructor() {
        this.toDispose = new core_1.DisposableCollection();
        this.executions = new Map();
        this.onDidChangeExecutionEmitter = new core_1.Emitter();
        this.onDidChangeExecution = this.onDidChangeExecutionEmitter.event;
        this.onDidChangeLastRunFailStateEmitter = new core_1.Emitter();
        this.onDidChangeLastRunFailState = this.onDidChangeLastRunFailStateEmitter.event;
    }
    getOrCreateCellExecution(notebookUri, cellHandle) {
        var _a, _b;
        const notebook = this.notebookService.getNotebookEditorModel(notebookUri);
        if (!notebook) {
            throw new Error(`Notebook not found: ${notebookUri.toString()}`);
        }
        let execution = (_a = this.executions.get(notebookUri.toString())) === null || _a === void 0 ? void 0 : _a.get(cellHandle);
        if (!execution) {
            execution = this.createNotebookCellExecution(notebook, cellHandle);
            if (!this.executions.has(notebookUri.toString())) {
                this.executions.set(notebookUri.toString(), new Map());
            }
            (_b = this.executions.get(notebookUri.toString())) === null || _b === void 0 ? void 0 : _b.set(cellHandle, execution);
            execution.initialize();
            this.onDidChangeExecutionEmitter.fire(new CellExecutionStateChangedEvent(notebookUri, cellHandle, execution));
        }
        return execution;
    }
    createNotebookCellExecution(notebook, cellHandle) {
        const notebookUri = notebook.uri;
        const execution = new CellExecution(cellHandle, notebook);
        execution.toDispose.push(execution.onDidUpdate(() => this.onDidChangeExecutionEmitter.fire(new CellExecutionStateChangedEvent(notebookUri, cellHandle, execution))));
        execution.toDispose.push(execution.onDidComplete(lastRunSuccess => this.onCellExecutionDidComplete(notebookUri, cellHandle, execution, lastRunSuccess)));
        return execution;
    }
    onCellExecutionDidComplete(notebookUri, cellHandle, exe, lastRunSuccess) {
        var _a, _b;
        const notebookExecutions = (_a = this.executions.get(notebookUri.toString())) === null || _a === void 0 ? void 0 : _a.get(cellHandle);
        if (!notebookExecutions) {
            throw new Error('Notebook Cell Execution not found while trying to complete it');
        }
        exe.dispose();
        (_b = this.executions.get(notebookUri.toString())) === null || _b === void 0 ? void 0 : _b.delete(cellHandle);
        this.onDidChangeExecutionEmitter.fire(new CellExecutionStateChangedEvent(notebookUri, cellHandle));
    }
    getCellExecution(cellUri) {
        var _a;
        const parsed = common_1.CellUri.parse(cellUri);
        if (!parsed) {
            throw new Error(`Not a cell URI: ${cellUri}`);
        }
        return (_a = this.executions.get(parsed.notebook.toString())) === null || _a === void 0 ? void 0 : _a.get(parsed.handle);
    }
    dispose() {
        this.onDidChangeExecutionEmitter.dispose();
        this.onDidChangeLastRunFailStateEmitter.dispose();
        this.executions.forEach(notebookExecutions => notebookExecutions.forEach(execution => execution.dispose()));
    }
};
exports.NotebookExecutionStateService = NotebookExecutionStateService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_service_1.NotebookService),
    tslib_1.__metadata("design:type", notebook_service_1.NotebookService)
], NotebookExecutionStateService.prototype, "notebookService", void 0);
exports.NotebookExecutionStateService = NotebookExecutionStateService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookExecutionStateService);
class CellExecution {
    get state() {
        return this._state;
    }
    get notebookURI() {
        return this.notebook.uri;
    }
    get didPause() {
        return this._didPause;
    }
    get isPaused() {
        return this._isPaused;
    }
    constructor(cellHandle, notebook) {
        this.cellHandle = cellHandle;
        this.notebook = notebook;
        this.onDidUpdateEmitter = new core_1.Emitter();
        this.onDidUpdate = this.onDidUpdateEmitter.event;
        this.onDidCompleteEmitter = new core_1.Emitter();
        this.onDidComplete = this.onDidCompleteEmitter.event;
        this.toDispose = new core_1.DisposableCollection();
        this._state = common_1.NotebookCellExecutionState.Unconfirmed;
        this._didPause = false;
        this._isPaused = false;
    }
    initialize() {
        const startExecuteEdit = {
            editType: 9 /* CellEditType.PartialInternalMetadata */,
            handle: this.cellHandle,
            internalMetadata: {
                executionId: (0, core_1.generateUuid)(),
                runStartTime: undefined,
                runEndTime: undefined,
                lastRunSuccess: undefined,
                executionOrder: undefined,
                renderDuration: undefined,
            }
        };
        this.applyCellExecutionEditsToNotebook([startExecuteEdit]);
    }
    confirm() {
        this._state = common_1.NotebookCellExecutionState.Pending;
        this.onDidUpdateEmitter.fire();
    }
    update(updates) {
        if (updates.some(u => u.editType === common_1.CellExecutionUpdateType.ExecutionState)) {
            this._state = common_1.NotebookCellExecutionState.Executing;
        }
        if (!this._didPause && updates.some(u => u.editType === common_1.CellExecutionUpdateType.ExecutionState && u.didPause)) {
            this._didPause = true;
        }
        const lastIsPausedUpdate = [...updates].reverse().find(u => u.editType === common_1.CellExecutionUpdateType.ExecutionState && typeof u.isPaused === 'boolean');
        if (lastIsPausedUpdate) {
            this._isPaused = lastIsPausedUpdate.isPaused;
        }
        const cellModel = this.notebook.cells.find(c => c.handle === this.cellHandle);
        if (!cellModel) {
            console.debug(`CellExecution#update, updating cell not in notebook: ${this.notebook.uri.toString()}, ${this.cellHandle}`);
        }
        else {
            const edits = updates.map(update => updateToEdit(update, this.cellHandle));
            this.applyCellExecutionEditsToNotebook(edits);
        }
        if (updates.some(u => u.editType === common_1.CellExecutionUpdateType.ExecutionState)) {
            this.onDidUpdateEmitter.fire();
        }
    }
    complete(completionData) {
        const cellModel = this.notebook.cells.find(c => c.handle === this.cellHandle);
        if (!cellModel) {
            console.debug(`CellExecution#complete, completing cell not in notebook: ${this.notebook.uri.toString()}, ${this.cellHandle}`);
        }
        else {
            const edit = {
                editType: 9 /* CellEditType.PartialInternalMetadata */,
                handle: this.cellHandle,
                internalMetadata: {
                    lastRunSuccess: completionData.lastRunSuccess,
                    // eslint-disable-next-line no-null/no-null
                    runStartTime: this._didPause ? null : cellModel.internalMetadata.runStartTime,
                    // eslint-disable-next-line no-null/no-null
                    runEndTime: this._didPause ? null : completionData.runEndTime,
                }
            };
            this.applyCellExecutionEditsToNotebook([edit]);
        }
        this.onDidCompleteEmitter.fire(completionData.lastRunSuccess);
    }
    dispose() {
        this.onDidUpdateEmitter.dispose();
        this.onDidCompleteEmitter.dispose();
        this.toDispose.dispose();
    }
    applyCellExecutionEditsToNotebook(edits) {
        this.notebook.applyEdits(edits, false);
    }
}
exports.CellExecution = CellExecution;
class CellExecutionStateChangedEvent {
    constructor(notebook, cellHandle, changed) {
        this.notebook = notebook;
        this.cellHandle = cellHandle;
        this.changed = changed;
        this.type = NotebookExecutionType.cell;
    }
    affectsCell(cell) {
        const parsedUri = common_1.CellUri.parse(cell);
        return !!parsedUri && this.notebook.isEqual(parsedUri.notebook) && this.cellHandle === parsedUri.handle;
    }
    affectsNotebook(notebook) {
        return this.notebook.toString() === notebook.toString();
    }
}
exports.CellExecutionStateChangedEvent = CellExecutionStateChangedEvent;
function updateToEdit(update, cellHandle) {
    if (update.editType === common_1.CellExecutionUpdateType.Output) {
        return {
            editType: 2 /* CellEditType.Output */,
            handle: update.cellHandle,
            append: update.append,
            outputs: update.outputs,
        };
    }
    else if (update.editType === common_1.CellExecutionUpdateType.OutputItems) {
        return {
            editType: 7 /* CellEditType.OutputItems */,
            items: update.items,
            outputId: update.outputId,
            append: update.append,
        };
    }
    else if (update.editType === common_1.CellExecutionUpdateType.ExecutionState) {
        const newInternalMetadata = {};
        if (typeof update.executionOrder !== 'undefined') {
            newInternalMetadata.executionOrder = update.executionOrder;
        }
        if (typeof update.runStartTime !== 'undefined') {
            newInternalMetadata.runStartTime = update.runStartTime;
        }
        return {
            editType: 9 /* CellEditType.PartialInternalMetadata */,
            handle: cellHandle,
            internalMetadata: newInternalMetadata
        };
    }
    throw new Error('Unknown cell update type');
}
exports.updateToEdit = updateToEdit;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-history-service.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-history-service.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var NotebookKernelHistoryService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookKernelHistoryService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_kernel_service_1 = __webpack_require__(/*! ./notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_actions_contribution_1 = __webpack_require__(/*! ../contributions/notebook-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js");
const MAX_KERNELS_IN_HISTORY = 5;
let NotebookKernelHistoryService = NotebookKernelHistoryService_1 = class NotebookKernelHistoryService {
    constructor() {
        this.mostRecentKernelsMap = {};
    }
    init() {
        this.loadState();
    }
    getKernels(notebook) {
        const allAvailableKernels = this.notebookKernelService.getMatchingKernel(notebook);
        const allKernels = allAvailableKernels.all;
        const selectedKernel = allAvailableKernels.selected;
        // We will suggest the only kernel
        const suggested = allAvailableKernels.all.length === 1 ? allAvailableKernels.all[0] : undefined;
        const mostRecentKernelIds = this.mostRecentKernelsMap[notebook.viewType] ? this.mostRecentKernelsMap[notebook.viewType].map(kernel => kernel[1]) : [];
        const all = mostRecentKernelIds.map(kernelId => allKernels.find(kernel => kernel.id === kernelId)).filter(kernel => !!kernel);
        return {
            selected: selectedKernel !== null && selectedKernel !== void 0 ? selectedKernel : suggested,
            all
        };
    }
    async resolveSelectedKernel(notebook) {
        const alreadySelected = this.getKernels(notebook);
        if (alreadySelected.selected) {
            return alreadySelected.selected;
        }
        await this.commandService.executeCommand(notebook_actions_contribution_1.NotebookCommands.SELECT_KERNEL_COMMAND.id, notebook);
        const { selected } = this.getKernels(notebook);
        return selected;
    }
    addMostRecentKernel(kernel) {
        var _a;
        const viewType = kernel.viewType;
        const recentKernels = (_a = this.mostRecentKernelsMap[viewType]) !== null && _a !== void 0 ? _a : [kernel.id];
        if (recentKernels.length > MAX_KERNELS_IN_HISTORY) {
            recentKernels.splice(MAX_KERNELS_IN_HISTORY);
        }
        this.mostRecentKernelsMap[viewType] = recentKernels;
        this.saveState();
    }
    saveState() {
        let notEmpty = false;
        for (const kernels of Object.values(this.mostRecentKernelsMap)) {
            notEmpty = notEmpty || Object.entries(kernels).length > 0;
        }
        this.storageService.setData(NotebookKernelHistoryService_1.STORAGE_KEY, notEmpty ? this.mostRecentKernelsMap : undefined);
    }
    async loadState() {
        const kernelMap = await this.storageService.getData(NotebookKernelHistoryService_1.STORAGE_KEY);
        if (kernelMap) {
            this.mostRecentKernelsMap = kernelMap;
        }
        else {
            this.mostRecentKernelsMap = {};
        }
    }
    clear() {
        this.mostRecentKernelsMap = {};
        this.saveState();
    }
    dispose() {
    }
};
exports.NotebookKernelHistoryService = NotebookKernelHistoryService;
NotebookKernelHistoryService.STORAGE_KEY = 'notebook.kernelHistory';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelHistoryService.prototype, "storageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_service_1.NotebookKernelService),
    tslib_1.__metadata("design:type", notebook_kernel_service_1.NotebookKernelService)
], NotebookKernelHistoryService.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelHistoryService.prototype, "commandService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookKernelHistoryService.prototype, "init", null);
exports.NotebookKernelHistoryService = NotebookKernelHistoryService = NotebookKernelHistoryService_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookKernelHistoryService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-quick-pick-service.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-quick-pick-service.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookKernelQuickPickService = exports.JUPYTER_EXTENSION_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_kernel_service_1 = __webpack_require__(/*! ./notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_kernel_history_service_1 = __webpack_require__(/*! ./notebook-kernel-history-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-history-service.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
exports.JUPYTER_EXTENSION_ID = 'ms-toolsai.jupyter';
function isKernelPick(item) {
    return 'kernel' in item;
}
function isGroupedKernelsPick(item) {
    return 'kernels' in item;
}
function isSourcePick(item) {
    return 'action' in item;
}
function isKernelSourceQuickPickItem(item) {
    return 'command' in item;
}
function supportAutoRun(item) {
    return 'autoRun' in item && !!item.autoRun;
}
const KERNEL_PICKER_UPDATE_DEBOUNCE = 200;
function toKernelQuickPick(kernel, selected) {
    const res = {
        kernel,
        label: kernel.label,
        description: kernel.description,
        detail: kernel.detail
    };
    if (kernel.id === (selected === null || selected === void 0 ? void 0 : selected.id)) {
        if (!res.description) {
            res.description = core_1.nls.localizeByDefault('Currently Selected');
        }
        else {
            res.description = core_1.nls.localizeByDefault('{0} - Currently Selected', res.description);
        }
    }
    return res;
}
let NotebookKernelQuickPickService = class NotebookKernelQuickPickService {
    async showQuickPick(editor, wantedId, skipAutoRun) {
        const notebook = editor;
        const matchResult = this.getMatchingResult(notebook);
        const { selected, all } = matchResult;
        let newKernel;
        if (wantedId) {
            for (const candidate of all) {
                if (candidate.id === wantedId) {
                    newKernel = candidate;
                    break;
                }
            }
            if (!newKernel) {
                console.warn(`wanted kernel DOES NOT EXIST, wanted: ${wantedId}, all: ${all.map(k => k.id)}`);
                return false;
            }
        }
        if (newKernel) {
            this.selectKernel(notebook, newKernel);
            return true;
        }
        const quickPick = this.quickInputService.createQuickPick();
        const quickPickItems = this.getKernelPickerQuickPickItems(matchResult);
        if (quickPickItems.length === 1 && supportAutoRun(quickPickItems[0]) && !skipAutoRun) {
            return this.handleQuickPick(editor, quickPickItems[0], quickPickItems);
        }
        quickPick.items = quickPickItems;
        quickPick.canSelectMany = false;
        quickPick.placeholder = selected
            ? core_1.nls.localizeByDefault("Change kernel for '{0}'", 'current') // TODO get label for current notebook from a label provider
            : core_1.nls.localizeByDefault("Select kernel for '{0}'", 'current');
        quickPick.busy = this.notebookKernelService.getKernelDetectionTasks(notebook).length > 0;
        const kernelDetectionTaskListener = this.notebookKernelService.onDidChangeKernelDetectionTasks(() => {
            quickPick.busy = this.notebookKernelService.getKernelDetectionTasks(notebook).length > 0;
        });
        const kernelChangeEventListener = debounce(core_1.Event.any(this.notebookKernelService.onDidChangeSourceActions, this.notebookKernelService.onDidAddKernel, this.notebookKernelService.onDidRemoveKernel, this.notebookKernelService.onDidChangeNotebookAffinity), KERNEL_PICKER_UPDATE_DEBOUNCE)(async () => {
            // reset quick pick progress
            quickPick.busy = false;
            const currentActiveItems = quickPick.activeItems;
            const newMatchResult = this.getMatchingResult(notebook);
            const newQuickPickItems = this.getKernelPickerQuickPickItems(newMatchResult);
            quickPick.keepScrollPosition = true;
            // recalculate active items
            const activeItems = [];
            for (const item of currentActiveItems) {
                if (isKernelPick(item)) {
                    const kernelId = item.kernel.id;
                    const sameItem = newQuickPickItems.find(pi => isKernelPick(pi) && pi.kernel.id === kernelId);
                    if (sameItem) {
                        activeItems.push(sameItem);
                    }
                }
                else if (isSourcePick(item)) {
                    const sameItem = newQuickPickItems.find(pi => isSourcePick(pi) && pi.action.command.id === item.action.command.id);
                    if (sameItem) {
                        activeItems.push(sameItem);
                    }
                }
            }
            quickPick.items = newQuickPickItems;
            quickPick.activeItems = activeItems;
        }, this);
        const pick = await new Promise((resolve, reject) => {
            quickPick.onDidAccept(() => {
                const item = quickPick.selectedItems[0];
                if (item) {
                    resolve({ selected: item, items: quickPick.items });
                }
                else {
                    resolve({ selected: undefined, items: quickPick.items });
                }
                quickPick.hide();
            });
            quickPick.onDidHide(() => {
                kernelDetectionTaskListener.dispose();
                kernelChangeEventListener === null || kernelChangeEventListener === void 0 ? void 0 : kernelChangeEventListener.dispose();
                quickPick.dispose();
                resolve({ selected: undefined, items: quickPick.items });
            });
            quickPick.show();
        });
        if (pick.selected) {
            return this.handleQuickPick(editor, pick.selected, pick.items);
        }
        return false;
    }
    getKernelPickerQuickPickItems(matchResult) {
        const quickPickItems = [];
        if (matchResult.selected) {
            const kernelItem = toKernelQuickPick(matchResult.selected, matchResult.selected);
            quickPickItems.push(kernelItem);
        }
        // TODO use suggested here when kernel affinity is implemented. For now though show all kernels
        matchResult.all.filter(kernel => { var _a; return kernel.id !== ((_a = matchResult.selected) === null || _a === void 0 ? void 0 : _a.id); }).map(kernel => toKernelQuickPick(kernel, matchResult.selected))
            .forEach(kernel => {
            quickPickItems.push(kernel);
        });
        const shouldAutoRun = quickPickItems.length === 0;
        if (quickPickItems.length > 0) {
            quickPickItems.push({
                type: 'separator'
            });
        }
        // select another kernel quick pick
        quickPickItems.push({
            id: 'selectAnother',
            label: core_1.nls.localizeByDefault('Select Another Kernel...'),
            autoRun: shouldAutoRun
        });
        return quickPickItems;
    }
    selectKernel(notebook, kernel) {
        this.logger.debug('Selected notebook kernel', {
            notebook: notebook.uri.toString(),
            kernel: kernel.id
        });
        const currentInfo = this.notebookKernelService.getMatchingKernel(notebook);
        if (currentInfo.selected) {
            // there is already a selected kernel
            this.notebookKernelHistoryService.addMostRecentKernel(currentInfo.selected);
        }
        this.notebookKernelService.selectKernelForNotebook(kernel, notebook);
        this.notebookKernelHistoryService.addMostRecentKernel(kernel);
    }
    getMatchingResult(notebook) {
        const { selected, all } = this.notebookKernelHistoryService.getKernels(notebook);
        const matchingResult = this.notebookKernelService.getMatchingKernel(notebook);
        return {
            selected: selected,
            all: matchingResult.all,
            suggestions: all,
            hidden: []
        };
    }
    async handleQuickPick(editor, pick, items) {
        if (pick.id === 'selectAnother') {
            return this.displaySelectAnotherQuickPick(editor, items.length === 1 && items[0] === pick);
        }
        if (isKernelPick(pick)) {
            const newKernel = pick.kernel;
            this.selectKernel(editor, newKernel);
            return true;
        }
        if (isSourcePick(pick)) {
            this.logger.debug('Selected notebook kernel command', {
                notebook: editor.uri.toString(),
                command: pick.action.command.id
            });
            // selected explicitly, it should trigger the execution?
            pick.action.run(this.commandService);
        }
        return true;
    }
    async displaySelectAnotherQuickPick(editor, kernelListEmpty) {
        const notebook = editor;
        const disposables = new core_1.DisposableCollection();
        const quickPick = this.quickInputService.createQuickPick();
        const quickPickItem = await new Promise(resolve => {
            // select from kernel sources
            quickPick.title = kernelListEmpty ? core_1.nls.localizeByDefault('Select Kernel') : core_1.nls.localizeByDefault('Select Another Kernel');
            quickPick.placeholder = core_1.nls.localizeByDefault('Type to choose a kernel source');
            quickPick.busy = true;
            // quickPick.buttons = [this.quickInputService.backButton];
            quickPick.show();
            disposables.push(quickPick.onDidTriggerButton(button => {
                if (button === this.quickInputService.backButton) {
                    resolve(button);
                }
            }));
            quickPick.onDidTriggerItemButton(async (e) => {
                if (isKernelSourceQuickPickItem(e.item) && e.item.documentation !== undefined) {
                    const uri = this.isUri(e.item.documentation) ? new core_1.URI(e.item.documentation) : await this.commandService.executeCommand(e.item.documentation);
                    if (uri) {
                        (await this.openerService.getOpener(uri, { openExternal: true })).open(uri, { openExternal: true });
                    }
                }
            });
            disposables.push(quickPick.onDidAccept(async () => {
                resolve(quickPick.selectedItems[0]);
            }));
            disposables.push(quickPick.onDidHide(() => {
                resolve(undefined);
            }));
            this.calculateKernelSources(editor).then(quickPickItems => {
                quickPick.items = quickPickItems;
                if (quickPick.items.length > 0) {
                    quickPick.busy = false;
                }
            });
            debounce(core_1.Event.any(this.notebookKernelService.onDidChangeSourceActions, this.notebookKernelService.onDidAddKernel, this.notebookKernelService.onDidRemoveKernel), KERNEL_PICKER_UPDATE_DEBOUNCE)(async () => {
                quickPick.busy = true;
                const quickPickItems = await this.calculateKernelSources(editor);
                quickPick.items = quickPickItems;
                quickPick.busy = false;
            });
        });
        quickPick.hide();
        disposables.dispose();
        if (quickPickItem === this.quickInputService.backButton) {
            return this.showQuickPick(editor, undefined, true);
        }
        if (quickPickItem) {
            const selectedKernelPickItem = quickPickItem;
            if (isKernelSourceQuickPickItem(selectedKernelPickItem)) {
                try {
                    const selectedKernelId = await this.executeCommand(notebook, selectedKernelPickItem.command);
                    if (selectedKernelId) {
                        const { all } = this.getMatchingResult(notebook);
                        const notebookKernel = all.find(kernel => kernel.id === `ms-toolsai.jupyter/${selectedKernelId}`);
                        if (notebookKernel) {
                            this.selectKernel(notebook, notebookKernel);
                            return true;
                        }
                        return true;
                    }
                    else {
                        return this.displaySelectAnotherQuickPick(editor, false);
                    }
                }
                catch (ex) {
                    console.error('Failed to select notebook kernel', ex);
                    return false;
                }
            }
            else if (isKernelPick(selectedKernelPickItem)) {
                this.selectKernel(notebook, selectedKernelPickItem.kernel);
                return true;
            }
            else if (isGroupedKernelsPick(selectedKernelPickItem)) {
                await this.selectOneKernel(notebook, selectedKernelPickItem.source, selectedKernelPickItem.kernels);
                return true;
            }
            else if (isSourcePick(selectedKernelPickItem)) {
                // selected explicitly, it should trigger the execution?
                try {
                    await selectedKernelPickItem.action.run(this.commandService);
                    return true;
                }
                catch (ex) {
                    console.error('Failed to select notebook kernel', ex);
                    return false;
                }
            }
            // } else if (isSearchMarketplacePick(selectedKernelPickItem)) {
            //     await this.showKernelExtension(
            //         this.paneCompositePartService,
            //         this.extensionWorkbenchService,
            //         this.extensionService,
            //         editor.textModel.viewType,
            //         []
            //     );
            //     return true;
            // } else if (isInstallExtensionPick(selectedKernelPickItem)) {
            //     await this.showKernelExtension(
            //         this.paneCompositePartService,
            //         this.extensionWorkbenchService,
            //         this.extensionService,
            //         editor.textModel.viewType,
            //         selectedKernelPickItem.extensionIds,
            //     );
            //     return true;
            // }
        }
        return false;
    }
    isUri(value) {
        return /^(?<scheme>\w[\w\d+.-]*):/.test(value);
    }
    async calculateKernelSources(editor) {
        const notebook = editor;
        const actions = await this.notebookKernelService.getKernelSourceActionsFromProviders(notebook);
        const matchResult = this.getMatchingResult(notebook);
        const others = matchResult.all.filter(item => item.extensionId !== exports.JUPYTER_EXTENSION_ID);
        const quickPickItems = [];
        // group controllers by extension
        for (const group of core_1.ArrayUtils.groupBy(others, (a, b) => a.extensionId === b.extensionId ? 0 : 1)) {
            const source = group[0].extensionId;
            if (group.length > 1) {
                quickPickItems.push({
                    label: source,
                    kernels: group
                });
            }
            else {
                quickPickItems.push({
                    label: group[0].label,
                    kernel: group[0]
                });
            }
        }
        const validActions = actions.filter(action => action.command);
        quickPickItems.push(...validActions.map(action => {
            const buttons = action.documentation ? [{
                    iconClass: (0, browser_1.codicon)('info'),
                    tooltip: core_1.nls.localizeByDefault('Learn More'),
                }] : [];
            return {
                id: typeof action.command === 'string' ? action.command : action.command.id,
                label: action.label,
                description: action.description,
                command: action.command,
                documentation: action.documentation,
                buttons
            };
        }));
        return quickPickItems;
    }
    async selectOneKernel(notebook, source, kernels) {
        const quickPickItems = kernels.map(kernel => toKernelQuickPick(kernel, undefined));
        const quickPick = this.quickInputService.createQuickPick();
        quickPick.items = quickPickItems;
        quickPick.canSelectMany = false;
        quickPick.title = core_1.nls.localizeByDefault('Select Kernel from {0}', source);
        quickPick.onDidAccept(async () => {
            if (quickPick.selectedItems && quickPick.selectedItems.length > 0 && isKernelPick(quickPick.selectedItems[0])) {
                this.selectKernel(notebook, quickPick.selectedItems[0].kernel);
            }
            quickPick.hide();
            quickPick.dispose();
        });
        quickPick.onDidHide(() => {
            quickPick.dispose();
        });
        quickPick.show();
    }
    async executeCommand(notebook, command) {
        const args = (command.arguments || []).concat([common_1.NotebookModelResource.create(notebook.uri)]);
        return this.commandService.executeCommand(command.id, ...args);
    }
};
exports.NotebookKernelQuickPickService = NotebookKernelQuickPickService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_service_1.NotebookKernelService),
    tslib_1.__metadata("design:type", notebook_kernel_service_1.NotebookKernelService)
], NotebookKernelQuickPickService.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.QuickInputService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelQuickPickService.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelQuickPickService.prototype, "commandService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelQuickPickService.prototype, "openerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_history_service_1.NotebookKernelHistoryService),
    tslib_1.__metadata("design:type", notebook_kernel_history_service_1.NotebookKernelHistoryService)
], NotebookKernelQuickPickService.prototype, "notebookKernelHistoryService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    (0, inversify_1.named)('notebook'),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelQuickPickService.prototype, "logger", void 0);
exports.NotebookKernelQuickPickService = NotebookKernelQuickPickService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookKernelQuickPickService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var NotebookKernelService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookKernelService = exports.SourceCommand = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_service_1 = __webpack_require__(/*! ./notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js");
class KernelInfo {
    constructor(kernel) {
        this.kernel = kernel;
        this.score = -1;
        this.handle = KernelInfo.instanceCounter++;
    }
}
KernelInfo.instanceCounter = 0;
class SourceCommand {
    constructor(command, model) {
        this.command = command;
        this.model = model;
        this.onDidChangeStateEmitter = new core_1.Emitter();
        this.onDidChangeState = this.onDidChangeStateEmitter.event;
    }
    async run(commandService) {
        if (this.execution) {
            return this.execution;
        }
        this.execution = this.runCommand(commandService);
        this.onDidChangeStateEmitter.fire();
        await this.execution;
        this.execution = undefined;
        this.onDidChangeStateEmitter.fire();
    }
    async runCommand(commandService) {
        try {
            await commandService.executeCommand(this.command.id, {
                uri: this.model.uri,
            });
        }
        catch (error) {
            console.warn(`Kernel source command failed: ${error}`);
        }
    }
    dispose() {
        this.onDidChangeStateEmitter.dispose();
    }
}
exports.SourceCommand = SourceCommand;
const NOTEBOOK_KERNEL_BINDING_STORAGE_KEY = 'notebook.kernel.bindings';
let NotebookKernelService = NotebookKernelService_1 = class NotebookKernelService {
    constructor() {
        this.kernels = new Map();
        this.notebookBindings = {};
        this.kernelDetectionTasks = new Map();
        this.onDidChangeKernelDetectionTasksEmitter = new core_1.Emitter();
        this.onDidChangeKernelDetectionTasks = this.onDidChangeKernelDetectionTasksEmitter.event;
        this.onDidChangeSourceActionsEmitter = new core_1.Emitter();
        this.kernelSourceActionProviders = new Map();
        this.onDidChangeSourceActions = this.onDidChangeSourceActionsEmitter.event;
        this.onDidAddKernelEmitter = new core_1.Emitter();
        this.onDidAddKernel = this.onDidAddKernelEmitter.event;
        this.onDidRemoveKernelEmitter = new core_1.Emitter();
        this.onDidRemoveKernel = this.onDidRemoveKernelEmitter.event;
        this.onDidChangeSelectedNotebookKernelBindingEmitter = new core_1.Emitter();
        this.onDidChangeSelectedKernel = this.onDidChangeSelectedNotebookKernelBindingEmitter.event;
        this.onDidChangeNotebookAffinityEmitter = new core_1.Emitter();
        this.onDidChangeNotebookAffinity = this.onDidChangeNotebookAffinityEmitter.event;
    }
    init() {
        this.notebookService.onDidAddNotebookDocument(model => this.tryAutoBindNotebook(model));
        this.storageService.getData(NOTEBOOK_KERNEL_BINDING_STORAGE_KEY).then((value) => {
            if (value) {
                this.notebookBindings = value;
            }
        });
    }
    registerKernel(kernel) {
        if (this.kernels.has(kernel.id)) {
            throw new Error(`Notebook Controller with id '${kernel.id}' already exists`);
        }
        this.kernels.set(kernel.id, new KernelInfo(kernel));
        this.onDidAddKernelEmitter.fire(kernel);
        // auto associate the new kernel to existing notebooks it was
        // associated to in the past.
        for (const notebook of this.notebookService.getNotebookModels()) {
            this.tryAutoBindNotebook(notebook, kernel);
        }
        return core_1.Disposable.create(() => {
            if (this.kernels.delete(kernel.id)) {
                this.onDidRemoveKernelEmitter.fire(kernel);
            }
        });
    }
    /**
     * Helps to find the best matching kernel for a notebook.
     * @param notebook notebook to get the matching kernel for
     * @returns and object containing:
     *  all kernels sorted to match the notebook best first (affinity ascending, score descending, label))
     *  the selected kernel (if any)
     *  specific suggested kernels (if any)
     *  hidden kernels (if any)
     */
    getMatchingKernel(notebook) {
        const kernels = [];
        for (const info of this.kernels.values()) {
            const score = NotebookKernelService_1.score(info.kernel, notebook);
            if (score) {
                kernels.push({
                    score,
                    kernel: info.kernel,
                    instanceAffinity: 1 /* vscode.NotebookControllerPriority.Default */,
                });
            }
        }
        kernels
            .sort((a, b) => b.instanceAffinity - a.instanceAffinity || a.score - b.score || a.kernel.label.localeCompare(b.kernel.label));
        const all = kernels.map(obj => obj.kernel);
        // bound kernel
        const selected = this.getSelectedNotebookKernel(notebook);
        const suggestions = kernels.filter(item => item.instanceAffinity > 1).map(item => item.kernel); // TODO implement notebookAffinity
        const hidden = kernels.filter(item => item.instanceAffinity < 0).map(item => item.kernel);
        return { all, selected, suggestions, hidden };
    }
    getSelectedNotebookKernel(notebook) {
        var _a;
        const selectedId = this.notebookBindings[`${notebook.viewType}/${notebook.uri}`];
        return selectedId ? (_a = this.kernels.get(selectedId)) === null || _a === void 0 ? void 0 : _a.kernel : undefined;
    }
    selectKernelForNotebook(kernel, notebook) {
        const key = `${notebook.viewType}/${notebook.uri}`;
        const oldKernel = this.notebookBindings[key];
        if (oldKernel !== (kernel === null || kernel === void 0 ? void 0 : kernel.id)) {
            if (kernel) {
                this.notebookBindings[key] = kernel.id;
            }
            else {
                delete this.notebookBindings[key];
            }
            this.storageService.setData(NOTEBOOK_KERNEL_BINDING_STORAGE_KEY, this.notebookBindings);
            this.onDidChangeSelectedNotebookKernelBindingEmitter.fire({ notebook: notebook.uri, oldKernel, newKernel: kernel === null || kernel === void 0 ? void 0 : kernel.id });
        }
    }
    getSelectedOrSuggestedKernel(notebook) {
        const info = this.getMatchingKernel(notebook);
        if (info.selected) {
            return info.selected;
        }
        return info.all.length === 1 ? info.all[0] : undefined;
    }
    getKernel(id) {
        var _a;
        return (_a = this.kernels.get(id)) === null || _a === void 0 ? void 0 : _a.kernel;
    }
    static score(kernel, notebook) {
        if (kernel.viewType === notebook.viewType) {
            return 10;
        }
        else if (kernel.viewType === '*') {
            return 5;
        }
        else {
            return 0;
        }
    }
    tryAutoBindNotebook(notebook, onlyThisKernel) {
        const id = this.notebookBindings[`${notebook.viewType}/${notebook.uri}`];
        if (!id) {
            // no kernel associated
            return;
        }
        const existingKernel = this.kernels.get(id);
        if (!existingKernel || !NotebookKernelService_1.score(existingKernel.kernel, notebook)) {
            // associated kernel not known, not matching
            return;
        }
        if (!onlyThisKernel || existingKernel.kernel === onlyThisKernel) {
            this.onDidChangeSelectedNotebookKernelBindingEmitter.fire({ notebook: notebook.uri, oldKernel: undefined, newKernel: existingKernel.kernel.id });
        }
    }
    registerNotebookKernelDetectionTask(notebookType) {
        var _a;
        const all = (_a = this.kernelDetectionTasks.get(notebookType)) !== null && _a !== void 0 ? _a : [];
        all.push(notebookType);
        this.kernelDetectionTasks.set(notebookType, all);
        this.onDidChangeKernelDetectionTasksEmitter.fire(notebookType);
        return core_1.Disposable.create(() => {
            var _a;
            const allTasks = (_a = this.kernelDetectionTasks.get(notebookType)) !== null && _a !== void 0 ? _a : [];
            const taskIndex = allTasks.indexOf(notebookType);
            if (taskIndex >= 0) {
                allTasks.splice(taskIndex, 1);
                this.kernelDetectionTasks.set(notebookType, allTasks);
                this.onDidChangeKernelDetectionTasksEmitter.fire(notebookType);
            }
        });
    }
    getKernelDetectionTasks(notebook) {
        var _a;
        return (_a = this.kernelDetectionTasks.get(notebook.viewType)) !== null && _a !== void 0 ? _a : [];
    }
    registerKernelSourceActionProvider(viewType, provider) {
        var _a, _b;
        const providers = (_a = this.kernelSourceActionProviders.get(viewType)) !== null && _a !== void 0 ? _a : [];
        providers.push(provider);
        this.kernelSourceActionProviders.set(viewType, providers);
        this.onDidChangeSourceActionsEmitter.fire({ viewType: viewType });
        const eventEmitterDisposable = (_b = provider.onDidChangeSourceActions) === null || _b === void 0 ? void 0 : _b.call(provider, () => {
            this.onDidChangeSourceActionsEmitter.fire({ viewType: viewType });
        });
        return core_1.Disposable.create(() => {
            var _a;
            const sourceProviders = (_a = this.kernelSourceActionProviders.get(viewType)) !== null && _a !== void 0 ? _a : [];
            const providerIndex = sourceProviders.indexOf(provider);
            if (providerIndex >= 0) {
                sourceProviders.splice(providerIndex, 1);
                this.kernelSourceActionProviders.set(viewType, sourceProviders);
            }
            eventEmitterDisposable === null || eventEmitterDisposable === void 0 ? void 0 : eventEmitterDisposable.dispose();
        });
    }
    async getKernelSourceActionsFromProviders(notebook) {
        var _a;
        const viewType = notebook.viewType;
        const providers = (_a = this.kernelSourceActionProviders.get(viewType)) !== null && _a !== void 0 ? _a : [];
        const promises = providers.map(provider => provider.provideKernelSourceActions());
        const allActions = await Promise.all(promises);
        return allActions.flat();
    }
};
exports.NotebookKernelService = NotebookKernelService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_service_1.NotebookService),
    tslib_1.__metadata("design:type", notebook_service_1.NotebookService)
], NotebookKernelService.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], NotebookKernelService.prototype, "storageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookKernelService.prototype, "init", null);
exports.NotebookKernelService = NotebookKernelService = NotebookKernelService_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookKernelService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-model-resolver-service.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-model-resolver-service.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookModelResolverService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const notebook_service_1 = __webpack_require__(/*! ./notebook-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js");
const notebook_type_registry_1 = __webpack_require__(/*! ../notebook-type-registry */ "../node_modules/@theia/notebook/lib/browser/notebook-type-registry.js");
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../node_modules/@theia/core/lib/common/glob.js");
let NotebookModelResolverService = class NotebookModelResolverService {
    constructor() {
        this.onDidChangeDirtyEmitter = new core_1.Emitter();
        this.onDidChangeDirty = this.onDidChangeDirtyEmitter.event;
        this.onDidSaveNotebookEmitter = new core_1.Emitter();
        this.onDidSaveNotebook = this.onDidSaveNotebookEmitter.event;
    }
    async resolve(resource, viewType) {
        const existingModel = this.notebookService.getNotebookEditorModel(resource);
        if (!viewType) {
            if (existingModel) {
                return existingModel;
            }
            else {
                viewType = this.findViewTypeForResource(resource);
            }
        }
        else if ((existingModel === null || existingModel === void 0 ? void 0 : existingModel.viewType) === viewType) {
            return existingModel;
        }
        if (!viewType) {
            throw new Error(`Missing viewType for '${resource}'`);
        }
        try {
            const actualResource = await this.resourceProvider(resource);
            const notebookData = await this.resolveExistingNotebookData(actualResource, viewType);
            const notebookModel = await this.notebookService.createNotebookModel(notebookData, viewType, actualResource);
            notebookModel.onDirtyChanged(() => this.onDidChangeDirtyEmitter.fire(notebookModel));
            notebookModel.onDidSaveNotebook(() => this.onDidSaveNotebookEmitter.fire(notebookModel.uri.toComponents()));
            return notebookModel;
        }
        catch (e) {
            const message = `Error resolving notebook model for: \n ${resource.path.fsPath()} \n with view type ${viewType}. \n ${e}`;
            console.error(message);
            throw new Error(message);
        }
    }
    async resolveUntitledResource(arg, viewType) {
        var _a, _b;
        let resource;
        // let hasAssociatedFilePath = false;
        arg = arg;
        if (!arg.untitledResource) {
            const notebookTypeInfo = this.notebookTypeRegistry.notebookTypes.find(info => info.type === viewType);
            if (!notebookTypeInfo) {
                throw new Error('UNKNOWN view type: ' + viewType);
            }
            const suffix = (_b = this.getPossibleFileEnding((_a = notebookTypeInfo.selector) !== null && _a !== void 0 ? _a : [])) !== null && _b !== void 0 ? _b : '';
            for (let counter = 1;; counter++) {
                const candidate = new core_1.URI()
                    .withScheme(core_1.UNTITLED_SCHEME)
                    .withPath(`Untitled-notebook-${counter}${suffix}`)
                    .withQuery(viewType);
                if (!this.notebookService.getNotebookEditorModel(candidate)) {
                    resource = candidate;
                    break;
                }
            }
        }
        else if (arg.untitledResource.scheme === core_1.UNTITLED_SCHEME) {
            resource = arg.untitledResource;
        }
        else {
            throw new Error('Invalid untitled resource: ' + arg.untitledResource.toString() + ' untitled resources with associated file path are not supported yet');
            // TODO implement associated file path support
            // resource = arg.untitledResource.withScheme('untitled');
            // hasAssociatedFilePath = true;
        }
        return this.resolve(resource, viewType);
    }
    async resolveExistingNotebookData(resource, viewType) {
        if (resource.uri.scheme === 'untitled') {
            return {
                cells: [],
                metadata: {}
            };
        }
        else {
            const [dataProvider, contents] = await Promise.all([
                this.notebookService.getNotebookDataProvider(viewType),
                this.fileService.readFile(resource.uri)
            ]);
            const notebook = await dataProvider.serializer.toNotebook(contents.value);
            return notebook;
        }
    }
    getPossibleFileEnding(selectors) {
        for (const selector of selectors) {
            const ending = this.possibleFileEnding(selector);
            if (ending) {
                return ending;
            }
        }
        return undefined;
    }
    possibleFileEnding(selector) {
        const pattern = /^.*(\.[a-zA-Z0-9_-]+)$/;
        const candidate = typeof selector === 'string' ? selector : selector.filenamePattern;
        if (candidate) {
            const matches = pattern.exec(candidate);
            if (matches) {
                return matches[1];
            }
        }
        return undefined;
    }
    findViewTypeForResource(resource) {
        var _a;
        return (_a = this.notebookTypeRegistry.notebookTypes.find(info => { var _a; return (_a = info.selector) === null || _a === void 0 ? void 0 : _a.some(selector => selector.filenamePattern && (0, glob_1.match)(selector.filenamePattern, resource.path.name + resource.path.ext)); })) === null || _a === void 0 ? void 0 : _a.type;
    }
};
exports.NotebookModelResolverService = NotebookModelResolverService;
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], NotebookModelResolverService.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ResourceProvider),
    tslib_1.__metadata("design:type", Function)
], NotebookModelResolverService.prototype, "resourceProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_service_1.NotebookService),
    tslib_1.__metadata("design:type", notebook_service_1.NotebookService)
], NotebookModelResolverService.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_type_registry_1.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", notebook_type_registry_1.NotebookTypeRegistry)
], NotebookModelResolverService.prototype, "notebookTypeRegistry", void 0);
exports.NotebookModelResolverService = NotebookModelResolverService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookModelResolverService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMonacoTextModelService = exports.NotebookMonacoEditorModelFilter = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco_text_model_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-text-model-service */ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const notebook_common_1 = __webpack_require__(/*! ../../common/notebook-common */ "../node_modules/@theia/notebook/lib/common/notebook-common.js");
let NotebookMonacoEditorModelFilter = class NotebookMonacoEditorModelFilter {
    constructor() {
        this.onDidCreateCellModelEmitter = new core_1.Emitter();
    }
    get onDidCreateCellModel() {
        return this.onDidCreateCellModelEmitter.event;
    }
    filter(model) {
        const applies = model.uri.startsWith(notebook_common_1.CellUri.cellUriScheme);
        if (applies) {
            // If the model is for a notebook cell, we emit the event to notify the listeners.
            // We create our own event here, as we don't want to propagate the creation of the cell to the plugin host.
            // Instead, we want to do that ourselves once the notebook model is completely initialized.
            this.onDidCreateCellModelEmitter.fire(model);
        }
        return applies;
    }
};
exports.NotebookMonacoEditorModelFilter = NotebookMonacoEditorModelFilter;
exports.NotebookMonacoEditorModelFilter = NotebookMonacoEditorModelFilter = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookMonacoEditorModelFilter);
/**
 * special service for creating monaco textmodels for notebook cells.
 * Its for optimization purposes since there is alot of overhead otherwise with calling the backend to create a document for each cell and other smaller things.
 */
let NotebookMonacoTextModelService = class NotebookMonacoTextModelService {
    getOrCreateNotebookCellModelReference(uri) {
        return this.monacoTextModelService.createModelReference(uri);
    }
    async createTextModelsForNotebook(notebook) {
        await Promise.all(notebook.cells.map(cell => cell.resolveTextModel()));
    }
    get onDidCreateNotebookCellModel() {
        return this.notebookMonacoEditorModelFilter.onDidCreateCellModel;
    }
};
exports.NotebookMonacoTextModelService = NotebookMonacoTextModelService;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_text_model_service_1.MonacoTextModelService),
    tslib_1.__metadata("design:type", monaco_text_model_service_1.MonacoTextModelService)
], NotebookMonacoTextModelService.prototype, "monacoTextModelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(NotebookMonacoEditorModelFilter),
    tslib_1.__metadata("design:type", NotebookMonacoEditorModelFilter)
], NotebookMonacoTextModelService.prototype, "notebookMonacoEditorModelFilter", void 0);
exports.NotebookMonacoTextModelService = NotebookMonacoTextModelService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookMonacoTextModelService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-options.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-options.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookOptionsService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_preferences_1 = __webpack_require__(/*! ../contributions/notebook-preferences */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-preferences.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const fontInfo_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/config/fontInfo */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/config/fontInfo.js");
const pixelRatio_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/browser/pixelRatio */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/browser/pixelRatio.js");
const notebookOutputOptionsRelevantPreferences = [
    'editor.fontSize',
    'editor.fontFamily',
    notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS,
    notebook_preferences_1.NotebookPreferences.OUTPUT_LINE_HEIGHT,
    notebook_preferences_1.NotebookPreferences.OUTPUT_FONT_SIZE,
    notebook_preferences_1.NotebookPreferences.OUTPUT_FONT_FAMILY,
    notebook_preferences_1.NotebookPreferences.OUTPUT_SCROLLING,
    notebook_preferences_1.NotebookPreferences.OUTPUT_WORD_WRAP,
    notebook_preferences_1.NotebookPreferences.OUTPUT_LINE_LIMIT
];
let NotebookOptionsService = class NotebookOptionsService {
    constructor() {
        this.outputOptionsChangedEmitter = new core_1.Emitter();
        this.onDidChangeOutputOptions = this.outputOptionsChangedEmitter.event;
    }
    get editorFontInfo() {
        return this.getOrCreateMonacoFontInfo();
    }
    init() {
        this.preferenceService.onPreferencesChanged(async (preferenceChanges) => {
            if (notebookOutputOptionsRelevantPreferences.some(p => p in preferenceChanges)) {
                this.outputOptionsChangedEmitter.fire(this.computeOutputOptions());
            }
        });
    }
    computeOutputOptions() {
        const outputLineHeight = this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_LINE_HEIGHT);
        const fontSize = this.preferenceService.get('editor.fontSize');
        const outputFontSize = this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_FONT_SIZE);
        return {
            fontSize,
            outputFontSize: outputFontSize,
            fontFamily: this.preferenceService.get('editor.fontFamily'),
            outputNodeLeftPadding: 8,
            outputFontFamily: this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_FONT_FAMILY),
            outputLineHeight: this.computeOutputLineHeight(outputLineHeight, outputFontSize !== null && outputFontSize !== void 0 ? outputFontSize : fontSize),
            outputScrolling: this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_SCROLLING),
            outputWordWrap: this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_WORD_WRAP),
            outputLineLimit: this.getNotebookPreferenceWithDefault(notebook_preferences_1.NotebookPreferences.OUTPUT_LINE_LIMIT)
        };
    }
    getNotebookPreferenceWithDefault(key) {
        var _a, _b;
        return this.preferenceService.get(key, (_b = (_a = notebook_preferences_1.notebookPreferenceSchema.properties) === null || _a === void 0 ? void 0 : _a[key]) === null || _b === void 0 ? void 0 : _b.default);
    }
    computeOutputLineHeight(lineHeight, outputFontSize) {
        const minimumLineHeight = 9;
        if (lineHeight === 0) {
            // use editor line height
            lineHeight = this.editorFontInfo.lineHeight;
        }
        else if (lineHeight < minimumLineHeight) {
            // Values too small to be line heights in pixels are in ems.
            let fontSize = outputFontSize;
            if (fontSize === 0) {
                fontSize = this.preferenceService.get('editor.fontSize');
            }
            lineHeight = lineHeight * fontSize;
        }
        // Enforce integer, minimum constraints
        lineHeight = Math.round(lineHeight);
        if (lineHeight < minimumLineHeight) {
            lineHeight = minimumLineHeight;
        }
        return lineHeight;
    }
    getOrCreateMonacoFontInfo() {
        if (!this.fontInfo) {
            this.fontInfo = this.createFontInfo();
            this.editorPreferences.onPreferenceChanged(e => this.fontInfo = this.createFontInfo());
        }
        return this.fontInfo;
    }
    createFontInfo() {
        return fontInfo_1.BareFontInfo.createFromRawSettings({
            fontFamily: this.editorPreferences['editor.fontFamily'],
            fontWeight: String(this.editorPreferences['editor.fontWeight']),
            fontSize: this.editorPreferences['editor.fontSize'],
            fontLigatures: this.editorPreferences['editor.fontLigatures'],
            lineHeight: this.editorPreferences['editor.lineHeight'],
            letterSpacing: this.editorPreferences['editor.letterSpacing'],
        }, pixelRatio_1.PixelRatio.getInstance(window).value);
    }
};
exports.NotebookOptionsService = NotebookOptionsService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], NotebookOptionsService.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorPreferences),
    tslib_1.__metadata("design:type", Object)
], NotebookOptionsService.prototype, "editorPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookOptionsService.prototype, "init", null);
exports.NotebookOptionsService = NotebookOptionsService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookOptionsService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-renderer-messaging-service.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-renderer-messaging-service.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRendererMessagingService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const notebook_editor_widget_service_1 = __webpack_require__(/*! ./notebook-editor-widget-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js");
;
let NotebookRendererMessagingService = class NotebookRendererMessagingService {
    constructor() {
        this.postMessageEmitter = new core_1.Emitter();
        this.onPostMessage = this.postMessageEmitter.event;
        this.willActivateRendererEmitter = new core_1.Emitter();
        this.onWillActivateRenderer = this.willActivateRendererEmitter.event;
        this.activations = new Map();
        this.scopedMessaging = new Map();
    }
    receiveMessage(editorId, rendererId, message) {
        var _a, _b, _c;
        if (editorId === undefined) {
            const sends = [...this.scopedMessaging.values()].map(e => { var _a; return (_a = e.receiveMessage) === null || _a === void 0 ? void 0 : _a.call(e, rendererId, message); });
            return Promise.all(sends).then(values => values.some(value => !!value));
        }
        return (_c = (_b = (_a = this.scopedMessaging.get(editorId)) === null || _a === void 0 ? void 0 : _a.receiveMessage) === null || _b === void 0 ? void 0 : _b.call(_a, rendererId, message)) !== null && _c !== void 0 ? _c : Promise.resolve(false);
    }
    prepare(rendererId) {
        if (this.activations.has(rendererId)) {
            return;
        }
        const queue = [];
        this.activations.set(rendererId, queue);
        Promise.all(this.willActivateRendererEmitter.fire(rendererId)).then(() => {
            for (const message of queue) {
                this.postMessageEmitter.fire(message);
            }
            this.activations.set(rendererId, undefined);
        });
    }
    getScoped(editorId) {
        const existing = this.scopedMessaging.get(editorId);
        if (existing) {
            return existing;
        }
        const messaging = {
            postMessage: (rendererId, message) => this.postMessage(editorId, rendererId, message),
            receiveMessage: async (rendererId, message) => {
                var _a;
                (_a = this.editorWidgetService.getNotebookEditor(editorId)) === null || _a === void 0 ? void 0 : _a.postRendererMessage(rendererId, message);
                return true;
            },
            dispose: () => this.scopedMessaging.delete(editorId),
        };
        this.scopedMessaging.set(editorId, messaging);
        return messaging;
    }
    postMessage(editorId, rendererId, message) {
        if (!this.activations.has(rendererId)) {
            this.prepare(rendererId);
        }
        const activation = this.activations.get(rendererId);
        const toSend = { rendererId, editorId, message };
        if (activation === undefined) {
            this.postMessageEmitter.fire(toSend);
        }
        else {
            activation.push(toSend);
        }
    }
    dispose() {
        this.postMessageEmitter.dispose();
    }
};
exports.NotebookRendererMessagingService = NotebookRendererMessagingService;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_editor_widget_service_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", notebook_editor_widget_service_1.NotebookEditorWidgetService)
], NotebookRendererMessagingService.prototype, "editorWidgetService", void 0);
exports.NotebookRendererMessagingService = NotebookRendererMessagingService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookRendererMessagingService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/service/notebook-service.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/service/notebook-service.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookService = exports.NotebookProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_model_1 = __webpack_require__(/*! ../view-model/notebook-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-model.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const notebook_cell_model_1 = __webpack_require__(/*! ../view-model/notebook-cell-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const notebook_monaco_text_model_service_1 = __webpack_require__(/*! ./notebook-monaco-text-model-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js");
exports.NotebookProvider = Symbol('notebook provider');
let NotebookService = class NotebookService {
    constructor() {
        this.willUseNotebookSerializerEmitter = new core_1.Emitter();
        this.onWillUseNotebookSerializer = this.willUseNotebookSerializerEmitter.event;
        this.disposables = new core_1.DisposableCollection();
        this.notebookProviders = new Map();
        this.notebookModels = new Map();
        this.didRegisterNotebookSerializerEmitter = new core_1.Emitter();
        this.onDidRegisterNotebookSerializer = this.didRegisterNotebookSerializerEmitter.event;
        this.didRemoveViewTypeEmitter = new core_1.Emitter();
        this.onDidRemoveViewType = this.didRemoveViewTypeEmitter.event;
        this.willOpenNotebookTypeEmitter = new core_1.Emitter();
        this.onWillOpenNotebook = this.willOpenNotebookTypeEmitter.event;
        this.didAddNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidAddNotebookDocument = this.didAddNotebookDocumentEmitter.event;
        this.didRemoveNotebookDocumentEmitter = new core_1.Emitter();
        this.onDidRemoveNotebookDocument = this.didRemoveNotebookDocumentEmitter.event;
        this.ready = new promise_util_1.Deferred();
    }
    dispose() {
        this.disposables.dispose();
    }
    /**
     * Marks the notebook service as ready. From this point on, the service will start dispatching the `onNotebookSerializer` event.
     */
    markReady() {
        this.ready.resolve();
    }
    registerNotebookSerializer(viewType, serializer) {
        if (this.notebookProviders.has(viewType)) {
            throw new Error(`notebook provider for viewtype '${viewType}' already exists`);
        }
        this.notebookProviders.set(viewType, { notebookType: viewType, serializer });
        this.didRegisterNotebookSerializerEmitter.fire(viewType);
        return core_1.Disposable.create(() => {
            this.notebookProviders.delete(viewType);
            this.didRemoveViewTypeEmitter.fire(viewType);
        });
    }
    async createNotebookModel(data, viewType, resource) {
        const dataProvider = await this.getNotebookDataProvider(viewType);
        const serializer = dataProvider.serializer;
        const model = this.notebookModelFactory({ data, resource, viewType, serializer });
        this.notebookModels.set(resource.uri.toString(), model);
        // Resolve cell text models right after creating the notebook model
        // This ensures that all text models are available in the plugin host
        await this.textModelService.createTextModelsForNotebook(model);
        this.didAddNotebookDocumentEmitter.fire(model);
        model.onDidDispose(() => {
            this.notebookModels.delete(resource.uri.toString());
            this.didRemoveNotebookDocumentEmitter.fire(model);
        });
        return model;
    }
    async getNotebookDataProvider(viewType) {
        try {
            return await this.waitForNotebookProvider(viewType);
        }
        catch {
            throw new Error(`No provider registered for view type: '${viewType}'`);
        }
    }
    /**
     * When the application starts up, notebook providers from plugins are not registered yet.
     * It takes a few seconds for the plugin host to start so that notebook data providers can be registered.
     * This methods waits until the notebook provider is registered.
     */
    waitForNotebookProvider(type) {
        const existing = this.notebookProviders.get(type);
        if (existing) {
            return Promise.resolve(existing);
        }
        const deferred = new promise_util_1.Deferred();
        // 20 seconds of timeout
        const timeoutDuration = 20000;
        // Must declare these variables where they can be captured by the closure
        let disposable;
        // eslint-disable-next-line
        let timeout;
        // eslint-disable-next-line
        disposable = this.onDidRegisterNotebookSerializer(viewType => {
            if (viewType === type) {
                clearTimeout(timeout);
                disposable.dispose();
                const newProvider = this.notebookProviders.get(type);
                if (!newProvider) {
                    deferred.reject(new Error(`Notebook provider for type ${type} is invalid`));
                }
                else {
                    deferred.resolve(newProvider);
                }
            }
        });
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            disposable.dispose();
            deferred.reject(new Error(`Timed out while waiting for notebook serializer for type ${type} to be registered`));
        }, timeoutDuration);
        this.ready.promise.then(() => {
            this.willUseNotebookSerializerEmitter.fire(type);
        });
        return deferred.promise;
    }
    getNotebookEditorModel(uri) {
        return this.notebookModels.get(uri.toString());
    }
    getNotebookModels() {
        return this.notebookModels.values();
    }
    async willOpenNotebook(type) {
        return this.willOpenNotebookTypeEmitter.sequence(async (listener) => listener(type));
    }
    listNotebookDocuments() {
        return [...this.notebookModels.values()];
    }
    applyWorkspaceEdit(workspaceEdit) {
        try {
            workspaceEdit.edits.forEach(edit => {
                const notebook = this.getNotebookEditorModel(edit.resource);
                notebook === null || notebook === void 0 ? void 0 : notebook.applyEdits([edit.edit], true);
            });
            return true;
        }
        catch (e) {
            console.error(e);
            return false;
        }
    }
    getCodeCellLanguage(model) {
        var _a;
        const firstCodeCell = model.cells.find(cellModel => cellModel.cellKind === common_1.CellKind.Code);
        const cellLanguage = (_a = firstCodeCell === null || firstCodeCell === void 0 ? void 0 : firstCodeCell.language) !== null && _a !== void 0 ? _a : 'plaintext';
        return cellLanguage;
    }
};
exports.NotebookService = NotebookService;
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], NotebookService.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_model_1.NotebookModelFactory),
    tslib_1.__metadata("design:type", Function)
], NotebookService.prototype, "notebookModelFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_model_1.NotebookCellModelFactory),
    tslib_1.__metadata("design:type", Function)
], NotebookService.prototype, "notebookCellModelFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_monaco_text_model_service_1.NotebookMonacoTextModelService),
    tslib_1.__metadata("design:type", notebook_monaco_text_model_service_1.NotebookMonacoTextModelService)
], NotebookService.prototype, "textModelService", void 0);
exports.NotebookService = NotebookService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookService);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCodeEditorFindMatch = exports.NotebookCellModel = exports.createNotebookCellModelContainer = exports.NotebookCellModelFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_monaco_text_model_service_1 = __webpack_require__(/*! ../service/notebook-monaco-text-model-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js");
const notebook_cell_output_model_1 = __webpack_require__(/*! ./notebook-cell-output-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-output-model.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_preferences_1 = __webpack_require__(/*! ../contributions/notebook-preferences */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-preferences.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../node_modules/@theia/core/lib/browser/language-service.js");
exports.NotebookCellModelFactory = Symbol('NotebookModelFactory');
function createNotebookCellModelContainer(parent, props) {
    const child = parent.createChild();
    child.bind(NotebookCellModelProps).toConstantValue(props);
    child.bind(NotebookCellModel).toSelf();
    return child;
}
exports.createNotebookCellModelContainer = createNotebookCellModelContainer;
const NotebookCellModelProps = Symbol('NotebookModelProps');
let NotebookCellModel = class NotebookCellModel {
    constructor() {
        this.onDidChangeOutputsEmitter = new core_1.Emitter();
        this.onDidChangeOutputs = this.onDidChangeOutputsEmitter.event;
        this.onDidChangeOutputItemsEmitter = new core_1.Emitter();
        this.onDidChangeOutputItems = this.onDidChangeOutputItemsEmitter.event;
        this.onDidChangeContentEmitter = new core_1.Emitter();
        this.onDidChangeContent = this.onDidChangeContentEmitter.event;
        this.onDidChangeMetadataEmitter = new core_1.Emitter();
        this.onDidChangeMetadata = this.onDidChangeMetadataEmitter.event;
        this.onDidChangeInternalMetadataEmitter = new core_1.Emitter();
        this.onDidChangeInternalMetadata = this.onDidChangeInternalMetadataEmitter.event;
        this.onDidChangeLanguageEmitter = new core_1.Emitter();
        this.onDidChangeLanguage = this.onDidChangeLanguageEmitter.event;
        this.onDidRequestCellEditChangeEmitter = new core_1.Emitter();
        this.onDidRequestCellEditChange = this.onDidRequestCellEditChangeEmitter.event;
        this.onWillFocusCellEditorEmitter = new core_1.Emitter();
        this.onWillFocusCellEditor = this.onWillFocusCellEditorEmitter.event;
        this.onWillBlurCellEditorEmitter = new core_1.Emitter();
        this.onWillBlurCellEditor = this.onWillBlurCellEditorEmitter.event;
        this.onDidChangeEditorOptionsEmitter = new core_1.Emitter();
        this.onDidChangeEditorOptions = this.onDidChangeEditorOptionsEmitter.event;
        this.outputVisibilityChangeEmitter = new core_1.Emitter();
        this.onDidChangeOutputVisibility = this.outputVisibilityChangeEmitter.event;
        this.onDidFindMatchesEmitter = new core_1.Emitter();
        this.onDidFindMatches = this.onDidFindMatchesEmitter.event;
        this.onDidSelectFindMatchEmitter = new core_1.Emitter();
        this.onDidSelectFindMatch = this.onDidSelectFindMatchEmitter.event;
        this.onDidRequestCenterEditorEmitter = new core_1.Emitter();
        this.onDidRequestCenterEditor = this.onDidRequestCenterEditorEmitter.event;
        this.onDidCellHeightChangeEmitter = new core_1.Emitter();
        this.onDidCellHeightChange = this.onDidCellHeightChangeEmitter.event;
        this.toDispose = new core_1.DisposableCollection();
        this._editing = false;
        this._editorOptions = {};
        this._outputVisible = true;
        this._selection = undefined;
        this._cellheight = 0;
    }
    get outputs() {
        return this._outputs;
    }
    get metadata() {
        return this._metadata;
    }
    set metadata(newMetadata) {
        this._metadata = newMetadata;
        this.onDidChangeMetadataEmitter.fire();
    }
    get internalMetadata() {
        return this._internalMetadata;
    }
    set internalMetadata(newInternalMetadata) {
        const lastRunSuccessChanged = this._internalMetadata.lastRunSuccess !== newInternalMetadata.lastRunSuccess;
        newInternalMetadata = {
            ...newInternalMetadata,
            ...{ runStartTimeAdjustment: computeRunStartTimeAdjustment(this._internalMetadata, newInternalMetadata) }
        };
        this._internalMetadata = newInternalMetadata;
        this.onDidChangeInternalMetadataEmitter.fire({ lastRunSuccessChanged });
    }
    get text() {
        return this.textModel && !this.textModel.isDisposed() ? this.textModel.getText() : this.source;
    }
    get source() {
        return this.props.source;
    }
    set source(source) {
        var _a;
        this.props.source = source;
        (_a = this.textModel) === null || _a === void 0 ? void 0 : _a.textEditorModel.setValue(source);
    }
    get language() {
        return this.props.language;
    }
    set language(newLanguage) {
        if (this.language === newLanguage) {
            return;
        }
        if (this.textModel) {
            this.textModel.setLanguageId(newLanguage);
        }
        this.props.language = newLanguage;
        this.onDidChangeLanguageEmitter.fire(newLanguage);
        this.onDidChangeContentEmitter.fire('language');
    }
    get languageName() {
        var _a, _b;
        return (_b = (_a = this.languageService.getLanguage(this.language)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : this.language;
    }
    get uri() {
        return this.props.uri;
    }
    get handle() {
        return this.props.handle;
    }
    get cellKind() {
        return this.props.cellKind;
    }
    get editing() {
        return this._editing;
    }
    get editorOptions() {
        return this._editorOptions;
    }
    set editorOptions(options) {
        this._editorOptions = options;
        this.onDidChangeEditorOptionsEmitter.fire(options);
    }
    get outputVisible() {
        return this._outputVisible;
    }
    set outputVisible(visible) {
        if (this._outputVisible !== visible) {
            this._outputVisible = visible;
            this.outputVisibilityChangeEmitter.fire(visible);
        }
    }
    get selection() {
        return this._selection;
    }
    set selection(selection) {
        this._selection = selection;
    }
    get cellHeight() {
        return this._cellheight;
    }
    set cellHeight(height) {
        if (height !== this._cellheight) {
            this.onDidCellHeightChangeEmitter.fire(height);
            this._cellheight = height;
        }
    }
    init() {
        var _a, _b;
        this._outputs = this.props.outputs.map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op));
        this._metadata = (_a = this.props.metadata) !== null && _a !== void 0 ? _a : {};
        this._internalMetadata = (_b = this.props.internalMetadata) !== null && _b !== void 0 ? _b : {};
        this.editorOptions = {
            lineNumbers: this.preferenceService.get(notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS)
        };
        this.toDispose.push(this.preferenceService.onPreferenceChanged(e => {
            if (e.preferenceName === notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS) {
                this.editorOptions = {
                    ...this.editorOptions,
                    lineNumbers: this.preferenceService.get(notebook_preferences_1.NotebookPreferences.NOTEBOOK_LINE_NUMBERS)
                };
            }
        }));
    }
    dispose() {
        this.onDidChangeOutputsEmitter.dispose();
        this.onDidChangeOutputItemsEmitter.dispose();
        this.onDidChangeContentEmitter.dispose();
        this.onDidChangeMetadataEmitter.dispose();
        this.onDidChangeInternalMetadataEmitter.dispose();
        this.onDidChangeLanguageEmitter.dispose();
        this.toDispose.dispose();
    }
    requestEdit() {
        if (!this.textModel || !this.textModel.readOnly) {
            this._editing = true;
            this.onDidRequestCellEditChangeEmitter.fire(true);
        }
    }
    requestStopEdit() {
        this._editing = false;
        this.onDidRequestCellEditChangeEmitter.fire(false);
    }
    requestFocusEditor(focusRequest) {
        this.requestEdit();
        this.onWillFocusCellEditorEmitter.fire(focusRequest);
    }
    requestBlurEditor() {
        this.requestStopEdit();
        this.onWillBlurCellEditorEmitter.fire();
    }
    requestCenterEditor() {
        this.onDidRequestCenterEditorEmitter.fire();
    }
    spliceNotebookCellOutputs(splice) {
        if (splice.deleteCount > 0 && splice.newOutputs.length > 0) {
            const commonLen = Math.min(splice.deleteCount, splice.newOutputs.length);
            // update
            for (let i = 0; i < commonLen; i++) {
                const currentOutput = this.outputs[splice.start + i];
                const newOutput = splice.newOutputs[i];
                this.replaceOutputData(currentOutput.outputId, newOutput);
            }
            this.outputs.splice(splice.start + commonLen, splice.deleteCount - commonLen, ...splice.newOutputs.slice(commonLen).map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op)));
            this.onDidChangeOutputsEmitter.fire({ start: splice.start + commonLen, deleteCount: splice.deleteCount - commonLen, newOutputs: splice.newOutputs.slice(commonLen) });
        }
        else {
            this.outputs.splice(splice.start, splice.deleteCount, ...splice.newOutputs.map(op => new notebook_cell_output_model_1.NotebookCellOutputModel(op)));
            this.onDidChangeOutputsEmitter.fire(splice);
        }
    }
    replaceOutputData(outputId, newOutputData) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (!output) {
            return false;
        }
        output.replaceData(newOutputData);
        this.onDidChangeOutputItemsEmitter.fire(output);
        return true;
    }
    changeOutputItems(outputId, append, items) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (!output) {
            return false;
        }
        if (append) {
            output.appendData(items);
        }
        else {
            output.replaceData({ outputId: outputId, outputs: items, metadata: output.metadata });
        }
        this.onDidChangeOutputItemsEmitter.fire(output);
        return true;
    }
    getData() {
        return {
            cellKind: this.cellKind,
            language: this.language,
            outputs: this.outputs.map(output => output.getData()),
            source: this.text,
            collapseState: this.props.collapseState,
            internalMetadata: this.internalMetadata,
            metadata: this.metadata
        };
    }
    async resolveTextModel() {
        if (this.textModel) {
            return this.textModel;
        }
        const ref = await this.textModelService.getOrCreateNotebookCellModelReference(this.uri);
        this.textModel = ref.object;
        this.toDispose.push(ref);
        this.toDispose.push(this.textModel.onDidChangeContent(e => {
            this.props.source = e.model.getText();
        }));
        return ref.object;
    }
    restartOutputRenderer(outputId) {
        const output = this.outputs.find(out => out.outputId === outputId);
        if (output) {
            this.onDidChangeOutputItemsEmitter.fire(output);
        }
    }
    showMatch(selected) {
        this.onDidSelectFindMatchEmitter.fire(selected);
    }
    findMatches(options) {
        var _a, _b;
        if (this.cellKind === common_1.CellKind.Markup && !this.editing) {
            return (_b = (_a = this.onMarkdownFind) === null || _a === void 0 ? void 0 : _a.call(this, options)) !== null && _b !== void 0 ? _b : [];
        }
        if (!this.textModel) {
            return [];
        }
        const matches = options.search ? this.textModel.findMatches({
            searchString: options.search,
            isRegex: options.regex,
            matchCase: options.matchCase,
            matchWholeWord: options.wholeWord
        }) : [];
        const editorFindMatches = matches.map(match => new NotebookCodeEditorFindMatch(this, match.range, this.textModel));
        this.onDidFindMatchesEmitter.fire(editorFindMatches);
        return editorFindMatches;
    }
    replaceAll(matches, value) {
        var _a;
        const editOperations = matches.map(match => ({
            range: {
                startColumn: match.range.start.character,
                startLineNumber: match.range.start.line,
                endColumn: match.range.end.character,
                endLineNumber: match.range.end.line
            },
            text: value
        }));
        (_a = this.textModel) === null || _a === void 0 ? void 0 : _a.textEditorModel.pushEditOperations(
        // eslint-disable-next-line no-null/no-null
        null, editOperations, 
        // eslint-disable-next-line no-null/no-null
        () => null);
    }
};
exports.NotebookCellModel = NotebookCellModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(NotebookCellModelProps),
    tslib_1.__metadata("design:type", Object)
], NotebookCellModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_monaco_text_model_service_1.NotebookMonacoTextModelService),
    tslib_1.__metadata("design:type", notebook_monaco_text_model_service_1.NotebookMonacoTextModelService)
], NotebookCellModel.prototype, "textModelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], NotebookCellModel.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], NotebookCellModel.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookCellModel.prototype, "init", null);
exports.NotebookCellModel = NotebookCellModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellModel);
class NotebookCodeEditorFindMatch {
    constructor(cell, range, textModel) {
        this.cell = cell;
        this.range = range;
        this.textModel = textModel;
        this.selected = false;
    }
    show() {
        this.cell.showMatch(this);
    }
    replace(value) {
        this.textModel.textEditorModel.pushEditOperations(
        // eslint-disable-next-line no-null/no-null
        null, [{
                range: {
                    startColumn: this.range.start.character,
                    startLineNumber: this.range.start.line,
                    endColumn: this.range.end.character,
                    endLineNumber: this.range.end.line
                },
                text: value
            }], 
        // eslint-disable-next-line no-null/no-null
        () => null);
    }
}
exports.NotebookCodeEditorFindMatch = NotebookCodeEditorFindMatch;
function computeRunStartTimeAdjustment(oldMetadata, newMetadata) {
    if (oldMetadata.runStartTime !== newMetadata.runStartTime && typeof newMetadata.runStartTime === 'number') {
        const offset = Date.now() - newMetadata.runStartTime;
        return offset < 0 ? Math.abs(offset) : 0;
    }
    else {
        return newMetadata.runStartTimeAdjustment;
    }
}


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-output-model.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-output-model.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellOutputModel = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_output_utils_1 = __webpack_require__(/*! ../notebook-output-utils */ "../node_modules/@theia/notebook/lib/browser/notebook-output-utils.js");
class NotebookCellOutputModel {
    get outputId() {
        return this.rawOutput.outputId;
    }
    get outputs() {
        return this.rawOutput.outputs || [];
    }
    get metadata() {
        return this.rawOutput.metadata;
    }
    constructor(rawOutput) {
        this.rawOutput = rawOutput;
        this.didChangeDataEmitter = new core_1.Emitter();
        this.onDidChangeData = this.didChangeDataEmitter.event;
    }
    replaceData(rawData) {
        this.rawOutput = rawData;
        this.optimizeOutputItems();
        this.didChangeDataEmitter.fire();
    }
    appendData(items) {
        this.rawOutput.outputs.push(...items);
        this.optimizeOutputItems();
        this.didChangeDataEmitter.fire();
    }
    dispose() {
        this.didChangeDataEmitter.dispose();
    }
    getData() {
        return {
            outputs: this.outputs,
            metadata: this.metadata,
            outputId: this.outputId
        };
    }
    optimizeOutputItems() {
        if (this.outputs.length > 1 && this.outputs.every(item => (0, common_1.isTextStreamMime)(item.mime))) {
            // Look for the mimes in the items, and keep track of their order.
            // Merge the streams into one output item, per mime type.
            const mimeOutputs = new Map();
            const mimeTypes = [];
            this.outputs.forEach(item => {
                let items;
                if (mimeOutputs.has(item.mime)) {
                    items = mimeOutputs.get(item.mime);
                }
                else {
                    items = [];
                    mimeOutputs.set(item.mime, items);
                    mimeTypes.push(item.mime);
                }
                items.push(item.data.buffer);
            });
            this.outputs.length = 0;
            mimeTypes.forEach(mime => {
                const compressionResult = (0, notebook_output_utils_1.compressOutputItemStreams)(mimeOutputs.get(mime));
                this.outputs.push({
                    mime,
                    data: compressionResult.data
                });
            });
        }
    }
}
exports.NotebookCellOutputModel = NotebookCellOutputModel;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-model.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view-model/notebook-model.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Typefox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookModel = exports.NotebookModelResolverServiceProxy = exports.createNotebookModelContainer = exports.NotebookModelFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const notebook_cell_model_1 = __webpack_require__(/*! ./notebook-cell-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const undo_redo_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/undo-redo-service */ "../node_modules/@theia/editor/lib/browser/undo-redo-service.js");
exports.NotebookModelFactory = Symbol('NotebookModelFactory');
function createNotebookModelContainer(parent, props) {
    const child = parent.createChild();
    child.bind(NotebookModelProps).toConstantValue(props);
    child.bind(NotebookModel).toSelf();
    return child;
}
exports.createNotebookModelContainer = createNotebookModelContainer;
exports.NotebookModelResolverServiceProxy = Symbol('NotebookModelResolverServiceProxy');
const NotebookModelProps = Symbol('NotebookModelProps');
let NotebookModel = class NotebookModel {
    constructor() {
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onDirtyChanged = this.onDirtyChangedEmitter.event;
        this.onDidSaveNotebookEmitter = new core_1.Emitter();
        this.onDidSaveNotebook = this.onDidSaveNotebookEmitter.event;
        this.onDidAddOrRemoveCellEmitter = new core_1.Emitter();
        this.onDidAddOrRemoveCell = this.onDidAddOrRemoveCellEmitter.event;
        this.onDidChangeContentEmitter = new core_1.QueueableEmitter();
        this.onDidChangeContent = this.onDidChangeContentEmitter.event;
        this.onContentChangedEmitter = new core_1.Emitter();
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.onDidChangeSelectedCellEmitter = new core_1.Emitter();
        this.onDidChangeSelectedCell = this.onDidChangeSelectedCellEmitter.event;
        this.onDidDisposeEmitter = new core_1.Emitter();
        this.onDidDispose = this.onDidDisposeEmitter.event;
        this.nextHandle = 0;
        this._dirty = false;
        this._selectedText = '';
        this.dirtyCells = [];
        this.metadata = {};
    }
    get onDidChangeReadOnly() {
        var _a;
        return (_a = this.props.resource.onDidChangeReadOnly) !== null && _a !== void 0 ? _a : core_1.Event.None;
    }
    set dirty(dirty) {
        const oldState = this._dirty;
        this._dirty = dirty;
        if (oldState !== dirty) {
            this.onDirtyChangedEmitter.fire();
        }
    }
    get dirty() {
        return this._dirty;
    }
    get readOnly() {
        var _a;
        return (_a = this.props.resource.readOnly) !== null && _a !== void 0 ? _a : false;
    }
    set selectedText(value) {
        this._selectedText = value;
    }
    get selectedText() {
        return this._selectedText;
    }
    get uri() {
        return this.props.resource.uri;
    }
    get viewType() {
        return this.props.viewType;
    }
    initialize() {
        this.dirty = false;
        this.cells = this.props.data.cells.map((cell, index) => this.cellModelFactory({
            uri: common_1.CellUri.generate(this.props.resource.uri, index),
            handle: index,
            source: cell.source,
            language: cell.language,
            cellKind: cell.cellKind,
            outputs: cell.outputs,
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata,
            collapseState: cell.collapseState
        }));
        this.addCellOutputListeners(this.cells);
        this.metadata = this.props.data.metadata;
        this.nextHandle = this.cells.length;
    }
    dispose() {
        this.onDirtyChangedEmitter.dispose();
        this.onDidSaveNotebookEmitter.dispose();
        this.onDidAddOrRemoveCellEmitter.dispose();
        this.onDidChangeContentEmitter.dispose();
        this.onDidChangeSelectedCellEmitter.dispose();
        this.cells.forEach(cell => cell.dispose());
        this.onDidDisposeEmitter.fire();
    }
    async save(options) {
        this.dirtyCells = [];
        this.dirty = false;
        const serializedNotebook = await this.serialize();
        this.fileService.writeFile(this.uri, serializedNotebook);
        this.onDidSaveNotebookEmitter.fire();
    }
    createSnapshot() {
        return {
            read: () => JSON.stringify(this.getData())
        };
    }
    serialize() {
        return this.props.serializer.fromNotebook(this.getData());
    }
    async applySnapshot(snapshot) {
        const rawData = browser_1.Saveable.Snapshot.read(snapshot);
        if (!rawData) {
            throw new Error('could not read notebook snapshot');
        }
        const data = JSON.parse(rawData);
        this.setData(data);
    }
    async revert(options) {
        if (!(options === null || options === void 0 ? void 0 : options.soft)) {
            // Load the data from the file again
            try {
                const data = await this.modelResolverService.resolveExistingNotebookData(this.props.resource, this.props.viewType);
                this.setData(data, false);
            }
            catch (err) {
                console.error('Failed to revert notebook', err);
            }
        }
        this.dirty = false;
    }
    isDirty() {
        return this.dirty;
    }
    cellDirtyChanged(cell, dirtyState) {
        if (dirtyState) {
            this.dirtyCells.push(cell);
        }
        else {
            this.dirtyCells.splice(this.dirtyCells.indexOf(cell), 1);
        }
        this.dirty = this.dirtyCells.length > 0;
        // Only fire `onContentChangedEmitter` here, because `onDidChangeContentEmitter` is used for model level changes only
        // However, this event indicates that the content of a cell has changed
        this.onContentChangedEmitter.fire();
    }
    setData(data, markDirty = true) {
        // Replace all cells in the model
        this.dirtyCells = [];
        this.replaceCells(0, this.cells.length, data.cells, false, false);
        this.metadata = data.metadata;
        this.dirty = markDirty;
        this.onDidChangeContentEmitter.fire();
    }
    getData() {
        return {
            cells: this.cells.map(cell => cell.getData()),
            metadata: this.metadata
        };
    }
    undo() {
        if (!this.readOnly) {
            this.undoRedoService.undo(this.uri);
        }
    }
    redo() {
        if (!this.readOnly) {
            this.undoRedoService.redo(this.uri);
        }
    }
    setSelectedCell(cell, scrollIntoView) {
        if (this.selectedCell !== cell) {
            this.selectedCell = cell;
            this.onDidChangeSelectedCellEmitter.fire({ cell, scrollIntoView: scrollIntoView !== null && scrollIntoView !== void 0 ? scrollIntoView : true });
        }
    }
    addCellOutputListeners(cells) {
        for (const cell of cells) {
            cell.onDidChangeOutputs(() => {
                this.dirty = true;
            });
            cell.onDidRequestCellEditChange(() => {
                this.onContentChangedEmitter.fire();
            });
        }
    }
    getVisibleCells() {
        return this.cells;
    }
    applyEdits(rawEdits, computeUndoRedo) {
        var _a, _b, _c;
        const editsWithDetails = rawEdits.map((edit, index) => {
            let cellIndex = -1;
            if ('index' in edit) {
                cellIndex = edit.index;
            }
            else if ('handle' in edit) {
                cellIndex = this.getCellIndexByHandle(edit.handle);
            }
            else if ('outputId' in edit) {
                cellIndex = this.cells.findIndex(cell => cell.outputs.some(output => output.outputId === edit.outputId));
            }
            return {
                edit,
                cellIndex,
                end: edit.editType === 1 /* CellEditType.Replace */ ? edit.index + edit.count : cellIndex,
                originalIndex: index
            };
        });
        for (const { edit, cellIndex } of editsWithDetails) {
            const cell = this.cells[cellIndex];
            if (cell) {
                this.cellDirtyChanged(cell, true);
            }
            let scrollIntoView = true;
            switch (edit.editType) {
                case 1 /* CellEditType.Replace */:
                    this.replaceCells(edit.index, edit.count, edit.cells, computeUndoRedo, true);
                    scrollIntoView = edit.cells.length > 0;
                    break;
                case 2 /* CellEditType.Output */: {
                    if (edit.append) {
                        cell.spliceNotebookCellOutputs({ deleteCount: 0, newOutputs: edit.outputs, start: cell.outputs.length });
                    }
                    else {
                        // could definitely be more efficient. See vscode __spliceNotebookCellOutputs2
                        // For now, just replace the whole existing output with the new output
                        cell.spliceNotebookCellOutputs({ start: 0, deleteCount: (_a = edit.deleteCount) !== null && _a !== void 0 ? _a : cell.outputs.length, newOutputs: edit.outputs });
                    }
                    this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.Output, index: cellIndex, outputs: cell.outputs, append: (_b = edit.append) !== null && _b !== void 0 ? _b : false });
                    break;
                }
                case 7 /* CellEditType.OutputItems */:
                    cell.changeOutputItems(edit.outputId, !!edit.append, edit.items);
                    this.onDidChangeContentEmitter.queue({
                        kind: common_1.NotebookCellsChangeType.OutputItem, index: cellIndex, outputItems: edit.items,
                        outputId: edit.outputId, append: (_c = edit.append) !== null && _c !== void 0 ? _c : false
                    });
                    break;
                case 3 /* CellEditType.Metadata */:
                    this.changeCellMetadata(this.cells[cellIndex], edit.metadata, false);
                    break;
                case 8 /* CellEditType.PartialMetadata */:
                    this.changeCellMetadataPartial(this.cells[cellIndex], edit.metadata, false);
                    break;
                case 9 /* CellEditType.PartialInternalMetadata */:
                    this.changeCellInternalMetadataPartial(this.cells[cellIndex], edit.internalMetadata);
                    break;
                case 4 /* CellEditType.CellLanguage */:
                    this.changeCellLanguage(this.cells[cellIndex], edit.language, computeUndoRedo);
                    break;
                case 5 /* CellEditType.DocumentMetadata */:
                    this.updateNotebookMetadata(edit.metadata, false);
                    break;
                case 6 /* CellEditType.Move */:
                    this.moveCellToIndex(cellIndex, edit.length, edit.newIdx, computeUndoRedo);
                    break;
            }
            // if selected cell is affected update it because it can potentially have been replaced
            if (cell === this.selectedCell) {
                this.setSelectedCell(this.cells[Math.min(cellIndex, this.cells.length - 1)], scrollIntoView);
            }
        }
        this.fireContentChange();
    }
    fireContentChange() {
        this.onDidChangeContentEmitter.fire();
        this.onContentChangedEmitter.fire();
    }
    replaceCells(start, deleteCount, newCells, computeUndoRedo, requestEdit) {
        var _a, _b;
        const cells = newCells.map(cell => {
            const handle = this.nextHandle++;
            return this.cellModelFactory({
                uri: common_1.CellUri.generate(this.uri, handle),
                handle: handle,
                source: cell.source,
                language: cell.language,
                cellKind: cell.cellKind,
                outputs: cell.outputs,
                metadata: cell.metadata,
                internalMetadata: cell.internalMetadata,
                collapseState: cell.collapseState
            });
        });
        this.addCellOutputListeners(cells);
        const changes = [{
                start,
                deleteCount,
                newItems: cells,
                startHandle: (_b = (_a = this.cells[start]) === null || _a === void 0 ? void 0 : _a.handle) !== null && _b !== void 0 ? _b : -1 // -1 in case of new Cells are added at the end.
            }];
        const deletedCells = this.cells.splice(start, deleteCount, ...cells);
        for (const cell of deletedCells) {
            cell.dispose();
        }
        if (computeUndoRedo) {
            this.undoRedoService.pushElement(this.uri, async () => {
                this.replaceCells(start, newCells.length, deletedCells.map(cell => cell.getData()), false, false);
                this.fireContentChange();
            }, async () => {
                this.replaceCells(start, deleteCount, newCells, false, false);
                this.fireContentChange();
            });
        }
        this.onDidAddOrRemoveCellEmitter.fire({ rawEvent: { kind: common_1.NotebookCellsChangeType.ModelChange, changes }, newCellIds: cells.map(cell => cell.handle) });
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.ModelChange, changes });
        if (cells.length > 0 && requestEdit) {
            this.setSelectedCell(cells[cells.length - 1]);
            cells[cells.length - 1].requestEdit();
        }
    }
    changeCellInternalMetadataPartial(cell, internalMetadata) {
        var _a;
        const newInternalMetadata = {
            ...cell.internalMetadata
        };
        let k;
        // eslint-disable-next-line guard-for-in
        for (k in internalMetadata) {
            newInternalMetadata[k] = ((_a = internalMetadata[k]) !== null && _a !== void 0 ? _a : undefined);
        }
        cell.internalMetadata = newInternalMetadata;
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.ChangeCellInternalMetadata, index: this.cells.indexOf(cell), internalMetadata: newInternalMetadata });
    }
    updateNotebookMetadata(metadata, computeUndoRedo) {
        const oldMetadata = this.metadata;
        if (computeUndoRedo) {
            this.undoRedoService.pushElement(this.uri, async () => this.updateNotebookMetadata(oldMetadata, false), async () => this.updateNotebookMetadata(metadata, false));
        }
        this.metadata = metadata;
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.ChangeDocumentMetadata, metadata: this.metadata });
    }
    changeCellMetadataPartial(cell, metadata, computeUndoRedo) {
        var _a;
        const newMetadata = {
            ...cell.metadata
        };
        let k;
        // eslint-disable-next-line guard-for-in
        for (k in metadata) {
            const value = (_a = metadata[k]) !== null && _a !== void 0 ? _a : undefined;
            newMetadata[k] = value;
        }
        this.changeCellMetadata(cell, newMetadata, computeUndoRedo);
    }
    changeCellMetadata(cell, metadata, computeUndoRedo) {
        const triggerDirtyChange = this.isCellMetadataChanged(cell.metadata, metadata);
        if (triggerDirtyChange) {
            if (computeUndoRedo) {
                const oldMetadata = cell.metadata;
                cell.metadata = metadata;
                this.undoRedoService.pushElement(this.uri, async () => { cell.metadata = oldMetadata; }, async () => { cell.metadata = metadata; });
            }
        }
        cell.metadata = metadata;
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.ChangeCellMetadata, index: this.cells.indexOf(cell), metadata: cell.metadata });
    }
    changeCellLanguage(cell, languageId, computeUndoRedo) {
        if (cell.language === languageId) {
            return;
        }
        cell.language = languageId;
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.ChangeCellLanguage, index: this.cells.indexOf(cell), language: languageId });
    }
    moveCellToIndex(fromIndex, length, toIndex, computeUndoRedo) {
        if (computeUndoRedo) {
            this.undoRedoService.pushElement(this.uri, async () => {
                this.moveCellToIndex(toIndex, length, fromIndex, false);
                this.fireContentChange();
            }, async () => {
                this.moveCellToIndex(fromIndex, length, toIndex, false);
                this.fireContentChange();
            });
        }
        const cells = this.cells.splice(fromIndex, length);
        this.cells.splice(toIndex, 0, ...cells);
        this.onDidChangeContentEmitter.queue({ kind: common_1.NotebookCellsChangeType.Move, index: fromIndex, length, newIdx: toIndex, cells });
        return true;
    }
    getCellIndexByHandle(handle) {
        return this.cells.findIndex(c => c.handle === handle);
    }
    getCellByHandle(handle) {
        return this.cells.find(c => c.handle === handle);
    }
    isCellMetadataChanged(a, b) {
        const keys = new Set([...Object.keys(a || {}), ...Object.keys(b || {})]);
        for (const key of keys) {
            if (a[key] !== b[key]) {
                return true;
            }
        }
        return false;
    }
    findMatches(options) {
        const matches = [];
        for (const cell of this.cells) {
            matches.push(...cell.findMatches(options));
        }
        return matches;
    }
    replaceAll(matches, text) {
        var _a;
        const matchMap = new Map();
        for (const match of matches) {
            if (match instanceof notebook_cell_model_1.NotebookCodeEditorFindMatch) {
                if (!matchMap.has(match.cell)) {
                    matchMap.set(match.cell, []);
                }
                (_a = matchMap.get(match.cell)) === null || _a === void 0 ? void 0 : _a.push(match);
            }
        }
        for (const [cell, cellMatches] of matchMap) {
            cell.replaceAll(cellMatches, text);
        }
    }
};
exports.NotebookModel = NotebookModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], NotebookModel.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(undo_redo_service_1.UndoRedoService),
    tslib_1.__metadata("design:type", undo_redo_service_1.UndoRedoService)
], NotebookModel.prototype, "undoRedoService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(NotebookModelProps),
    tslib_1.__metadata("design:type", Object)
], NotebookModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_model_1.NotebookCellModelFactory),
    tslib_1.__metadata("design:type", Function)
], NotebookModel.prototype, "cellModelFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.NotebookModelResolverServiceProxy),
    tslib_1.__metadata("design:type", Function)
], NotebookModel.prototype, "modelResolverService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], NotebookModel.prototype, "initialize", null);
exports.NotebookModel = NotebookModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookModel);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-editor.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-cell-editor.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellEditor = exports.FIND_MATCH_DECORATION = exports.CURRENT_FIND_MATCH_DECORATION = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const simple_monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/simple-monaco-editor */ "../node_modules/@theia/monaco/lib/browser/simple-monaco-editor.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const contextkey_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/contextkey/common/contextkey */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/contextkey/common/contextkey.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_context_keys_1 = __webpack_require__(/*! ../contributions/notebook-context-keys */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
const editorExtensions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/editorExtensions */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/editorExtensions.js");
const textModel_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/model/textModel */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/model/textModel.js");
const model_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/model */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/model.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const DEFAULT_EDITOR_OPTIONS = {
    ...monaco_editor_provider_1.MonacoEditorProvider.inlineOptions,
    minHeight: -1,
    maxHeight: -1,
    scrollbar: {
        ...monaco_editor_provider_1.MonacoEditorProvider.inlineOptions.scrollbar,
        alwaysConsumeMouseWheel: false
    },
    lineDecorationsWidth: 10,
};
exports.CURRENT_FIND_MATCH_DECORATION = textModel_1.ModelDecorationOptions.register({
    description: 'current-find-match',
    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
    zIndex: 13,
    className: 'currentFindMatch',
    inlineClassName: 'currentFindMatchInline',
    showIfCollapsed: true,
    overviewRuler: {
        color: 'editorOverviewRuler.findMatchForeground',
        position: model_1.OverviewRulerLane.Center
    }
});
exports.FIND_MATCH_DECORATION = textModel_1.ModelDecorationOptions.register({
    description: 'find-match',
    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,
    zIndex: 10,
    className: 'findMatch',
    inlineClassName: 'findMatchInline',
    showIfCollapsed: true,
    overviewRuler: {
        color: 'editorOverviewRuler.findMatchForeground',
        position: model_1.OverviewRulerLane.Center
    }
});
class CellEditor extends React.Component {
    constructor() {
        super(...arguments);
        this.toDispose = new core_1.DisposableCollection();
        this.matches = [];
        this.oldMatchDecorations = [];
        this.handleResize = () => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.refresh();
        };
    }
    componentDidMount() {
        var _a;
        this.disposeEditor();
        this.toDispose.push(this.props.cell.onWillFocusCellEditor(focusRequest => {
            var _a, _b, _c, _d, _e, _f;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().focus();
            const lineCount = (_c = (_b = this.editor) === null || _b === void 0 ? void 0 : _b.getControl().getModel()) === null || _c === void 0 ? void 0 : _c.getLineCount();
            if (focusRequest && lineCount !== undefined) {
                (_d = this.editor) === null || _d === void 0 ? void 0 : _d.getControl().setPosition(focusRequest === 'lastLine' ?
                    { lineNumber: lineCount, column: 1 } :
                    { lineNumber: focusRequest, column: 1 }, 'keyboard');
            }
            const currentLine = (_f = (_e = this.editor) === null || _e === void 0 ? void 0 : _e.getControl().getPosition()) === null || _f === void 0 ? void 0 : _f.lineNumber;
            this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, currentLine === 1);
            this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, currentLine === lineCount);
        }));
        this.toDispose.push(this.props.cell.onWillBlurCellEditor(() => this.blurEditor()));
        this.toDispose.push(this.props.cell.onDidChangeEditorOptions(options => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().updateOptions(options);
        }));
        this.toDispose.push(this.props.cell.onDidChangeLanguage(language => {
            var _a;
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.setLanguage(language);
        }));
        this.toDispose.push(this.props.cell.onDidFindMatches(matches => {
            this.matches = matches;
            (0, browser_1.animationFrame)().then(() => this.setMatches());
        }));
        this.toDispose.push(this.props.cell.onDidSelectFindMatch(match => this.centerEditorInView()));
        this.toDispose.push(this.props.notebookModel.onDidChangeSelectedCell(e => {
            var _a;
            if (e.cell !== this.props.cell && ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().hasTextFocus())) {
                this.blurEditor();
            }
        }));
        if (!this.props.notebookViewportService || (this.container && this.props.notebookViewportService.isElementInViewport(this.container))) {
            this.initEditor();
        }
        else {
            const disposable = (_a = this.props.notebookViewportService) === null || _a === void 0 ? void 0 : _a.onDidChangeViewport(() => {
                if (!this.editor && this.container && this.props.notebookViewportService.isElementInViewport(this.container)) {
                    this.initEditor();
                    disposable.dispose();
                }
            });
            this.toDispose.push(disposable);
        }
        this.toDispose.push(this.props.cell.onDidRequestCenterEditor(() => {
            this.centerEditorInView();
        }));
    }
    componentWillUnmount() {
        this.disposeEditor();
    }
    disposeEditor() {
        if (this.editor) {
            this.props.notebookCellEditorService.editorDisposed(this.editor.uri);
        }
        this.toDispose.dispose();
        this.toDispose = new core_1.DisposableCollection();
    }
    centerEditorInView() {
        var _a, _b;
        const editorDomNode = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().getDomNode();
        if (editorDomNode) {
            editorDomNode.scrollIntoView({
                behavior: 'instant',
                block: 'center'
            });
        }
        else {
            (_b = this.container) === null || _b === void 0 ? void 0 : _b.scrollIntoView({
                behavior: 'instant',
                block: 'center'
            });
        }
    }
    async initEditor() {
        const { cell, notebookModel, monacoServices } = this.props;
        if (this.container) {
            const editorNode = this.container;
            editorNode.style.height = '';
            const editorModel = await cell.resolveTextModel();
            const uri = cell.uri;
            this.editor = new simple_monaco_editor_1.SimpleMonacoEditor(uri, editorModel, editorNode, monacoServices, { ...DEFAULT_EDITOR_OPTIONS, ...cell.editorOptions }, [[contextkey_1.IContextKeyService, this.props.notebookContextManager.scopedStore]], { contributions: editorExtensions_1.EditorExtensionsRegistry.getEditorContributions().filter(c => c.id !== 'editor.contrib.findController') });
            this.toDispose.push(this.editor);
            this.editor.setLanguage(cell.language);
            this.toDispose.push(this.editor.getControl().onDidContentSizeChange(() => {
                editorNode.style.height = this.editor.getControl().getContentHeight() + 7 + 'px';
                this.editor.setSize({ width: -1, height: this.editor.getControl().getContentHeight() });
            }));
            this.toDispose.push(this.editor.onDocumentContentChanged(e => {
                notebookModel.cellDirtyChanged(cell, true);
            }));
            this.toDispose.push(this.editor.getControl().onDidFocusEditorText(() => {
                this.props.notebookModel.setSelectedCell(cell, false);
                this.props.notebookCellEditorService.editorFocusChanged(this.editor);
            }));
            this.toDispose.push(this.editor.getControl().onDidBlurEditorText(() => {
                var _a;
                if (((_a = this.props.notebookCellEditorService.getActiveCell()) === null || _a === void 0 ? void 0 : _a.uri.toString()) === this.props.cell.uri.toString()) {
                    this.props.notebookCellEditorService.editorFocusChanged(undefined);
                }
            }));
            this.toDispose.push(this.editor.getControl().onDidChangeCursorSelection(e => {
                const selectedText = this.editor.getControl().getModel().getValueInRange(e.selection);
                // TODO handle secondary selections
                this.props.cell.selection = {
                    start: { line: e.selection.startLineNumber - 1, character: e.selection.startColumn - 1 },
                    end: { line: e.selection.endLineNumber - 1, character: e.selection.endColumn - 1 }
                };
                this.props.notebookModel.selectedText = selectedText;
            }));
            this.toDispose.push(this.editor.getControl().onDidChangeCursorPosition(e => {
                if (e.secondaryPositions.length === 0) {
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, e.position.lineNumber === 1);
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, e.position.lineNumber === this.editor.getControl().getModel().getLineCount());
                }
                else {
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_FIRST_LINE, false);
                    this.props.notebookContextManager.scopedStore.setContext(notebook_context_keys_1.NOTEBOOK_CELL_CURSOR_LAST_LINE, false);
                }
            }));
            this.props.notebookCellEditorService.editorCreated(uri, this.editor);
            this.setMatches();
            if (notebookModel.selectedCell === cell) {
                this.editor.getControl().focus();
            }
        }
    }
    setMatches() {
        if (!this.editor) {
            return;
        }
        const decorations = [];
        for (const match of this.matches) {
            const decoration = match.selected ? exports.CURRENT_FIND_MATCH_DECORATION : exports.FIND_MATCH_DECORATION;
            decorations.push({
                range: {
                    startLineNumber: match.range.start.line,
                    startColumn: match.range.start.character,
                    endLineNumber: match.range.end.line,
                    endColumn: match.range.end.character
                },
                options: decoration
            });
        }
        this.oldMatchDecorations = this.editor.getControl()
            .changeDecorations(accessor => accessor.deltaDecorations(this.oldMatchDecorations, decorations));
    }
    setContainer(component) {
        this.container = component !== null && component !== void 0 ? component : undefined;
    }
    ;
    estimateHeight() {
        var _a, _b;
        const lineHeight = (_b = (_a = this.props.fontInfo) === null || _a === void 0 ? void 0 : _a.lineHeight) !== null && _b !== void 0 ? _b : 20;
        return this.props.cell.text.split(core_1.OS.backend.EOL).length * lineHeight + 10 + 7 + 'px';
    }
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-editor', onResize: this.handleResize, id: this.props.cell.uri.toString(), ref: container => this.setContainer(container), style: { height: this.editor ? undefined : this.estimateHeight() } });
    }
    blurEditor() {
        var _a;
        let parent = (_a = this.container) === null || _a === void 0 ? void 0 : _a.parentElement;
        while (parent && !parent.classList.contains('theia-notebook-cell')) {
            parent = parent.parentElement;
        }
        if (parent) {
            parent.focus();
        }
    }
}
exports.CellEditor = CellEditor;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-list-view.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-cell-list-view.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellDivider = exports.NotebookCellListView = exports.observeCellHeight = void 0;
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_actions_contribution_1 = __webpack_require__(/*! ../contributions/notebook-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js");
const notebook_cell_actions_contribution_1 = __webpack_require__(/*! ../contributions/notebook-cell-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-cell-actions-contribution.js");
function observeCellHeight(ref, cell) {
    var _a;
    if (ref) {
        cell.cellHeight = (_a = ref === null || ref === void 0 ? void 0 : ref.getBoundingClientRect().height) !== null && _a !== void 0 ? _a : 0;
        new ResizeObserver(entries => { var _a; return cell.cellHeight = (_a = ref === null || ref === void 0 ? void 0 : ref.getBoundingClientRect().height) !== null && _a !== void 0 ? _a : 0; }).observe(ref);
    }
}
exports.observeCellHeight = observeCellHeight;
class NotebookCellListView extends React.Component {
    constructor(props) {
        super(props);
        this.toDispose = new core_1.DisposableCollection();
        this.cellListRef = React.createRef();
        this.state = { selectedCell: props.notebookModel.selectedCell, dragOverIndicator: undefined, scrollIntoView: true };
        this.toDispose.push(props.notebookModel.onDidAddOrRemoveCell(e => {
            if (e.newCellIds && e.newCellIds.length > 0) {
                this.setState({
                    ...this.state,
                    selectedCell: this.props.notebookModel.cells.find(model => model.handle === e.newCellIds[e.newCellIds.length - 1]),
                    scrollIntoView: true
                });
            }
            else {
                this.setState({
                    ...this.state,
                    selectedCell: this.props.notebookModel.cells.find(cell => cell === this.state.selectedCell),
                    scrollIntoView: false
                });
            }
        }));
        this.toDispose.push(props.notebookModel.onDidChangeContent(events => {
            if (events.some(e => e.kind === common_1.NotebookCellsChangeType.Move)) {
                // When a cell has been moved, we need to rerender the whole component
                this.forceUpdate();
            }
        }));
        this.toDispose.push(props.notebookModel.onDidChangeSelectedCell(e => {
            this.setState({
                ...this.state,
                selectedCell: e.cell,
                scrollIntoView: e.scrollIntoView
            });
        }));
        this.toDispose.push((0, browser_1.onDomEvent)(document, 'focusin', () => {
            (0, browser_1.animationFrame)().then(() => {
                if (!this.cellListRef.current) {
                    return;
                }
                let hasCellFocus = false;
                let hasFocus = false;
                if (this.cellListRef.current.contains(document.activeElement)) {
                    if (this.props.notebookModel.selectedCell) {
                        hasCellFocus = true;
                    }
                    hasFocus = true;
                }
                this.props.notebookContext.changeCellFocus(hasCellFocus);
                this.props.notebookContext.changeCellListFocus(hasFocus);
            });
        }));
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    render() {
        return React.createElement("ul", { className: 'theia-notebook-cell-list', ref: this.cellListRef, onDragStart: e => this.onDragStart(e) },
            this.props.notebookModel.getVisibleCells()
                .map((cell, index) => React.createElement(React.Fragment, { key: 'cell-' + cell.handle },
                React.createElement(NotebookCellDivider, { menuRegistry: this.props.menuRegistry, isVisible: () => this.isEnabled(), onAddNewCell: (commandId) => this.onAddNewCell(commandId, index), onDrop: e => this.onDrop(e, index), onDragOver: e => this.onDragOver(e, cell, 'top') }),
                React.createElement(CellDropIndicator, { visible: this.shouldRenderDragOverIndicator(cell, 'top') }),
                React.createElement("li", { className: 'theia-notebook-cell' + (this.state.selectedCell === cell ? ' focused' : '') + (this.isEnabled() ? ' draggable' : ''), onDragEnd: e => {
                        var _a;
                        (_a = NotebookCellListView.dragGhost) === null || _a === void 0 ? void 0 : _a.remove();
                        this.setState({ ...this.state, dragOverIndicator: undefined });
                    }, onDragOver: e => this.onDragOver(e, cell), onDrop: e => this.onDrop(e, index), draggable: true, tabIndex: -1, "data-cell-handle": cell.handle, ref: ref => {
                        if (ref && cell === this.state.selectedCell && this.state.scrollIntoView) {
                            ref.scrollIntoView({ block: 'nearest' });
                            if (cell.cellKind === common_1.CellKind.Markup && !cell.editing) {
                                ref.focus();
                            }
                        }
                    }, onClick: e => {
                        this.setState({ ...this.state, selectedCell: cell });
                        this.props.notebookModel.setSelectedCell(cell, false);
                    } },
                    React.createElement("div", { className: 'theia-notebook-cell-sidebar' },
                        React.createElement("div", { className: 'theia-notebook-cell-marker' + (this.state.selectedCell === cell ? ' theia-notebook-cell-marker-selected' : '') }),
                        this.renderCellSidebar(cell)),
                    React.createElement("div", { className: 'theia-notebook-cell-content' }, this.renderCellContent(cell, index)),
                    this.state.selectedCell === cell &&
                        this.props.toolbarRenderer.renderCellToolbar(notebook_cell_actions_contribution_1.NotebookCellActionContribution.ACTION_MENU, cell, {
                            contextMenuArgs: () => [cell], commandArgs: () => [this.props.notebookModel]
                        })),
                React.createElement(CellDropIndicator, { visible: this.shouldRenderDragOverIndicator(cell, 'bottom') }))),
            React.createElement(NotebookCellDivider, { menuRegistry: this.props.menuRegistry, isVisible: () => this.isEnabled(), onAddNewCell: (commandId) => this.onAddNewCell(commandId, this.props.notebookModel.cells.length), onDrop: e => this.onDrop(e, this.props.notebookModel.cells.length - 1), onDragOver: e => this.onDragOver(e, this.props.notebookModel.cells[this.props.notebookModel.cells.length - 1], 'bottom') }));
    }
    renderCellContent(cell, index) {
        const renderer = this.props.renderers.get(cell.cellKind);
        if (!renderer) {
            throw new Error(`No renderer found for cell type ${cell.cellKind}`);
        }
        return renderer.render(this.props.notebookModel, cell, index);
    }
    renderCellSidebar(cell) {
        const renderer = this.props.renderers.get(cell.cellKind);
        if (!renderer) {
            throw new Error(`No renderer found for cell type ${cell.cellKind}`);
        }
        return renderer.renderSidebar(this.props.notebookModel, cell);
    }
    onDragStart(event) {
        var _a, _b;
        event.stopPropagation();
        if (!this.isEnabled()) {
            event.preventDefault();
            return;
        }
        const cellHandle = event.target.getAttribute('data-cell-handle');
        if (!cellHandle) {
            throw new Error('Cell handle not found in element for cell drag event');
        }
        const index = this.props.notebookModel.getCellIndexByHandle(parseInt(cellHandle));
        const cell = this.props.notebookModel.cells[index];
        NotebookCellListView.dragGhost = document.createElement('div');
        NotebookCellListView.dragGhost.classList.add('theia-notebook-drag-ghost-image');
        NotebookCellListView.dragGhost.appendChild((_b = (_a = this.props.renderers.get(cell.cellKind)) === null || _a === void 0 ? void 0 : _a.renderDragImage(cell)) !== null && _b !== void 0 ? _b : document.createElement('div'));
        document.body.appendChild(NotebookCellListView.dragGhost);
        event.dataTransfer.setDragImage(NotebookCellListView.dragGhost, -10, 0);
        event.dataTransfer.setData('text/theia-notebook-cell-index', index.toString());
        event.dataTransfer.setData('text/plain', this.props.notebookModel.cells[index].source);
    }
    onDragOver(event, cell, position) {
        if (!this.isEnabled()) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        // show indicator
        this.setState({ ...this.state, dragOverIndicator: { cell, position: (position !== null && position !== void 0 ? position : event.nativeEvent.offsetY < event.currentTarget.clientHeight / 2) ? 'top' : 'bottom' } });
    }
    isEnabled() {
        return !Boolean(this.props.notebookModel.readOnly);
    }
    onDrop(event, dropElementIndex) {
        var _a;
        if (!this.isEnabled()) {
            this.setState({ dragOverIndicator: undefined });
            return;
        }
        const index = parseInt(event.dataTransfer.getData('text/theia-notebook-cell-index'));
        const isTargetBelow = index < dropElementIndex;
        let newIdx = ((_a = this.state.dragOverIndicator) === null || _a === void 0 ? void 0 : _a.position) === 'top' ? dropElementIndex : dropElementIndex + 1;
        newIdx = isTargetBelow ? newIdx - 1 : newIdx;
        if (index !== undefined && index !== dropElementIndex) {
            this.props.notebookModel.applyEdits([{
                    editType: 6 /* CellEditType.Move */,
                    length: 1,
                    index,
                    newIdx
                }], true);
        }
        this.setState({ ...this.state, dragOverIndicator: undefined });
    }
    onAddNewCell(commandId, index) {
        if (this.isEnabled()) {
            this.props.commandRegistry.executeCommand(notebook_actions_contribution_1.NotebookCommands.CHANGE_SELECTED_CELL.id, index - 1);
            this.props.commandRegistry.executeCommand(commandId, this.props.notebookModel, index);
        }
    }
    shouldRenderDragOverIndicator(cell, position) {
        return this.isEnabled() &&
            this.state.dragOverIndicator !== undefined &&
            this.state.dragOverIndicator.cell === cell &&
            this.state.dragOverIndicator.position === position;
    }
}
exports.NotebookCellListView = NotebookCellListView;
function NotebookCellDivider({ isVisible, onAddNewCell, onDrop, onDragOver, menuRegistry }) {
    const [hover, setHover] = React.useState(false);
    const menuPath = notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP;
    const menuItems = menuRegistry.getMenuNode(menuPath).children;
    const renderItem = (item) => React.createElement("button", { key: item.id, className: 'theia-notebook-add-cell-button', onClick: () => onAddNewCell(item.command || ''), title: core_1.nls.localizeByDefault(`Add ${item.label} Cell`) },
        React.createElement("div", { className: item.icon + ' theia-notebook-add-cell-button-icon' }),
        React.createElement("div", { className: 'theia-notebook-add-cell-button-text' }, item.label));
    return React.createElement("li", { className: 'theia-notebook-cell-divider', onMouseEnter: () => setHover(true), onMouseLeave: () => setHover(false), onDrop: onDrop, onDragOver: onDragOver }, hover && isVisible() && React.createElement("div", { className: 'theia-notebook-add-cell-buttons' }, menuItems.map((item) => renderItem(item))));
}
exports.NotebookCellDivider = NotebookCellDivider;
function CellDropIndicator(props) {
    return React.createElement("div", { className: 'theia-notebook-cell-drop-indicator', style: { visibility: props.visible ? 'visible' : 'hidden' } });
}


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar-factory.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar-factory.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellToolbarFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const notebook_cell_toolbar_1 = __webpack_require__(/*! ./notebook-cell-toolbar */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_context_manager_1 = __webpack_require__(/*! ../service/notebook-context-manager */ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js");
let NotebookCellToolbarFactory = class NotebookCellToolbarFactory {
    renderCellToolbar(menuPath, cell, itemOptions) {
        return React.createElement(notebook_cell_toolbar_1.NotebookCellToolbar, { getMenuItems: () => this.getMenuItems(menuPath, cell, itemOptions), onContextKeysChanged: this.notebookContextManager.onDidChangeContext });
    }
    renderSidebar(menuPath, cell, itemOptions) {
        return React.createElement(notebook_cell_toolbar_1.NotebookCellSidebar, { getMenuItems: () => this.getMenuItems(menuPath, cell, itemOptions), onContextKeysChanged: this.notebookContextManager.onDidChangeContext });
    }
    getMenuItems(menuItemPath, cell, itemOptions) {
        var _a, _b;
        const inlineItems = [];
        for (const menuNode of this.menuRegistry.getMenu(menuItemPath).children) {
            if (!menuNode.when || this.notebookContextManager.getCellContext(cell.handle).match(menuNode.when, this.notebookContextManager.context)) {
                if (menuNode.role === 2 /* CompoundMenuNodeRole.Flat */) {
                    inlineItems.push(...(_b = (_a = menuNode.children) === null || _a === void 0 ? void 0 : _a.map(child => this.createToolbarItem(child, itemOptions))) !== null && _b !== void 0 ? _b : []);
                }
                else {
                    inlineItems.push(this.createToolbarItem(menuNode, itemOptions));
                }
            }
        }
        return inlineItems;
    }
    createToolbarItem(menuNode, itemOptions) {
        const menuPath = menuNode.role === 0 /* CompoundMenuNodeRole.Submenu */ ? this.menuRegistry.getPath(menuNode) : undefined;
        return {
            id: menuNode.id,
            icon: menuNode.icon,
            label: menuNode.label,
            onClick: menuPath ?
                e => {
                    var _a;
                    return this.contextMenuRenderer.render({
                        anchor: e.nativeEvent,
                        menuPath,
                        includeAnchorArg: false,
                        args: (_a = itemOptions.contextMenuArgs) === null || _a === void 0 ? void 0 : _a.call(itemOptions),
                        context: this.notebookContextManager.context || e.currentTarget
                    });
                } :
                () => { var _a, _b; return this.commandRegistry.executeCommand(menuNode.command, ...((_b = (_a = itemOptions.commandArgs) === null || _a === void 0 ? void 0 : _a.call(itemOptions)) !== null && _b !== void 0 ? _b : [])); },
            isVisible: () => { var _a, _b; return menuPath ? true : Boolean(this.commandRegistry.getVisibleHandler(menuNode.command, ...((_b = (_a = itemOptions.commandArgs) === null || _a === void 0 ? void 0 : _a.call(itemOptions)) !== null && _b !== void 0 ? _b : []))); },
            contextKeys: menuNode.when ? this.contextKeyService.parseKeys(menuNode.when) : undefined
        };
    }
};
exports.NotebookCellToolbarFactory = NotebookCellToolbarFactory;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], NotebookCellToolbarFactory.prototype, "menuRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookCellToolbarFactory.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_1.ContextMenuRenderer)
], NotebookCellToolbarFactory.prototype, "contextMenuRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], NotebookCellToolbarFactory.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_context_manager_1.NotebookContextManager),
    tslib_1.__metadata("design:type", notebook_context_manager_1.NotebookContextManager)
], NotebookCellToolbarFactory.prototype, "notebookContextManager", void 0);
exports.NotebookCellToolbarFactory = NotebookCellToolbarFactory = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCellToolbarFactory);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellSidebar = exports.NotebookCellToolbar = void 0;
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class NotebookCellActionBar extends React.Component {
    constructor(props) {
        super(props);
        this.toDispose = new core_1.DisposableCollection();
        this.toDispose.push(props.onContextKeysChanged(e => {
            const menuItems = this.props.getMenuItems();
            if (menuItems.some(item => item.contextKeys ? e.affects(item.contextKeys) : false)) {
                this.setState({ inlineItems: menuItems });
            }
        }));
        this.state = { inlineItems: this.props.getMenuItems() };
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    renderItem(item) {
        return React.createElement("div", { key: item.id, id: item.id, title: item.label, onClick: item.onClick, className: `${item.icon} ${browser_1.ACTION_ITEM} theia-notebook-cell-toolbar-item` });
    }
}
class NotebookCellToolbar extends NotebookCellActionBar {
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-toolbar' }, this.state.inlineItems.filter(e => e.isVisible()).map(item => this.renderItem(item)));
    }
}
exports.NotebookCellToolbar = NotebookCellToolbar;
class NotebookCellSidebar extends NotebookCellActionBar {
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-sidebar-toolbar' }, this.state.inlineItems.filter(e => e.isVisible()).map(item => this.renderItem(item)));
    }
}
exports.NotebookCellSidebar = NotebookCellSidebar;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-code-cell-view.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-code-cell-view.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCodeCellOutputs = exports.NotebookCodeCellStatus = exports.NotebookCodeCellSidebar = exports.NotebookCodeCellRenderer = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const notebook_renderer_registry_1 = __webpack_require__(/*! ../notebook-renderer-registry */ "../node_modules/@theia/notebook/lib/browser/notebook-renderer-registry.js");
const notebook_cell_editor_1 = __webpack_require__(/*! ./notebook-cell-editor */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-editor.js");
const notebook_cell_list_view_1 = __webpack_require__(/*! ./notebook-cell-list-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-list-view.js");
const notebook_cell_toolbar_factory_1 = __webpack_require__(/*! ./notebook-cell-toolbar-factory */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-toolbar-factory.js");
const notebook_cell_actions_contribution_1 = __webpack_require__(/*! ../contributions/notebook-cell-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-cell-actions-contribution.js");
const notebook_execution_state_service_1 = __webpack_require__(/*! ../service/notebook-execution-state-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/notebook/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_context_manager_1 = __webpack_require__(/*! ../service/notebook-context-manager */ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js");
const notebook_viewport_service_1 = __webpack_require__(/*! ./notebook-viewport-service */ "../node_modules/@theia/notebook/lib/browser/view/notebook-viewport-service.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const notebook_options_1 = __webpack_require__(/*! ../service/notebook-options */ "../node_modules/@theia/notebook/lib/browser/service/notebook-options.js");
const markdown_renderer_1 = __webpack_require__(/*! @theia/core/lib/browser/markdown-rendering/markdown-renderer */ "../node_modules/@theia/core/lib/browser/markdown-rendering/markdown-renderer.js");
const htmlContent_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/htmlContent */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/htmlContent.js");
const notebook_cell_editor_service_1 = __webpack_require__(/*! ../service/notebook-cell-editor-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js");
const cell_output_webview_1 = __webpack_require__(/*! ../renderers/cell-output-webview */ "../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js");
const notebook_cell_status_bar_service_1 = __webpack_require__(/*! ../service/notebook-cell-status-bar-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js");
const label_parser_1 = __webpack_require__(/*! @theia/core/lib/browser/label-parser */ "../node_modules/@theia/core/lib/browser/label-parser.js");
let NotebookCodeCellRenderer = class NotebookCodeCellRenderer {
    render(notebookModel, cell, handle) {
        return React.createElement("div", { className: 'theia-notebook-cell-with-sidebar', ref: ref => (0, notebook_cell_list_view_1.observeCellHeight)(ref, cell) },
            React.createElement("div", { className: 'theia-notebook-cell-editor-container' },
                React.createElement(notebook_cell_editor_1.CellEditor, { notebookModel: notebookModel, cell: cell, monacoServices: this.monacoServices, notebookContextManager: this.notebookContextManager, notebookViewportService: this.notebookViewportService, notebookCellEditorService: this.notebookCellEditorService, fontInfo: this.notebookOptionsService.editorFontInfo }),
                React.createElement(NotebookCodeCellStatus, { cell: cell, notebook: notebookModel, commandRegistry: this.commandRegistry, executionStateService: this.executionStateService, cellStatusBarService: this.notebookCellStatusBarService, labelParser: this.labelParser, onClick: () => cell.requestFocusEditor() })));
    }
    renderSidebar(notebookModel, cell) {
        return React.createElement("div", null,
            React.createElement(NotebookCodeCellSidebar, { cell: cell, notebook: notebookModel, notebookCellToolbarFactory: this.notebookCellToolbarFactory }),
            React.createElement(NotebookCodeCellOutputs, { cell: cell, notebook: notebookModel, outputWebview: this.outputWebview, renderSidebar: () => this.notebookCellToolbarFactory.renderSidebar(notebook_cell_actions_contribution_1.NotebookCellActionContribution.OUTPUT_SIDEBAR_MENU, cell, {
                    contextMenuArgs: () => [notebookModel, cell, cell.outputs[0]]
                }) }));
    }
    renderDragImage(cell) {
        var _a;
        const dragImage = document.createElement('div');
        dragImage.className = 'theia-notebook-drag-image';
        dragImage.style.width = ((_a = this.notebookContextManager.context) === null || _a === void 0 ? void 0 : _a.clientWidth) + 'px';
        dragImage.style.height = '100px';
        dragImage.style.display = 'flex';
        const fakeRunButton = document.createElement('span');
        fakeRunButton.className = `${(0, browser_1.codicon)('play')} theia-notebook-cell-status-item`;
        dragImage.appendChild(fakeRunButton);
        const fakeEditor = document.createElement('div');
        dragImage.appendChild(fakeEditor);
        const lines = cell.source.split('\n').slice(0, 5).join('\n');
        const codeSequence = this.getMarkdownCodeSequence(lines);
        const firstLine = new htmlContent_1.MarkdownString(`${codeSequence}${cell.language}\n${lines}\n${codeSequence}`, { supportHtml: true, isTrusted: false });
        fakeEditor.appendChild(this.markdownRenderer.render(firstLine).element);
        fakeEditor.classList.add('theia-notebook-cell-editor-container');
        fakeEditor.style.padding = '10px';
        return dragImage;
    }
    getMarkdownCodeSequence(input) {
        // We need a minimum of 3 backticks to start a code block.
        let longest = 2;
        let current = 0;
        for (let i = 0; i < input.length; i++) {
            const char = input.charAt(i);
            if (char === '`') {
                current++;
                if (current > longest) {
                    longest = current;
                }
            }
            else {
                current = 0;
            }
        }
        return Array(longest + 1).fill('`').join('');
    }
};
exports.NotebookCodeCellRenderer = NotebookCodeCellRenderer;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_1.MonacoEditorServices),
    tslib_1.__metadata("design:type", monaco_editor_1.MonacoEditorServices)
], NotebookCodeCellRenderer.prototype, "monacoServices", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_renderer_registry_1.NotebookRendererRegistry),
    tslib_1.__metadata("design:type", notebook_renderer_registry_1.NotebookRendererRegistry)
], NotebookCodeCellRenderer.prototype, "notebookRendererRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_toolbar_factory_1.NotebookCellToolbarFactory),
    tslib_1.__metadata("design:type", notebook_cell_toolbar_factory_1.NotebookCellToolbarFactory)
], NotebookCodeCellRenderer.prototype, "notebookCellToolbarFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_execution_state_service_1.NotebookExecutionStateService),
    tslib_1.__metadata("design:type", notebook_execution_state_service_1.NotebookExecutionStateService)
], NotebookCodeCellRenderer.prototype, "executionStateService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_context_manager_1.NotebookContextManager),
    tslib_1.__metadata("design:type", notebook_context_manager_1.NotebookContextManager)
], NotebookCodeCellRenderer.prototype, "notebookContextManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_viewport_service_1.NotebookViewportService),
    tslib_1.__metadata("design:type", notebook_viewport_service_1.NotebookViewportService)
], NotebookCodeCellRenderer.prototype, "notebookViewportService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorPreferences),
    tslib_1.__metadata("design:type", Object)
], NotebookCodeCellRenderer.prototype, "editorPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_editor_service_1.NotebookCellEditorService),
    tslib_1.__metadata("design:type", notebook_cell_editor_service_1.NotebookCellEditorService)
], NotebookCodeCellRenderer.prototype, "notebookCellEditorService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], NotebookCodeCellRenderer.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_options_1.NotebookOptionsService),
    tslib_1.__metadata("design:type", notebook_options_1.NotebookOptionsService)
], NotebookCodeCellRenderer.prototype, "notebookOptionsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(markdown_renderer_1.MarkdownRenderer),
    tslib_1.__metadata("design:type", Object)
], NotebookCodeCellRenderer.prototype, "markdownRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(cell_output_webview_1.CellOutputWebview),
    tslib_1.__metadata("design:type", Object)
], NotebookCodeCellRenderer.prototype, "outputWebview", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_status_bar_service_1.NotebookCellStatusBarService),
    tslib_1.__metadata("design:type", notebook_cell_status_bar_service_1.NotebookCellStatusBarService)
], NotebookCodeCellRenderer.prototype, "notebookCellStatusBarService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_parser_1.LabelParser),
    tslib_1.__metadata("design:type", label_parser_1.LabelParser)
], NotebookCodeCellRenderer.prototype, "labelParser", void 0);
exports.NotebookCodeCellRenderer = NotebookCodeCellRenderer = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookCodeCellRenderer);
class NotebookCodeCellSidebar extends React.Component {
    constructor(props) {
        super(props);
        this.toDispose = new core_1.DisposableCollection();
        this.toDispose.push(props.cell.onDidCellHeightChange(() => this.forceUpdate()));
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-sidebar-actions', style: { height: `${this.props.cell.cellHeight}px` } },
            this.props.notebookCellToolbarFactory.renderSidebar(notebook_cell_actions_contribution_1.NotebookCellActionContribution.CODE_CELL_SIDEBAR_MENU, this.props.cell, {
                contextMenuArgs: () => [this.props.cell], commandArgs: () => [this.props.notebook, this.props.cell]
            }),
            React.createElement(CodeCellExecutionOrder, { cell: this.props.cell }));
    }
}
exports.NotebookCodeCellSidebar = NotebookCodeCellSidebar;
class NotebookCodeCellStatus extends React.Component {
    constructor(props) {
        super(props);
        this.toDispose = new core_1.DisposableCollection();
        this.statusBarItems = [];
        this.state = {
            executionTime: 0
        };
        let currentInterval;
        if (props.executionStateService) {
            this.toDispose.push(props.executionStateService.onDidChangeExecution(event => {
                var _a;
                if (event.affectsCell(this.props.cell.uri)) {
                    this.setState({ currentExecution: event.changed, executionTime: 0 });
                    clearInterval(currentInterval);
                    if (((_a = event.changed) === null || _a === void 0 ? void 0 : _a.state) === common_1.NotebookCellExecutionState.Executing) {
                        const startTime = Date.now();
                        // The resolution of the time display is only a single digit after the decimal point.
                        // Therefore, we only need to update the display every 100ms.
                        currentInterval = setInterval(() => {
                            this.setState({
                                executionTime: Date.now() - startTime
                            });
                        }, 100);
                    }
                }
            }));
        }
        this.toDispose.push(props.cell.onDidChangeLanguage(() => {
            this.forceUpdate();
        }));
        this.updateStatusBarItems();
        this.props.cellStatusBarService.onDidChangeItems(() => this.updateStatusBarItems());
        this.props.notebook.onContentChanged(() => this.updateStatusBarItems());
    }
    async updateStatusBarItems() {
        this.statusBarItems = await this.props.cellStatusBarService.getStatusBarItemsForCell(this.props.notebook.uri, this.props.notebook.cells.indexOf(this.props.cell), this.props.notebook.viewType, core_1.CancellationToken.None);
        this.forceUpdate();
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    render() {
        var _a;
        return React.createElement("div", { className: 'notebook-cell-status', onClick: () => this.props.onClick() },
            React.createElement("div", { className: 'notebook-cell-status-left' },
                this.props.executionStateService && this.renderExecutionState(),
                ((_a = this.statusBarItems) === null || _a === void 0 ? void 0 : _a.length) && this.renderStatusBarItems()),
            React.createElement("div", { className: 'notebook-cell-status-right' },
                React.createElement("span", { className: 'notebook-cell-language-label', onClick: () => {
                        this.props.commandRegistry.executeCommand(notebook_cell_actions_contribution_1.NotebookCellCommands.CHANGE_CELL_LANGUAGE.id, this.props.notebook, this.props.cell);
                    } }, this.props.cell.languageName)));
    }
    renderExecutionState() {
        var _a;
        const state = (_a = this.state.currentExecution) === null || _a === void 0 ? void 0 : _a.state;
        const { lastRunSuccess } = this.props.cell.internalMetadata;
        let iconClasses = undefined;
        let color = undefined;
        if (!state && lastRunSuccess) {
            iconClasses = (0, browser_1.codicon)('check');
            color = 'green';
        }
        else if (!state && lastRunSuccess === false) {
            iconClasses = (0, browser_1.codicon)('error');
            color = 'red';
        }
        else if (state === common_1.NotebookCellExecutionState.Pending || state === common_1.NotebookCellExecutionState.Unconfirmed) {
            iconClasses = (0, browser_1.codicon)('clock');
        }
        else if (state === common_1.NotebookCellExecutionState.Executing) {
            iconClasses = `${(0, browser_1.codicon)('sync')} theia-animation-spin`;
        }
        return React.createElement(React.Fragment, null, iconClasses &&
            React.createElement(React.Fragment, null,
                React.createElement("span", { className: `${iconClasses} notebook-cell-status-item`, style: { color } }),
                React.createElement("div", { className: 'notebook-cell-status-item' }, this.renderTime(this.getExecutionTime()))));
    }
    getExecutionTime() {
        const { runStartTime, runEndTime } = this.props.cell.internalMetadata;
        const { executionTime } = this.state;
        if (runStartTime !== undefined && runEndTime !== undefined) {
            return runEndTime - runStartTime;
        }
        return executionTime;
    }
    renderTime(ms) {
        return `${(ms / 1000).toLocaleString(undefined, { maximumFractionDigits: 1, minimumFractionDigits: 1 })}s`;
    }
    renderStatusBarItems() {
        return React.createElement(React.Fragment, null, this.statusBarItems.flatMap((itemList, listIndex) => itemList.items.map((item, index) => this.renderStatusBarItem(item, `${listIndex}-${index}`))));
    }
    renderStatusBarItem(item, key) {
        const content = this.props.labelParser.parse(item.text).map(part => {
            if (typeof part === 'string') {
                return part;
            }
            else {
                return React.createElement("span", { key: part.name, className: `codicon codicon-${part.name}` });
            }
        });
        return React.createElement("div", { key: key, className: `cell-status-bar-item ${item.command ? 'cell-status-item-has-command' : ''}`, onClick: async () => {
                var _a;
                if (item.command) {
                    if (typeof item.command === 'string') {
                        this.props.commandRegistry.executeCommand(item.command);
                    }
                    else {
                        this.props.commandRegistry.executeCommand(item.command.id, ...((_a = item.command.arguments) !== null && _a !== void 0 ? _a : []));
                    }
                }
            } }, content);
    }
}
exports.NotebookCodeCellStatus = NotebookCodeCellStatus;
class NotebookCodeCellOutputs extends React.Component {
    constructor() {
        super(...arguments);
        this.toDispose = new core_1.DisposableCollection();
        this.outputHeight = 0;
    }
    async componentDidMount() {
        const { cell } = this.props;
        this.toDispose.push(cell.onDidChangeOutputs(() => this.forceUpdate()));
        this.toDispose.push(this.props.cell.onDidChangeOutputVisibility(() => this.forceUpdate()));
        this.toDispose.push(this.props.outputWebview.onDidRenderOutput(event => {
            if (event.cellHandle === this.props.cell.handle) {
                this.outputHeight = event.outputHeight;
                this.forceUpdate();
            }
        }));
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    render() {
        var _a;
        if (!((_a = this.props.cell.outputs) === null || _a === void 0 ? void 0 : _a.length)) {
            return React.createElement(React.Fragment, null);
        }
        if (this.props.cell.outputVisible) {
            return React.createElement("div", { style: { minHeight: this.outputHeight } }, this.props.renderSidebar());
        }
        return React.createElement("div", { className: 'theia-notebook-collapsed-output-container' },
            React.createElement("i", { className: 'theia-notebook-collapsed-output' }, core_1.nls.localizeByDefault('Outputs are collapsed')));
    }
}
exports.NotebookCodeCellOutputs = NotebookCodeCellOutputs;
function CodeCellExecutionOrder({ cell }) {
    var _a;
    const [executionOrder, setExecutionOrder] = React.useState((_a = cell.internalMetadata.executionOrder) !== null && _a !== void 0 ? _a : ' ');
    React.useEffect(() => {
        const listener = cell.onDidChangeInternalMetadata(e => {
            var _a;
            setExecutionOrder((_a = cell.internalMetadata.executionOrder) !== null && _a !== void 0 ? _a : ' ');
        });
        return () => listener.dispose();
    }, []);
    return React.createElement("span", { className: 'theia-notebook-code-cell-execution-order' }, `[${executionOrder}]`);
}


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-find-widget.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-find-widget.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookFindWidget = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const debounce = __webpack_require__(/*! lodash/debounce */ "../node_modules/lodash/debounce.js");
class NotebookFindWidget extends React.Component {
    constructor(props) {
        var _a;
        super(props);
        this.searchRef = React.createRef();
        this.debounceSearch = debounce(this.search.bind(this), 50);
        this.state = {
            search: '',
            replace: '',
            currentMatch: 0,
            matches: [],
            expanded: false,
            matchCase: false,
            regex: false,
            wholeWord: false,
            activeFilters: ((_a = props.filters) === null || _a === void 0 ? void 0 : _a.filter(filter => filter.active).map(filter => filter.id)) || []
        };
    }
    render() {
        const hasMatches = this.hasMatches();
        const canReplace = this.canReplace();
        const canReplaceAll = this.canReplaceAll();
        return (React.createElement("div", { onKeyUp: event => {
                if (event.key === 'Escape') {
                    this.props.onClose();
                }
            }, className: `theia-notebook-find-widget ${!this.state.expanded ? 'search-mode' : ''} ${this.props.hidden ? 'hidden' : ''}` },
            React.createElement("div", { className: 'theia-notebook-find-widget-expand', title: core_1.nls.localizeByDefault('Toggle Replace'), onClick: () => {
                    this.setState({
                        expanded: !this.state.expanded
                    });
                } },
                React.createElement("div", { className: (0, browser_1.codicon)(`chevron-${this.state.expanded ? 'down' : 'right'}`) })),
            React.createElement("div", { className: 'theia-notebook-find-widget-inputs' },
                React.createElement("div", { className: 'theia-notebook-find-widget-input-wrapper' },
                    React.createElement("input", { ref: this.searchRef, type: 'text', className: 'theia-input theia-notebook-find-widget-input', placeholder: core_1.nls.localizeByDefault('Find'), value: this.state.search, onChange: event => {
                            this.setState({
                                search: event.target.value
                            });
                            this.debounceSearch({});
                        }, onKeyDown: event => {
                            if (event.key === 'Enter') {
                                if (event.shiftKey) {
                                    this.gotoPreviousMatch();
                                }
                                else {
                                    this.gotoNextMatch();
                                }
                                event.preventDefault();
                            }
                        } }),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('case-sensitive', true)} option ${this.state.matchCase ? 'enabled' : ''}`, title: core_1.nls.localizeByDefault('Match Case'), onClick: () => {
                            this.search({
                                matchCase: !this.state.matchCase
                            });
                        } }),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('whole-word', true)} option ${this.state.wholeWord ? 'enabled' : ''}`, title: core_1.nls.localizeByDefault('Match Whole Word'), onClick: () => {
                            this.search({
                                wholeWord: !this.state.wholeWord
                            });
                        } }),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('regex', true)} option ${this.state.regex ? 'enabled' : ''}`, title: core_1.nls.localizeByDefault('Use Regular Expression'), onClick: () => {
                            this.search({
                                regex: !this.state.regex
                            });
                        } })),
                React.createElement("input", { type: 'text', className: 'theia-input theia-notebook-find-widget-replace', placeholder: core_1.nls.localizeByDefault('Replace'), value: this.state.replace, onChange: event => {
                        this.setState({
                            replace: event.target.value
                        });
                    }, onKeyDown: event => {
                        if (event.key === 'Enter') {
                            this.replaceOne();
                            event.preventDefault();
                        }
                    } })),
            React.createElement("div", { className: 'theia-notebook-find-widget-buttons' },
                React.createElement("div", { className: 'theia-notebook-find-widget-buttons-first' },
                    React.createElement("div", { className: 'theia-notebook-find-widget-matches-count' }, this.getMatchesCount()),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('arrow-up', hasMatches)} ${hasMatches ? '' : 'disabled'}`, title: core_1.nls.localizeByDefault('Previous Match'), onClick: () => {
                            this.gotoPreviousMatch();
                        } }),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('arrow-down', hasMatches)} ${hasMatches ? '' : 'disabled'}`, title: core_1.nls.localizeByDefault('Next Match'), onClick: () => {
                            this.gotoNextMatch();
                        } }),
                    React.createElement("div", { className: (0, browser_1.codicon)('close', true), title: core_1.nls.localizeByDefault('Close'), onClick: () => {
                            this.props.onClose();
                        } })),
                React.createElement("div", { className: 'theia-notebook-find-widget-buttons-second' },
                    React.createElement("div", { className: `${(0, browser_1.codicon)('replace', canReplace)} ${canReplace ? '' : 'disabled'}`, title: core_1.nls.localizeByDefault('Replace'), onClick: () => {
                            this.replaceOne();
                        } }),
                    React.createElement("div", { className: `${(0, browser_1.codicon)('replace-all', canReplaceAll)} ${canReplaceAll ? '' : 'disabled'}`, title: core_1.nls.localizeByDefault('Replace All'), onClick: () => {
                            this.replaceAll();
                        } })))));
    }
    hasMatches() {
        return this.state.matches.length > 0;
    }
    canReplace() {
        var _a;
        return Boolean((_a = this.state.matches[this.state.currentMatch]) === null || _a === void 0 ? void 0 : _a.replace);
    }
    canReplaceAll() {
        return this.state.matches.some(match => Boolean(match.replace));
    }
    getMatchesCount() {
        if (this.hasMatches()) {
            return core_1.nls.localizeByDefault('{0} of {1}', this.state.currentMatch + 1, this.state.matches.length);
        }
        else {
            return core_1.nls.localizeByDefault('No results');
        }
    }
    gotoNextMatch() {
        this.search({
            modifyIndex: (matches, index) => (index + 1) % matches.length,
            jumpToMatch: true
        });
    }
    gotoPreviousMatch() {
        this.search({
            modifyIndex: (matches, index) => (index === 0 ? matches.length : index) - 1,
            jumpToMatch: true
        });
    }
    replaceOne() {
        var _a;
        const existingMatches = this.state.matches;
        const match = existingMatches[this.state.currentMatch];
        if (match) {
            (_a = match.replace) === null || _a === void 0 ? void 0 : _a.call(match, this.state.replace);
            this.search({
                jumpToMatch: true,
                modifyIndex: (matches, index) => {
                    if (matches.length < existingMatches.length) {
                        return index % matches.length;
                    }
                    else {
                        const diff = matches.length - existingMatches.length;
                        return (index + diff + 1) % matches.length;
                    }
                }
            });
        }
    }
    replaceAll() {
        this.props.onReplace(this.state.matches, this.state.replace);
        this.search({});
    }
    componentDidUpdate(prevProps, prevState) {
        var _a;
        if (!this.props.hidden && prevProps.hidden) {
            // Focus the search input when the widget switches from hidden to visible.
            (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    focusSearch(content) {
        var _a;
        (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        if (content) {
            this.search({
                search: content,
                jumpToMatch: false
            });
        }
    }
    search(options) {
        var _a, _b, _c, _d;
        const matchCase = (_a = options.matchCase) !== null && _a !== void 0 ? _a : this.state.matchCase;
        const wholeWord = (_b = options.wholeWord) !== null && _b !== void 0 ? _b : this.state.wholeWord;
        const regex = (_c = options.regex) !== null && _c !== void 0 ? _c : this.state.regex;
        const search = (_d = options.search) !== null && _d !== void 0 ? _d : this.state.search;
        const matches = this.props.onSearch({
            search,
            matchCase,
            wholeWord,
            regex,
            activeFilters: this.state.activeFilters
        });
        let currentMatch = Math.max(0, Math.min(this.state.currentMatch, matches.length - 1));
        if (options.modifyIndex && matches.length > 0) {
            currentMatch = options.modifyIndex(matches, currentMatch);
        }
        const selectedMatch = matches[currentMatch];
        if (selectedMatch) {
            selectedMatch.selected = true;
            if (options.jumpToMatch) {
                selectedMatch.show();
            }
        }
        this.setState({
            search,
            matches,
            currentMatch,
            matchCase,
            wholeWord,
            regex
        });
    }
}
exports.NotebookFindWidget = NotebookFindWidget;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-main-toolbar.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-main-toolbar.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMainToolbar = exports.NotebookMainToolbarRenderer = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const notebook_actions_contribution_1 = __webpack_require__(/*! ../contributions/notebook-actions-contribution */ "../node_modules/@theia/notebook/lib/browser/contributions/notebook-actions-contribution.js");
const notebook_kernel_service_1 = __webpack_require__(/*! ../service/notebook-kernel-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const notebook_context_manager_1 = __webpack_require__(/*! ../service/notebook-context-manager */ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js");
let NotebookMainToolbarRenderer = class NotebookMainToolbarRenderer {
    render(notebookModel, editorNode) {
        return React.createElement(NotebookMainToolbar, { notebookModel: notebookModel, menuRegistry: this.menuRegistry, notebookKernelService: this.notebookKernelService, commandRegistry: this.commandRegistry, contextKeyService: this.contextKeyService, editorNode: editorNode, notebookContextManager: this.notebookContextManager, contextMenuRenderer: this.contextMenuRenderer });
    }
};
exports.NotebookMainToolbarRenderer = NotebookMainToolbarRenderer;
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_kernel_service_1.NotebookKernelService),
    tslib_1.__metadata("design:type", notebook_kernel_service_1.NotebookKernelService)
], NotebookMainToolbarRenderer.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], NotebookMainToolbarRenderer.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], NotebookMainToolbarRenderer.prototype, "menuRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], NotebookMainToolbarRenderer.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_context_manager_1.NotebookContextManager),
    tslib_1.__metadata("design:type", notebook_context_manager_1.NotebookContextManager)
], NotebookMainToolbarRenderer.prototype, "notebookContextManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_1.ContextMenuRenderer)
], NotebookMainToolbarRenderer.prototype, "contextMenuRenderer", void 0);
exports.NotebookMainToolbarRenderer = NotebookMainToolbarRenderer = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookMainToolbarRenderer);
class NotebookMainToolbar extends React.Component {
    constructor(props) {
        var _a;
        super(props);
        this.toDispose = new core_1.DisposableCollection();
        this.nativeSubmenus = [
            notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP[notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_CELL_ADD_GROUP.length - 1],
            notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP[notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_EXECUTION_GROUP.length - 1]
        ];
        this.lastGapElementWidth = 0;
        this.resizeObserver = new ResizeObserver(() => this.calculateItemsToHide());
        this.state = {
            selectedKernelLabel: (_a = props.notebookKernelService.getSelectedOrSuggestedKernel(props.notebookModel)) === null || _a === void 0 ? void 0 : _a.label,
            numberOfHiddenItems: 0,
        };
        this.toDispose.push(props.notebookKernelService.onDidChangeSelectedKernel(event => {
            var _a, _b;
            if (props.notebookModel.uri.isEqual(event.notebook)) {
                this.setState({ selectedKernelLabel: (_b = props.notebookKernelService.getKernel((_a = event.newKernel) !== null && _a !== void 0 ? _a : '')) === null || _b === void 0 ? void 0 : _b.label });
            }
        }));
        // in case the selected kernel is added after the notebook is loaded
        this.toDispose.push(props.notebookKernelService.onDidAddKernel(() => {
            var _a;
            if (!this.state.selectedKernelLabel) {
                this.setState({ selectedKernelLabel: (_a = props.notebookKernelService.getSelectedOrSuggestedKernel(props.notebookModel)) === null || _a === void 0 ? void 0 : _a.label });
            }
        }));
        // TODO maybe we need a mechanism to check for changes in the menu to update this toolbar
        const contextKeys = new Set();
        this.getAllContextKeys(this.getMenuItems(), contextKeys);
        props.notebookContextManager.onDidChangeContext(e => {
            if (e.affects(contextKeys)) {
                this.forceUpdate();
            }
        });
        props.contextKeyService.onDidChange(e => {
            if (e.affects(contextKeys)) {
                this.forceUpdate();
            }
        });
    }
    componentWillUnmount() {
        this.toDispose.dispose();
    }
    componentDidUpdate() {
        this.calculateItemsToHide();
    }
    componentDidMount() {
        this.calculateItemsToHide();
    }
    calculateItemsToHide() {
        const numberOfMenuItems = this.getMenuItems().length;
        if (this.gapElement && this.gapElement.getBoundingClientRect().width < NotebookMainToolbar.MIN_FREE_AREA && this.state.numberOfHiddenItems < numberOfMenuItems) {
            this.setState({ ...this.state, numberOfHiddenItems: this.state.numberOfHiddenItems + 1 });
            this.lastGapElementWidth = this.gapElement.getBoundingClientRect().width;
        }
        else if (this.gapElement && this.gapElement.getBoundingClientRect().width > this.lastGapElementWidth && this.state.numberOfHiddenItems > 0) {
            this.setState({ ...this.state, numberOfHiddenItems: 0 });
            this.lastGapElementWidth = this.gapElement.getBoundingClientRect().width;
        }
    }
    renderContextMenu(event, menuItems) {
        const hiddenItems = menuItems.slice(menuItems.length - this.calculateNumberOfHiddenItems(menuItems));
        const contextMenu = this.props.menuRegistry.getMenu([notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_HIDDEN_ITEMS_CONTEXT_MENU]);
        contextMenu.children.map(item => item.id).forEach(id => contextMenu.removeNode(id));
        hiddenItems.forEach(item => contextMenu.addNode(item));
        this.props.contextMenuRenderer.render({
            anchor: event,
            menuPath: [notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR_HIDDEN_ITEMS_CONTEXT_MENU],
            context: this.props.editorNode,
            args: [this.props.notebookModel.uri]
        });
    }
    render() {
        var _a;
        const menuItems = this.getMenuItems();
        return React.createElement("div", { className: 'theia-notebook-main-toolbar', id: 'notebook-main-toolbar' },
            menuItems.slice(0, menuItems.length - this.calculateNumberOfHiddenItems(menuItems)).map(item => this.renderMenuItem(item)),
            this.state.numberOfHiddenItems > 0 &&
                React.createElement("span", { className: `${(0, browser_1.codicon)('ellipsis')} action-label theia-notebook-main-toolbar-item`, onClick: e => this.renderContextMenu(e.nativeEvent, menuItems) }),
            React.createElement("div", { ref: element => this.gapElementChanged(element), style: { flexGrow: 1 } }),
            React.createElement("div", { className: 'theia-notebook-main-toolbar-item action-label', id: notebook_actions_contribution_1.NotebookCommands.SELECT_KERNEL_COMMAND.id, onClick: () => this.props.commandRegistry.executeCommand(notebook_actions_contribution_1.NotebookCommands.SELECT_KERNEL_COMMAND.id, this.props.notebookModel) },
                React.createElement("span", { className: (0, browser_1.codicon)('server-environment') }),
                React.createElement("span", { className: ' theia-notebook-main-toolbar-item-text', id: 'kernel-text' }, (_a = this.state.selectedKernelLabel) !== null && _a !== void 0 ? _a : core_1.nls.localizeByDefault('Select Kernel'))));
    }
    gapElementChanged(element) {
        if (this.gapElement) {
            this.resizeObserver.unobserve(this.gapElement);
        }
        this.gapElement = element !== null && element !== void 0 ? element : undefined;
        if (this.gapElement) {
            this.lastGapElementWidth = this.gapElement.getBoundingClientRect().width;
            this.resizeObserver.observe(this.gapElement);
        }
    }
    renderMenuItem(item, submenu) {
        var _a, _b, _c, _d, _e, _f;
        if (item.role === 1 /* CompoundMenuNodeRole.Group */) {
            const itemNodes = core_1.ArrayUtils.coalesce((_b = (_a = item.children) === null || _a === void 0 ? void 0 : _a.map(child => this.renderMenuItem(child, item.id))) !== null && _b !== void 0 ? _b : []);
            return React.createElement(React.Fragment, { key: item.id },
                itemNodes,
                itemNodes && itemNodes.length > 0 && React.createElement("span", { key: `${item.id}-separator`, className: 'theia-notebook-toolbar-separator' }));
        }
        else if ((this.nativeSubmenus.includes(submenu !== null && submenu !== void 0 ? submenu : '')) || !item.when || this.props.contextKeyService.match(item.when, this.props.editorNode)) {
            const visibleCommand = Boolean(this.props.commandRegistry.getVisibleHandler((_c = item.command) !== null && _c !== void 0 ? _c : '', this.props.notebookModel));
            if (!visibleCommand) {
                return undefined;
            }
            const command = this.props.commandRegistry.getCommand((_d = item.command) !== null && _d !== void 0 ? _d : '');
            const label = (_e = command === null || command === void 0 ? void 0 : command.shortTitle) !== null && _e !== void 0 ? _e : item.label;
            const title = (_f = command === null || command === void 0 ? void 0 : command.tooltip) !== null && _f !== void 0 ? _f : item.label;
            return React.createElement("div", { key: item.id, id: item.id, title: title, className: `theia-notebook-main-toolbar-item action-label${this.getAdditionalClasses(item)}`, onClick: () => {
                    if (item.command && (!item.when || this.props.contextKeyService.match(item.when, this.props.editorNode))) {
                        this.props.commandRegistry.executeCommand(item.command, this.props.notebookModel.uri);
                    }
                } },
                React.createElement("span", { className: item.icon }),
                React.createElement("span", { className: 'theia-notebook-main-toolbar-item-text' }, label));
        }
        return undefined;
    }
    getMenuItems() {
        const menuPath = notebook_actions_contribution_1.NotebookMenus.NOTEBOOK_MAIN_TOOLBAR;
        const pluginCommands = this.props.menuRegistry.getMenuNode(menuPath).children;
        const theiaCommands = this.props.menuRegistry.getMenu([menuPath]).children;
        return theiaCommands.concat(pluginCommands);
    }
    getAdditionalClasses(item) {
        return !item.when || this.props.contextKeyService.match(item.when, this.props.editorNode) ? '' : ' theia-mod-disabled';
    }
    getAllContextKeys(menus, keySet) {
        menus.filter(item => item.when)
            .forEach(item => { var _a; return (_a = this.props.contextKeyService.parseKeys(item.when)) === null || _a === void 0 ? void 0 : _a.forEach(key => keySet.add(key)); });
        menus.filter(item => item.children && item.children.length > 0)
            .forEach(item => this.getAllContextKeys(item.children, keySet));
    }
    calculateNumberOfHiddenItems(allMenuItems) {
        return this.state.numberOfHiddenItems >= allMenuItems.length ?
            allMenuItems.length :
            this.state.numberOfHiddenItems % allMenuItems.length;
    }
}
exports.NotebookMainToolbar = NotebookMainToolbar;
// The minimum area between items and kernel select before hiding items in a context menu
NotebookMainToolbar.MIN_FREE_AREA = 10;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-markdown-cell-view.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-markdown-cell-view.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMarkdownCellRenderer = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const markdown_renderer_1 = __webpack_require__(/*! @theia/core/lib/browser/markdown-rendering/markdown-renderer */ "../node_modules/@theia/core/lib/browser/markdown-rendering/markdown-renderer.js");
const markdown_string_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering/markdown-string */ "../node_modules/@theia/core/lib/common/markdown-rendering/markdown-string.js");
const notebook_cell_list_view_1 = __webpack_require__(/*! ./notebook-cell-list-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-list-view.js");
const notebook_cell_editor_1 = __webpack_require__(/*! ./notebook-cell-editor */ "../node_modules/@theia/notebook/lib/browser/view/notebook-cell-editor.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebook_context_manager_1 = __webpack_require__(/*! ../service/notebook-context-manager */ "../node_modules/@theia/notebook/lib/browser/service/notebook-context-manager.js");
const notebook_options_1 = __webpack_require__(/*! ../service/notebook-options */ "../node_modules/@theia/notebook/lib/browser/service/notebook-options.js");
const notebook_code_cell_view_1 = __webpack_require__(/*! ./notebook-code-cell-view */ "../node_modules/@theia/notebook/lib/browser/view/notebook-code-cell-view.js");
const mark = __webpack_require__(/*! advanced-mark.js */ "../node_modules/advanced-mark.js/dist/mark.js");
const notebook_cell_editor_service_1 = __webpack_require__(/*! ../service/notebook-cell-editor-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js");
const notebook_cell_status_bar_service_1 = __webpack_require__(/*! ../service/notebook-cell-status-bar-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js");
const label_parser_1 = __webpack_require__(/*! @theia/core/lib/browser/label-parser */ "../node_modules/@theia/core/lib/browser/label-parser.js");
let NotebookMarkdownCellRenderer = class NotebookMarkdownCellRenderer {
    render(notebookModel, cell) {
        return React.createElement(MarkdownCell, { markdownRenderer: this.markdownRenderer, commandRegistry: this.commandRegistry, monacoServices: this.monacoServices, notebookOptionsService: this.notebookOptionsService, cell: cell, notebookModel: notebookModel, notebookContextManager: this.notebookContextManager, notebookCellEditorService: this.notebookCellEditorService, notebookCellStatusBarService: this.notebookCellStatusBarService, labelParser: this.labelParser });
    }
    renderSidebar(notebookModel, cell) {
        return React.createElement("div", { className: 'theia-notebook-markdown-sidebar' });
    }
    renderDragImage(cell) {
        var _a;
        const dragImage = document.createElement('div');
        dragImage.style.width = ((_a = this.notebookContextManager.context) === null || _a === void 0 ? void 0 : _a.clientWidth) + 'px';
        const markdownString = new markdown_string_1.MarkdownStringImpl(cell.source, { supportHtml: true, isTrusted: true });
        const markdownElement = this.markdownRenderer.render(markdownString).element;
        dragImage.appendChild(markdownElement);
        return dragImage;
    }
};
exports.NotebookMarkdownCellRenderer = NotebookMarkdownCellRenderer;
tslib_1.__decorate([
    (0, inversify_1.inject)(markdown_renderer_1.MarkdownRenderer),
    tslib_1.__metadata("design:type", Object)
], NotebookMarkdownCellRenderer.prototype, "markdownRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_1.MonacoEditorServices),
    tslib_1.__metadata("design:type", monaco_editor_1.MonacoEditorServices)
], NotebookMarkdownCellRenderer.prototype, "monacoServices", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_context_manager_1.NotebookContextManager),
    tslib_1.__metadata("design:type", notebook_context_manager_1.NotebookContextManager)
], NotebookMarkdownCellRenderer.prototype, "notebookContextManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], NotebookMarkdownCellRenderer.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_options_1.NotebookOptionsService),
    tslib_1.__metadata("design:type", notebook_options_1.NotebookOptionsService)
], NotebookMarkdownCellRenderer.prototype, "notebookOptionsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_editor_service_1.NotebookCellEditorService),
    tslib_1.__metadata("design:type", notebook_cell_editor_service_1.NotebookCellEditorService)
], NotebookMarkdownCellRenderer.prototype, "notebookCellEditorService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_cell_status_bar_service_1.NotebookCellStatusBarService),
    tslib_1.__metadata("design:type", notebook_cell_status_bar_service_1.NotebookCellStatusBarService)
], NotebookMarkdownCellRenderer.prototype, "notebookCellStatusBarService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_parser_1.LabelParser),
    tslib_1.__metadata("design:type", label_parser_1.LabelParser)
], NotebookMarkdownCellRenderer.prototype, "labelParser", void 0);
exports.NotebookMarkdownCellRenderer = NotebookMarkdownCellRenderer = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookMarkdownCellRenderer);
function MarkdownCell({ markdownRenderer, monacoServices, cell, notebookModel, notebookContextManager, notebookOptionsService, commandRegistry, notebookCellEditorService, notebookCellStatusBarService, labelParser }) {
    const [editMode, setEditMode] = React.useState(cell.editing);
    let empty = false;
    React.useEffect(() => {
        const listener = cell.onDidRequestCellEditChange(cellEdit => setEditMode(cellEdit));
        return () => listener.dispose();
    }, [editMode]);
    React.useEffect(() => {
        if (!editMode) {
            const instance = new mark(markdownContent);
            cell.onMarkdownFind = options => {
                instance.unmark();
                if (empty) {
                    return [];
                }
                return searchInMarkdown(instance, options);
            };
            return () => {
                cell.onMarkdownFind = undefined;
                instance.unmark();
            };
        }
    }, [editMode, cell.source]);
    let markdownContent = React.useMemo(() => {
        const markdownString = new markdown_string_1.MarkdownStringImpl(cell.source, { supportHtml: true, isTrusted: true });
        const rendered = markdownRenderer.render(markdownString).element;
        const children = [];
        rendered.childNodes.forEach(child => {
            if (child instanceof HTMLElement) {
                children.push(child);
            }
        });
        return children;
    }, [cell.source]);
    if (markdownContent.length === 0) {
        const italic = document.createElement('i');
        italic.className = 'theia-notebook-empty-markdown';
        italic.innerText = core_1.nls.localizeByDefault('Empty markdown cell, double-click or press enter to edit.');
        italic.style.pointerEvents = 'none';
        markdownContent = [italic];
        empty = true;
    }
    return editMode ?
        (React.createElement("div", { className: 'theia-notebook-markdown-editor-container', key: "code", ref: ref => (0, notebook_cell_list_view_1.observeCellHeight)(ref, cell) },
            React.createElement(notebook_cell_editor_1.CellEditor, { notebookModel: notebookModel, cell: cell, monacoServices: monacoServices, notebookContextManager: notebookContextManager, notebookCellEditorService: notebookCellEditorService, fontInfo: notebookOptionsService.editorFontInfo }),
            React.createElement(notebook_code_cell_view_1.NotebookCodeCellStatus, { cell: cell, notebook: notebookModel, commandRegistry: commandRegistry, cellStatusBarService: notebookCellStatusBarService, labelParser: labelParser, onClick: () => cell.requestFocusEditor() }))) :
        (React.createElement("div", { className: 'theia-notebook-markdown-content', key: "markdown", onDoubleClick: () => cell.requestEdit(), ref: node => {
                node === null || node === void 0 ? void 0 : node.replaceChildren(...markdownContent);
                (0, notebook_cell_list_view_1.observeCellHeight)(node, cell);
            } }));
}
function searchInMarkdown(instance, options) {
    const matches = [];
    const markOptions = {
        className: 'theia-find-match',
        diacritics: false,
        caseSensitive: options.matchCase,
        acrossElements: true,
        separateWordSearch: false,
        each: node => {
            matches.push(new MarkdownEditorFindMatch(node));
        }
    };
    if (options.regex || options.wholeWord) {
        let search = options.search;
        if (options.wholeWord) {
            if (!options.regex) {
                search = escapeRegExp(search);
            }
            search = '\\b' + search + '\\b';
        }
        instance.markRegExp(new RegExp(search, options.matchCase ? '' : 'i'), markOptions);
    }
    else {
        instance.mark(options.search, markOptions);
    }
    return matches;
}
function escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
class MarkdownEditorFindMatch {
    constructor(node) {
        this.node = node;
        this._selected = false;
    }
    get selected() {
        return this._selected;
    }
    set selected(selected) {
        this._selected = selected;
        const className = 'theia-find-match-selected';
        if (this.node instanceof HTMLElement) {
            if (selected) {
                this.node.classList.add(className);
            }
            else {
                this.node.classList.remove(className);
            }
        }
    }
    show() {
        if (this.node instanceof HTMLElement) {
            this.node.scrollIntoView({
                behavior: 'instant',
                block: 'center'
            });
        }
    }
}


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/browser/view/notebook-viewport-service.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/browser/view/notebook-viewport-service.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookViewportService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
/**
 * this service is for managing the viewport and scroll state of a notebook editor.
 * its used both for restoring scroll state after reopening an editor and for cell to check if they are in the viewport.
 */
let NotebookViewportService = class NotebookViewportService {
    constructor() {
        this.onDidChangeViewportEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeViewport = this.onDidChangeViewportEmitter.event;
    }
    set viewportElement(element) {
        var _a;
        this._viewportElement = element;
        if (element) {
            this.onDidChangeViewportEmitter.fire();
            (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
            this.resizeObserver = new ResizeObserver(() => this.onDidChangeViewportEmitter.fire());
            this.resizeObserver.observe(element);
        }
    }
    isElementInViewport(element) {
        if (this._viewportElement) {
            const rect = element.getBoundingClientRect();
            const viewRect = this._viewportElement.getBoundingClientRect();
            return rect.top < viewRect.top ? rect.bottom > viewRect.top : rect.top < viewRect.bottom;
        }
        return false;
    }
    onScroll(e) {
        this.onDidChangeViewportEmitter.fire();
    }
    dispose() {
        var _a;
        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
};
exports.NotebookViewportService = NotebookViewportService;
exports.NotebookViewportService = NotebookViewportService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], NotebookViewportService);


/***/ }),

/***/ "../node_modules/@theia/output/lib/browser/output-channel.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@theia/output/lib/browser/output-channel.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputChannel = exports.OutputChannelSeverity = exports.OutputChannelManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const monaco_text_model_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-text-model-service */ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const output_uri_1 = __webpack_require__(/*! ../common/output-uri */ "../node_modules/@theia/output/lib/common/output-uri.js");
const output_resource_1 = __webpack_require__(/*! ../browser/output-resource */ "../node_modules/@theia/output/lib/browser/output-resource.js");
const output_preferences_1 = __webpack_require__(/*! ./output-preferences */ "../node_modules/@theia/output/lib/browser/output-preferences.js");
const monaco = tslib_1.__importStar(__webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js"));
const p_queue_1 = tslib_1.__importDefault(__webpack_require__(/*! p-queue */ "../node_modules/p-queue/dist/index.js"));
let OutputChannelManager = class OutputChannelManager {
    constructor() {
        this.channels = new Map();
        this.resources = new Map();
        this.channelAddedEmitter = new core_1.Emitter();
        this.channelDeletedEmitter = new core_1.Emitter();
        this.channelWasShownEmitter = new core_1.Emitter();
        this.channelWasHiddenEmitter = new core_1.Emitter();
        this.selectedChannelChangedEmitter = new core_1.Emitter();
        this.onChannelAdded = this.channelAddedEmitter.event;
        this.onChannelDeleted = this.channelDeletedEmitter.event;
        this.onChannelWasShown = this.channelWasShownEmitter.event;
        this.onChannelWasHidden = this.channelWasHiddenEmitter.event;
        this.onSelectedChannelChanged = this.selectedChannelChangedEmitter.event;
        this.toDispose = new core_1.DisposableCollection();
        this.toDisposeOnChannelDeletion = new Map();
    }
    getChannel(name) {
        const existing = this.channels.get(name);
        if (existing) {
            return existing;
        }
        // We have to register the resource first, because `textModelService#createModelReference` will require it
        // right after creating the monaco.editor.ITextModel.
        // All `append` and `appendLine` will be deferred until the underlying text-model instantiation.
        let resource = this.resources.get(name);
        if (!resource) {
            const uri = output_uri_1.OutputUri.create(name);
            const editorModelRef = new promise_util_1.Deferred();
            resource = this.createResource({ uri, editorModelRef });
            this.resources.set(name, resource);
            this.textModelService.createModelReference(uri).then(ref => editorModelRef.resolve(ref));
        }
        const channel = this.createChannel(resource);
        this.channels.set(name, channel);
        this.toDisposeOnChannelDeletion.set(name, this.registerListeners(channel));
        this.channelAddedEmitter.fire(channel);
        if (!this.selectedChannel) {
            this.selectedChannel = channel;
        }
        return channel;
    }
    registerListeners(channel) {
        const { name } = channel;
        return new core_1.DisposableCollection(channel, channel.onVisibilityChange(({ isVisible, preserveFocus }) => {
            if (isVisible) {
                this.selectedChannel = channel;
                this.channelWasShownEmitter.fire({ name, preserveFocus });
            }
            else {
                if (channel === this.selectedChannel) {
                    this.selectedChannel = this.getVisibleChannels()[0];
                }
                this.channelWasHiddenEmitter.fire({ name });
            }
        }), channel.onDisposed(() => this.deleteChannel(name)), core_1.Disposable.create(() => {
            const resource = this.resources.get(name);
            if (resource) {
                resource.dispose();
                this.resources.delete(name);
            }
            else {
                console.warn(`Could not dispose. No resource was for output channel: '${name}'.`);
            }
        }), core_1.Disposable.create(() => {
            const toDispose = this.channels.get(name);
            if (!toDispose) {
                console.warn(`Could not dispose. No channel exist with name: '${name}'.`);
                return;
            }
            this.channels.delete(name);
            toDispose.dispose();
            this.channelDeletedEmitter.fire({ name });
            if (this.selectedChannel && this.selectedChannel.name === name) {
                this.selectedChannel = this.getVisibleChannels()[0];
            }
        }));
    }
    deleteChannel(name) {
        const toDispose = this.toDisposeOnChannelDeletion.get(name);
        if (toDispose) {
            toDispose.dispose();
        }
    }
    getChannels() {
        return Array.from(this.channels.values()).sort(this.channelComparator);
    }
    getVisibleChannels() {
        return this.getChannels().filter(channel => channel.isVisible);
    }
    get channelComparator() {
        return (left, right) => {
            if (left.isVisible !== right.isVisible) {
                return left.isVisible ? -1 : 1;
            }
            return left.name.toLocaleLowerCase().localeCompare(right.name.toLocaleLowerCase());
        };
    }
    dispose() {
        this.toDispose.dispose();
    }
    get selectedChannel() {
        return this._selectedChannel;
    }
    set selectedChannel(channel) {
        this._selectedChannel = channel;
        if (this._selectedChannel) {
            this.selectedChannelChangedEmitter.fire({ name: this._selectedChannel.name });
        }
        else {
            this.selectedChannelChangedEmitter.fire(undefined);
        }
    }
    /**
     * Non-API: do not call directly.
     */
    async resolve(uri) {
        if (!output_uri_1.OutputUri.is(uri)) {
            throw new Error(`Expected '${output_uri_1.OutputUri.SCHEME}' URI scheme. Got: ${uri} instead.`);
        }
        const resource = this.resources.get(output_uri_1.OutputUri.channelName(uri));
        if (!resource) {
            throw new Error(`No output resource was registered with URI: ${uri.toString()}`);
        }
        return resource;
    }
    createResource({ uri, editorModelRef }) {
        return new output_resource_1.OutputResource(uri, editorModelRef);
    }
    createChannel(resource) {
        return new OutputChannel(resource, this.preferences);
    }
};
exports.OutputChannelManager = OutputChannelManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_text_model_service_1.MonacoTextModelService),
    tslib_1.__metadata("design:type", monaco_text_model_service_1.MonacoTextModelService)
], OutputChannelManager.prototype, "textModelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(output_preferences_1.OutputPreferences),
    tslib_1.__metadata("design:type", Object)
], OutputChannelManager.prototype, "preferences", void 0);
exports.OutputChannelManager = OutputChannelManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], OutputChannelManager);
var OutputChannelSeverity;
(function (OutputChannelSeverity) {
    OutputChannelSeverity[OutputChannelSeverity["Error"] = 1] = "Error";
    OutputChannelSeverity[OutputChannelSeverity["Warning"] = 2] = "Warning";
    OutputChannelSeverity[OutputChannelSeverity["Info"] = 3] = "Info";
})(OutputChannelSeverity || (exports.OutputChannelSeverity = OutputChannelSeverity = {}));
class OutputChannel {
    constructor(resource, preferences) {
        this.resource = resource;
        this.preferences = preferences;
        this.contentChangeEmitter = new core_1.Emitter();
        this.visibilityChangeEmitter = new core_1.Emitter();
        this.disposedEmitter = new core_1.Emitter();
        this.textModifyQueue = new p_queue_1.default({ autoStart: true, concurrency: 1 });
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => this.textModifyQueue.clear()), this.contentChangeEmitter, this.visibilityChangeEmitter, this.disposedEmitter);
        this.disposed = false;
        this.visible = true;
        this.decorationIds = new Set();
        this.onVisibilityChange = this.visibilityChangeEmitter.event;
        this.onContentChange = this.contentChangeEmitter.event;
        this.onDisposed = this.disposedEmitter.event;
        this._maxLineNumber = this.preferences['output.maxChannelHistory'];
        this.toDispose.push(resource);
        this.toDispose.push(core_1.Disposable.create(() => this.decorationIds.clear()));
        this.toDispose.push(this.preferences.onPreferenceChanged(event => {
            if (event.preferenceName === 'output.maxChannelHistory') {
                const maxLineNumber = event.newValue;
                if (this.maxLineNumber !== maxLineNumber) {
                    this.maxLineNumber = maxLineNumber;
                }
            }
        }));
    }
    get name() {
        return output_uri_1.OutputUri.channelName(this.uri);
    }
    get uri() {
        return this.resource.uri;
    }
    hide() {
        this.visible = false;
        this.visibilityChangeEmitter.fire({ isVisible: this.isVisible });
    }
    /**
     * If `preserveFocus` is `true`, the channel will not take focus. It is `false` by default.
     *  - Calling `show` without args or with `preserveFocus: false` will reveal **and** activate the `Output` widget.
     *  - Calling `show` with `preserveFocus: true` will reveal the `Output` widget but **won't** activate it.
     */
    show({ preserveFocus } = { preserveFocus: false }) {
        this.visible = true;
        this.visibilityChangeEmitter.fire({ isVisible: this.isVisible, preserveFocus });
    }
    /**
     * Note: if `false` it does not meant it is disposed or not available, it is only hidden from the UI.
     */
    get isVisible() {
        return this.visible;
    }
    clear() {
        this.textModifyQueue.add(async () => {
            const textModel = (await this.resource.editorModelRef.promise).object.textEditorModel;
            textModel.deltaDecorations(Array.from(this.decorationIds), []);
            this.decorationIds.clear();
            textModel.setValue('');
            this.contentChangeEmitter.fire();
        });
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        this.toDispose.dispose();
        this.disposedEmitter.fire();
    }
    append(content, severity = OutputChannelSeverity.Info) {
        this.textModifyQueue.add(() => this.doAppend({ content, severity }));
    }
    appendLine(content, severity = OutputChannelSeverity.Info) {
        this.textModifyQueue.add(() => this.doAppend({ content, severity, appendEol: true }));
    }
    async doAppend({ content, severity, appendEol }) {
        const textModel = (await this.resource.editorModelRef.promise).object.textEditorModel;
        const lastLine = textModel.getLineCount();
        const lastLineMaxColumn = textModel.getLineMaxColumn(lastLine);
        const position = new monaco.Position(lastLine, lastLineMaxColumn);
        const range = new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column);
        const edits = [{
                range,
                text: !!appendEol ? `${content}${textModel.getEOL()}` : content,
                forceMoveMarkers: true
            }];
        // We do not use `pushEditOperations` as we do not need undo/redo support. VS Code uses `applyEdits` too.
        // https://github.com/microsoft/vscode/blob/dc348340fd1a6c583cb63a1e7e6b4fd657e01e01/src/vs/workbench/services/output/common/outputChannelModel.ts#L108-L115
        textModel.applyEdits(edits);
        if (severity !== OutputChannelSeverity.Info) {
            const inlineClassName = severity === OutputChannelSeverity.Error ? 'theia-output-error' : 'theia-output-warning';
            let endLineNumber = textModel.getLineCount();
            // If last line is empty (the first non-whitespace is 0), apply decorator to previous line's last non-whitespace instead
            // Note: if the user appends `inlineWarning `, the new decorator's range includes the trailing whitespace.
            if (!textModel.getLineFirstNonWhitespaceColumn(endLineNumber)) {
                endLineNumber--;
            }
            const endColumn = textModel.getLineLastNonWhitespaceColumn(endLineNumber);
            const newDecorations = [{
                    range: new monaco.Range(range.startLineNumber, range.startColumn, endLineNumber, endColumn), options: {
                        inlineClassName
                    }
                }];
            for (const decorationId of textModel.deltaDecorations([], newDecorations)) {
                this.decorationIds.add(decorationId);
            }
        }
        this.ensureMaxChannelHistory(textModel);
        this.contentChangeEmitter.fire();
    }
    ensureMaxChannelHistory(textModel) {
        this.contentChangeEmitter.fire();
        const linesToRemove = textModel.getLineCount() - this.maxLineNumber - 1; // -1 as the last line is usually empty -> `appendLine`.
        if (linesToRemove > 0) {
            const endColumn = textModel.getLineMaxColumn(linesToRemove);
            // `endLineNumber` is `linesToRemove` + 1 as monaco is one based.
            const range = new monaco.Range(1, 1, linesToRemove, endColumn + 1);
            // eslint-disable-next-line no-null/no-null
            const text = null;
            const decorationsToRemove = textModel.getLinesDecorations(range.startLineNumber, range.endLineNumber)
                .filter(({ id }) => this.decorationIds.has(id)).map(({ id }) => id); // Do we need to filter here? Who else can put decorations to the output model?
            if (decorationsToRemove.length) {
                for (const newId of textModel.deltaDecorations(decorationsToRemove, [])) {
                    this.decorationIds.add(newId);
                }
                for (const toRemoveId of decorationsToRemove) {
                    this.decorationIds.delete(toRemoveId);
                }
            }
            textModel.applyEdits([
                {
                    range: new monaco.Range(1, 1, linesToRemove + 1, textModel.getLineFirstNonWhitespaceColumn(linesToRemove + 1)),
                    text,
                    forceMoveMarkers: true
                }
            ]);
        }
    }
    get maxLineNumber() {
        return this._maxLineNumber;
    }
    set maxLineNumber(maxLineNumber) {
        this._maxLineNumber = maxLineNumber;
        this.append(''); // will trigger an `ensureMaxChannelHistory` call and will refresh the content.
    }
}
exports.OutputChannel = OutputChannel;


/***/ }),

/***/ "../node_modules/@theia/output/lib/browser/output-preferences.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/output/lib/browser/output-preferences.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindOutputPreferences = exports.createOutputPreferences = exports.OutputPreferences = exports.OutputPreferenceContribution = exports.OutputConfigSchema = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
exports.OutputConfigSchema = {
    'type': 'object',
    'properties': {
        'output.maxChannelHistory': {
            'type': 'number',
            'description': nls_1.nls.localize('theia/output/maxChannelHistory', 'The maximum number of entries in an output channel.'),
            'default': 1000
        }
    }
};
exports.OutputPreferenceContribution = Symbol('OutputPreferenceContribution');
exports.OutputPreferences = Symbol('OutputPreferences');
function createOutputPreferences(preferences, schema = exports.OutputConfigSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createOutputPreferences = createOutputPreferences;
function bindOutputPreferences(bind) {
    bind(exports.OutputPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.OutputPreferenceContribution);
        return createOutputPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.OutputPreferenceContribution).toConstantValue({ schema: exports.OutputConfigSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.OutputPreferenceContribution);
}
exports.bindOutputPreferences = bindOutputPreferences;


/***/ }),

/***/ "../node_modules/@theia/output/lib/browser/output-resource.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/output/lib/browser/output-resource.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputResource = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
class OutputResource {
    constructor(uri, editorModelRef) {
        this.uri = uri;
        this.editorModelRef = editorModelRef;
        this.onDidChangeContentsEmitter = new common_1.Emitter();
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeContentsEmitter);
        this.editorModelRef.promise.then(modelRef => {
            if (this.toDispose.disposed) {
                modelRef.dispose();
                return;
            }
            const textModel = modelRef.object.textEditorModel;
            this._textModel = textModel;
            this.toDispose.push(modelRef);
            this.toDispose.push(this._textModel.onDidChangeContent(() => this.onDidChangeContentsEmitter.fire()));
        });
    }
    get textModel() {
        return this._textModel;
    }
    get onDidChangeContents() {
        return this.onDidChangeContentsEmitter.event;
    }
    async readContents(options) {
        if (this._textModel) {
            const modelRef = await this.editorModelRef.promise;
            return modelRef.object.textEditorModel.getValue();
        }
        return '';
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.OutputResource = OutputResource;


/***/ }),

/***/ "../node_modules/@theia/output/lib/browser/output-widget.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/output/lib/browser/output-widget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var OutputWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
__webpack_require__(/*! ../../src/browser/style/output.css */ "../node_modules/@theia/output/src/browser/style/output.css");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const algorithm_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/algorithm */ "../node_modules/@theia/core/shared/@phosphor/algorithm/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const selection_service_1 = __webpack_require__(/*! @theia/core/lib/common/selection-service */ "../node_modules/@theia/core/lib/common/selection-service.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const output_uri_1 = __webpack_require__(/*! ../common/output-uri */ "../node_modules/@theia/output/lib/common/output-uri.js");
const output_channel_1 = __webpack_require__(/*! ./output-channel */ "../node_modules/@theia/output/lib/browser/output-channel.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const monaco = tslib_1.__importStar(__webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js"));
let OutputWidget = OutputWidget_1 = class OutputWidget extends browser_2.BaseWidget {
    constructor() {
        super();
        this._state = { locked: false };
        this.toDisposeOnSelectedChannelChanged = new disposable_1.DisposableCollection();
        this.onStateChangedEmitter = new core_1.Emitter();
        this.id = OutputWidget_1.ID;
        this.title.label = OutputWidget_1.LABEL;
        this.title.caption = OutputWidget_1.LABEL;
        this.title.iconClass = (0, browser_2.codicon)('output');
        this.title.closable = true;
        this.addClass('theia-output');
        this.node.tabIndex = 0;
        this.editorContainer = new NoopDragOverDockPanel({ spacing: 0, mode: 'single-document' });
        this.editorContainer.addClass('editor-container');
        this.editorContainer.node.tabIndex = -1;
    }
    init() {
        this.toDispose.pushAll([
            this.outputChannelManager.onChannelWasHidden(() => this.refreshEditorWidget()),
            this.outputChannelManager.onChannelWasShown(({ preserveFocus }) => this.refreshEditorWidget({ preserveFocus: !!preserveFocus })),
            this.toDisposeOnSelectedChannelChanged,
            this.onStateChangedEmitter,
            this.onStateChanged(() => this.update())
        ]);
        this.refreshEditorWidget();
    }
    storeState() {
        return this.state;
    }
    restoreState(oldState) {
        const copy = (0, core_1.deepClone)(this.state);
        if (oldState.locked) {
            copy.locked = oldState.locked;
        }
        this.state = copy;
    }
    get state() {
        return this._state;
    }
    set state(state) {
        this._state = state;
        this.onStateChangedEmitter.fire(this._state);
    }
    async refreshEditorWidget({ preserveFocus } = { preserveFocus: false }) {
        const { selectedChannel } = this;
        const editorWidget = this.editorWidget;
        if (selectedChannel && editorWidget) {
            // If the input is the current one, do nothing.
            const model = editorWidget.editor.getControl().getModel();
            if (model && model.uri.toString() === selectedChannel.uri.toString()) {
                if (!preserveFocus) {
                    this.activate();
                }
                return;
            }
        }
        this.toDisposeOnSelectedChannelChanged.dispose();
        if (selectedChannel) {
            const widget = await this.createEditorWidget();
            if (widget) {
                this.editorContainer.addWidget(widget);
                this.toDisposeOnSelectedChannelChanged.pushAll([
                    disposable_1.Disposable.create(() => widget.close()),
                    selectedChannel.onContentChange(() => this.revealLastLine())
                ]);
                if (!preserveFocus) {
                    this.activate();
                }
                this.revealLastLine();
            }
        }
    }
    onAfterAttach(message) {
        super.onAfterAttach(message);
        browser_2.Widget.attach(this.editorContainer, this.node);
        this.toDisposeOnDetach.push(disposable_1.Disposable.create(() => browser_2.Widget.detach(this.editorContainer)));
    }
    onActivateRequest(message) {
        super.onActivateRequest(message);
        if (this.editor) {
            this.editor.focus();
        }
        else {
            this.node.focus();
        }
    }
    onResize(message) {
        super.onResize(message);
        browser_2.MessageLoop.sendMessage(this.editorContainer, browser_2.Widget.ResizeMessage.UnknownSize);
        for (const widget of (0, algorithm_1.toArray)(this.editorContainer.widgets())) {
            browser_2.MessageLoop.sendMessage(widget, browser_2.Widget.ResizeMessage.UnknownSize);
        }
    }
    onAfterShow(msg) {
        super.onAfterShow(msg);
        this.onResize(browser_2.Widget.ResizeMessage.UnknownSize); // Triggers an editor widget resize. (#8361)
    }
    get onStateChanged() {
        return this.onStateChangedEmitter.event;
    }
    clear() {
        if (this.selectedChannel) {
            this.selectedChannel.clear();
        }
    }
    selectAll() {
        const editor = this.editor;
        if (editor) {
            const model = editor.getControl().getModel();
            if (model) {
                const endLine = model.getLineCount();
                const endCharacter = model.getLineMaxColumn(endLine);
                editor.getControl().setSelection(new monaco.Range(1, 1, endLine, endCharacter));
            }
        }
    }
    lock() {
        this.state = { ...(0, core_1.deepClone)(this.state), locked: true };
    }
    unlock() {
        this.state = { ...(0, core_1.deepClone)(this.state), locked: false };
    }
    get isLocked() {
        return !!this.state.locked;
    }
    revealLastLine() {
        if (this.isLocked) {
            return;
        }
        const editor = this.editor;
        if (editor) {
            const model = editor.getControl().getModel();
            if (model) {
                const lineNumber = model.getLineCount();
                const column = model.getLineMaxColumn(lineNumber);
                editor.getControl().revealPosition({ lineNumber, column }, monaco.editor.ScrollType.Smooth);
            }
        }
    }
    get selectedChannel() {
        return this.outputChannelManager.selectedChannel;
    }
    async createEditorWidget() {
        if (!this.selectedChannel) {
            return undefined;
        }
        const { name } = this.selectedChannel;
        const editor = await this.editorProvider.get(output_uri_1.OutputUri.create(name));
        return new browser_1.EditorWidget(editor, this.selectionService);
    }
    get editorWidget() {
        for (const widget of (0, algorithm_1.toArray)(this.editorContainer.children())) {
            if (widget instanceof browser_1.EditorWidget) {
                return widget;
            }
        }
        return undefined;
    }
    get editor() {
        const widget = this.editorWidget;
        if (widget instanceof browser_1.EditorWidget) {
            if (widget.editor instanceof monaco_editor_1.MonacoEditor) {
                return widget.editor;
            }
        }
        return undefined;
    }
    getText() {
        var _a, _b;
        return (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().getModel()) === null || _b === void 0 ? void 0 : _b.getValue();
    }
};
exports.OutputWidget = OutputWidget;
OutputWidget.ID = 'outputView';
OutputWidget.LABEL = nls_1.nls.localizeByDefault('Output');
tslib_1.__decorate([
    (0, inversify_1.inject)(selection_service_1.SelectionService),
    tslib_1.__metadata("design:type", selection_service_1.SelectionService)
], OutputWidget.prototype, "selectionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider),
    tslib_1.__metadata("design:type", monaco_editor_provider_1.MonacoEditorProvider)
], OutputWidget.prototype, "editorProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(output_channel_1.OutputChannelManager),
    tslib_1.__metadata("design:type", output_channel_1.OutputChannelManager)
], OutputWidget.prototype, "outputChannelManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], OutputWidget.prototype, "init", null);
exports.OutputWidget = OutputWidget = OutputWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], OutputWidget);
/**
 * Customized `DockPanel` that does not allow dropping widgets into it.
 */
class NoopDragOverDockPanel extends browser_2.DockPanel {
}
NoopDragOverDockPanel.prototype['_evtDragOver'] = () => { };
NoopDragOverDockPanel.prototype['_evtDrop'] = () => { };
NoopDragOverDockPanel.prototype['_evtDragLeave'] = () => { };


/***/ }),

/***/ "../node_modules/@theia/output/lib/common/output-uri.js":
/*!**************************************************************!*\
  !*** ../node_modules/@theia/output/lib/common/output-uri.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputUri = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const uri_1 = tslib_1.__importDefault(__webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js"));
var OutputUri;
(function (OutputUri) {
    OutputUri.SCHEME = 'output';
    function is(uri) {
        if (uri instanceof uri_1.default) {
            return uri.scheme === OutputUri.SCHEME;
        }
        return is(new uri_1.default(uri));
    }
    OutputUri.is = is;
    function create(name) {
        if (!name) {
            throw new Error("'name' must be defined.");
        }
        if (!name.trim().length) {
            throw new Error("'name' must contain at least one non-whitespace character.");
        }
        return new uri_1.default(encodeURIComponent(name)).withScheme(OutputUri.SCHEME);
    }
    OutputUri.create = create;
    function channelName(uri) {
        if (!is(uri)) {
            throw new Error(`Expected '${OutputUri.SCHEME}' URI scheme. Got: ${uri} instead.`);
        }
        return (uri instanceof uri_1.default ? uri : new uri_1.default(uri)).toString(true).slice(`${OutputUri.SCHEME}:/`.length);
    }
    OutputUri.channelName = channelName;
})(OutputUri || (exports.OutputUri = OutputUri = {}));


/***/ }),

/***/ "../node_modules/@theia/output/src/browser/style/output.css":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/output/src/browser/style/output.css ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_output_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./output.css */ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/output/src/browser/style/output.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_output_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_output_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OVSXRouterClient = exports.OVSXMockClient = exports.OVSX_RATE_LIMIT = exports.OVSXHttpClient = exports.OVSXApiFilterProvider = exports.OVSXApiFilterImpl = exports.OVSXApiFilter = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
var ovsx_api_filter_1 = __webpack_require__(/*! ./ovsx-api-filter */ "../node_modules/@theia/ovsx-client/lib/ovsx-api-filter.js");
Object.defineProperty(exports, "OVSXApiFilter", ({ enumerable: true, get: function () { return ovsx_api_filter_1.OVSXApiFilter; } }));
Object.defineProperty(exports, "OVSXApiFilterImpl", ({ enumerable: true, get: function () { return ovsx_api_filter_1.OVSXApiFilterImpl; } }));
Object.defineProperty(exports, "OVSXApiFilterProvider", ({ enumerable: true, get: function () { return ovsx_api_filter_1.OVSXApiFilterProvider; } }));
var ovsx_http_client_1 = __webpack_require__(/*! ./ovsx-http-client */ "../node_modules/@theia/ovsx-client/lib/ovsx-http-client.js");
Object.defineProperty(exports, "OVSXHttpClient", ({ enumerable: true, get: function () { return ovsx_http_client_1.OVSXHttpClient; } }));
Object.defineProperty(exports, "OVSX_RATE_LIMIT", ({ enumerable: true, get: function () { return ovsx_http_client_1.OVSX_RATE_LIMIT; } }));
var ovsx_mock_client_1 = __webpack_require__(/*! ./ovsx-mock-client */ "../node_modules/@theia/ovsx-client/lib/ovsx-mock-client.js");
Object.defineProperty(exports, "OVSXMockClient", ({ enumerable: true, get: function () { return ovsx_mock_client_1.OVSXMockClient; } }));
var ovsx_router_client_1 = __webpack_require__(/*! ./ovsx-router-client */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-client.js");
Object.defineProperty(exports, "OVSXRouterClient", ({ enumerable: true, get: function () { return ovsx_router_client_1.OVSXRouterClient; } }));
tslib_1.__exportStar(__webpack_require__(/*! ./ovsx-router-filters */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./ovsx-types */ "../node_modules/@theia/ovsx-client/lib/ovsx-types.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-api-filter.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-api-filter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OVSXApiFilterImpl = exports.OVSXApiFilter = exports.OVSXApiFilterProvider = void 0;
const semver = __webpack_require__(/*! semver */ "../node_modules/semver/index.js");
const ovsx_types_1 = __webpack_require__(/*! ./ovsx-types */ "../node_modules/@theia/ovsx-client/lib/ovsx-types.js");
exports.OVSXApiFilterProvider = Symbol('OVSXApiFilterProvider');
exports.OVSXApiFilter = Symbol('OVSXApiFilter');
class OVSXApiFilterImpl {
    constructor(client, supportedApiVersion) {
        this.client = client;
        this.supportedApiVersion = supportedApiVersion;
    }
    async findLatestCompatibleExtension(query) {
        const targetPlatform = query.targetPlatform;
        if (!targetPlatform) {
            return this.queryLatestCompatibleExtension(query);
        }
        const latestWithTargetPlatform = await this.queryLatestCompatibleExtension(query);
        let latestUniversal;
        if (targetPlatform !== 'universal' && targetPlatform !== 'web') {
            // Additionally query the universal version, as there might be a newer one available
            latestUniversal = await this.queryLatestCompatibleExtension({ ...query, targetPlatform: 'universal' });
        }
        if (latestWithTargetPlatform && latestUniversal) {
            // Prefer the version with the target platform if it's greater or equal to the universal version
            return this.versionGreaterThanOrEqualTo(latestWithTargetPlatform.version, latestUniversal.version) ? latestWithTargetPlatform : latestUniversal;
        }
        return latestWithTargetPlatform !== null && latestWithTargetPlatform !== void 0 ? latestWithTargetPlatform : latestUniversal;
    }
    async queryLatestCompatibleExtension(query) {
        let offset = 0;
        let size = 5;
        let loop = true;
        while (loop) {
            const queryOptions = {
                ...query,
                offset,
                size // there is a great chance that the newest version will work
            };
            const results = await this.client.query(queryOptions);
            const compatibleExtension = this.getLatestCompatibleExtension(results.extensions);
            if (compatibleExtension) {
                return compatibleExtension;
            }
            // Adjust offset by the amount of returned extensions
            offset += results.extensions.length;
            // Continue querying if there are more extensions available
            loop = results.totalSize > offset;
            // Adjust the size to fetch more extensions next time
            size = Math.min(size * 2, 100);
        }
        return undefined;
    }
    getLatestCompatibleExtension(extensions) {
        if (extensions.length === 0) {
            return;
        }
        else if (this.isBuiltinNamespace(extensions[0].namespace.toLowerCase())) {
            return extensions.find(extension => this.versionGreaterThanOrEqualTo(this.supportedApiVersion, extension.version));
        }
        else {
            return extensions.find(extension => { var _a, _b; return this.supportedVscodeApiSatisfies((_b = (_a = extension.engines) === null || _a === void 0 ? void 0 : _a.vscode) !== null && _b !== void 0 ? _b : '*'); });
        }
    }
    getLatestCompatibleVersion(searchEntry) {
        function getLatestCompatibleVersion(predicate) {
            if (searchEntry.allVersions) {
                return searchEntry.allVersions.find(predicate);
            }
            // If the allVersions field is missing then try to use the
            // searchEntry as VSXAllVersions and check if it's compatible:
            if (predicate(searchEntry)) {
                return searchEntry;
            }
        }
        if (this.isBuiltinNamespace(searchEntry.namespace)) {
            return getLatestCompatibleVersion(allVersions => this.versionGreaterThanOrEqualTo(this.supportedApiVersion, allVersions.version));
        }
        else {
            return getLatestCompatibleVersion(allVersions => { var _a, _b; return this.supportedVscodeApiSatisfies((_b = (_a = allVersions.engines) === null || _a === void 0 ? void 0 : _a.vscode) !== null && _b !== void 0 ? _b : '*'); });
        }
    }
    isBuiltinNamespace(namespace) {
        return ovsx_types_1.VSXBuiltinNamespaces.is(namespace);
    }
    /**
     * @returns `a >= b`
     */
    versionGreaterThanOrEqualTo(a, b) {
        const versionA = semver.clean(a);
        const versionB = semver.clean(b);
        if (!versionA || !versionB) {
            return false;
        }
        return semver.gte(versionA, versionB);
    }
    supportedVscodeApiSatisfies(vscodeApiRange) {
        return semver.satisfies(this.supportedApiVersion, vscodeApiRange);
    }
}
exports.OVSXApiFilterImpl = OVSXApiFilterImpl;


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-http-client.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-http-client.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OVSXHttpClient = exports.OVSX_RATE_LIMIT = void 0;
const request_1 = __webpack_require__(/*! @theia/request */ "../node_modules/@theia/request/lib/index.js");
const limiter_1 = __webpack_require__(/*! limiter */ "../node_modules/limiter/dist/cjs/index.js");
exports.OVSX_RATE_LIMIT = 15;
class OVSXHttpClient {
    /**
     * @param requestService
     * @returns factory that will cache clients based on the requested input URL.
     */
    static createClientFactory(requestService, rateLimiter) {
        // eslint-disable-next-line no-null/no-null
        const cachedClients = Object.create(null);
        return url => { var _a; return (_a = cachedClients[url]) !== null && _a !== void 0 ? _a : (cachedClients[url] = new this(url, requestService, rateLimiter)); };
    }
    constructor(vsxRegistryUrl, requestService, rateLimiter = new limiter_1.RateLimiter({ tokensPerInterval: exports.OVSX_RATE_LIMIT, interval: 'second' })) {
        this.vsxRegistryUrl = vsxRegistryUrl;
        this.requestService = requestService;
        this.rateLimiter = rateLimiter;
    }
    search(searchOptions) {
        return this.requestJson(this.buildUrl('api/-/search', searchOptions));
    }
    query(queryOptions) {
        return this.requestJson(this.buildUrl('api/v2/-/query', queryOptions));
    }
    async requestJson(url) {
        const attempts = 5;
        for (let i = 0; i < attempts; i++) {
            // Use 1, 2, 4, 8, 16 tokens for each attempt
            const tokenCount = Math.pow(2, i);
            await this.rateLimiter.removeTokens(tokenCount);
            const context = await this.requestService.request({
                url,
                headers: { 'Accept': 'application/json' }
            });
            if (context.res.statusCode === 429) {
                console.warn('OVSX rate limit exceeded. Consider reducing the rate limit.');
                // If there are still more attempts left, retry the request with a higher token count
                if (i < attempts - 1) {
                    continue;
                }
            }
            return request_1.RequestContext.asJson(context);
        }
        throw new Error('Failed to fetch data from OVSX.');
    }
    buildUrl(url, query) {
        return new URL(`${url}${this.buildQueryString(query)}`, this.vsxRegistryUrl).toString();
    }
    buildQueryString(searchQuery) {
        if (!searchQuery) {
            return '';
        }
        let queryString = '';
        for (const [key, value] of Object.entries(searchQuery)) {
            if (typeof value === 'string') {
                queryString += `&${key}=${encodeURIComponent(value)}`;
            }
            else if (typeof value === 'boolean' || typeof value === 'number') {
                queryString += `&${key}=${value}`;
            }
        }
        return queryString && '?' + queryString.slice(1);
    }
}
exports.OVSXHttpClient = OVSXHttpClient;


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-mock-client.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-mock-client.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OVSXMockClient = void 0;
/**
 * Querying will only find exact matches.
 * Searching will try to find the query string in various fields.
 */
class OVSXMockClient {
    constructor(extensions = []) {
        this.extensions = extensions;
    }
    setExtensions(extensions) {
        this.extensions = extensions;
        return this;
    }
    /**
     * @param baseUrl required to construct the URLs required by {@link VSXExtensionRaw}.
     * @param ids list of ids to generate {@link VSXExtensionRaw} from.
     */
    setExtensionsFromIds(baseUrl, ids) {
        const now = Date.now();
        const url = new OVSXMockClient.UrlBuilder(baseUrl);
        this.extensions = ids.map((extension, i) => {
            const [id, version = '0.0.1'] = extension.split('@', 2);
            const [namespace, name] = id.split('.', 2);
            return {
                allVersions: {
                    [version]: url.extensionUrl(namespace, name, `/${version}`)
                },
                displayName: name,
                downloadCount: 0,
                files: {
                    download: url.extensionFileUrl(namespace, name, version, `/${id}-${version}.vsix`)
                },
                name,
                namespace,
                namespaceAccess: 'public',
                namespaceUrl: url.namespaceUrl(namespace),
                publishedBy: {
                    loginName: 'mock'
                },
                reviewCount: 0,
                reviewsUrl: url.extensionReviewsUrl(namespace, name),
                timestamp: new Date(now - ids.length + i + 1).toISOString(),
                version,
                description: `Mock VS Code Extension for ${id}`,
                namespaceDisplayName: name,
                preRelease: false
            };
        });
        return this;
    }
    async query(queryOptions) {
        const extensions = this.extensions
            .filter(extension => typeof queryOptions === 'object' && (this.compare(queryOptions.extensionId, this.id(extension)) &&
            this.compare(queryOptions.extensionName, extension.name) &&
            this.compare(queryOptions.extensionVersion, extension.version) &&
            this.compare(queryOptions.namespaceName, extension.namespace)));
        return {
            offset: 0,
            totalSize: extensions.length,
            extensions
        };
    }
    async search(searchOptions) {
        var _a, _b;
        const query = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.query;
        const offset = (_a = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.offset) !== null && _a !== void 0 ? _a : 0;
        const size = (_b = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.size) !== null && _b !== void 0 ? _b : 18;
        const end = offset + size;
        return {
            offset,
            extensions: this.extensions
                .filter(extension => typeof query !== 'string' || (this.includes(query, this.id(extension)) ||
                this.includes(query, extension.description) ||
                this.includes(query, extension.displayName)))
                .sort((a, b) => this.sort(a, b, searchOptions))
                .filter((extension, i) => i >= offset && i < end)
                .map(extension => ({
                downloadCount: extension.downloadCount,
                files: extension.files,
                name: extension.name,
                namespace: extension.namespace,
                timestamp: extension.timestamp,
                url: `${extension.namespaceUrl}/${extension.name}`,
                version: extension.version,
            }))
        };
    }
    id(extension) {
        return `${extension.namespace}.${extension.name}`;
    }
    /**
     * Case sensitive.
     */
    compare(expected, value) {
        return expected === undefined || value === undefined || expected === value;
    }
    /**
     * Case insensitive.
     */
    includes(needle, value) {
        return value === undefined || value.toLowerCase().includes(needle.toLowerCase());
    }
    sort(a, b, searchOptions) {
        var _a, _b, _c, _d;
        let order = 0;
        const sortBy = (_a = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.sortBy) !== null && _a !== void 0 ? _a : 'relevance';
        const sortOrder = (_b = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.sortOrder) !== null && _b !== void 0 ? _b : 'desc';
        if (sortBy === 'averageRating') {
            order = ((_c = a.averageRating) !== null && _c !== void 0 ? _c : -1) - ((_d = b.averageRating) !== null && _d !== void 0 ? _d : -1);
        }
        else if (sortBy === 'downloadCount') {
            order = a.downloadCount - b.downloadCount;
        }
        else if (sortBy === 'relevance') {
            order = 0;
        }
        else if (sortBy === 'timestamp') {
            order = new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
        }
        if (sortOrder === 'asc') {
            order *= -1;
        }
        return order;
    }
}
exports.OVSXMockClient = OVSXMockClient;
(function (OVSXMockClient) {
    /**
     * URLs should respect the official OpenVSX API:
     * https://open-vsx.org/swagger-ui/index.html
     */
    class UrlBuilder {
        constructor(baseUrl) {
            this.baseUrl = baseUrl;
        }
        url(path) {
            return this.baseUrl + path;
        }
        apiUrl(path) {
            return this.url(`/api${path}`);
        }
        namespaceUrl(namespace, path = '') {
            return this.apiUrl(`/${namespace}${path}`);
        }
        extensionUrl(namespace, name, path = '') {
            return this.apiUrl(`/${namespace}/${name}${path}`);
        }
        extensionReviewsUrl(namespace, name) {
            return this.apiUrl(`/${namespace}/${name}/reviews`);
        }
        extensionFileUrl(namespace, name, version, path = '') {
            return this.apiUrl(`/${namespace}/${name}/${version}/file${path}`);
        }
    }
    OVSXMockClient.UrlBuilder = UrlBuilder;
})(OVSXMockClient || (exports.OVSXMockClient = OVSXMockClient = {}));


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-router-client.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-router-client.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OVSXRouterClient = exports.createFilterFactory = void 0;
/**
 * Helper function to create factories that handle a single condition key.
 */
function createFilterFactory(conditionKey, factory) {
    return (conditions, remainingKeys) => {
        if (conditionKey in conditions) {
            const filter = factory(conditions[conditionKey]);
            if (filter) {
                remainingKeys.delete(conditionKey);
                return filter;
            }
        }
    };
}
exports.createFilterFactory = createFilterFactory;
/**
 * Route and agglomerate queries according to {@link routerConfig}.
 * {@link ruleFactories} is the actual logic used to evaluate the config.
 * Each rule implementation will be ran sequentially over each configured rule.
 */
class OVSXRouterClient {
    static async FromConfig(routerConfig, clientProvider, filterFactories) {
        const rules = routerConfig.rules ? await this.ParseRules(routerConfig.rules, filterFactories, routerConfig.registries) : [];
        return new this(this.ParseUse(routerConfig.use, routerConfig.registries), clientProvider, rules);
    }
    static async ParseRules(rules, filterFactories, aliases) {
        return Promise.all(rules.map(async ({ use, ...conditions }) => {
            const remainingKeys = new Set(Object.keys(conditions));
            const filters = removeNullValues(await Promise.all(filterFactories.map(filterFactory => filterFactory(conditions, remainingKeys))));
            if (remainingKeys.size > 0) {
                throw new Error(`unknown conditions: ${Array.from(remainingKeys).join(', ')}`);
            }
            return {
                filters,
                use: this.ParseUse(use, aliases)
            };
        }));
    }
    static ParseUse(use, aliases) {
        if (typeof use === 'string') {
            return [alias(use)];
        }
        else if (Array.isArray(use)) {
            return use.map(alias);
        }
        else {
            return [];
        }
        function alias(aliasOrUri) {
            var _a;
            return (_a = aliases === null || aliases === void 0 ? void 0 : aliases[aliasOrUri]) !== null && _a !== void 0 ? _a : aliasOrUri;
        }
    }
    constructor(useDefault, clientProvider, rules) {
        this.useDefault = useDefault;
        this.clientProvider = clientProvider;
        this.rules = rules;
    }
    async search(searchOptions) {
        return this.runRules(filter => { var _a; return (_a = filter.filterSearchOptions) === null || _a === void 0 ? void 0 : _a.call(filter, searchOptions); }, rule => rule.use.length > 0
            ? this.mergedSearch(rule.use, searchOptions)
            : this.emptySearchResult(searchOptions), () => this.mergedSearch(this.useDefault, searchOptions));
    }
    async query(queryOptions = {}) {
        return this.runRules(filter => { var _a; return (_a = filter.filterQueryOptions) === null || _a === void 0 ? void 0 : _a.call(filter, queryOptions); }, rule => rule.use.length > 0
            ? this.mergedQuery(rule.use, queryOptions)
            : this.emptyQueryResult(queryOptions), () => this.mergedQuery(this.useDefault, queryOptions));
    }
    emptySearchResult(searchOptions) {
        var _a;
        return {
            extensions: [],
            offset: (_a = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.offset) !== null && _a !== void 0 ? _a : 0
        };
    }
    emptyQueryResult(queryOptions) {
        return {
            offset: 0,
            totalSize: 0,
            extensions: []
        };
    }
    async mergedQuery(registries, queryOptions) {
        return this.mergeQueryResults(await createMapping(registries, async (registry) => (await this.clientProvider(registry)).query(queryOptions)));
    }
    async mergedSearch(registries, searchOptions) {
        return this.mergeSearchResults(await createMapping(registries, async (registry) => (await this.clientProvider(registry)).search(searchOptions)));
    }
    async mergeSearchResults(results) {
        const filtering = [];
        results.forEach((result, sourceUri) => {
            filtering.push(Promise
                .all(result.extensions.map(extension => this.filterExtension(sourceUri, extension)))
                .then(removeNullValues));
        });
        return {
            extensions: interleave(await Promise.all(filtering)),
            offset: Math.min(...Array.from(results.values(), result => result.offset))
        };
    }
    async mergeQueryResults(results) {
        const filtering = [];
        results.forEach((result, sourceUri) => {
            result.extensions.forEach(extension => filtering.push(this.filterExtension(sourceUri, extension)));
        });
        const extensions = removeNullValues(await Promise.all(filtering));
        return {
            offset: 0,
            totalSize: extensions.length,
            extensions
        };
    }
    async filterExtension(sourceUri, extension) {
        return this.runRules(filter => { var _a; return (_a = filter.filterExtension) === null || _a === void 0 ? void 0 : _a.call(filter, extension); }, rule => rule.use.includes(sourceUri) ? extension : undefined, () => extension);
    }
    async runRules(runFilter, onRuleMatched, onNoRuleMatched) {
        for (const rule of this.rules) {
            const results = removeNullValues(await Promise.all(rule.filters.map(filter => runFilter(filter))));
            if (results.length > 0 && results.every(value => value)) {
                return onRuleMatched(rule);
            }
        }
        return onNoRuleMatched === null || onNoRuleMatched === void 0 ? void 0 : onNoRuleMatched();
    }
}
exports.OVSXRouterClient = OVSXRouterClient;
function nonNullable(value) {
    // eslint-disable-next-line no-null/no-null
    return typeof value !== 'undefined' && value !== null;
}
function removeNullValues(values) {
    return values.filter(nonNullable);
}
/**
 * Create a map where the keys are each element from {@link values} and the
 * values are the result of a mapping function applied on the key.
 */
async function createMapping(values, map, thisArg) {
    return new Map(await Promise.all(values.map(async (value, index) => [value, await map.call(thisArg, value, index)])));
}
/**
 * @example
 * interleave([[1, 2, 3], [4, 5], [6, 7, 8]]) === [1, 4, 6, 2, 5, 7, 3, 8]
 */
function interleave(arrays) {
    const interleaved = [];
    const length = Math.max(...arrays.map(array => array.length));
    for (let i = 0; i < length; i++) {
        for (const array of arrays) {
            if (i < array.length) {
                interleaved.push(array[i]);
            }
        }
    }
    return interleaved;
}


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/abstract-reg-exp-filter.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/abstract-reg-exp-filter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractRegExpFilter = void 0;
class AbstractRegExpFilter {
    constructor(regExp) {
        this.regExp = regExp;
    }
    test(value) {
        return typeof value === 'string' && this.regExp.test(value);
    }
}
exports.AbstractRegExpFilter = AbstractRegExpFilter;


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/extension-id-matches-filter.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/extension-id-matches-filter.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionIdMatchesFilter = exports.ExtensionIdMatchesFilterFactory = void 0;
const ovsx_router_client_1 = __webpack_require__(/*! ../ovsx-router-client */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-client.js");
const ovsx_types_1 = __webpack_require__(/*! ../ovsx-types */ "../node_modules/@theia/ovsx-client/lib/ovsx-types.js");
const abstract_reg_exp_filter_1 = __webpack_require__(/*! ./abstract-reg-exp-filter */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/abstract-reg-exp-filter.js");
exports.ExtensionIdMatchesFilterFactory = (0, ovsx_router_client_1.createFilterFactory)('ifExtensionIdMatches', ifExtensionIdMatches => {
    if (typeof ifExtensionIdMatches !== 'string') {
        throw new TypeError(`expected a string, got: ${typeof ifExtensionIdMatches}`);
    }
    return new ExtensionIdMatchesFilter(new RegExp(ifExtensionIdMatches, 'i'));
});
class ExtensionIdMatchesFilter extends abstract_reg_exp_filter_1.AbstractRegExpFilter {
    filterExtension(extension) {
        return this.test(ovsx_types_1.ExtensionLike.id(extension));
    }
}
exports.ExtensionIdMatchesFilter = ExtensionIdMatchesFilter;


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/index.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestContainsFilterFactory = exports.ExtensionIdMatchesFilterFactory = void 0;
var extension_id_matches_filter_1 = __webpack_require__(/*! ./extension-id-matches-filter */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/extension-id-matches-filter.js");
Object.defineProperty(exports, "ExtensionIdMatchesFilterFactory", ({ enumerable: true, get: function () { return extension_id_matches_filter_1.ExtensionIdMatchesFilterFactory; } }));
var request_contains_filter_1 = __webpack_require__(/*! ./request-contains-filter */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/request-contains-filter.js");
Object.defineProperty(exports, "RequestContainsFilterFactory", ({ enumerable: true, get: function () { return request_contains_filter_1.RequestContainsFilterFactory; } }));


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/request-contains-filter.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/request-contains-filter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestContainsFilter = exports.RequestContainsFilterFactory = void 0;
const ovsx_router_client_1 = __webpack_require__(/*! ../ovsx-router-client */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-client.js");
const abstract_reg_exp_filter_1 = __webpack_require__(/*! ./abstract-reg-exp-filter */ "../node_modules/@theia/ovsx-client/lib/ovsx-router-filters/abstract-reg-exp-filter.js");
exports.RequestContainsFilterFactory = (0, ovsx_router_client_1.createFilterFactory)('ifRequestContains', ifRequestContains => {
    if (typeof ifRequestContains !== 'string') {
        throw new TypeError(`expected a string, got: ${typeof ifRequestContains}`);
    }
    return new RequestContainsFilter(new RegExp(ifRequestContains, 'i'));
});
class RequestContainsFilter extends abstract_reg_exp_filter_1.AbstractRegExpFilter {
    filterSearchOptions(searchOptions) {
        return !searchOptions || this.test(searchOptions.query) || this.test(searchOptions.category);
    }
    filterQueryOptions(queryOptions) {
        return !queryOptions || Object.values(queryOptions).some(this.test, this);
    }
}
exports.RequestContainsFilter = RequestContainsFilter;


/***/ }),

/***/ "../node_modules/@theia/ovsx-client/lib/ovsx-types.js":
/*!************************************************************!*\
  !*** ../node_modules/@theia/ovsx-client/lib/ovsx-types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VSXBuiltinNamespaces = exports.VSXResponseError = exports.ExtensionLike = void 0;
var ExtensionLike;
(function (ExtensionLike) {
    function id(extension) {
        return `${extension.namespace}.${extension.name}`;
    }
    ExtensionLike.id = id;
    function idWithVersion(extension) {
        if (!extension.version) {
            throw new Error(`no valid "version" value provided for "${id(extension)}"`);
        }
        return `${id(extension)}@${extension.version}`;
    }
    ExtensionLike.idWithVersion = idWithVersion;
    // eslint-disable-next-line @typescript-eslint/no-shadow
    function fromId(id) {
        const [left, version] = id.split('@', 2);
        const [namespace, name] = left.split('.', 2);
        return {
            name,
            namespace,
            version
        };
    }
    ExtensionLike.fromId = fromId;
})(ExtensionLike || (exports.ExtensionLike = ExtensionLike = {}));
var VSXResponseError;
(function (VSXResponseError) {
    function is(error) {
        return !!error && typeof error === 'object' && typeof error.statusCode === 'number';
    }
    VSXResponseError.is = is;
})(VSXResponseError || (exports.VSXResponseError = VSXResponseError = {}));
/**
 * Builtin namespaces maintained by the framework.
 */
var VSXBuiltinNamespaces;
(function (VSXBuiltinNamespaces) {
    /**
     * Namespace for individual vscode builtin extensions.
     */
    VSXBuiltinNamespaces.VSCODE = 'vscode';
    /**
     * Namespace for vscode builtin extension packs.
     * - corresponds to: https://github.com/eclipse-theia/vscode-builtin-extensions/blob/af9cfeb2ea23e1668a8340c1c2fb5afd56be07d7/src/create-extension-pack.js#L45
     */
    VSXBuiltinNamespaces.THEIA = 'eclipse-theia';
    /**
     * Determines if the extension namespace is a builtin maintained by the framework.
     * @param namespace the extension namespace to verify.
     */
    function is(namespace) {
        return namespace === VSXBuiltinNamespaces.VSCODE
            || namespace === VSXBuiltinNamespaces.THEIA;
    }
    VSXBuiltinNamespaces.is = is;
})(VSXBuiltinNamespaces || (exports.VSXBuiltinNamespaces = VSXBuiltinNamespaces = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguagePackService = exports.languagePackServicePath = void 0;
exports.languagePackServicePath = '/services/languagePackService';
exports.LanguagePackService = Symbol('LanguagePackService');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostedPluginWatcher = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
let HostedPluginWatcher = class HostedPluginWatcher {
    constructor() {
        this.onPostMessage = new event_1.Emitter();
        this.onLogMessage = new event_1.Emitter();
        this.onDidDeployEmitter = new event_1.Emitter();
        this.onDidDeploy = this.onDidDeployEmitter.event;
    }
    getHostedPluginClient() {
        const messageEmitter = this.onPostMessage;
        const logEmitter = this.onLogMessage;
        return {
            postMessage(pluginHostId, message) {
                messageEmitter.fire({ pluginHostId, message });
                return Promise.resolve();
            },
            log(logPart) {
                logEmitter.fire(logPart);
                return Promise.resolve();
            },
            onDidDeploy: () => this.onDidDeployEmitter.fire(undefined)
        };
    }
    get onPostMessageEvent() {
        return this.onPostMessage.event;
    }
    get onLogMessageEvent() {
        return this.onLogMessage.event;
    }
};
exports.HostedPluginWatcher = HostedPluginWatcher;
exports.HostedPluginWatcher = HostedPluginWatcher = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], HostedPluginWatcher);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts
var HostedPluginSupport_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostedPluginSupport = exports.PluginProgressLocation = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../node_modules/@theia/core/lib/common/uuid.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_worker_1 = __webpack_require__(/*! ./plugin-worker */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const hosted_plugin_watcher_1 = __webpack_require__(/*! ./hosted-plugin-watcher */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const main_context_1 = __webpack_require__(/*! ../../main/browser/main-context */ "../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const plugin_contribution_handler_1 = __webpack_require__(/*! ../../main/browser/plugin-contribution-handler */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js");
const env_main_1 = __webpack_require__(/*! ../../main/browser/env-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js");
const preference_registry_main_1 = __webpack_require__(/*! ../../main/browser/preference-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const debug_session_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_configuration_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-configuration-manager */ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const file_search_service_1 = __webpack_require__(/*! @theia/file-search/lib/common/file-search-service */ "../node_modules/@theia/file-search/lib/common/file-search-service.js");
const frontend_application_state_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-state */ "../node_modules/@theia/core/lib/browser/frontend-application-state.js");
const plugin_view_registry_1 = __webpack_require__(/*! ../../main/browser/view/plugin-view-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const task_contribution_1 = __webpack_require__(/*! @theia/task/lib/browser/task-contribution */ "../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_definition_registry_1 = __webpack_require__(/*! @theia/task/lib/browser/task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const webview_environment_1 = __webpack_require__(/*! ../../main/browser/webview/webview-environment */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const webview_1 = __webpack_require__(/*! ../../main/browser/webview/webview */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../node_modules/@theia/core/lib/browser/widget-manager.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
const json_schema_store_1 = __webpack_require__(/*! @theia/core/lib/browser/json-schema-store */ "../node_modules/@theia/core/lib/browser/json-schema-store.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ../../main/browser/custom-editors/plugin-custom-editor-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const custom_editor_widget_1 = __webpack_require__(/*! ../../main/browser/custom-editors/custom-editor-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const language_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/languages/language */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/languages/language.js");
const uint8_array_message_buffer_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/uint8-array-message-buffer */ "../node_modules/@theia/core/lib/common/message-rpc/uint8-array-message-buffer.js");
const channel_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/channel */ "../node_modules/@theia/core/lib/common/message-rpc/channel.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const application_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/application-protocol */ "../node_modules/@theia/core/lib/common/application-protocol.js");
const hosted_plugin_1 = __webpack_require__(/*! ../common/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js");
const browser_3 = __webpack_require__(/*! @theia/core/lib/browser/browser */ "../node_modules/@theia/core/lib/browser/browser.js");
exports.PluginProgressLocation = 'plugin';
let HostedPluginSupport = HostedPluginSupport_1 = class HostedPluginSupport extends hosted_plugin_1.AbstractHostedPluginSupport {
    constructor() {
        super((0, uuid_1.generateUuid)());
        this.webviewsToRestore = new Map();
        this.webviewRevivers = new Map();
    }
    init() {
        super.init();
        this.workspaceService.onWorkspaceChanged(() => this.updateStoragePath());
        const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
        for (const language of languageService['_requestedBasicLanguages']) {
            this.activateByLanguage(language);
        }
        languageService.onDidRequestBasicLanguageFeatures(language => this.activateByLanguage(language));
        this.commands.onWillExecuteCommand(event => this.ensureCommandHandlerRegistration(event));
        this.debugSessionManager.onWillStartDebugSession(event => this.ensureDebugActivation(event));
        this.debugSessionManager.onWillResolveDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugResolve', event.debugType));
        this.debugConfigurationManager.onWillProvideDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugInitialConfigurations'));
        // Activate all providers of dynamic configurations, i.e. Let the user pick a configuration from all the available ones.
        this.debugConfigurationManager.onWillProvideDynamicDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugDynamicConfigurations', hosted_plugin_1.ALL_ACTIVATION_EVENT));
        this.viewRegistry.onDidExpandView(id => this.activateByView(id));
        this.taskProviderRegistry.onWillProvideTaskProvider(event => this.ensureTaskActivation(event));
        this.taskResolverRegistry.onWillProvideTaskResolver(event => this.ensureTaskActivation(event));
        this.fileService.onWillActivateFileSystemProvider(event => this.ensureFileSystemActivation(event));
        this.customEditorRegistry.onWillOpenCustomEditor(event => this.activateByCustomEditor(event));
        this.notebookService.onWillOpenNotebook(async (event) => this.activateByNotebook(event));
        this.notebookRendererMessagingService.onWillActivateRenderer(rendererId => this.activateByNotebookRenderer(rendererId));
        this.widgets.onDidCreateWidget(({ factoryId, widget }) => {
            // note: state restoration of custom editors is handled in `PluginCustomEditorRegistry.init`
            if (factoryId === webview_1.WebviewWidget.FACTORY_ID && widget instanceof webview_1.WebviewWidget) {
                const storeState = widget.storeState.bind(widget);
                const restoreState = widget.restoreState.bind(widget);
                widget.storeState = () => {
                    if (this.webviewRevivers.has(widget.viewType)) {
                        return storeState();
                    }
                    return undefined;
                };
                widget.restoreState = state => {
                    if (state.viewType) {
                        restoreState(state);
                        this.preserveWebview(widget);
                    }
                    else {
                        widget.dispose();
                    }
                };
            }
        });
    }
    createTheiaReadyPromise() {
        return Promise.all([this.preferenceServiceImpl.ready, this.workspaceService.roots]);
    }
    runOperation(operation) {
        return this.progressService.withProgress('', exports.PluginProgressLocation, () => this.doLoad());
    }
    afterStart() {
        this.watcher.onDidDeploy(() => this.load());
        this.server.onDidOpenConnection(() => this.load());
    }
    // Only load connection-scoped plugins
    acceptPlugin(plugin) {
        return (0, hosted_plugin_1.isConnectionScopedBackendPlugin)(plugin);
    }
    async beforeSyncPlugins(toDisconnect) {
        await super.beforeSyncPlugins(toDisconnect);
        toDisconnect.push(core_1.Disposable.create(() => this.preserveWebviews()));
        this.server.onDidCloseConnection(() => toDisconnect.dispose());
    }
    async beforeLoadContributions(toDisconnect) {
        // make sure that the previous state, including plugin widgets, is restored
        // and core layout is initialized, i.e. explorer, scm, debug views are already added to the shell
        // but shell is not yet revealed
        await this.appState.reachedState('initialized_layout');
    }
    async afterLoadContributions(toDisconnect) {
        await this.viewRegistry.initWidgets();
        // remove restored plugin widgets which were not registered by contributions
        this.viewRegistry.removeStaleWidgets();
    }
    handleContributions(plugin) {
        return this.contributionHandler.handleContributions(this.clientId, plugin);
    }
    handlePluginStarted(manager, plugin) {
        this.activateByWorkspaceContains(manager, plugin);
    }
    async obtainManager(host, hostContributions, toDisconnect) {
        var _a;
        let manager = this.managers.get(host);
        if (!manager) {
            const pluginId = (0, plugin_protocol_1.getPluginId)(hostContributions[0].plugin.metadata.model);
            const rpc = this.initRpc(host, pluginId);
            toDisconnect.push(rpc);
            manager = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.HOSTED_PLUGIN_MANAGER_EXT);
            this.managers.set(host, manager);
            toDisconnect.push(core_1.Disposable.create(() => this.managers.delete(host)));
            const [extApi, globalState, workspaceState, webviewResourceRoot, webviewCspSource, defaultShell, jsonValidation] = await Promise.all([
                this.server.getExtPluginAPI(),
                this.pluginServer.getAllStorageValues(undefined),
                this.pluginServer.getAllStorageValues({
                    workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
                    roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
                }),
                this.webviewEnvironment.resourceRoot(host),
                this.webviewEnvironment.cspSource(),
                this.terminalService.getDefaultShell(),
                this.jsonSchemaStore.schemas
            ]);
            if (toDisconnect.disposed) {
                return undefined;
            }
            const isElectron = environment_1.environment.electron.is();
            const supportedActivationEvents = [...HostedPluginSupport_1.BUILTIN_ACTIVATION_EVENTS];
            const [additionalActivationEvents, appRoot] = await Promise.all([
                this.envServer.getValue(HostedPluginSupport_1.ADDITIONAL_ACTIVATION_EVENTS_ENV),
                this.applicationServer.getApplicationRoot()
            ]);
            if (additionalActivationEvents && additionalActivationEvents.value) {
                additionalActivationEvents.value.split(',').forEach(event => supportedActivationEvents.push(event));
            }
            await manager.$init({
                preferences: (0, preference_registry_main_1.getPreferences)(this.preferenceProviderProvider, this.workspaceService.tryGetRoots()),
                globalState,
                workspaceState,
                env: {
                    queryParams: (0, env_main_1.getQueryParameters)(),
                    language: core_1.nls.locale || core_1.nls.defaultLocale,
                    shell: defaultShell,
                    uiKind: isElectron ? plugin_api_rpc_1.UIKind.Desktop : plugin_api_rpc_1.UIKind.Web,
                    appName: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName,
                    appHost: isElectron ? 'desktop' : 'web', // TODO: 'web' could be the embedder's name, e.g. 'github.dev'
                    appRoot,
                    appUriScheme: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().electron.uriScheme
                },
                extApi,
                webview: {
                    webviewResourceRoot,
                    webviewCspSource
                },
                jsonValidation,
                pluginKind: browser_3.isRemote ? plugin_api_rpc_1.ExtensionKind.Workspace : plugin_api_rpc_1.ExtensionKind.UI,
                supportedActivationEvents
            });
            if (toDisconnect.disposed) {
                return undefined;
            }
            this.activationEvents.forEach(event => manager.$activateByEvent(event));
        }
        return manager;
    }
    initRpc(host, pluginId) {
        const rpc = host === 'frontend' ? new plugin_worker_1.PluginWorker().rpc : this.createServerRpc(host);
        (0, main_context_1.setUpPluginApi)(rpc, this.container);
        this.mainPluginApiProviders.getContributions().forEach(p => p.initialize(rpc, this.container));
        return rpc;
    }
    createServerRpc(pluginHostId) {
        const channel = new channel_1.BasicChannel(() => {
            const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
            writer.onCommit(buffer => {
                this.server.onMessage(pluginHostId, buffer);
            });
            return writer;
        });
        // Create RPC protocol before adding the listener to the watcher to receive the watcher's cached messages after the rpc protocol was created.
        const rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
        this.watcher.onPostMessageEvent(received => {
            if (pluginHostId === received.pluginHostId) {
                channel.onMessageEmitter.fire(() => new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(received.message));
            }
        });
        return rpc;
    }
    async updateStoragePath() {
        const path = await this.getStoragePath();
        for (const manager of this.managers.values()) {
            manager.$updateStoragePath(path);
        }
    }
    async getStoragePath() {
        var _a;
        const roots = await this.workspaceService.roots;
        return this.pluginPathsService.getHostStoragePath((_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(), roots.map(root => root.resource.toString()));
    }
    async getHostGlobalStoragePath() {
        const configDirUri = await this.envServer.getConfigDirUri();
        const globalStorageFolderUri = new uri_1.default(configDirUri).resolve('globalStorage');
        // Make sure that folder by the path exists
        if (!await this.fileService.exists(globalStorageFolderUri)) {
            await this.fileService.createFolder(globalStorageFolderUri, { fromUserGesture: false });
        }
        const globalStorageFolderFsPath = await this.fileService.fsPath(globalStorageFolderUri);
        if (!globalStorageFolderFsPath) {
            throw new Error(`Could not resolve the FS path for URI: ${globalStorageFolderUri}`);
        }
        return globalStorageFolderFsPath;
    }
    async activateByViewContainer(viewContainerId) {
        await Promise.all(this.viewRegistry.getContainerViews(viewContainerId).map(viewId => this.activateByView(viewId)));
    }
    async activateByView(viewId) {
        await this.activateByEvent(`onView:${viewId}`);
    }
    async activateByLanguage(languageId) {
        await this.activateByEvent('onLanguage');
        await this.activateByEvent(`onLanguage:${languageId}`);
    }
    async activateByUri(scheme, authority) {
        await this.activateByEvent(`onUri:${scheme}://${authority}`);
    }
    async activateByCommand(commandId) {
        await this.activateByEvent(`onCommand:${commandId}`);
    }
    async activateByTaskType(taskType) {
        await this.activateByEvent(`onTaskType:${taskType}`);
    }
    async activateByCustomEditor(viewType) {
        await this.activateByEvent(`onCustomEditor:${viewType}`);
    }
    async activateByNotebook(viewType) {
        await this.activateByEvent(`onNotebook:${viewType}`);
    }
    async activateByNotebookSerializer(viewType) {
        await this.activateByEvent(`onNotebookSerializer:${viewType}`);
    }
    async activateByNotebookRenderer(rendererId) {
        await this.activateByEvent(`onRenderer:${rendererId}`);
    }
    activateByFileSystem(event) {
        return this.activateByEvent(`onFileSystem:${event.scheme}`);
    }
    activateByTerminalProfile(profileId) {
        return this.activateByEvent(`onTerminalProfile:${profileId}`);
    }
    ensureFileSystemActivation(event) {
        event.waitUntil(this.activateByFileSystem(event).then(() => {
            if (!this.fileService.hasProvider(event.scheme)) {
                return (0, promise_util_1.waitForEvent)(event_1.Event.filter(this.fileService.onDidChangeFileSystemProviderRegistrations, ({ added, scheme }) => added && scheme === event.scheme), 3000);
            }
        }));
    }
    ensureCommandHandlerRegistration(event) {
        const activation = this.activateByCommand(event.commandId);
        if (this.commands.getCommand(event.commandId) &&
            (!this.contributionHandler.hasCommand(event.commandId) ||
                this.contributionHandler.hasCommandHandler(event.commandId))) {
            return;
        }
        const waitForCommandHandler = new promise_util_1.Deferred();
        const listener = this.contributionHandler.onDidRegisterCommandHandler(id => {
            if (id === event.commandId) {
                listener.dispose();
                waitForCommandHandler.resolve();
            }
        });
        const p = Promise.all([
            activation,
            waitForCommandHandler.promise
        ]);
        p.then(() => listener.dispose(), () => listener.dispose());
        event.waitUntil(p);
    }
    ensureTaskActivation(event) {
        const promises = [this.activateByCommand('workbench.action.tasks.runTask')];
        const taskType = event.taskType;
        if (taskType) {
            if (taskType === hosted_plugin_1.ALL_ACTIVATION_EVENT) {
                for (const taskDefinition of this.taskDefinitionRegistry.getAll()) {
                    promises.push(this.activateByTaskType(taskDefinition.taskType));
                }
            }
            else {
                promises.push(this.activateByTaskType(taskType));
            }
        }
        event.waitUntil(Promise.all(promises));
    }
    ensureDebugActivation(event, activationEvent, debugType) {
        event.waitUntil(this.activateByDebug(activationEvent, debugType));
    }
    async activateByDebug(activationEvent, debugType) {
        const promises = [this.activateByEvent('onDebug')];
        if (activationEvent) {
            promises.push(this.activateByEvent(activationEvent));
            if (debugType) {
                promises.push(this.activateByEvent(activationEvent + ':' + debugType));
            }
        }
        await Promise.all(promises);
    }
    async activateByWorkspaceContains(manager, plugin) {
        const activationEvents = plugin.contributes && plugin.contributes.activationEvents;
        if (!activationEvents) {
            return;
        }
        const paths = [];
        const includePatterns = [];
        // should be aligned with https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts#L460-L469
        for (const activationEvent of activationEvents) {
            if (/^workspaceContains:/.test(activationEvent)) {
                const fileNameOrGlob = activationEvent.substring('workspaceContains:'.length);
                if (fileNameOrGlob.indexOf(hosted_plugin_1.ALL_ACTIVATION_EVENT) >= 0 || fileNameOrGlob.indexOf('?') >= 0) {
                    includePatterns.push(fileNameOrGlob);
                }
                else {
                    paths.push(fileNameOrGlob);
                }
            }
        }
        const activatePlugin = () => manager.$activateByEvent(`onPlugin:${plugin.metadata.model.id}`);
        const promises = [];
        if (paths.length) {
            promises.push(this.workspaceService.containsSome(paths));
        }
        if (includePatterns.length) {
            const tokenSource = new core_1.CancellationTokenSource();
            const searchTimeout = setTimeout(() => {
                tokenSource.cancel();
                // activate eagerly if took to long to search
                activatePlugin();
            }, 7000);
            promises.push((async () => {
                try {
                    const result = await this.fileSearchService.find('', {
                        rootUris: this.workspaceService.tryGetRoots().map(r => r.resource.toString()),
                        includePatterns,
                        limit: 1
                    }, tokenSource.token);
                    return result.length > 0;
                }
                catch (e) {
                    if (!(0, core_1.isCancelled)(e)) {
                        console.error(e);
                    }
                    return false;
                }
                finally {
                    clearTimeout(searchTimeout);
                }
            })());
        }
        if (promises.length && await Promise.all(promises).then(exists => exists.some(v => v))) {
            await activatePlugin();
        }
    }
    registerWebviewReviver(viewType, reviver) {
        if (this.webviewRevivers.has(viewType)) {
            throw new Error(`Reviver for ${viewType} already registered`);
        }
        this.webviewRevivers.set(viewType, reviver);
        if (this.webviewsToRestore.has(viewType)) {
            this.restoreWebview(this.webviewsToRestore.get(viewType));
        }
    }
    unregisterWebviewReviver(viewType) {
        this.webviewRevivers.delete(viewType);
    }
    async preserveWebviews() {
        for (const webview of this.widgets.getWidgets(webview_1.WebviewWidget.FACTORY_ID)) {
            this.preserveWebview(webview);
        }
        for (const webview of this.widgets.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID)) {
            webview.modelRef.dispose();
            if (webview['closeWithoutSaving']) {
                delete webview['closeWithoutSaving'];
            }
            this.customEditorRegistry.resolveWidget(webview);
        }
    }
    preserveWebview(webview) {
        if (!this.webviewsToRestore.has(webview.viewType)) {
            this.activateByEvent(`onWebviewPanel:${webview.viewType}`);
            this.webviewsToRestore.set(webview.viewType, webview);
            webview.disposed.connect(() => this.webviewsToRestore.delete(webview.viewType));
        }
    }
    async restoreWebview(webview) {
        const restore = this.webviewRevivers.get(webview.viewType);
        if (restore) {
            try {
                await restore(webview);
            }
            catch (e) {
                webview.setHTML(this.getDeserializationFailedContents(`
                An error occurred while restoring '${webview.viewType}' view. Please check logs.
                `));
                console.error('Failed to restore the webview', e);
            }
        }
    }
    getDeserializationFailedContents(message) {
        return `<!DOCTYPE html>
        <html>
            <head>
                <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none';">
            </head>
            <body>${message}</body>
        </html>`;
    }
};
exports.HostedPluginSupport = HostedPluginSupport;
HostedPluginSupport.ADDITIONAL_ACTIVATION_EVENTS_ENV = 'ADDITIONAL_ACTIVATION_EVENTS';
HostedPluginSupport.BUILTIN_ACTIVATION_EVENTS = [
    '*',
    'onLanguage',
    'onCommand',
    'onDebug',
    'onDebugInitialConfigurations',
    'onDebugResolve',
    'onDebugAdapterProtocolTracker',
    'onDebugDynamicConfigurations',
    'onTaskType',
    'workspaceContains',
    'onView',
    'onUri',
    'onTerminalProfile',
    'onWebviewPanel',
    'onFileSystem',
    'onCustomEditor',
    'onStartupFinished',
    'onAuthenticationRequest',
    'onNotebook',
    'onNotebookSerializer'
];
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_watcher_1.HostedPluginWatcher),
    tslib_1.__metadata("design:type", hosted_plugin_watcher_1.HostedPluginWatcher)
], HostedPluginSupport.prototype, "watcher", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_contribution_handler_1.PluginContributionHandler),
    tslib_1.__metadata("design:type", plugin_contribution_handler_1.PluginContributionHandler)
], HostedPluginSupport.prototype, "contributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceProviderProvider),
    tslib_1.__metadata("design:type", Function)
], HostedPluginSupport.prototype, "preferenceProviderProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceServiceImpl),
    tslib_1.__metadata("design:type", preferences_1.PreferenceServiceImpl)
], HostedPluginSupport.prototype, "preferenceServiceImpl", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], HostedPluginSupport.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookService),
    tslib_1.__metadata("design:type", browser_2.NotebookService)
], HostedPluginSupport.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookRendererMessagingService),
    tslib_1.__metadata("design:type", browser_2.NotebookRendererMessagingService)
], HostedPluginSupport.prototype, "notebookRendererMessagingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], HostedPluginSupport.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], HostedPluginSupport.prototype, "debugSessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], HostedPluginSupport.prototype, "debugConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], HostedPluginSupport.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_search_service_1.FileSearchService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "fileSearchService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(frontend_application_state_1.FrontendApplicationStateService),
    tslib_1.__metadata("design:type", frontend_application_state_1.FrontendApplicationStateService)
], HostedPluginSupport.prototype, "appState", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", browser_2.NotebookTypeRegistry)
], HostedPluginSupport.prototype, "notebookTypeRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_view_registry_1.PluginViewRegistry),
    tslib_1.__metadata("design:type", plugin_view_registry_1.PluginViewRegistry)
], HostedPluginSupport.prototype, "viewRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskProviderRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskProviderRegistry)
], HostedPluginSupport.prototype, "taskProviderRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskResolverRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskResolverRegistry)
], HostedPluginSupport.prototype, "taskResolverRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], HostedPluginSupport.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ProgressService),
    tslib_1.__metadata("design:type", core_1.ProgressService)
], HostedPluginSupport.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], HostedPluginSupport.prototype, "webviewEnvironment", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(widget_manager_1.WidgetManager),
    tslib_1.__metadata("design:type", widget_manager_1.WidgetManager)
], HostedPluginSupport.prototype, "widgets", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(json_schema_store_1.JsonSchemaStore),
    tslib_1.__metadata("design:type", json_schema_store_1.JsonSchemaStore)
], HostedPluginSupport.prototype, "jsonSchemaStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_custom_editor_registry_1.PluginCustomEditorRegistry),
    tslib_1.__metadata("design:type", plugin_custom_editor_registry_1.PluginCustomEditorRegistry)
], HostedPluginSupport.prototype, "customEditorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_protocol_1.ApplicationServer),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "applicationServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], HostedPluginSupport.prototype, "init", null);
exports.HostedPluginSupport = HostedPluginSupport = HostedPluginSupport_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], HostedPluginSupport);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginWorker = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const channel_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/channel */ "../node_modules/@theia/core/lib/common/message-rpc/channel.js");
const uint8_array_message_buffer_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/uint8-array-message-buffer */ "../node_modules/@theia/core/lib/common/message-rpc/uint8-array-message-buffer.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
let PluginWorker = class PluginWorker {
    constructor() {
        this.worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("_1402-_6154-_3ce7-_2e93-_b43e"), __webpack_require__.b));
        const channel = new channel_1.BasicChannel(() => {
            const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
            writer.onCommit(buffer => {
                this.worker.postMessage(buffer);
            });
            return writer;
        });
        this.rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
        // eslint-disable-next-line arrow-body-style
        this.worker.onmessage = buffer => channel.onMessageEmitter.fire(() => {
            return new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(buffer.data);
        });
        this.worker.onerror = e => channel.onErrorEmitter.fire(e);
    }
};
exports.PluginWorker = PluginWorker;
exports.PluginWorker = PluginWorker = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginWorker);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginContributions = exports.AbstractHostedPluginSupport = exports.isConnectionScopedBackendPlugin = exports.ALL_ACTIVATION_EVENT = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const plugin_ext_api_contribution_1 = __webpack_require__(/*! ../../common/plugin-ext-api-contribution */ "../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js");
const plugin_paths_protocol_1 = __webpack_require__(/*! ../../main/common/plugin-paths-protocol */ "../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../node_modules/@theia/core/lib/common/env-variables/index.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
exports.ALL_ACTIVATION_EVENT = '*';
function isConnectionScopedBackendPlugin(plugin) {
    const entryPoint = plugin.metadata.model.entryPoint;
    // A plugin doesn't have to have any entry-point if it doesn't need the activation handler,
    // in which case it's assumed to be a backend plugin.
    return !entryPoint.headless || !!entryPoint.backend;
}
exports.isConnectionScopedBackendPlugin = isConnectionScopedBackendPlugin;
let AbstractHostedPluginSupport = class AbstractHostedPluginSupport {
    /**
     * Resolves when the initial plugins are loaded and about to be started.
     */
    get willStart() {
        return this.deferredWillStart.promise;
    }
    /**
     * Resolves when the initial plugins are started.
     */
    get didStart() {
        return this.deferredDidStart.promise;
    }
    constructor(clientId) {
        this.clientId = clientId;
        this.managers = new Map();
        this.contributions = new Map();
        this.activationEvents = new Set();
        this.onDidChangePluginsEmitter = new core_1.Emitter();
        this.onDidChangePlugins = this.onDidChangePluginsEmitter.event;
        this.deferredWillStart = new promise_util_1.Deferred();
        this.deferredDidStart = new promise_util_1.Deferred();
        this.loadQueue = Promise.resolve(undefined);
        this.load = debounce(() => this.loadQueue = this.loadQueue.then(async () => {
            try {
                await this.runOperation(() => this.doLoad());
            }
            catch (e) {
                console.error('Failed to load plugins:', e);
            }
        }), 50, { leading: true });
    }
    init() {
        this.theiaReadyPromise = this.createTheiaReadyPromise();
    }
    get plugins() {
        const plugins = [];
        this.contributions.forEach(contributions => plugins.push(contributions.plugin.metadata));
        return plugins;
    }
    getPlugin(id) {
        const contributions = this.contributions.get(id);
        return contributions && contributions.plugin;
    }
    /** do not call it, except from the plugin frontend contribution */
    onStart(container) {
        this.container = container;
        this.load();
        this.afterStart();
    }
    afterStart() {
        // Nothing to do in the abstract
    }
    runOperation(operation) {
        return operation();
    }
    async doLoad() {
        const toDisconnect = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        await this.beforeSyncPlugins(toDisconnect);
        // process empty plugins as well in order to properly remove stale plugin widgets
        await this.syncPlugins();
        // it has to be resolved before awaiting layout is initialized
        // otherwise clients can hang forever in the initialization phase
        this.deferredWillStart.resolve();
        await this.beforeLoadContributions(toDisconnect);
        if (toDisconnect.disposed) {
            // if disconnected then don't try to load plugin contributions
            return;
        }
        const contributionsByHost = this.loadContributions(toDisconnect);
        await this.afterLoadContributions(toDisconnect);
        await this.theiaReadyPromise;
        if (toDisconnect.disposed) {
            // if disconnected then don't try to init plugin code and dynamic contributions
            return;
        }
        await this.startPlugins(contributionsByHost, toDisconnect);
        this.deferredDidStart.resolve();
    }
    beforeSyncPlugins(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    beforeLoadContributions(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    afterLoadContributions(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    /**
     * Sync loaded and deployed plugins:
     * - undeployed plugins are unloaded
     * - newly deployed plugins are initialized
     */
    async syncPlugins() {
        var _a;
        let initialized = 0;
        const waitPluginsMeasurement = this.measure('waitForDeployment');
        let syncPluginsMeasurement;
        const toUnload = new Set(this.contributions.keys());
        let didChangeInstallationStatus = false;
        try {
            const newPluginIds = [];
            const [deployedPluginIds, uninstalledPluginIds] = await Promise.all([this.server.getDeployedPluginIds(), this.server.getUninstalledPluginIds()]);
            waitPluginsMeasurement.log('Waiting for backend deployment');
            syncPluginsMeasurement = this.measure('syncPlugins');
            for (const versionedId of deployedPluginIds) {
                const unversionedId = plugin_protocol_1.PluginIdentifiers.unversionedFromVersioned(versionedId);
                toUnload.delete(unversionedId);
                if (!this.contributions.has(unversionedId)) {
                    newPluginIds.push(versionedId);
                }
            }
            for (const pluginId of toUnload) {
                (_a = this.contributions.get(pluginId)) === null || _a === void 0 ? void 0 : _a.dispose();
            }
            for (const versionedId of uninstalledPluginIds) {
                const plugin = this.getPlugin(plugin_protocol_1.PluginIdentifiers.unversionedFromVersioned(versionedId));
                if (plugin && plugin_protocol_1.PluginIdentifiers.componentsToVersionedId(plugin.metadata.model) === versionedId && !plugin.metadata.outOfSync) {
                    plugin.metadata.outOfSync = didChangeInstallationStatus = true;
                }
            }
            for (const contribution of this.contributions.values()) {
                if (contribution.plugin.metadata.outOfSync && !uninstalledPluginIds.includes(plugin_protocol_1.PluginIdentifiers.componentsToVersionedId(contribution.plugin.metadata.model))) {
                    contribution.plugin.metadata.outOfSync = false;
                    didChangeInstallationStatus = true;
                }
            }
            if (newPluginIds.length) {
                const deployedPlugins = await this.server.getDeployedPlugins({ pluginIds: newPluginIds });
                const plugins = [];
                for (const plugin of deployedPlugins) {
                    const accepted = this.acceptPlugin(plugin);
                    if (typeof accepted === 'object') {
                        plugins.push(accepted);
                    }
                    else if (accepted) {
                        plugins.push(plugin);
                    }
                }
                for (const plugin of plugins) {
                    const pluginId = plugin_protocol_1.PluginIdentifiers.componentsToUnversionedId(plugin.metadata.model);
                    const contributions = new PluginContributions(plugin);
                    this.contributions.set(pluginId, contributions);
                    contributions.push(core_1.Disposable.create(() => this.contributions.delete(pluginId)));
                    initialized++;
                }
            }
        }
        finally {
            if (initialized || toUnload.size || didChangeInstallationStatus) {
                this.onDidChangePluginsEmitter.fire(undefined);
            }
            if (!syncPluginsMeasurement) {
                // await didn't complete normally
                waitPluginsMeasurement.error('Backend deployment failed.');
            }
        }
        if (initialized > 0) {
            // Only log sync measurement if there are were plugins to sync.
            syncPluginsMeasurement === null || syncPluginsMeasurement === void 0 ? void 0 : syncPluginsMeasurement.log(`Sync of ${this.getPluginCount(initialized)}`);
        }
        else {
            syncPluginsMeasurement === null || syncPluginsMeasurement === void 0 ? void 0 : syncPluginsMeasurement.stop();
        }
    }
    /**
     * Always synchronous in order to simplify handling disconnections.
     * @throws never
     */
    loadContributions(toDisconnect) {
        let loaded = 0;
        const loadPluginsMeasurement = this.measure('loadPlugins');
        const hostContributions = new Map();
        console.log(`[${this.clientId}] Loading plugin contributions`);
        for (const contributions of this.contributions.values()) {
            const plugin = contributions.plugin.metadata;
            const pluginId = plugin.model.id;
            if (contributions.state === PluginContributions.State.INITIALIZING) {
                contributions.state = PluginContributions.State.LOADING;
                contributions.push(core_1.Disposable.create(() => console.log(`[${pluginId}]: Unloaded plugin.`)));
                contributions.push(this.handleContributions(contributions.plugin));
                contributions.state = PluginContributions.State.LOADED;
                console.debug(`[${this.clientId}][${pluginId}]: Loaded contributions.`);
                loaded++;
            }
            if (contributions.state === PluginContributions.State.LOADED) {
                contributions.state = PluginContributions.State.STARTING;
                const host = plugin.model.entryPoint.frontend ? 'frontend' : plugin.host;
                const dynamicContributions = hostContributions.get(host) || [];
                dynamicContributions.push(contributions);
                hostContributions.set(host, dynamicContributions);
                toDisconnect.push(core_1.Disposable.create(() => {
                    contributions.state = PluginContributions.State.LOADED;
                    console.debug(`[${this.clientId}][${pluginId}]: Disconnected.`);
                }));
            }
        }
        if (loaded > 0) {
            // Only log load measurement if there are were plugins to load.
            loadPluginsMeasurement === null || loadPluginsMeasurement === void 0 ? void 0 : loadPluginsMeasurement.log(`Load contributions of ${this.getPluginCount(loaded)}`);
        }
        else {
            loadPluginsMeasurement.stop();
        }
        return hostContributions;
    }
    async startPlugins(contributionsByHost, toDisconnect) {
        let started = 0;
        const startPluginsMeasurement = this.measure('startPlugins');
        const [hostLogPath, hostStoragePath, hostGlobalStoragePath] = await Promise.all([
            this.pluginPathsService.getHostLogPath(),
            this.getStoragePath(),
            this.getHostGlobalStoragePath()
        ]);
        if (toDisconnect.disposed) {
            return;
        }
        const thenable = [];
        const configStorage = {
            hostLogPath,
            hostStoragePath,
            hostGlobalStoragePath
        };
        for (const [host, hostContributions] of contributionsByHost) {
            // do not start plugins for electron browser
            if (host === 'frontend' && environment_1.environment.electron.is()) {
                continue;
            }
            const manager = await this.obtainManager(host, hostContributions, toDisconnect);
            if (!manager) {
                continue;
            }
            const plugins = hostContributions.map(contributions => contributions.plugin.metadata);
            thenable.push((async () => {
                try {
                    const activationEvents = [...this.activationEvents];
                    await manager.$start({ plugins, configStorage, activationEvents });
                    if (toDisconnect.disposed) {
                        return;
                    }
                    console.log(`[${this.clientId}] Starting plugins.`);
                    for (const contributions of hostContributions) {
                        started++;
                        const plugin = contributions.plugin;
                        const id = plugin.metadata.model.id;
                        contributions.state = PluginContributions.State.STARTED;
                        console.debug(`[${this.clientId}][${id}]: Started plugin.`);
                        toDisconnect.push(contributions.push(core_1.Disposable.create(() => {
                            console.debug(`[${this.clientId}][${id}]: Stopped plugin.`);
                            manager.$stop(id);
                        })));
                        this.handlePluginStarted(manager, plugin);
                    }
                }
                catch (e) {
                    console.error(`Failed to start plugins for '${host}' host`, e);
                }
            })());
        }
        await Promise.all(thenable);
        await this.activateByEvent('onStartupFinished');
        if (toDisconnect.disposed) {
            return;
        }
        if (started > 0) {
            startPluginsMeasurement.log(`Start of ${this.getPluginCount(started)}`);
        }
        else {
            startPluginsMeasurement.stop();
        }
    }
    async activateByEvent(activationEvent) {
        if (this.activationEvents.has(activationEvent)) {
            return;
        }
        this.activationEvents.add(activationEvent);
        await Promise.all(Array.from(this.managers.values(), manager => manager.$activateByEvent(activationEvent)));
    }
    async activatePlugin(id) {
        const activation = [];
        for (const manager of this.managers.values()) {
            activation.push(manager.$activatePlugin(id));
        }
        await Promise.all(activation);
    }
    handlePluginStarted(manager, plugin) {
        // Nothing to do in the abstract
    }
    measure(name) {
        return this.stopwatch.start(name, { context: this.clientId });
    }
    getPluginCount(plugins) {
        return `${plugins} plugin${plugins === 1 ? '' : 's'}`;
    }
};
exports.AbstractHostedPluginSupport = AbstractHostedPluginSupport;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "logger", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_protocol_1.HostedPluginServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "server", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ContributionProvider),
    (0, inversify_1.named)(plugin_ext_api_contribution_1.MainPluginApiProvider),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "mainPluginApiProviders", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_protocol_1.PluginServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "pluginServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_paths_protocol_1.PluginPathsService),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "pluginPathsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "envServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.Stopwatch),
    tslib_1.__metadata("design:type", common_1.Stopwatch)
], AbstractHostedPluginSupport.prototype, "stopwatch", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], AbstractHostedPluginSupport.prototype, "init", null);
exports.AbstractHostedPluginSupport = AbstractHostedPluginSupport = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.unmanaged)()),
    tslib_1.__metadata("design:paramtypes", [String])
], AbstractHostedPluginSupport);
class PluginContributions extends core_1.DisposableCollection {
    constructor(plugin) {
        super();
        this.plugin = plugin;
        this.state = PluginContributions.State.INITIALIZING;
    }
}
exports.PluginContributions = PluginContributions;
(function (PluginContributions) {
    let State;
    (function (State) {
        State[State["INITIALIZING"] = 0] = "INITIALIZING";
        State[State["LOADING"] = 1] = "LOADING";
        State[State["LOADED"] = 2] = "LOADED";
        State[State["STARTING"] = 3] = "STARTING";
        State[State["STARTED"] = 4] = "STARTED";
    })(State = PluginContributions.State || (PluginContributions.State = {}));
})(PluginContributions || (exports.PluginContributions = PluginContributions = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationProviderImpl = exports.AuthenticationMainImpl = exports.getAuthenticationProviderActivationEvent = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../node_modules/@theia/core/lib/common/message-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const authentication_service_1 = __webpack_require__(/*! @theia/core/lib/browser/authentication-service */ "../node_modules/@theia/core/lib/browser/authentication-service.js");
const quick_pick_service_1 = __webpack_require__(/*! @theia/core/lib/common/quick-pick-service */ "../node_modules/@theia/core/lib/common/quick-pick-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
function getAuthenticationProviderActivationEvent(id) { return `onAuthenticationRequest:${id}`; }
exports.getAuthenticationProviderActivationEvent = getAuthenticationProviderActivationEvent;
class AuthenticationMainImpl {
    constructor(rpc, container) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.AUTHENTICATION_EXT);
        this.messageService = container.get(message_service_1.MessageService);
        this.storageService = container.get(browser_1.StorageService);
        this.authenticationService = container.get(authentication_service_1.AuthenticationService);
        this.quickPickService = container.get(quick_pick_service_1.QuickPickService);
        this.authenticationService.onDidChangeSessions(e => {
            this.proxy.$onDidChangeAuthenticationSessions({ id: e.providerId, label: e.label });
        });
    }
    async $registerAuthenticationProvider(id, label, supportsMultipleAccounts) {
        const provider = new AuthenticationProviderImpl(this.proxy, id, label, supportsMultipleAccounts, this.storageService, this.messageService);
        this.authenticationService.registerAuthenticationProvider(id, provider);
    }
    async $unregisterAuthenticationProvider(id) {
        this.authenticationService.unregisterAuthenticationProvider(id);
    }
    async $updateSessions(id, event) {
        this.authenticationService.updateSessions(id, event);
    }
    $logout(providerId, sessionId) {
        return this.authenticationService.logout(providerId, sessionId);
    }
    async requestNewSession(providerId, scopes, extensionId, extensionName) {
        return this.authenticationService.requestNewSession(providerId, scopes, extensionId, extensionName);
    }
    $getAccounts(providerId) {
        return this.authenticationService.getSessions(providerId).then(sessions => sessions.map(session => session.account));
    }
    async $getSession(providerId, scopes, extensionId, extensionName, options) {
        const sessions = await this.authenticationService.getSessions(providerId, scopes, options === null || options === void 0 ? void 0 : options.account);
        // Error cases
        if (options.forceNewSession && !sessions.length) {
            throw new Error('No existing sessions found.');
        }
        if (options.forceNewSession && options.createIfNone) {
            throw new Error('Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone');
        }
        if (options.forceNewSession && options.silent) {
            throw new Error('Invalid combination of options. Please remove one of the following: forceNewSession, silent');
        }
        if (options.createIfNone && options.silent) {
            throw new Error('Invalid combination of options. Please remove one of the following: createIfNone, silent');
        }
        const supportsMultipleAccounts = this.authenticationService.supportsMultipleAccounts(providerId);
        // Check if the sessions we have are valid
        if (!options.forceNewSession && sessions.length) {
            if (supportsMultipleAccounts) {
                if (options.clearSessionPreference) {
                    await this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, undefined);
                }
                else {
                    const existingSessionPreference = await this.storageService.getData(`authentication-session-${extensionName}-${providerId}`);
                    if (existingSessionPreference) {
                        const matchingSession = sessions.find(session => session.id === existingSessionPreference);
                        if (matchingSession && await this.isAccessAllowed(providerId, matchingSession.account.label, extensionId)) {
                            return matchingSession;
                        }
                    }
                }
            }
            else if (await this.isAccessAllowed(providerId, sessions[0].account.label, extensionId)) {
                return sessions[0];
            }
        }
        // We may need to prompt because we don't have a valid session modal flows
        if (options.createIfNone || options.forceNewSession) {
            const providerName = this.authenticationService.getLabel(providerId);
            const detail = isAuthenticationForceNewSessionOptions(options.forceNewSession) ? options.forceNewSession.detail : undefined;
            const isAllowed = await this.loginPrompt(providerName, extensionName, !!options.forceNewSession, detail);
            if (!isAllowed) {
                throw new Error('User did not consent to login.');
            }
            const session = (sessions === null || sessions === void 0 ? void 0 : sessions.length) && !options.forceNewSession && supportsMultipleAccounts
                ? await this.selectSession(providerId, providerName, extensionId, extensionName, sessions, scopes, !!options.clearSessionPreference)
                : await this.authenticationService.login(providerId, scopes);
            await this.setTrustedExtensionAndAccountPreference(providerId, session.account.label, extensionId, extensionName, session.id);
            return session;
        }
        // passive flows (silent or default)
        const validSession = sessions.find(s => this.isAccessAllowed(providerId, s.account.label, extensionId));
        if (!options.silent && !validSession) {
            this.authenticationService.requestNewSession(providerId, scopes, extensionId, extensionName);
        }
        return validSession;
    }
    async selectSession(providerId, providerName, extensionId, extensionName, potentialSessions, scopes, clearSessionPreference) {
        if (!potentialSessions.length) {
            throw new Error('No potential sessions found');
        }
        return new Promise(async (resolve, reject) => {
            var _a, _b;
            const items = potentialSessions.map(session => ({
                label: session.account.label,
                value: { session }
            }));
            items.push({
                label: nls_1.nls.localizeByDefault('Sign in to another account'),
                value: {}
            });
            // VS Code has code here that pushes accounts that have no active sessions. However, since we do not store
            // any accounts that don't have sessions, we dont' do this.
            const selected = await this.quickPickService.show(items, {
                title: nls_1.nls.localizeByDefault("The extension '{0}' wants to access a {1} account", extensionName, providerName),
                ignoreFocusOut: true
            });
            if (selected) {
                // if we ever have accounts without sessions, pass the account to the login call
                const session = (_b = (_a = selected.value) === null || _a === void 0 ? void 0 : _a.session) !== null && _b !== void 0 ? _b : await this.authenticationService.login(providerId, scopes);
                const accountName = session.account.label;
                const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
                if (!allowList.find(allowed => allowed.id === extensionId)) {
                    allowList.push({ id: extensionId, name: extensionName });
                    this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
                }
                this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, session.id);
                resolve(session);
            }
            else {
                reject('User did not consent to account access');
            }
        });
    }
    async getSessionsPrompt(providerId, accountName, providerName, extensionId, extensionName) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        const extensionData = allowList.find(extension => extension.id === extensionId);
        if (extensionData) {
            addAccountUsage(this.storageService, providerId, accountName, extensionId, extensionName);
            return true;
        }
        const choice = await this.messageService.info(`The extension '${extensionName}' wants to access the ${providerName} account '${accountName}'.`, 'Allow', 'Cancel');
        const allow = choice === 'Allow';
        if (allow) {
            await addAccountUsage(this.storageService, providerId, accountName, extensionId, extensionName);
            allowList.push({ id: extensionId, name: extensionName });
            this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
        }
        return allow;
    }
    async loginPrompt(providerName, extensionName, recreatingSession, detail) {
        const msg = document.createElement('span');
        msg.textContent = recreatingSession
            ? nls_1.nls.localizeByDefault("The extension '{0}' wants you to sign in again using {1}.", extensionName, providerName)
            : nls_1.nls.localizeByDefault("The extension '{0}' wants to sign in using {1}.", extensionName, providerName);
        if (detail) {
            const detailElement = document.createElement('p');
            detailElement.textContent = detail;
            msg.appendChild(detailElement);
        }
        return !!await new browser_1.ConfirmDialog({
            title: nls_1.nls.localize('theia/plugin-ext/authentication-main/loginTitle', 'Login'),
            msg,
            ok: nls_1.nls.localizeByDefault('Allow'),
            cancel: browser_1.Dialog.CANCEL
        }).open();
    }
    async isAccessAllowed(providerId, accountName, extensionId) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        return !!allowList.find(allowed => allowed.id === extensionId);
    }
    async setTrustedExtensionAndAccountPreference(providerId, accountName, extensionId, extensionName, sessionId) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        if (!allowList.find(allowed => allowed.id === extensionId)) {
            allowList.push({ id: extensionId, name: extensionName });
            this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
        }
        this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, sessionId);
    }
    $onDidChangeSessions(providerId, event) {
        this.authenticationService.updateSessions(providerId, event);
    }
}
exports.AuthenticationMainImpl = AuthenticationMainImpl;
function isAuthenticationForceNewSessionOptions(arg) {
    return (0, core_1.isObject)(arg) && typeof arg.detail === 'string';
}
async function addAccountUsage(storageService, providerId, accountName, extensionId, extensionName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    const usages = await readAccountUsages(storageService, providerId, accountName);
    const existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);
    if (existingUsageIndex > -1) {
        usages.splice(existingUsageIndex, 1, {
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    else {
        usages.push({
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    await storageService.setData(accountKey, JSON.stringify(usages));
}
class AuthenticationProviderImpl {
    constructor(proxy, id, label, supportsMultipleAccounts, storageService, messageService) {
        this.proxy = proxy;
        this.id = id;
        this.label = label;
        this.supportsMultipleAccounts = supportsMultipleAccounts;
        this.storageService = storageService;
        this.messageService = messageService;
        /** map from account name to session ids */
        this.accounts = new Map();
        /** map from session id to account name */
        this.sessions = new Map();
    }
    hasSessions() {
        return !!this.sessions.size;
    }
    registerSession(session) {
        this.sessions.set(session.id, session.account.label);
        const existingSessionsForAccount = this.accounts.get(session.account.label);
        if (existingSessionsForAccount) {
            this.accounts.set(session.account.label, existingSessionsForAccount.concat(session.id));
            return;
        }
        else {
            this.accounts.set(session.account.label, [session.id]);
        }
    }
    async signOut(accountName) {
        const accountUsages = await readAccountUsages(this.storageService, this.id, accountName);
        const sessionsForAccount = this.accounts.get(accountName);
        const result = await this.messageService.info(accountUsages.length
            ? nls_1.nls.localizeByDefault("The account '{0}' has been used by: \n\n{1}\n\n Sign out from these extensions?", accountName, accountUsages.map(usage => usage.extensionName).join(', '))
            : nls_1.nls.localizeByDefault("Sign out of '{0}'?", accountName), nls_1.nls.localizeByDefault('Sign Out'), browser_1.Dialog.CANCEL);
        if (result && result === nls_1.nls.localizeByDefault('Sign Out') && sessionsForAccount) {
            sessionsForAccount.forEach(sessionId => this.removeSession(sessionId));
            removeAccountUsage(this.storageService, this.id, accountName);
        }
    }
    async getSessions(scopes, account) {
        return this.proxy.$getSessions(this.id, scopes, { account: account });
    }
    async updateSessionItems(event) {
        const { added, removed } = event;
        const session = await this.proxy.$getSessions(this.id, undefined, {});
        const addedSessions = added ? session.filter(s => added.some(addedSession => addedSession.id === s.id)) : [];
        removed === null || removed === void 0 ? void 0 : removed.forEach(removedSession => {
            const sessionId = removedSession.id;
            if (sessionId) {
                const accountName = this.sessions.get(sessionId);
                if (accountName) {
                    this.sessions.delete(sessionId);
                    const sessionsForAccount = this.accounts.get(accountName) || [];
                    const sessionIndex = sessionsForAccount.indexOf(sessionId);
                    sessionsForAccount.splice(sessionIndex);
                    if (!sessionsForAccount.length) {
                        this.accounts.delete(accountName);
                    }
                }
            }
        });
        addedSessions.forEach(s => this.registerSession(s));
    }
    async login(scopes, options) {
        return this.createSession(scopes, options);
    }
    async logout(sessionId) {
        return this.removeSession(sessionId);
    }
    createSession(scopes, options) {
        return this.proxy.$createSession(this.id, scopes, options);
    }
    removeSession(sessionId) {
        return this.proxy.$removeSession(this.id, sessionId)
            .then(() => {
            this.messageService.info(nls_1.nls.localizeByDefault('Successfully signed out.'));
        });
    }
}
exports.AuthenticationProviderImpl = AuthenticationProviderImpl;
async function readAccountUsages(storageService, providerId, accountName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    const storedUsages = await storageService.getData(accountKey);
    let usages = [];
    if (storedUsages) {
        try {
            usages = JSON.parse(storedUsages);
        }
        catch (e) {
            console.log(e);
        }
    }
    return usages;
}
function removeAccountUsage(storageService, providerId, accountName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    storageService.setData(accountKey, undefined);
}


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipboardMainImpl = void 0;
const clipboard_service_1 = __webpack_require__(/*! @theia/core/lib/browser/clipboard-service */ "../node_modules/@theia/core/lib/browser/clipboard-service.js");
class ClipboardMainImpl {
    constructor(container) {
        this.clipboardService = container.get(clipboard_service_1.ClipboardService);
    }
    async $readText() {
        const result = await this.clipboardService.readText();
        return result;
    }
    async $writeText(value) {
        await this.clipboardService.writeText(value);
    }
}
exports.ClipboardMainImpl = ClipboardMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandRegistryMainImpl = exports.ArgumentProcessorContribution = void 0;
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const plugin_contribution_handler_1 = __webpack_require__(/*! ./plugin-contribution-handler */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
exports.ArgumentProcessorContribution = Symbol('ArgumentProcessorContribution');
class CommandRegistryMainImpl {
    constructor(rpc, container) {
        this.commands = new Map();
        this.handlers = new Map();
        this.argumentProcessors = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMAND_REGISTRY_EXT);
        this.delegate = container.get(command_1.CommandRegistry);
        this.keyBinding = container.get(browser_1.KeybindingRegistry);
        this.contributions = container.get(plugin_contribution_handler_1.PluginContributionHandler);
        container.getNamed(core_1.ContributionProvider, exports.ArgumentProcessorContribution).getContributions().forEach(processor => {
            this.registerArgumentProcessor(processor);
        });
    }
    dispose() {
        this.toDispose.dispose();
    }
    registerArgumentProcessor(processor) {
        this.argumentProcessors.push(processor);
        return disposable_1.Disposable.create(() => {
            const index = this.argumentProcessors.lastIndexOf(processor);
            if (index >= 0) {
                this.argumentProcessors.splice(index, 1);
            }
        });
    }
    $registerCommand(command) {
        const id = command.id;
        this.commands.set(id, this.contributions.registerCommand(command));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterCommand(id)));
    }
    $unregisterCommand(id) {
        const command = this.commands.get(id);
        if (command) {
            command.dispose();
            this.commands.delete(id);
        }
    }
    $registerHandler(id) {
        this.handlers.set(id, this.contributions.registerCommandHandler(id, (...args) => this.proxy.$executeCommand(id, ...args.map(arg => this.argumentProcessors.reduce((currentValue, processor) => processor.processArgument(currentValue), arg)))));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterHandler(id)));
    }
    $unregisterHandler(id) {
        const handler = this.handlers.get(id);
        if (handler) {
            handler.dispose();
            this.handlers.delete(id);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $executeCommand(id, ...args) {
        if (!this.delegate.getCommand(id)) {
            throw new Error(`Command with id '${id}' is not registered.`);
        }
        try {
            return await this.delegate.executeCommand(id, ...args);
        }
        catch (e) {
            // Command handler may be not active at the moment so the error must be caught. See https://github.com/eclipse-theia/theia/pull/6687#discussion_r354810079
            if ('code' in e && e['code'] === 'NO_ACTIVE_HANDLER') {
                return;
            }
            else {
                throw e;
            }
        }
    }
    $getKeyBinding(commandId) {
        try {
            const keyBindings = this.keyBinding.getKeybindingsForCommand(commandId);
            if (keyBindings) {
                // transform inner type to CommandKeyBinding
                return Promise.resolve(keyBindings.map(keyBinding => ({ id: commandId, value: keyBinding.keybinding })));
            }
            else {
                return Promise.resolve(undefined);
            }
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    $getCommands() {
        return Promise.resolve(this.delegate.commandIds);
    }
}
exports.CommandRegistryMainImpl = CommandRegistryMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentGlyphWidget = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/commentGlyphWidget.ts
class CommentGlyphWidget {
    constructor(editor) {
        this.commentsDecorations = [];
        this.commentsOptions = {
            isWholeLine: true,
            linesDecorationsClassName: 'comment-range-glyph comment-thread'
        };
        this.editor = editor;
    }
    getPosition() {
        const model = this.editor.getModel();
        const range = model && this.commentsDecorations && this.commentsDecorations.length
            ? model.getDecorationRange(this.commentsDecorations[0])
            : null;
        return range ? range.startLineNumber : this.lineNumber;
    }
    setLineNumber(lineNumber) {
        this.lineNumber = lineNumber;
        const commentsDecorations = [{
                range: {
                    startLineNumber: lineNumber, startColumn: 1,
                    endLineNumber: lineNumber, endColumn: 1
                },
                options: this.commentsOptions
            }];
        this.commentsDecorations = this.editor.deltaDecorations(this.commentsDecorations, commentsDecorations);
    }
    dispose() {
        if (this.commentsDecorations) {
            this.editor.deltaDecorations(this.commentsDecorations, []);
        }
    }
}
exports.CommentGlyphWidget = CommentGlyphWidget;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentAction = exports.CommentActions = exports.CommentsInlineAction = exports.CommentEditContainer = exports.CommentBody = exports.ReviewComment = exports.CommentForm = exports.CommentThreadWidget = exports.COMMENT_TITLE = exports.COMMENT_CONTEXT = exports.COMMENT_THREAD_CONTEXT = void 0;
// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const monaco_editor_zone_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-zone-widget */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc-model */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const comment_glyph_widget_1 = __webpack_require__(/*! ./comment-glyph-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const client_1 = __webpack_require__(/*! @theia/core/shared/react-dom/client */ "../node_modules/@theia/core/shared/react-dom/client/index.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/commentThreadWidget.ts
exports.COMMENT_THREAD_CONTEXT = ['comment_thread-context-menu'];
exports.COMMENT_CONTEXT = ['comment-context-menu'];
exports.COMMENT_TITLE = ['comment-title-menu'];
class CommentThreadWidget extends browser_1.BaseWidget {
    constructor(editor, _owner, _commentThread, commentService, menus, contextKeyService, commands) {
        super();
        this._owner = _owner;
        this._commentThread = _commentThread;
        this.commentService = commentService;
        this.menus = menus;
        this.contextKeyService = contextKeyService;
        this.commands = commands;
        this.commentFormRef = React.createRef();
        this.toDispose.push(this.zoneWidget = new monaco_editor_zone_widget_1.MonacoEditorZoneWidget(editor));
        this.containerNodeRoot = (0, client_1.createRoot)(this.zoneWidget.containerNode);
        this.toDispose.push(this.commentGlyphWidget = new comment_glyph_widget_1.CommentGlyphWidget(editor));
        this.toDispose.push(this._commentThread.onDidChangeCollapsibleState(state => {
            var _a, _b;
            if (state === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded && !this.isExpanded) {
                const lineNumber = (_b = (_a = this._commentThread.range) === null || _a === void 0 ? void 0 : _a.startLineNumber) !== null && _b !== void 0 ? _b : 0;
                this.display({ afterLineNumber: lineNumber, afterColumn: 1, heightInLines: 2 });
                return;
            }
            if (state === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed && this.isExpanded) {
                this.hide();
                return;
            }
        }));
        this.contextKeyService.commentIsEmpty.set(true);
        this.toDispose.push(this.zoneWidget.editor.onMouseDown(e => this.onEditorMouseDown(e)));
        this.toDispose.push(this.contextKeyService.onDidChange(() => {
            const commentForm = this.commentFormRef.current;
            if (commentForm) {
                commentForm.update();
            }
        }));
        this.toDispose.push(this._commentThread.onDidChangeCanReply(_canReply => {
            const commentForm = this.commentFormRef.current;
            if (commentForm) {
                commentForm.update();
            }
        }));
        this.toDispose.push(this._commentThread.onDidChangeState(_state => {
            this.update();
        }));
        this.contextMenu = this.menus.getMenu(exports.COMMENT_THREAD_CONTEXT);
        this.contextMenu.children.map(node => node instanceof common_1.ActionMenuNode && node.when).forEach(exp => {
            if (typeof exp === 'string') {
                this.contextKeyService.setExpression(exp);
            }
        });
    }
    getGlyphPosition() {
        return this.commentGlyphWidget.getPosition();
    }
    collapse() {
        this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
        if (this._commentThread.comments && this._commentThread.comments.length === 0) {
            this.deleteCommentThread();
        }
        this.hide();
    }
    deleteCommentThread() {
        this.dispose();
        this.commentService.disposeCommentThread(this.owner, this._commentThread.threadId);
    }
    dispose() {
        super.dispose();
        if (this.commentGlyphWidget) {
            this.commentGlyphWidget.dispose();
        }
    }
    toggleExpand(lineNumber) {
        if (this.isExpanded) {
            this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
            this.hide();
            if (!this._commentThread.comments || !this._commentThread.comments.length) {
                this.deleteCommentThread();
            }
        }
        else {
            this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
            this.display({ afterLineNumber: lineNumber, afterColumn: 1, heightInLines: 2 });
        }
    }
    hide() {
        this.zoneWidget.hide();
        this.isExpanded = false;
        super.hide();
    }
    display(options) {
        this.isExpanded = true;
        if (this._commentThread.collapsibleState && this._commentThread.collapsibleState !== plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded) {
            return;
        }
        this.commentGlyphWidget.setLineNumber(options.afterLineNumber);
        this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
        this.zoneWidget.show(options);
        this.update();
    }
    onEditorMouseDown(e) {
        const range = e.target.range;
        if (!range) {
            return;
        }
        if (!e.event.leftButton) {
            return;
        }
        if (e.target.type !== browser_2.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        const data = e.target.detail;
        const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;
        // don't collide with folding and git decorations
        if (gutterOffsetX > 14) {
            return;
        }
        const mouseDownInfo = { lineNumber: range.startLineNumber };
        const { lineNumber } = mouseDownInfo;
        if (!range || range.startLineNumber !== lineNumber) {
            return;
        }
        if (e.target.type !== browser_2.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        if (!e.target.element) {
            return;
        }
        if (this.commentGlyphWidget && this.commentGlyphWidget.getPosition() !== lineNumber) {
            return;
        }
        if (e.target.element.className.indexOf('comment-thread') >= 0) {
            this.toggleExpand(lineNumber);
            return;
        }
        if (this._commentThread.collapsibleState === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed) {
            this.display({ afterLineNumber: mouseDownInfo.lineNumber, heightInLines: 2 });
        }
        else {
            this.hide();
        }
    }
    get owner() {
        return this._owner;
    }
    get commentThread() {
        return this._commentThread;
    }
    getThreadLabel() {
        let label;
        label = this._commentThread.label;
        if (label === undefined) {
            if (this._commentThread.comments && this._commentThread.comments.length) {
                const onlyUnique = (value, index, self) => self.indexOf(value) === index;
                const participantsList = this._commentThread.comments.filter(onlyUnique).map(comment => `@${comment.userName}`).join(', ');
                const resolutionState = this._commentThread.state === plugin_api_rpc_model_1.CommentThreadState.Resolved ? '(Resolved)' : '(Unresolved)';
                label = `Participants: ${participantsList} ${resolutionState}`;
            }
            else {
                label = 'Start discussion';
            }
        }
        return label;
    }
    update() {
        var _a, _b, _c;
        if (!this.isExpanded) {
            return;
        }
        this.render();
        const headHeight = Math.ceil(this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight) * 1.2);
        const lineHeight = this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight);
        const arrowHeight = Math.round(lineHeight / 3);
        const frameThickness = Math.round(lineHeight / 9) * 2;
        const body = this.zoneWidget.containerNode.getElementsByClassName('body')[0];
        const computedLinesNumber = Math.ceil((headHeight + ((_a = body === null || body === void 0 ? void 0 : body.clientHeight) !== null && _a !== void 0 ? _a : 0) + arrowHeight + frameThickness + 8 /** margin bottom to avoid margin collapse */)
            / lineHeight);
        this.zoneWidget.show({ afterLineNumber: (_c = (_b = this._commentThread.range) === null || _b === void 0 ? void 0 : _b.startLineNumber) !== null && _c !== void 0 ? _c : 0, heightInLines: computedLinesNumber });
    }
    render() {
        var _a;
        const headHeight = Math.ceil(this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight) * 1.2);
        this.containerNodeRoot.render(React.createElement("div", { className: 'review-widget' },
            React.createElement("div", { className: 'head', style: { height: headHeight, lineHeight: `${headHeight}px` } },
                React.createElement("div", { className: 'review-title' },
                    React.createElement("span", { className: 'filename' }, this.getThreadLabel())),
                React.createElement("div", { className: 'review-actions' },
                    React.createElement("div", { className: 'monaco-action-bar animated' },
                        React.createElement("ul", { className: 'actions-container', role: 'toolbar' },
                            React.createElement("li", { className: 'action-item', role: 'presentation' },
                                React.createElement("a", { className: 'action-label codicon expand-review-action codicon-chevron-up', role: 'button', tabIndex: 0, title: 'Collapse', onClick: () => this.collapse() })))))),
            React.createElement("div", { className: 'body' },
                React.createElement("div", { className: 'comments-container', role: 'presentation', tabIndex: 0 }, (_a = this._commentThread.comments) === null || _a === void 0 ? void 0 : _a.map((comment, index) => React.createElement(ReviewComment, { key: index, contextKeyService: this.contextKeyService, menus: this.menus, comment: comment, commentForm: this.commentFormRef, commands: this.commands, commentThread: this._commentThread }))),
                React.createElement(CommentForm, { contextKeyService: this.contextKeyService, commands: this.commands, commentThread: this._commentThread, menus: this.menus, widget: this, ref: this.commentFormRef }))));
    }
}
exports.CommentThreadWidget = CommentThreadWidget;
class CommentForm extends React.Component {
    update() {
        this.setState(this.state);
    }
    componentDidMount() {
        // Wait for the widget to be rendered.
        setTimeout(() => {
            var _a;
            (_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, 100);
    }
    constructor(props) {
        super(props);
        this.inputRef = React.createRef();
        this.inputValue = '';
        this.getInput = () => this.inputValue;
        this.clearInput = () => {
            const input = this.inputRef.current;
            if (input) {
                this.inputValue = '';
                input.value = this.inputValue;
                this.props.contextKeyService.commentIsEmpty.set(true);
            }
        };
        this.expand = () => {
            this.setState({ expanded: true });
            // Wait for the widget to be rendered.
            setTimeout(() => {
                var _a;
                // Update the widget's height.
                this.props.widget.update();
                (_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 100);
        };
        this.collapse = () => {
            this.setState({ expanded: false });
            // Wait for the widget to be rendered.
            setTimeout(() => {
                // Update the widget's height.
                this.props.widget.update();
            }, 100);
        };
        this.onInput = (event) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const value = event.target.value;
            if (this.inputValue.length === 0 || value.length === 0) {
                this.props.contextKeyService.commentIsEmpty.set(value.length === 0);
            }
            this.inputValue = value;
        };
        this.state = {
            expanded: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            setState(newState);
        };
        this.menu = this.props.menus.getMenu(exports.COMMENT_THREAD_CONTEXT);
        this.menu.children.map(node => node instanceof common_1.ActionMenuNode && node.when).forEach(exp => {
            if (typeof exp === 'string') {
                this.props.contextKeyService.setExpression(exp);
            }
        });
    }
    render() {
        const { commands, commentThread, contextKeyService } = this.props;
        const hasExistingComments = commentThread.comments && commentThread.comments.length > 0;
        return commentThread.canReply ? React.createElement("div", { className: 'comment-form' + (this.state.expanded || commentThread.comments && commentThread.comments.length === 0 ? ' expand' : '') },
            React.createElement("div", { className: 'theia-comments-input-message-container' },
                React.createElement("textarea", { className: 'theia-comments-input-message theia-input', spellCheck: false, placeholder: hasExistingComments ? 'Reply...' : 'Type a new comment', onInput: this.onInput, 
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    onBlur: (event) => {
                        if (event.target.value.length > 0) {
                            return;
                        }
                        if (event.relatedTarget && event.relatedTarget.className === 'comments-button comments-text-button theia-button') {
                            this.state = { expanded: false };
                            return;
                        }
                        this.collapse();
                    }, ref: this.inputRef })),
            React.createElement(CommentActions, { menu: this.menu, contextKeyService: contextKeyService, commands: commands, commentThread: commentThread, getInput: this.getInput, clearInput: this.clearInput }),
            React.createElement("button", { className: 'review-thread-reply-button', title: 'Reply...', onClick: this.expand }, "Reply...")) : null;
    }
}
exports.CommentForm = CommentForm;
class ReviewComment extends React.Component {
    constructor(props) {
        super(props);
        this.detectHover = (element) => {
            if (element) {
                window.requestAnimationFrame(() => {
                    const hover = element.matches(':hover');
                    this.setState({ hover });
                });
            }
        };
        this.showHover = () => this.setState({ hover: true });
        this.hideHover = () => this.setState({ hover: false });
        this.state = {
            hover: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            setState(newState);
        };
    }
    render() {
        const { comment, commentForm, contextKeyService, menus, commands, commentThread } = this.props;
        const commentUniqueId = comment.uniqueIdInThread;
        const { hover } = this.state;
        contextKeyService.comment.set(comment.contextValue);
        return React.createElement("div", { className: 'review-comment', tabIndex: -1, "aria-label": `${comment.userName}, ${comment.body.value}`, ref: this.detectHover, onMouseEnter: this.showHover, onMouseLeave: this.hideHover },
            React.createElement("div", { className: 'avatar-container' },
                React.createElement("img", { className: 'avatar', src: comment.userIconPath })),
            React.createElement("div", { className: 'review-comment-contents' },
                React.createElement("div", { className: 'comment-title monaco-mouse-cursor-text' },
                    React.createElement("strong", { className: 'author' }, comment.userName),
                    React.createElement("small", { className: 'timestamp' }, this.localeDate(comment.timestamp)),
                    React.createElement("span", { className: 'isPending' }, comment.label),
                    React.createElement("div", { className: 'theia-comments-inline-actions-container' },
                        React.createElement("div", { className: 'theia-comments-inline-actions', role: 'toolbar' }, hover && menus.getMenu(exports.COMMENT_TITLE).children.map((node, index) => node instanceof common_1.ActionMenuNode &&
                            React.createElement(CommentsInlineAction, { key: index, node, commands, commentThread, commentUniqueId, contextKeyService }))))),
                React.createElement(CommentBody, { value: comment.body.value, isVisible: comment.mode === undefined || comment.mode === plugin_api_rpc_model_1.CommentMode.Preview }),
                React.createElement(CommentEditContainer, { contextKeyService: contextKeyService, menus: menus, comment: comment, commentThread: commentThread, commentForm: commentForm, commands: commands })));
    }
    localeDate(timestamp) {
        if (timestamp === undefined) {
            return '';
        }
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
            return date.toLocaleString();
        }
        return '';
    }
}
exports.ReviewComment = ReviewComment;
class CommentBody extends React.Component {
    render() {
        const { value, isVisible } = this.props;
        if (!isVisible) {
            return false;
        }
        return React.createElement("div", { className: 'comment-body monaco-mouse-cursor-text' },
            React.createElement("div", null,
                React.createElement("p", null, value)));
    }
}
exports.CommentBody = CommentBody;
class CommentEditContainer extends React.Component {
    constructor() {
        super(...arguments);
        this.inputRef = React.createRef();
    }
    componentDidUpdate(prevProps, prevState) {
        var _a;
        const commentFormState = (_a = this.props.commentForm.current) === null || _a === void 0 ? void 0 : _a.state;
        const mode = this.props.comment.mode;
        if (this.dirtyCommentMode !== mode || (this.dirtyCommentFormState !== (commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded) && !(commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded))) {
            const currentInput = this.inputRef.current;
            if (currentInput) {
                // Wait for the widget to be rendered.
                setTimeout(() => {
                    currentInput.focus();
                    currentInput.setSelectionRange(currentInput.value.length, currentInput.value.length);
                }, 50);
            }
        }
        this.dirtyCommentMode = mode;
        this.dirtyCommentFormState = commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded;
    }
    render() {
        const { menus, comment, commands, commentThread, contextKeyService } = this.props;
        if (!(comment.mode === plugin_api_rpc_model_1.CommentMode.Editing)) {
            return false;
        }
        return React.createElement("div", { className: 'edit-container' },
            React.createElement("div", { className: 'edit-textarea' },
                React.createElement("div", { className: 'theia-comments-input-message-container' },
                    React.createElement("textarea", { className: 'theia-comments-input-message theia-input', spellCheck: false, defaultValue: comment.body.value, ref: this.inputRef }))),
            React.createElement("div", { className: 'form-actions' }, menus.getMenu(exports.COMMENT_CONTEXT).children.map((node, index) => {
                const onClick = () => {
                    commands.executeCommand(node.id, {
                        commentControlHandle: commentThread.controllerHandle,
                        commentThreadHandle: commentThread.commentThreadHandle,
                        commentUniqueId: comment.uniqueIdInThread,
                        text: this.inputRef.current ? this.inputRef.current.value : ''
                    });
                };
                return node instanceof common_1.ActionMenuNode &&
                    React.createElement(CommentAction, { key: index, node, commands, onClick, contextKeyService });
            })));
    }
}
exports.CommentEditContainer = CommentEditContainer;
class CommentsInlineAction extends React.Component {
    render() {
        const { node, commands, contextKeyService, commentThread, commentUniqueId } = this.props;
        if (node.when && !contextKeyService.match(node.when)) {
            return false;
        }
        return React.createElement("div", { className: 'theia-comments-inline-action' },
            React.createElement("a", { className: node.icon, title: node.label, onClick: () => {
                    commands.executeCommand(node.id, {
                        commentControlHandle: commentThread.controllerHandle,
                        commentThreadHandle: commentThread.commentThreadHandle,
                        commentUniqueId
                    });
                } }));
    }
}
exports.CommentsInlineAction = CommentsInlineAction;
class CommentActions extends React.Component {
    render() {
        const { contextKeyService, commands, menu, commentThread, getInput, clearInput } = this.props;
        return React.createElement("div", { className: 'form-actions' }, menu.children.map((node, index) => node instanceof common_1.ActionMenuNode &&
            React.createElement(CommentAction, { key: index, commands: commands, node: node, onClick: () => {
                    commands.executeCommand(node.id, {
                        commentControlHandle: commentThread.controllerHandle,
                        commentThreadHandle: commentThread.commentThreadHandle,
                        text: getInput()
                    });
                    clearInput();
                }, contextKeyService: contextKeyService })));
    }
}
exports.CommentActions = CommentActions;
class CommentAction extends React.Component {
    render() {
        const classNames = ['comments-button', 'comments-text-button', 'theia-button'];
        const { node, commands, contextKeyService, onClick } = this.props;
        if (node.when && !contextKeyService.match(node.when)) {
            return false;
        }
        const isEnabled = commands.isEnabled(node.command);
        if (!isEnabled) {
            classNames.push(browser_1.DISABLED_CLASS);
        }
        return React.createElement("button", { className: classNames.join(' '), tabIndex: 0, role: 'button', onClick: () => {
                if (isEnabled) {
                    onClick();
                }
            } }, node.label);
    }
}
exports.CommentAction = CommentAction;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context-key-service.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context-key-service.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
let CommentsContextKeyService = class CommentsContextKeyService {
    constructor() {
        this.contextKeys = new Set();
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    get commentController() {
        return this._commentController;
    }
    get comment() {
        return this._comment;
    }
    get commentIsEmpty() {
        return this._commentIsEmpty;
    }
    init() {
        this.contextKeys.add('commentIsEmpty');
        this._commentController = this.contextKeyService.createKey('commentController', undefined);
        this._comment = this.contextKeyService.createKey('comment', undefined);
        this._commentIsEmpty = this.contextKeyService.createKey('commentIsEmpty', true);
        this.contextKeyService.onDidChange(event => {
            if (event.affects(this.contextKeys)) {
                this.onDidChangeEmitter.fire();
            }
        });
    }
    setExpression(expression) {
        var _a;
        (_a = this.contextKeyService.parseKeys(expression)) === null || _a === void 0 ? void 0 : _a.forEach(key => {
            this.contextKeys.add(key);
        });
    }
    match(expression) {
        return !expression || this.contextKeyService.match(expression);
    }
};
exports.CommentsContextKeyService = CommentsContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CommentsContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CommentsContextKeyService.prototype, "init", null);
exports.CommentsContextKeyService = CommentsContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CommentsContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const comments_decorator_1 = __webpack_require__(/*! ./comments-decorator */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
const comment_thread_widget_1 = __webpack_require__(/*! ./comment-thread-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js");
const comments_service_1 = __webpack_require__(/*! ./comments-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const comments_context_key_service_1 = __webpack_require__(/*! ./comments-context-key-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context-key-service.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/comments.contribution.ts
let CommentsContribution = class CommentsContribution {
    constructor(rangeDecorator, commentService, editorManager) {
        this.rangeDecorator = rangeDecorator;
        this.commentService = commentService;
        this.editorManager = editorManager;
        this.emptyThreadsToAddQueue = [];
        this.commentWidgets = [];
        this.commentInfos = [];
        this.commentService.onDidSetResourceCommentInfos(e => {
            const editor = this.getCurrentEditor();
            const editorURI = editor && editor.editor instanceof monaco_diff_editor_1.MonacoDiffEditor && editor.editor.diffEditor.getModifiedEditor().getModel();
            if (editorURI && editorURI.toString() === e.resource.toString()) {
                this.setComments(e.commentInfos.filter(commentInfo => commentInfo !== null));
            }
        });
        this.editorManager.onCreated(async (widget) => {
            const disposables = new common_1.DisposableCollection();
            const editor = widget.editor;
            if (editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                const originalEditorModel = editor.diffEditor.getOriginalEditor().getModel();
                if (originalEditorModel) {
                    // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                    const originalComments = await this.commentService.getComments(originalEditorModel.uri);
                    if (originalComments) {
                        this.rangeDecorator.update(editor.diffEditor.getOriginalEditor(), originalComments.filter(c => !!c));
                    }
                }
                const modifiedEditorModel = editor.diffEditor.getModifiedEditor().getModel();
                if (modifiedEditorModel) {
                    // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                    const modifiedComments = await this.commentService.getComments(modifiedEditorModel.uri);
                    if (modifiedComments) {
                        this.rangeDecorator.update(editor.diffEditor.getModifiedEditor(), modifiedComments.filter(c => !!c));
                    }
                }
                disposables.push(editor.onMouseDown(e => this.onEditorMouseDown(e)));
                disposables.push(this.commentService.onDidUpdateCommentThreads(async (e) => {
                    const editorURI = editor.document.uri;
                    const commentInfo = this.commentInfos.filter(info => info.owner === e.owner);
                    if (!commentInfo || !commentInfo.length) {
                        return;
                    }
                    const added = e.added.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    const removed = e.removed.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    const changed = e.changed.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    removed.forEach(thread => {
                        const matchedZones = this.commentWidgets.filter(zoneWidget => zoneWidget.owner === e.owner
                            && zoneWidget.commentThread.threadId === thread.threadId && zoneWidget.commentThread.threadId !== '');
                        if (matchedZones.length) {
                            const matchedZone = matchedZones[0];
                            const index = this.commentWidgets.indexOf(matchedZone);
                            this.commentWidgets.splice(index, 1);
                            matchedZone.dispose();
                        }
                    });
                    changed.forEach(thread => {
                        const matchedZones = this.commentWidgets.filter(zoneWidget => zoneWidget.owner === e.owner
                            && zoneWidget.commentThread.threadId === thread.threadId);
                        if (matchedZones.length) {
                            const matchedZone = matchedZones[0];
                            matchedZone.update();
                        }
                    });
                    added.forEach(thread => {
                        this.displayCommentThread(e.owner, thread);
                        this.commentInfos.filter(info => info.owner === e.owner)[0].threads.push(thread);
                    });
                }));
                editor.onDispose(() => {
                    disposables.dispose();
                });
                this.beginCompute();
            }
        });
    }
    onEditorMouseDown(e) {
        let mouseDownInfo = null;
        const range = e.target.range;
        if (!range) {
            return;
        }
        if (e.target.type !== monaco.editor.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        const data = e.target.detail;
        const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;
        // don't collide with folding and git decorations
        if (gutterOffsetX > 14) {
            return;
        }
        mouseDownInfo = { lineNumber: range.start };
        const { lineNumber } = mouseDownInfo;
        mouseDownInfo = null;
        if (!range || range.start !== lineNumber) {
            return;
        }
        if (!e.target.element) {
            return;
        }
        if (e.target.element.className.indexOf('comment-diff-added') >= 0) {
            this.addOrToggleCommentAtLine(e.target.position.line + 1, e);
        }
    }
    async beginCompute() {
        const editorModel = this.editor && this.editor.getModel();
        const editorURI = this.editor && editorModel && editorModel.uri;
        if (editorURI) {
            // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
            const comments = await this.commentService.getComments(editorURI);
            this.setComments(comments.filter(c => !!c));
        }
    }
    setComments(commentInfos) {
        if (!this.editor) {
            return;
        }
        this.commentInfos = commentInfos;
    }
    get editor() {
        const editor = this.getCurrentEditor();
        if (editor && editor.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
            return editor.editor.diffEditor.getModifiedEditor();
        }
    }
    displayCommentThread(owner, thread) {
        var _a, _b;
        const editor = this.editor;
        if (editor) {
            const provider = this.commentService.getCommentController(owner);
            if (provider) {
                this.commentsContextKeyService.commentController.set(provider.id);
            }
            const zoneWidget = new comment_thread_widget_1.CommentThreadWidget(editor, owner, thread, this.commentService, this.menus, this.commentsContextKeyService, this.commands);
            zoneWidget.display({ afterLineNumber: (_b = (_a = thread.range) === null || _a === void 0 ? void 0 : _a.startLineNumber) !== null && _b !== void 0 ? _b : 0, heightInLines: 5 }); // messages with no range are put on top of the editor
            const currentEditor = this.getCurrentEditor();
            if (currentEditor) {
                currentEditor.onDispose(() => zoneWidget.dispose());
            }
            this.commentWidgets.push(zoneWidget);
        }
    }
    async addOrToggleCommentAtLine(lineNumber, e) {
        // If an add is already in progress, queue the next add and process it after the current one finishes to
        // prevent empty comment threads from being added to the same line.
        if (!this.addInProgress) {
            this.addInProgress = true;
            // The widget's position is undefined until the widget has been displayed, so rely on the glyph position instead
            const existingCommentsAtLine = this.commentWidgets.filter(widget => widget.getGlyphPosition() === lineNumber);
            if (existingCommentsAtLine.length) {
                existingCommentsAtLine.forEach(widget => widget.toggleExpand(lineNumber));
                this.processNextThreadToAdd();
                return;
            }
            else {
                this.addCommentAtLine(lineNumber, e);
            }
        }
        else {
            this.emptyThreadsToAddQueue.push([lineNumber, e]);
        }
    }
    processNextThreadToAdd() {
        this.addInProgress = false;
        const info = this.emptyThreadsToAddQueue.shift();
        if (info) {
            this.addOrToggleCommentAtLine(info[0], info[1]);
        }
    }
    getCurrentEditor() {
        return this.editorManager.currentEditor;
    }
    addCommentAtLine(lineNumber, e) {
        const newCommentInfos = this.rangeDecorator.getMatchedCommentAction(lineNumber);
        const editor = this.getCurrentEditor();
        if (!editor) {
            return Promise.resolve();
        }
        if (!newCommentInfos.length) {
            return Promise.resolve();
        }
        const { ownerId } = newCommentInfos[0];
        this.addCommentAtLine2(lineNumber, ownerId);
        return Promise.resolve();
    }
    addCommentAtLine2(lineNumber, ownerId) {
        const editorModel = this.editor && this.editor.getModel();
        const editorURI = this.editor && editorModel && editorModel.uri;
        if (editorURI) {
            this.commentService.createCommentThreadTemplate(ownerId, vscode_uri_1.URI.parse(editorURI.toString()), {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: 1,
                endColumn: 1
            });
            this.processNextThreadToAdd();
        }
    }
};
exports.CommentsContribution = CommentsContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", common_1.MenuModelRegistry)
], CommentsContribution.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(comments_context_key_service_1.CommentsContextKeyService),
    tslib_1.__metadata("design:type", comments_context_key_service_1.CommentsContextKeyService)
], CommentsContribution.prototype, "commentsContextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CommentsContribution.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], CommentsContribution.prototype, "commands", void 0);
exports.CommentsContribution = CommentsContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(comments_decorator_1.CommentingRangeDecorator)),
    tslib_1.__param(1, (0, inversify_1.inject)(comments_service_1.CommentsService)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.EditorManager)),
    tslib_1.__metadata("design:paramtypes", [comments_decorator_1.CommentingRangeDecorator, Object, browser_1.EditorManager])
], CommentsContribution);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentingRangeDecorator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let CommentingRangeDecorator = class CommentingRangeDecorator {
    constructor() {
        this.commentingRangeDecorations = [];
        this.decorationOptions = {
            isWholeLine: true,
            linesDecorationsClassName: 'comment-range-glyph comment-diff-added'
        };
    }
    update(editor, commentInfos) {
        const model = editor.getModel();
        if (!model) {
            return;
        }
        const commentingRangeDecorations = [];
        for (const info of commentInfos) {
            info.commentingRanges.ranges.forEach(range => {
                commentingRangeDecorations.push(new CommentingRangeDecoration(editor, info.owner, info.extensionId, info.label, range, this.decorationOptions, info.commentingRanges));
            });
        }
        const oldDecorations = this.commentingRangeDecorations.map(decoration => decoration.id);
        editor.deltaDecorations(oldDecorations, []);
        this.commentingRangeDecorations = commentingRangeDecorations;
    }
    getMatchedCommentAction(line) {
        const result = [];
        for (const decoration of this.commentingRangeDecorations) {
            const range = decoration.getActiveRange();
            if (range && range.startLineNumber <= line && line <= range.endLineNumber) {
                result.push(decoration.getCommentAction());
            }
        }
        return result;
    }
};
exports.CommentingRangeDecorator = CommentingRangeDecorator;
exports.CommentingRangeDecorator = CommentingRangeDecorator = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], CommentingRangeDecorator);
class CommentingRangeDecoration {
    get id() {
        return this.decorationId;
    }
    constructor(_editor, _ownerId, _extensionId, _label, _range, commentingOptions, commentingRangesInfo) {
        this._editor = _editor;
        this._ownerId = _ownerId;
        this._extensionId = _extensionId;
        this._label = _label;
        this._range = _range;
        this.commentingRangesInfo = commentingRangesInfo;
        const startLineNumber = _range.startLineNumber;
        const endLineNumber = _range.endLineNumber;
        const commentingRangeDecorations = [{
                range: {
                    startLineNumber: startLineNumber, startColumn: 1,
                    endLineNumber: endLineNumber, endColumn: 1
                },
                options: commentingOptions
            }];
        this.decorationId = this._editor.deltaDecorations([], commentingRangeDecorations)[0];
    }
    getCommentAction() {
        return {
            extensionId: this._extensionId,
            label: this._label,
            ownerId: this._ownerId,
            commentingRangesInfo: this.commentingRangesInfo
        };
    }
    getOriginalRange() {
        return this._range;
    }
    getActiveRange() {
        const range = this._editor.getModel().getDecorationRange(this.decorationId);
        if (range) {
            return range;
        }
    }
}


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsMainImp = exports.CommentController = exports.CommentThreadImpl = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const comments_service_1 = __webpack_require__(/*! ./comments-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../node_modules/@theia/core/lib/common/uuid.js");
const comments_contribution_1 = __webpack_require__(/*! ./comments-contribution */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/api/browser/mainThreadComments.ts
class CommentThreadImpl {
    get input() {
        return this._input;
    }
    set input(value) {
        this._input = value;
        this.onDidChangeInputEmitter.fire(value);
    }
    get onDidChangeInput() { return this.onDidChangeInputEmitter.event; }
    get label() {
        return this._label;
    }
    set label(label) {
        this._label = label;
        this.onDidChangeLabelEmitter.fire(this._label);
    }
    get contextValue() {
        return this._contextValue;
    }
    set contextValue(context) {
        this._contextValue = context;
    }
    get comments() {
        return this._comments;
    }
    set comments(newComments) {
        this._comments = newComments;
        this.onDidChangeCommentsEmitter.fire(this._comments);
    }
    get onDidChangeComments() { return this.onDidChangeCommentsEmitter.event; }
    set range(range) {
        this._range = range;
        this.onDidChangeRangeEmitter.fire(this._range);
    }
    get range() {
        return this._range;
    }
    get collapsibleState() {
        return this._collapsibleState;
    }
    set collapsibleState(newState) {
        this._collapsibleState = newState;
        this.onDidChangeCollapsibleStateEmitter.fire(this._collapsibleState);
    }
    get state() {
        return this._state;
    }
    set state(newState) {
        if (this._state !== newState) {
            this._state = newState;
            this.onDidChangeStateEmitter.fire(this._state);
        }
    }
    get isDisposed() {
        return this._isDisposed;
    }
    get canReply() {
        return this._canReply;
    }
    set canReply(canReply) {
        this._canReply = canReply;
        this.onDidChangeCanReplyEmitter.fire(this._canReply);
    }
    constructor(commentThreadHandle, controllerHandle, extensionId, threadId, resource, _range) {
        this.commentThreadHandle = commentThreadHandle;
        this.controllerHandle = controllerHandle;
        this.extensionId = extensionId;
        this.threadId = threadId;
        this.resource = resource;
        this._range = _range;
        this.onDidChangeInputEmitter = new event_1.Emitter();
        this.onDidChangeLabelEmitter = new event_1.Emitter();
        this.onDidChangeLabel = this.onDidChangeLabelEmitter.event;
        this.onDidChangeCommentsEmitter = new event_1.Emitter();
        this.onDidChangeRangeEmitter = new event_1.Emitter();
        this.onDidChangeRange = this.onDidChangeRangeEmitter.event;
        this.onDidChangeCollapsibleStateEmitter = new event_1.Emitter();
        this.onDidChangeCollapsibleState = this.onDidChangeCollapsibleStateEmitter.event;
        this.onDidChangeStateEmitter = new event_1.Emitter();
        this.onDidChangeState = this.onDidChangeStateEmitter.event;
        this.onDidChangeCanReplyEmitter = new event_1.Emitter();
        this.onDidChangeCanReply = this.onDidChangeCanReplyEmitter.event;
        this._canReply = true;
        this._isDisposed = false;
    }
    batchUpdate(changes) {
        const modified = (value) => Object.prototype.hasOwnProperty.call(changes, value);
        if (modified('range')) {
            this._range = changes.range;
        }
        if (modified('label')) {
            this._label = changes.label;
        }
        if (modified('contextValue')) {
            this._contextValue = changes.contextValue;
        }
        if (modified('comments')) {
            this._comments = changes.comments;
        }
        if (modified('collapseState')) {
            this._collapsibleState = changes.collapseState;
        }
        if (modified('state')) {
            this._state = changes.state;
        }
        if (modified('canReply')) {
            this._canReply = changes.canReply;
        }
    }
    dispose() {
        this._isDisposed = true;
        this.onDidChangeCollapsibleStateEmitter.dispose();
        this.onDidChangeStateEmitter.dispose();
        this.onDidChangeCommentsEmitter.dispose();
        this.onDidChangeInputEmitter.dispose();
        this.onDidChangeLabelEmitter.dispose();
        this.onDidChangeRangeEmitter.dispose();
        this.onDidChangeCanReplyEmitter.dispose();
    }
}
exports.CommentThreadImpl = CommentThreadImpl;
class CommentController {
    get handle() {
        return this._handle;
    }
    get id() {
        return this._id;
    }
    get contextValue() {
        return this._id;
    }
    get proxy() {
        return this._proxy;
    }
    get label() {
        return this._label;
    }
    get options() {
        return this._features.options;
    }
    get features() {
        return this._features;
    }
    constructor(_proxy, _commentService, _handle, _uniqueId, _id, _label, _features) {
        this._proxy = _proxy;
        this._commentService = _commentService;
        this._handle = _handle;
        this._uniqueId = _uniqueId;
        this._id = _id;
        this._label = _label;
        this._features = _features;
        this.threads = new Map();
    }
    updateFeatures(features) {
        this._features = features;
    }
    createCommentThread(extensionId, commentThreadHandle, threadId, resource, range) {
        const thread = new CommentThreadImpl(commentThreadHandle, this.handle, extensionId, threadId, vscode_uri_1.URI.revive(resource).toString(), range);
        this.threads.set(commentThreadHandle, thread);
        this._commentService.updateComments(this._uniqueId, {
            added: [thread],
            removed: [],
            changed: []
        });
        return thread;
    }
    updateCommentThread(commentThreadHandle, threadId, resource, changes) {
        const thread = this.getKnownThread(commentThreadHandle);
        thread.batchUpdate(changes);
        this._commentService.updateComments(this._uniqueId, {
            added: [],
            removed: [],
            changed: [thread]
        });
    }
    deleteCommentThread(commentThreadHandle) {
        const thread = this.getKnownThread(commentThreadHandle);
        this.threads.delete(commentThreadHandle);
        this._commentService.updateComments(this._uniqueId, {
            added: [],
            removed: [thread],
            changed: []
        });
        thread.dispose();
    }
    deleteCommentThreadMain(commentThreadId) {
        this.threads.forEach(thread => {
            if (thread.threadId === commentThreadId) {
                this._proxy.$deleteCommentThread(this._handle, thread.commentThreadHandle);
            }
        });
    }
    updateInput(input) {
        const thread = this.activeCommentThread;
        if (thread && thread.input) {
            const commentInput = thread.input;
            commentInput.value = input;
            thread.input = commentInput;
        }
    }
    getKnownThread(commentThreadHandle) {
        const thread = this.threads.get(commentThreadHandle);
        if (!thread) {
            throw new Error('unknown thread');
        }
        return thread;
    }
    async getDocumentComments(resource, token) {
        const ret = [];
        for (const thread of [...this.threads.keys()]) {
            const commentThread = this.threads.get(thread);
            if (commentThread.resource === resource.toString()) {
                ret.push(commentThread);
            }
        }
        const commentingRanges = await this._proxy.$provideCommentingRanges(this.handle, resource, token);
        return {
            owner: this._uniqueId,
            label: this.label,
            threads: ret,
            commentingRanges: {
                resource: resource,
                ranges: (commentingRanges === null || commentingRanges === void 0 ? void 0 : commentingRanges.ranges) || [],
                fileComments: !!(commentingRanges === null || commentingRanges === void 0 ? void 0 : commentingRanges.fileComments)
            }
        };
    }
    async getCommentingRanges(resource, token) {
        const commentingRanges = await this._proxy.$provideCommentingRanges(this.handle, resource, token);
        return commentingRanges;
    }
    getAllComments() {
        const ret = [];
        for (const thread of [...this.threads.keys()]) {
            ret.push(this.threads.get(thread));
        }
        return ret;
    }
    createCommentThreadTemplate(resource, range) {
        this._proxy.$createCommentThreadTemplate(this.handle, resource, range);
    }
    async updateCommentThreadTemplate(threadHandle, range) {
        await this._proxy.$updateCommentThreadTemplate(this.handle, threadHandle, range);
    }
}
exports.CommentController = CommentController;
class CommentsMainImp {
    constructor(rpc, container) {
        this.documentProviders = new Map();
        this.workspaceProviders = new Map();
        this.handlers = new Map();
        this.commentControllers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMENTS_EXT);
        container.get(comments_contribution_1.CommentsContribution);
        this.commentService = container.get(comments_service_1.CommentsService);
        this.commentService.onDidChangeActiveCommentThread(async (thread) => {
            const handle = thread.controllerHandle;
            const controller = this.commentControllers.get(handle);
            if (!controller) {
                return;
            }
            this.activeCommentThread = thread;
            controller.activeCommentThread = this.activeCommentThread;
        });
    }
    $registerCommentController(handle, id, label) {
        const providerId = (0, uuid_1.generateUuid)();
        this.handlers.set(handle, providerId);
        const provider = new CommentController(this.proxy, this.commentService, handle, providerId, id, label, {});
        this.commentService.registerCommentController(providerId, provider);
        this.commentControllers.set(handle, provider);
        this.commentService.setWorkspaceComments(String(handle), []);
    }
    $unregisterCommentController(handle) {
        const providerId = this.handlers.get(handle);
        if (typeof providerId !== 'string') {
            throw new Error('unknown handler');
        }
        this.commentService.unregisterCommentController(providerId);
        this.handlers.delete(handle);
        this.commentControllers.delete(handle);
    }
    $updateCommentControllerFeatures(handle, features) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        provider.updateFeatures(features);
    }
    $createCommentThread(handle, commentThreadHandle, threadId, resource, range, extensionId) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        return provider.createCommentThread(extensionId, commentThreadHandle, threadId, resource, range);
    }
    $updateCommentThread(handle, commentThreadHandle, threadId, resource, changes) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        return provider.updateCommentThread(commentThreadHandle, threadId, resource, changes);
    }
    $deleteCommentThread(handle, commentThreadHandle) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return;
        }
        return provider.deleteCommentThread(commentThreadHandle);
    }
    getHandler(handle) {
        if (!this.handlers.has(handle)) {
            throw new Error('Unknown handler');
        }
        return this.handlers.get(handle);
    }
    $onDidCommentThreadsChange(handle, event) {
        const providerId = this.getHandler(handle);
        this.commentService.updateComments(providerId, event);
    }
    dispose() {
        this.workspaceProviders.forEach(value => value.dispose());
        this.workspaceProviders.clear();
        this.documentProviders.forEach(value => value.dispose());
        this.documentProviders.clear();
    }
}
exports.CommentsMainImp = CommentsMainImp;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginCommentService = exports.CommentsService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
exports.CommentsService = Symbol('CommentsService');
let PluginCommentService = class PluginCommentService {
    constructor() {
        this.onDidSetDataProviderEmitter = new event_1.Emitter();
        this.onDidSetDataProvider = this.onDidSetDataProviderEmitter.event;
        this.onDidDeleteDataProviderEmitter = new event_1.Emitter();
        this.onDidDeleteDataProvider = this.onDidDeleteDataProviderEmitter.event;
        this.onDidSetResourceCommentInfosEmitter = new event_1.Emitter();
        this.onDidSetResourceCommentInfos = this.onDidSetResourceCommentInfosEmitter.event;
        this.onDidSetAllCommentThreadsEmitter = new event_1.Emitter();
        this.onDidSetAllCommentThreads = this.onDidSetAllCommentThreadsEmitter.event;
        this.onDidUpdateCommentThreadsEmitter = new event_1.Emitter();
        this.onDidUpdateCommentThreads = this.onDidUpdateCommentThreadsEmitter.event;
        this.onDidChangeActiveCommentThreadEmitter = new event_1.Emitter();
        this.onDidChangeActiveCommentThread = this.onDidChangeActiveCommentThreadEmitter.event;
        this.onDidChangeActiveCommentingRangeEmitter = new event_1.Emitter();
        this.onDidChangeActiveCommentingRange = this.onDidChangeActiveCommentingRangeEmitter.event;
        this.commentControls = new Map();
    }
    setActiveCommentThread(commentThread) {
        this.onDidChangeActiveCommentThreadEmitter.fire(commentThread);
    }
    setDocumentComments(resource, commentInfos) {
        this.onDidSetResourceCommentInfosEmitter.fire({ resource, commentInfos });
    }
    setWorkspaceComments(owner, commentsByResource) {
        this.onDidSetAllCommentThreadsEmitter.fire({ ownerId: owner, commentThreads: commentsByResource });
    }
    removeWorkspaceComments(owner) {
        this.onDidSetAllCommentThreadsEmitter.fire({ ownerId: owner, commentThreads: [] });
    }
    registerCommentController(owner, commentControl) {
        this.commentControls.set(owner, commentControl);
        this.onDidSetDataProviderEmitter.fire();
    }
    unregisterCommentController(owner) {
        this.commentControls.delete(owner);
        this.onDidDeleteDataProviderEmitter.fire(owner);
    }
    getCommentController(owner) {
        return this.commentControls.get(owner);
    }
    createCommentThreadTemplate(owner, resource, range) {
        const commentController = this.commentControls.get(owner);
        if (!commentController) {
            return;
        }
        commentController.createCommentThreadTemplate(resource, range);
    }
    async updateCommentThreadTemplate(owner, threadHandle, range) {
        const commentController = this.commentControls.get(owner);
        if (!commentController) {
            return;
        }
        await commentController.updateCommentThreadTemplate(threadHandle, range);
    }
    disposeCommentThread(owner, threadId) {
        const controller = this.getCommentController(owner);
        if (controller) {
            controller.deleteCommentThreadMain(threadId);
        }
    }
    updateComments(ownerId, event) {
        const evt = Object.assign({}, event, { owner: ownerId });
        this.onDidUpdateCommentThreadsEmitter.fire(evt);
    }
    async getComments(resource) {
        const commentControlResult = [];
        this.commentControls.forEach(control => {
            commentControlResult.push(control.getDocumentComments(resource, cancellation_1.CancellationToken.None)
                .catch(e => {
                console.log(e);
                return null;
            }));
        });
        return Promise.all(commentControlResult);
    }
    async getCommentingRanges(resource) {
        const commentControlResult = [];
        this.commentControls.forEach(control => {
            commentControlResult.push(control.getCommentingRanges(resource, cancellation_1.CancellationToken.None));
        });
        const ret = await Promise.all(commentControlResult);
        return ret.reduce((prev, curr) => {
            if (curr) {
                prev.push(...curr.ranges);
            }
            return prev;
        }, []);
    }
};
exports.PluginCommentService = PluginCommentService;
exports.PluginCommentService = PluginCommentService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginCommentService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorOpener = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editor-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../node_modules/@theia/core/lib/common/uuid.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../node_modules/@theia/core/lib/common/glob.js");
class CustomEditorOpener {
    constructor(editor, shell, widgetManager, editorRegistry, preferenceService) {
        this.editor = editor;
        this.shell = shell;
        this.widgetManager = widgetManager;
        this.editorRegistry = editorRegistry;
        this.preferenceService = preferenceService;
        this.onDidOpenCustomEditorEmitter = new core_1.Emitter();
        this.onDidOpenCustomEditor = this.onDidOpenCustomEditorEmitter.event;
        this.pendingWidgetPromises = new Map();
        this.id = CustomEditorOpener.toCustomEditorId(this.editor.viewType);
        this.label = this.editor.displayName;
    }
    static toCustomEditorId(editorViewType) {
        return `custom-editor-${editorViewType}`;
    }
    canHandle(uri, options) {
        let priority = 0;
        const { selector } = this.editor;
        if (browser_1.DiffUris.isDiffUri(uri)) {
            const [left, right] = browser_1.DiffUris.decode(uri);
            if (this.matches(selector, right) && this.matches(selector, left)) {
                priority = this.getPriority();
            }
        }
        else if (this.matches(selector, uri)) {
            if ((0, browser_1.getDefaultHandler)(uri, this.preferenceService) === this.editor.viewType) {
                priority = browser_1.defaultHandlerPriority;
            }
            else {
                priority = this.getPriority();
            }
        }
        return priority;
    }
    canOpenWith(uri) {
        if (this.matches(this.editor.selector, uri)) {
            return this.getPriority();
        }
        return 0;
    }
    getPriority() {
        switch (this.editor.priority) {
            case common_1.CustomEditorPriority.default: return 500;
            case common_1.CustomEditorPriority.builtin: return 400;
            /** `option` should not open the custom-editor by default. */
            case common_1.CustomEditorPriority.option: return 1;
            default: return 200;
        }
    }
    async openCustomEditor(uri, options) {
        let widget;
        let isNewWidget = false;
        const uriString = uri.toString();
        let widgetPromise = this.pendingWidgetPromises.get(uriString);
        if (widgetPromise) {
            widget = await widgetPromise;
        }
        else {
            const widgets = this.widgetManager.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID);
            widget = widgets.find(w => w.viewType === this.editor.viewType && w.resource.toString() === uriString);
            if (!widget) {
                isNewWidget = true;
                const id = (0, uuid_1.generateUuid)();
                widgetPromise = this.widgetManager.getOrCreateWidget(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID, { id }).then(async (w) => {
                    try {
                        w.viewType = this.editor.viewType;
                        w.resource = uri;
                        await this.editorRegistry.resolveWidget(w);
                        if (options === null || options === void 0 ? void 0 : options.widgetOptions) {
                            await this.shell.addWidget(w, options.widgetOptions);
                        }
                        return w;
                    }
                    catch (e) {
                        w.dispose();
                        throw e;
                    }
                }).finally(() => this.pendingWidgetPromises.delete(uriString));
                this.pendingWidgetPromises.set(uriString, widgetPromise);
                widget = await widgetPromise;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.mode) === 'activate') {
            await this.shell.activateWidget(widget.id);
        }
        else if ((options === null || options === void 0 ? void 0 : options.mode) === 'reveal') {
            await this.shell.revealWidget(widget.id);
        }
        if (isNewWidget) {
            this.onDidOpenCustomEditorEmitter.fire([widget, options]);
        }
        return widget;
    }
    async openSideBySide(uri, options) {
        const [leftUri, rightUri] = browser_1.DiffUris.decode(uri);
        const widget = await this.widgetManager.getOrCreateWidget(custom_editor_widget_1.CustomEditorWidget.SIDE_BY_SIDE_FACTORY_ID, { uri: uri.toString(), viewType: this.editor.viewType });
        if (!widget.panes.length) { // a new widget
            const trackedDisposables = new core_1.DisposableCollection(widget);
            try {
                const createPane = async (paneUri) => {
                    let pane = await this.openCustomEditor(paneUri);
                    if (pane.isAttached) {
                        await this.shell.closeWidget(pane.id);
                        if (!pane.isDisposed) { // user canceled
                            return undefined;
                        }
                        pane = await this.openCustomEditor(paneUri);
                    }
                    return pane;
                };
                const rightPane = await createPane(rightUri);
                if (!rightPane) {
                    trackedDisposables.dispose();
                    return undefined;
                }
                trackedDisposables.push(rightPane);
                const leftPane = await createPane(leftUri);
                if (!leftPane) {
                    trackedDisposables.dispose();
                    return undefined;
                }
                trackedDisposables.push(leftPane);
                widget.addPane(leftPane);
                widget.addPane(rightPane);
                // dispose the widget if either of its panes gets externally disposed
                leftPane.disposed.connect(() => widget.dispose());
                rightPane.disposed.connect(() => widget.dispose());
                if (options === null || options === void 0 ? void 0 : options.widgetOptions) {
                    await this.shell.addWidget(widget, options.widgetOptions);
                }
            }
            catch (e) {
                trackedDisposables.dispose();
                console.error(e);
                throw e;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.mode) === 'activate') {
            await this.shell.activateWidget(widget.id);
        }
        else if ((options === null || options === void 0 ? void 0 : options.mode) === 'reveal') {
            await this.shell.revealWidget(widget.id);
        }
        return widget;
    }
    async open(uri, options) {
        var _a, _b;
        options = { ...options };
        (_a = options.mode) !== null && _a !== void 0 ? _a : (options.mode = 'activate');
        (_b = options.widgetOptions) !== null && _b !== void 0 ? _b : (options.widgetOptions = { area: 'main' });
        return browser_1.DiffUris.isDiffUri(uri) ? this.openSideBySide(uri, options) : this.openCustomEditor(uri, options);
    }
    matches(selectors, resource) {
        return selectors.some(selector => this.selectorMatches(selector, resource));
    }
    selectorMatches(selector, resource) {
        if (selector.filenamePattern) {
            if ((0, glob_1.match)(selector.filenamePattern.toLowerCase(), resource.path.name.toLowerCase() + resource.path.ext.toLowerCase())) {
                return true;
            }
        }
        return false;
    }
}
exports.CustomEditorOpener = CustomEditorOpener;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/contrib/customEditor/browser/customEditors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.once = exports.CustomEditorModelManager = exports.CustomEditorService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let CustomEditorService = class CustomEditorService {
    constructor() {
        this._models = new CustomEditorModelManager();
    }
    get models() { return this._models; }
};
exports.CustomEditorService = CustomEditorService;
exports.CustomEditorService = CustomEditorService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CustomEditorService);
class CustomEditorModelManager {
    constructor() {
        this.references = new Map();
    }
    add(resource, viewType, model) {
        const key = this.key(resource, viewType);
        const existing = this.references.get(key);
        if (existing) {
            throw new Error('Model already exists');
        }
        this.references.set(key, { viewType, model, counter: 0 });
        return this.tryRetain(resource, viewType);
    }
    async get(resource, viewType) {
        const key = this.key(resource, viewType);
        const entry = this.references.get(key);
        return entry === null || entry === void 0 ? void 0 : entry.model;
    }
    tryRetain(resource, viewType) {
        const key = this.key(resource, viewType);
        const entry = this.references.get(key);
        if (!entry) {
            return undefined;
        }
        entry.counter++;
        return entry.model.then(model => ({
            object: model,
            dispose: once(() => {
                if (--entry.counter <= 0) {
                    entry.model.then(x => x.dispose());
                    this.references.delete(key);
                }
            }),
        }));
    }
    disposeAllModelsForView(viewType) {
        for (const [key, value] of this.references) {
            if (value.viewType === viewType) {
                value.model.then(x => x.dispose());
                this.references.delete(key);
            }
        }
    }
    key(resource, viewType) {
        return `${resource.toString()}@@@${viewType}`;
    }
}
exports.CustomEditorModelManager = CustomEditorModelManager;
function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}
exports.once = once;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var CustomEditorWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const saveable_service_1 = __webpack_require__(/*! @theia/core/lib/browser/saveable-service */ "../node_modules/@theia/core/lib/browser/saveable-service.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
let CustomEditorWidget = CustomEditorWidget_1 = class CustomEditorWidget extends webview_1.WebviewWidget {
    constructor() {
        super(...arguments);
        this._modelRef = { object: undefined, dispose: () => { } };
        // ensures that saveable is available even if modelRef.object is undefined
        this.delegatingSaveable = new browser_1.DelegatingSaveable();
    }
    get modelRef() {
        return this._modelRef;
    }
    set modelRef(modelRef) {
        this._modelRef.dispose();
        this._modelRef = modelRef;
        this.delegatingSaveable.delegate = modelRef.object;
        this.doUpdateContent();
    }
    get saveable() {
        return this.delegatingSaveable;
    }
    init() {
        super.init();
        this.id = CustomEditorWidget_1.FACTORY_ID + ':' + this.identifier.id;
        this.toDispose.push(this.fileService.onDidRunOperation(e => {
            if (e.isOperation(2 /* FileOperation.MOVE */)) {
                this.doMove(e.target.resource);
            }
        }));
    }
    undo() {
        var _a;
        (_a = this._modelRef.object) === null || _a === void 0 ? void 0 : _a.undo();
    }
    redo() {
        var _a;
        (_a = this._modelRef.object) === null || _a === void 0 ? void 0 : _a.redo();
    }
    async save(options) {
        var _a;
        await ((_a = this._modelRef.object) === null || _a === void 0 ? void 0 : _a.saveCustomEditor(options));
    }
    async saveAs(source, target, options) {
        if (this._modelRef.object) {
            const result = await this._modelRef.object.saveCustomEditorAs(source, target, options);
            this.doMove(target);
            return result;
        }
    }
    getResourceUri() {
        return this.resource;
    }
    createMoveToUri(resourceUri) {
        return this.resource.withPath(resourceUri.path);
    }
    storeState() {
        return {
            ...super.storeState(),
            strResource: this.resource.toString(),
        };
    }
    restoreState(oldState) {
        const { strResource } = oldState;
        this.resource = new uri_1.default(strResource);
        super.restoreState(oldState);
    }
    onMove(handler) {
        this._moveHandler = handler;
    }
    doMove(target) {
        if (this._moveHandler) {
            this._moveHandler(target);
        }
    }
};
exports.CustomEditorWidget = CustomEditorWidget;
CustomEditorWidget.FACTORY_ID = 'plugin-custom-editor';
CustomEditorWidget.SIDE_BY_SIDE_FACTORY_ID = CustomEditorWidget_1.FACTORY_ID + '.side-by-side';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], CustomEditorWidget.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(saveable_service_1.SaveableService),
    tslib_1.__metadata("design:type", saveable_service_1.SaveableService)
], CustomEditorWidget.prototype, "saveService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CustomEditorWidget.prototype, "init", null);
exports.CustomEditorWidget = CustomEditorWidget = CustomEditorWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CustomEditorWidget);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/api/browser/mainThreadCustomEditors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomTextEditorModel = exports.MainCustomEditorModel = exports.CustomEditorsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ./plugin-custom-editor-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
const text_editor_model_service_1 = __webpack_require__(/*! ../text-editor-model-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const custom_editor_service_1 = __webpack_require__(/*! ./custom-editor-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const undo_redo_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/undo-redo-service */ "../node_modules/@theia/editor/lib/browser/undo-redo-service.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../node_modules/@theia/core/lib/browser/widget-manager.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
class CustomEditorsMainImpl {
    constructor(rpc, container, webviewsMain) {
        this.webviewsMain = webviewsMain;
        this.editorProviders = new Map();
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.shell = container.get(browser_1.ApplicationShell);
        this.textModelService = container.get(text_editor_model_service_1.EditorModelService);
        this.fileService = container.get(file_service_1.FileService);
        this.customEditorService = container.get(custom_editor_service_1.CustomEditorService);
        this.undoRedoService = container.get(undo_redo_service_1.UndoRedoService);
        this.customEditorRegistry = container.get(plugin_custom_editor_registry_1.PluginCustomEditorRegistry);
        this.labelProvider = container.get(browser_1.LabelProvider);
        this.editorPreferences = container.get(browser_2.EditorPreferences);
        this.widgetManager = container.get(widget_manager_1.WidgetManager);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CUSTOM_EDITORS_EXT);
    }
    dispose() {
        for (const disposable of this.editorProviders.values()) {
            disposable.dispose();
        }
        this.editorProviders.clear();
    }
    $registerTextEditorProvider(viewType, options, capabilities) {
        this.registerEditorProvider(1 /* CustomEditorModelType.Text */, viewType, options, capabilities, true);
    }
    $registerCustomEditorProvider(viewType, options, supportsMultipleEditorsPerDocument) {
        this.registerEditorProvider(0 /* CustomEditorModelType.Custom */, viewType, options, {}, supportsMultipleEditorsPerDocument);
    }
    async registerEditorProvider(modelType, viewType, options, capabilities, supportsMultipleEditorsPerDocument) {
        if (this.editorProviders.has(viewType)) {
            throw new Error(`Provider for ${viewType} already registered`);
        }
        const disposables = new disposable_1.DisposableCollection();
        disposables.push(this.customEditorRegistry.registerResolver(viewType, async (widget) => {
            const { resource, identifier } = widget;
            widget.options = options;
            const cancellationSource = new cancellation_1.CancellationTokenSource();
            let modelRef = await this.getOrCreateCustomEditorModel(modelType, resource, viewType, cancellationSource.token);
            widget.modelRef = modelRef;
            widget.onDidDispose(() => {
                // If the model is still dirty, make sure we have time to save it
                if (modelRef.object.dirty) {
                    const sub = modelRef.object.onDirtyChanged(() => {
                        if (!modelRef.object.dirty) {
                            sub.dispose();
                            modelRef.dispose();
                        }
                    });
                    return;
                }
                modelRef.dispose();
            });
            if (capabilities.supportsMove) {
                const onMoveCancelTokenSource = new cancellation_1.CancellationTokenSource();
                widget.onMove(async (newResource) => {
                    const oldModel = modelRef;
                    modelRef = await this.getOrCreateCustomEditorModel(modelType, newResource, viewType, onMoveCancelTokenSource.token);
                    this.proxy.$onMoveCustomEditor(identifier.id, newResource.toComponents(), viewType);
                    oldModel.dispose();
                });
            }
            this.webviewsMain.hookWebview(widget);
            widget.title.label = this.labelProvider.getName(resource);
            const _cancellationSource = new cancellation_1.CancellationTokenSource();
            await this.proxy.$resolveWebviewEditor(resource.toComponents(), identifier.id, viewType, widget.title.label, widget.viewState.position, options, _cancellationSource.token);
        }));
        this.editorProviders.set(viewType, disposables);
    }
    $unregisterEditorProvider(viewType) {
        const provider = this.editorProviders.get(viewType);
        if (!provider) {
            throw new Error(`No provider for ${viewType} registered`);
        }
        provider.dispose();
        this.editorProviders.delete(viewType);
        this.customEditorService.models.disposeAllModelsForView(viewType);
    }
    async getOrCreateCustomEditorModel(modelType, resource, viewType, cancellationToken) {
        const existingModel = this.customEditorService.models.tryRetain(resource, viewType);
        if (existingModel) {
            return existingModel;
        }
        switch (modelType) {
            case 1 /* CustomEditorModelType.Text */: {
                const model = CustomTextEditorModel.create(viewType, resource, this.textModelService, this.fileService);
                return this.customEditorService.models.add(resource, viewType, model);
            }
            case 0 /* CustomEditorModelType.Custom */: {
                const model = MainCustomEditorModel.create(this.proxy, viewType, resource, this.undoRedoService, this.fileService, cancellationToken);
                return this.customEditorService.models.add(resource, viewType, model);
            }
        }
    }
    async getCustomEditorModel(resourceComponents, viewType) {
        const resource = vscode_uri_1.URI.revive(resourceComponents);
        const model = await this.customEditorService.models.get(new uri_1.default(resource), viewType);
        if (!model || !(model instanceof MainCustomEditorModel)) {
            throw new Error('Could not find model for custom editor');
        }
        return model;
    }
    async $onDidEdit(resourceComponents, viewType, editId, label) {
        const model = await this.getCustomEditorModel(resourceComponents, viewType);
        model.pushEdit(editId, label);
    }
    async $onContentChange(resourceComponents, viewType) {
        const model = await this.getCustomEditorModel(resourceComponents, viewType);
        model.changeContent();
    }
}
exports.CustomEditorsMainImpl = CustomEditorsMainImpl;
class MainCustomEditorModel {
    static async create(proxy, viewType, resource, undoRedoService, fileService, cancellation) {
        const { editable } = await proxy.$createCustomDocument(resource.toComponents(), viewType, {}, cancellation);
        return new MainCustomEditorModel(proxy, viewType, resource, editable, undoRedoService, fileService);
    }
    constructor(proxy, viewType, editorResource, editable, undoRedoService, fileService) {
        this.proxy = proxy;
        this.viewType = viewType;
        this.editorResource = editorResource;
        this.editable = editable;
        this.undoRedoService = undoRedoService;
        this.fileService = fileService;
        this.currentEditIndex = -1;
        this.savePoint = -1;
        this.isDirtyFromContentChange = false;
        this.edits = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onDirtyChanged = this.onDirtyChangedEmitter.event;
        this.onContentChangedEmitter = new core_1.Emitter();
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.toDispose.push(this.onDirtyChangedEmitter);
    }
    get resource() {
        return vscode_uri_1.URI.from(this.editorResource.toComponents());
    }
    get dirty() {
        if (this.isDirtyFromContentChange) {
            return true;
        }
        if (this.edits.length > 0) {
            return this.savePoint !== this.currentEditIndex;
        }
        return false;
    }
    get readonly() {
        return !this.editable;
    }
    setProxy(proxy) {
        this.proxy = proxy;
    }
    dispose() {
        if (this.editable) {
            this.undoRedoService.removeElements(this.editorResource);
        }
        this.proxy.$disposeCustomDocument(this.resource, this.viewType);
    }
    changeContent() {
        this.change(() => {
            this.isDirtyFromContentChange = true;
        });
    }
    pushEdit(editId, label) {
        if (!this.editable) {
            throw new Error('Document is not editable');
        }
        this.change(() => {
            this.spliceEdits(editId);
            this.currentEditIndex = this.edits.length - 1;
        });
        this.undoRedoService.pushElement(this.editorResource, () => this.undo(), () => this.redo());
    }
    async revert(options) {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex === this.savePoint && !this.isDirtyFromContentChange) {
            return;
        }
        const cancellationSource = new cancellation_1.CancellationTokenSource();
        this.proxy.$revert(this.resource, this.viewType, cancellationSource.token);
        this.change(() => {
            this.isDirtyFromContentChange = false;
            this.currentEditIndex = this.savePoint;
            this.spliceEdits();
        });
    }
    async save(options) {
        await this.saveCustomEditor(options);
    }
    async saveCustomEditor(options) {
        var _a;
        if (!this.editable) {
            return;
        }
        const cancelable = new cancellation_1.CancellationTokenSource();
        const savePromise = this.proxy.$onSave(this.resource, this.viewType, cancelable.token);
        (_a = this.ongoingSave) === null || _a === void 0 ? void 0 : _a.cancel();
        this.ongoingSave = cancelable;
        try {
            await savePromise;
            if (this.ongoingSave === cancelable) { // Make sure we are still doing the same save
                this.change(() => {
                    this.isDirtyFromContentChange = false;
                    this.savePoint = this.currentEditIndex;
                });
            }
        }
        finally {
            if (this.ongoingSave === cancelable) { // Make sure we are still doing the same save
                this.ongoingSave = undefined;
            }
        }
    }
    async saveCustomEditorAs(resource, targetResource, options) {
        if (this.editable) {
            const source = new cancellation_1.CancellationTokenSource();
            await this.proxy.$onSaveAs(this.resource, this.viewType, targetResource.toComponents(), source.token);
            this.change(() => {
                this.savePoint = this.currentEditIndex;
            });
        }
        else {
            // Since the editor is readonly, just copy the file over
            await this.fileService.copy(resource, targetResource, { overwrite: false });
        }
    }
    async undo() {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex < 0) {
            // nothing to undo
            return;
        }
        const undoneEdit = this.edits[this.currentEditIndex];
        this.change(() => {
            --this.currentEditIndex;
        });
        await this.proxy.$undo(this.resource, this.viewType, undoneEdit, this.dirty);
    }
    async redo() {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex >= this.edits.length - 1) {
            // nothing to redo
            return;
        }
        const redoneEdit = this.edits[this.currentEditIndex + 1];
        this.change(() => {
            ++this.currentEditIndex;
        });
        await this.proxy.$redo(this.resource, this.viewType, redoneEdit, this.dirty);
    }
    spliceEdits(editToInsert) {
        const start = this.currentEditIndex + 1;
        const toRemove = this.edits.length - this.currentEditIndex;
        const removedEdits = typeof editToInsert === 'number'
            ? this.edits.splice(start, toRemove, editToInsert)
            : this.edits.splice(start, toRemove);
        if (removedEdits.length) {
            this.proxy.$disposeEdits(this.resource, this.viewType, removedEdits);
        }
    }
    change(makeEdit) {
        const wasDirty = this.dirty;
        makeEdit();
        if (this.dirty !== wasDirty) {
            this.onDirtyChangedEmitter.fire();
        }
        this.onContentChangedEmitter.fire();
    }
}
exports.MainCustomEditorModel = MainCustomEditorModel;
// copied from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/contrib/customEditor/common/customTextEditorModel.ts
class CustomTextEditorModel {
    static async create(viewType, resource, editorModelService, fileService) {
        const model = await editorModelService.createModelReference(resource);
        model.object.suppressOpenEditorWhenDirty = true;
        return new CustomTextEditorModel(viewType, resource, model, fileService);
    }
    constructor(viewType, editorResource, model, fileService) {
        this.viewType = viewType;
        this.editorResource = editorResource;
        this.model = model;
        this.fileService = fileService;
        this.toDispose = new disposable_1.DisposableCollection();
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onDirtyChanged = this.onDirtyChangedEmitter.event;
        this.onContentChangedEmitter = new core_1.Emitter();
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.toDispose.push(this.editorTextModel.onDirtyChanged(e => {
            this.onDirtyChangedEmitter.fire();
        }));
        this.toDispose.push(this.editorTextModel.onContentChanged(e => {
            this.onContentChangedEmitter.fire();
        }));
        this.toDispose.push(this.onDirtyChangedEmitter);
        this.toDispose.push(this.onContentChangedEmitter);
    }
    dispose() {
        this.toDispose.dispose();
        this.model.dispose();
    }
    get resource() {
        return vscode_uri_1.URI.from(this.editorResource.toComponents());
    }
    get dirty() {
        return this.editorTextModel.dirty;
    }
    ;
    get readonly() {
        return Boolean(this.editorTextModel.readOnly);
    }
    get editorTextModel() {
        return this.model.object;
    }
    revert(options) {
        return this.editorTextModel.revert(options);
    }
    save(options) {
        return this.saveCustomEditor(options);
    }
    saveCustomEditor(options) {
        return this.editorTextModel.save(options);
    }
    async saveCustomEditorAs(resource, targetResource, options) {
        await this.saveCustomEditor(options);
        await this.fileService.copy(resource, targetResource, { overwrite: false });
    }
    undo() {
        this.editorTextModel.undo();
    }
    redo() {
        this.editorTextModel.redo();
    }
}
exports.CustomTextEditorModel = CustomTextEditorModel;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginCustomEditorRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const custom_editor_opener_1 = __webpack_require__(/*! ./custom-editor-opener */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editor-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
let PluginCustomEditorRegistry = class PluginCustomEditorRegistry {
    constructor() {
        this.editors = new Map();
        this.pendingEditors = new Map();
        this.resolvers = new Map();
        this.onWillOpenCustomEditorEmitter = new core_1.Emitter();
        this.onWillOpenCustomEditor = this.onWillOpenCustomEditorEmitter.event;
    }
    init() {
        this.widgetManager.onDidCreateWidget(({ factoryId, widget }) => {
            if (factoryId === custom_editor_widget_1.CustomEditorWidget.FACTORY_ID && widget instanceof custom_editor_widget_1.CustomEditorWidget) {
                const restoreState = widget.restoreState.bind(widget);
                widget.restoreState = state => {
                    if (state.viewType && state.strResource) {
                        restoreState(state);
                        this.resolveWidget(widget);
                    }
                    else {
                        widget.dispose();
                    }
                };
            }
        });
    }
    registerCustomEditor(editor, plugin) {
        if (this.editors.has(editor.viewType)) {
            console.warn('editor with such id already registered: ', JSON.stringify(editor));
            return disposable_1.Disposable.NULL;
        }
        this.editors.set(editor.viewType, editor);
        const toDispose = new disposable_1.DisposableCollection();
        toDispose.push(disposable_1.Disposable.create(() => this.editors.delete(editor.viewType)));
        const editorOpenHandler = new custom_editor_opener_1.CustomEditorOpener(editor, this.shell, this.widgetManager, this, this.preferenceService);
        toDispose.push(this.defaultOpenerService.addHandler(editorOpenHandler));
        toDispose.push(this.openWithService.registerHandler({
            id: editor.viewType,
            label: editorOpenHandler.label,
            providerName: plugin.metadata.model.displayName,
            canHandle: uri => editorOpenHandler.canOpenWith(uri),
            open: uri => editorOpenHandler.open(uri)
        }));
        return toDispose;
    }
    async resolveWidget(widget) {
        const resolver = this.resolvers.get(widget.viewType);
        if (resolver) {
            await resolver(widget);
        }
        else {
            const deferred = new promise_util_1.Deferred();
            const disposable = widget.onDidDispose(() => this.pendingEditors.delete(widget));
            this.pendingEditors.set(widget, { deferred, disposable });
            this.onWillOpenCustomEditorEmitter.fire(widget.viewType);
            return deferred.promise;
        }
    }
    ;
    registerResolver(viewType, resolver) {
        if (this.resolvers.has(viewType)) {
            throw new Error(`Resolver for ${viewType} already registered`);
        }
        for (const [editorWidget, { deferred, disposable }] of this.pendingEditors.entries()) {
            if (editorWidget.viewType === viewType) {
                resolver(editorWidget).then(() => deferred.resolve(), err => deferred.reject(err)).finally(() => disposable.dispose());
                this.pendingEditors.delete(editorWidget);
            }
        }
        this.resolvers.set(viewType, resolver);
        return disposable_1.Disposable.create(() => this.resolvers.delete(viewType));
    }
};
exports.PluginCustomEditorRegistry = PluginCustomEditorRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.DefaultOpenerService),
    tslib_1.__metadata("design:type", browser_1.DefaultOpenerService)
], PluginCustomEditorRegistry.prototype, "defaultOpenerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], PluginCustomEditorRegistry.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], PluginCustomEditorRegistry.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenWithService),
    tslib_1.__metadata("design:type", browser_1.OpenWithService)
], PluginCustomEditorRegistry.prototype, "openWithService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], PluginCustomEditorRegistry.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginCustomEditorRegistry.prototype, "init", null);
exports.PluginCustomEditorRegistry = PluginCustomEditorRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginCustomEditorRegistry);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const debug_session_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-manager */ "../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const breakpoint_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/breakpoint/breakpoint-manager */ "../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! @theia/debug/lib/browser/model/debug-source-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const debug_configuration_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-configuration-manager */ "../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const message_service_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/message-service-protocol */ "../node_modules/@theia/core/lib/common/message-service-protocol.js");
const output_channel_1 = __webpack_require__(/*! @theia/output/lib/browser/output-channel */ "../node_modules/@theia/output/lib/browser/output-channel.js");
const debug_preferences_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-preferences */ "../node_modules/@theia/debug/lib/browser/debug-preferences.js");
const plugin_debug_adapter_contribution_1 = __webpack_require__(/*! ./plugin-debug-adapter-contribution */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js");
const plugin_debug_configuration_provider_1 = __webpack_require__(/*! ./plugin-debug-configuration-provider */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js");
const plugin_debug_session_contribution_registry_1 = __webpack_require__(/*! ./plugin-debug-session-contribution-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const plugin_debug_session_factory_1 = __webpack_require__(/*! ./plugin-debug-session-factory */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js");
const plugin_debug_service_1 = __webpack_require__(/*! ./plugin-debug-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const debug_function_breakpoint_1 = __webpack_require__(/*! @theia/debug/lib/browser/model/debug-function-breakpoint */ "../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const console_session_manager_1 = __webpack_require__(/*! @theia/console/lib/browser/console-session-manager */ "../node_modules/@theia/console/lib/browser/console-session-manager.js");
const debug_console_session_1 = __webpack_require__(/*! @theia/debug/lib/browser/console/debug-console-session */ "../node_modules/@theia/debug/lib/browser/console/debug-console-session.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const debug_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-contribution */ "../node_modules/@theia/debug/lib/browser/debug-contribution.js");
const browser_3 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const debug_session_options_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-options */ "../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
class DebugMainImpl {
    constructor(rpc, connectionMain, container) {
        this.connectionMain = connectionMain;
        this.debuggerContributions = new Map();
        this.configurationProviders = new Map();
        this.toDispose = new disposable_1.DisposableCollection();
        this.debugExt = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DEBUG_EXT);
        this.sessionManager = container.get(debug_session_manager_1.DebugSessionManager);
        this.labelProvider = container.get(browser_1.LabelProvider);
        this.editorManager = container.get(browser_2.EditorManager);
        this.breakpointsManager = container.get(breakpoint_manager_1.BreakpointManager);
        this.consoleSessionManager = container.get(console_session_manager_1.ConsoleSessionManager);
        this.configurationManager = container.get(debug_configuration_manager_1.DebugConfigurationManager);
        this.terminalService = container.get(terminal_service_1.TerminalService);
        this.messages = container.get(message_service_protocol_1.MessageClient);
        this.outputChannelManager = container.get(output_channel_1.OutputChannelManager);
        this.debugPreferences = container.get(debug_preferences_1.DebugPreferences);
        this.pluginDebugService = container.get(plugin_debug_service_1.PluginDebugService);
        this.sessionContributionRegistrator = container.get(plugin_debug_session_contribution_registry_1.PluginDebugSessionContributionRegistry);
        this.debugContributionProvider = container.getNamed(common_1.ContributionProvider, debug_contribution_1.DebugContribution);
        this.fileService = container.get(file_service_1.FileService);
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.testService = container.get(test_service_1.TestService);
        this.workspaceService = container.get(browser_3.WorkspaceService);
        const fireDidChangeBreakpoints = ({ added, removed, changed }) => {
            this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(added), removed.map(b => b.id), this.toTheiaPluginApiBreakpoints(changed));
        };
        this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(this.breakpointsManager.getBreakpoints()), [], []);
        this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(this.breakpointsManager.getFunctionBreakpoints()), [], []);
        this.toDispose.pushAll([
            this.breakpointsManager.onDidChangeBreakpoints(fireDidChangeBreakpoints),
            this.breakpointsManager.onDidChangeFunctionBreakpoints(fireDidChangeBreakpoints),
            this.sessionManager.onDidCreateDebugSession(debugSession => this.debugExt.$sessionDidCreate(debugSession.id)),
            this.sessionManager.onDidStartDebugSession(debugSession => this.debugExt.$sessionDidStart(debugSession.id)),
            this.sessionManager.onDidDestroyDebugSession(debugSession => this.debugExt.$sessionDidDestroy(debugSession.id)),
            this.sessionManager.onDidChangeActiveDebugSession(event => this.debugExt.$sessionDidChange(event.current && event.current.id)),
            this.sessionManager.onDidReceiveDebugSessionCustomEvent(event => this.debugExt.$onSessionCustomEvent(event.session.id, event.event, event.body)),
            this.sessionManager.onDidFocusStackFrame(stackFrame => this.debugExt.$onDidChangeActiveFrame(this.toDebugStackFrameDTO(stackFrame))),
            this.sessionManager.onDidFocusThread(debugThread => this.debugExt.$onDidChangeActiveThread(this.toDebugThreadDTO(debugThread))),
        ]);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $appendToDebugConsole(value) {
        const session = this.consoleSessionManager.selectedSession;
        if (session instanceof debug_console_session_1.DebugConsoleSession) {
            session.append(value);
        }
    }
    async $appendLineToDebugConsole(value) {
        const session = this.consoleSessionManager.selectedSession;
        if (session instanceof debug_console_session_1.DebugConsoleSession) {
            session.appendLine(value);
        }
    }
    async $registerDebuggerContribution(description) {
        const debugType = description.type;
        const terminalOptionsExt = await this.debugExt.$getTerminalCreationOptions(debugType);
        if (this.toDispose.disposed) {
            return;
        }
        const debugSessionFactory = new plugin_debug_session_factory_1.PluginDebugSessionFactory(this.terminalService, this.editorManager, this.breakpointsManager, this.labelProvider, this.messages, this.outputChannelManager, this.debugPreferences, async (sessionId) => {
            const connection = await this.connectionMain.ensureConnection(sessionId);
            return connection;
        }, this.fileService, terminalOptionsExt, this.debugContributionProvider, this.testService, this.workspaceService);
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.debuggerContributions.delete(debugType)));
        this.debuggerContributions.set(debugType, toDispose);
        toDispose.pushAll([
            this.pluginDebugService.registerDebugAdapterContribution(new plugin_debug_adapter_contribution_1.PluginDebugAdapterContribution(description, this.debugExt, this.pluginService)),
            this.sessionContributionRegistrator.registerDebugSessionContribution({
                debugType: description.type,
                debugSessionFactory: () => debugSessionFactory
            })
        ]);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterDebuggerConfiguration(debugType)));
    }
    async $unregisterDebuggerConfiguration(debugType) {
        const disposable = this.debuggerContributions.get(debugType);
        if (disposable) {
            disposable.dispose();
        }
    }
    $registerDebugConfigurationProvider(description) {
        const handle = description.handle;
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.configurationProviders.delete(handle)));
        this.configurationProviders.set(handle, toDispose);
        toDispose.push(this.pluginDebugService.registerDebugConfigurationProvider(new plugin_debug_configuration_provider_1.PluginDebugConfigurationProvider(description, this.debugExt)));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterDebugConfigurationProvider(handle)));
    }
    async $unregisterDebugConfigurationProvider(handle) {
        const disposable = this.configurationProviders.get(handle);
        if (disposable) {
            disposable.dispose();
        }
    }
    async $addBreakpoints(breakpoints) {
        const newBreakpoints = new Map();
        breakpoints.forEach(b => newBreakpoints.set(b.id, b));
        this.breakpointsManager.findMarkers({
            dataFilter: data => {
                // install only new breakpoints
                if (newBreakpoints.has(data.id)) {
                    newBreakpoints.delete(data.id);
                }
                return false;
            }
        });
        let addedFunctionBreakpoints = false;
        const functionBreakpoints = this.breakpointsManager.getFunctionBreakpoints();
        for (const breakpoint of functionBreakpoints) {
            // install only new breakpoints
            if (newBreakpoints.has(breakpoint.id)) {
                newBreakpoints.delete(breakpoint.id);
            }
        }
        for (const breakpoint of newBreakpoints.values()) {
            if (breakpoint.location) {
                const location = breakpoint.location;
                const column = breakpoint.location.range.startColumn;
                this.breakpointsManager.addBreakpoint({
                    id: breakpoint.id,
                    uri: vscode_uri_1.URI.revive(location.uri).toString(),
                    enabled: breakpoint.enabled,
                    raw: {
                        line: breakpoint.location.range.startLineNumber + 1,
                        column: column > 0 ? column + 1 : undefined,
                        condition: breakpoint.condition,
                        hitCondition: breakpoint.hitCondition,
                        logMessage: breakpoint.logMessage
                    }
                });
            }
            else if (breakpoint.functionName) {
                addedFunctionBreakpoints = true;
                functionBreakpoints.push({
                    id: breakpoint.id,
                    enabled: breakpoint.enabled,
                    raw: {
                        name: breakpoint.functionName
                    }
                });
            }
        }
        if (addedFunctionBreakpoints) {
            this.breakpointsManager.setFunctionBreakpoints(functionBreakpoints);
        }
    }
    async $getDebugProtocolBreakpoint(sessionId, breakpointId) {
        var _a;
        const session = this.sessionManager.getSession(sessionId);
        if (session) {
            return (_a = session.getBreakpoint(breakpointId)) === null || _a === void 0 ? void 0 : _a.raw;
        }
        else {
            throw new Error(`Debug session '${sessionId}' not found`);
        }
    }
    async $removeBreakpoints(breakpoints) {
        const { labelProvider, breakpointsManager, editorManager } = this;
        const session = this.sessionManager.currentSession;
        const ids = new Set(breakpoints);
        for (const origin of this.breakpointsManager.findMarkers({ dataFilter: data => ids.has(data.id) })) {
            const breakpoint = new debug_source_breakpoint_1.DebugSourceBreakpoint(origin.data, { labelProvider, breakpoints: breakpointsManager, editorManager, session });
            breakpoint.remove();
        }
        for (const origin of this.breakpointsManager.getFunctionBreakpoints()) {
            if (ids.has(origin.id)) {
                const breakpoint = new debug_function_breakpoint_1.DebugFunctionBreakpoint(origin, { labelProvider, breakpoints: breakpointsManager, editorManager, session });
                breakpoint.remove();
            }
        }
    }
    async $customRequest(sessionId, command, args) {
        const session = this.sessionManager.getSession(sessionId);
        if (session) {
            return session.sendCustomRequest(command, args);
        }
        throw new Error(`Debug session '${sessionId}' not found`);
    }
    async $startDebugging(folder, nameOrConfiguration, options) {
        // search for matching options
        let sessionOptions;
        if (typeof nameOrConfiguration === 'string') {
            for (const configOptions of this.configurationManager.all) {
                if (configOptions.name === nameOrConfiguration) {
                    sessionOptions = configOptions;
                }
            }
        }
        else {
            sessionOptions = {
                name: nameOrConfiguration.name,
                configuration: nameOrConfiguration
            };
        }
        if (!sessionOptions) {
            console.error(`There is no debug configuration for ${nameOrConfiguration}`);
            return false;
        }
        // translate given extra data
        const workspaceFolderUri = folder && vscode_uri_1.URI.revive(folder.uri).toString();
        if (debug_session_options_1.DebugSessionOptions.isConfiguration(sessionOptions)) {
            sessionOptions = { ...sessionOptions, configuration: { ...sessionOptions.configuration, ...options }, workspaceFolderUri };
        }
        else {
            sessionOptions = { ...sessionOptions, ...options, workspaceFolderUri };
        }
        sessionOptions.testRun = options.testRun;
        // start options
        const session = await this.sessionManager.start(sessionOptions);
        return !!session;
    }
    async $stopDebugging(sessionId) {
        if (sessionId) {
            const session = this.sessionManager.getSession(sessionId);
            return this.sessionManager.terminateSession(session);
        }
        // Terminate all sessions if no session is provided.
        for (const session of this.sessionManager.sessions) {
            this.sessionManager.terminateSession(session);
        }
    }
    toDebugStackFrameDTO(stackFrame) {
        return stackFrame ? {
            sessionId: stackFrame.session.id,
            frameId: stackFrame.frameId,
            threadId: stackFrame.thread.threadId
        } : undefined;
    }
    toDebugThreadDTO(debugThread) {
        return debugThread ? {
            sessionId: debugThread.session.id,
            threadId: debugThread.threadId
        } : undefined;
    }
    toTheiaPluginApiBreakpoints(breakpoints) {
        return breakpoints.map(b => this.toTheiaPluginApiBreakpoint(b));
    }
    toTheiaPluginApiBreakpoint(breakpoint) {
        if ('uri' in breakpoint) {
            const raw = breakpoint.raw;
            return {
                id: breakpoint.id,
                enabled: breakpoint.enabled,
                condition: breakpoint.raw.condition,
                hitCondition: breakpoint.raw.hitCondition,
                logMessage: raw.logMessage,
                location: {
                    uri: vscode_uri_1.URI.parse(breakpoint.uri),
                    range: {
                        startLineNumber: raw.line - 1,
                        startColumn: (raw.column || 1) - 1,
                        endLineNumber: raw.line - 1,
                        endColumn: (raw.column || 1) - 1
                    }
                }
            };
        }
        return {
            id: breakpoint.id,
            enabled: breakpoint.enabled,
            functionName: breakpoint.raw.name
        };
    }
}
exports.DebugMainImpl = DebugMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugAdapterContribution = void 0;
/**
 * Plugin [DebugAdapterContribution](#DebugAdapterContribution).
 */
class PluginDebugAdapterContribution {
    constructor(description, debugExt, pluginService) {
        this.description = description;
        this.debugExt = debugExt;
        this.pluginService = pluginService;
    }
    get type() {
        return this.description.type;
    }
    get label() {
        return this.description.label;
    }
    async createDebugSession(config, workspaceFolder) {
        await this.pluginService.activateByDebug('onDebugAdapterProtocolTracker', config.type);
        return this.debugExt.$createDebugSession(config, workspaceFolder);
    }
    async terminateDebugSession(sessionId) {
        this.debugExt.$terminateDebugSession(sessionId);
    }
}
exports.PluginDebugAdapterContribution = PluginDebugAdapterContribution;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugConfigurationProvider = void 0;
class PluginDebugConfigurationProvider {
    constructor(description, debugExt) {
        this.debugExt = debugExt;
        this.handle = description.handle;
        this.type = description.type;
        this.triggerKind = description.trigger;
        if (description.provideDebugConfiguration) {
            this.provideDebugConfigurations = async (folder) => this.debugExt.$provideDebugConfigurationsByHandle(this.handle, folder);
        }
        if (description.resolveDebugConfigurations) {
            this.resolveDebugConfiguration =
                async (folder, debugConfiguration) => this.debugExt.$resolveDebugConfigurationByHandle(this.handle, folder, debugConfiguration);
        }
        if (description.resolveDebugConfigurationWithSubstitutedVariables) {
            this.resolveDebugConfigurationWithSubstitutedVariables =
                async (folder, debugConfiguration) => this.debugExt.$resolveDebugConfigurationWithSubstitutedVariablesByHandle(this.handle, folder, debugConfiguration);
        }
    }
}
exports.PluginDebugConfigurationProvider = PluginDebugConfigurationProvider;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const debug_service_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-service */ "../node_modules/@theia/debug/lib/common/debug-service.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const ws_connection_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/messaging/ws-connection-provider */ "../node_modules/@theia/core/lib/browser/messaging/ws-connection-provider.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/**
 * Debug service to work with plugin and extension contributions.
 */
let PluginDebugService = class PluginDebugService {
    constructor() {
        this.onDidChangeDebuggersEmitter = new core_1.Emitter();
        this.debuggers = [];
        this.contributors = new Map();
        this.configurationProviders = new Map();
        this.toDispose = new disposable_1.DisposableCollection(this.onDidChangeDebuggersEmitter);
        this.onDidChangeDebugConfigurationProvidersEmitter = new core_1.Emitter();
        // maps session and contribution
        this.sessionId2contrib = new Map();
        // debouncing to send a single notification for multiple registrations at initialization time
        this.fireOnDidConfigurationProvidersChanged = debounce(() => {
            this.onDidChangeDebugConfigurationProvidersEmitter.fire();
        }, 100);
    }
    get onDidChangeDebuggers() {
        return this.onDidChangeDebuggersEmitter.event;
    }
    get onDidChangeDebugConfigurationProviders() {
        return this.onDidChangeDebugConfigurationProvidersEmitter.event;
    }
    init() {
        this.delegated = this.connectionProvider.createProxy(debug_service_1.DebugPath);
        this.toDispose.pushAll([
            disposable_1.Disposable.create(() => this.delegated.dispose()),
            disposable_1.Disposable.create(() => {
                for (const sessionId of this.sessionId2contrib.keys()) {
                    const contrib = this.sessionId2contrib.get(sessionId);
                    contrib.terminateDebugSession(sessionId);
                }
                this.sessionId2contrib.clear();
            })
        ]);
    }
    registerDebugAdapterContribution(contrib) {
        const { type } = contrib;
        if (this.contributors.has(type)) {
            console.warn(`Debugger with type '${type}' already registered.`);
            return disposable_1.Disposable.NULL;
        }
        this.contributors.set(type, contrib);
        return disposable_1.Disposable.create(() => this.unregisterDebugAdapterContribution(type));
    }
    unregisterDebugAdapterContribution(debugType) {
        this.contributors.delete(debugType);
    }
    registerDebugConfigurationProvider(provider) {
        if (this.configurationProviders.has(provider.handle)) {
            const configuration = this.configurationProviders.get(provider.handle);
            if (configuration && configuration.type !== provider.type) {
                console.warn(`Different debug configuration provider with type '${configuration.type}' already registered.`);
                provider.handle = this.configurationProviders.size;
            }
        }
        const handle = provider.handle;
        this.configurationProviders.set(handle, provider);
        this.fireOnDidConfigurationProvidersChanged();
        return disposable_1.Disposable.create(() => this.unregisterDebugConfigurationProvider(handle));
    }
    unregisterDebugConfigurationProvider(handle) {
        this.configurationProviders.delete(handle);
        this.fireOnDidConfigurationProvidersChanged();
    }
    async debugTypes() {
        const debugTypes = new Set(await this.delegated.debugTypes());
        for (const contribution of this.debuggers) {
            debugTypes.add(contribution.type);
        }
        for (const debugType of this.contributors.keys()) {
            debugTypes.add(debugType);
        }
        return [...debugTypes];
    }
    async provideDebugConfigurations(debugType, workspaceFolderUri) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Initial &&
            (p.type === debugType || p.type === '*') &&
            p.provideDebugConfigurations));
        if (pluginProviders.length === 0) {
            return this.delegated.provideDebugConfigurations(debugType, workspaceFolderUri);
        }
        const results = [];
        await Promise.all(pluginProviders.map(async (p) => {
            const result = await p.provideDebugConfigurations(workspaceFolderUri);
            if (result) {
                results.push(...result);
            }
        }));
        return results;
    }
    async fetchDynamicDebugConfiguration(name, providerType, folder) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Dynamic &&
            p.type === providerType &&
            p.provideDebugConfigurations));
        for (const provider of pluginProviders) {
            const configurations = await provider.provideDebugConfigurations(folder);
            for (const configuration of configurations) {
                if (configuration.name === name) {
                    return configuration;
                }
            }
        }
    }
    async provideDynamicDebugConfigurations(folder) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Dynamic &&
            p.provideDebugConfigurations));
        const configurationsRecord = {};
        await Promise.all(pluginProviders.map(async (provider) => {
            const configurations = await provider.provideDebugConfigurations(folder);
            let configurationsPerType = configurationsRecord[provider.type];
            configurationsPerType = configurationsPerType ? configurationsPerType.concat(configurations) : configurations;
            if (configurationsPerType.length > 0) {
                configurationsRecord[provider.type] = configurationsPerType;
            }
        }));
        return configurationsRecord;
    }
    async resolveDebugConfiguration(config, workspaceFolderUri) {
        const allProviders = Array.from(this.configurationProviders.values());
        const resolvers = allProviders
            .filter(p => p.type === config.type && !!p.resolveDebugConfiguration)
            .map(p => p.resolveDebugConfiguration);
        // Append debug type '*' at the end
        resolvers.push(...allProviders
            .filter(p => p.type === '*' && !!p.resolveDebugConfiguration)
            .map(p => p.resolveDebugConfiguration));
        const resolved = await this.resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers);
        return resolved ? this.delegated.resolveDebugConfiguration(resolved, workspaceFolderUri) : resolved;
    }
    async resolveDebugConfigurationWithSubstitutedVariables(config, workspaceFolderUri) {
        const allProviders = Array.from(this.configurationProviders.values());
        const resolvers = allProviders
            .filter(p => p.type === config.type && !!p.resolveDebugConfigurationWithSubstitutedVariables)
            .map(p => p.resolveDebugConfigurationWithSubstitutedVariables);
        // Append debug type '*' at the end
        resolvers.push(...allProviders
            .filter(p => p.type === '*' && !!p.resolveDebugConfigurationWithSubstitutedVariables)
            .map(p => p.resolveDebugConfigurationWithSubstitutedVariables));
        const resolved = await this.resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers);
        return resolved
            ? this.delegated.resolveDebugConfigurationWithSubstitutedVariables(resolved, workspaceFolderUri)
            : resolved;
    }
    async resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers) {
        let resolved = config;
        for (const resolver of resolvers) {
            try {
                if (!resolved) {
                    // A provider has indicated to stop and process undefined or null as per specified in the vscode API
                    // https://code.visualstudio.com/api/references/vscode-api#DebugConfigurationProvider
                    break;
                }
                resolved = await resolver(workspaceFolderUri, resolved);
            }
            catch (e) {
                console.error(e);
            }
        }
        return resolved;
    }
    registerDebugger(contribution) {
        this.debuggers.push(contribution);
        return disposable_1.Disposable.create(() => {
            const index = this.debuggers.indexOf(contribution);
            if (index !== -1) {
                this.debuggers.splice(index, 1);
            }
        });
    }
    async provideDebuggerVariables(debugType) {
        for (const contribution of this.debuggers) {
            if (contribution.type === debugType) {
                const variables = contribution.variables;
                if (variables && Object.keys(variables).length > 0) {
                    return variables;
                }
            }
        }
        return {};
    }
    async getDebuggersForLanguage(language) {
        const debuggers = await this.delegated.getDebuggersForLanguage(language);
        for (const contributor of this.debuggers) {
            const languages = contributor.languages;
            if (languages && languages.indexOf(language) !== -1) {
                const { label, type } = contributor;
                debuggers.push({ type, label: label || type });
            }
        }
        return debuggers;
    }
    async getSchemaAttributes(debugType) {
        let schemas = await this.delegated.getSchemaAttributes(debugType);
        for (const contribution of this.debuggers) {
            if (contribution.configurationAttributes &&
                (contribution.type === debugType || contribution.type === '*' || debugType === '*')) {
                schemas = schemas.concat(this.resolveSchemaAttributes(contribution.type, contribution.configurationAttributes));
            }
        }
        return schemas;
    }
    resolveSchemaAttributes(type, configurationAttributes) {
        const taskSchema = {};
        return Object.keys(configurationAttributes).map(request => {
            const attributes = (0, core_1.deepClone)(configurationAttributes[request]);
            const defaultRequired = ['name', 'type', 'request'];
            attributes.required = attributes.required && attributes.required.length ? defaultRequired.concat(attributes.required) : defaultRequired;
            attributes.additionalProperties = false;
            attributes.type = 'object';
            if (!attributes.properties) {
                attributes.properties = {};
            }
            const properties = attributes.properties;
            properties['type'] = {
                enum: [type],
                description: core_1.nls.localizeByDefault('Type of configuration.'),
                pattern: '^(?!node2)',
                errorMessage: core_1.nls.localizeByDefault('The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled.'),
                patternErrorMessage: core_1.nls.localizeByDefault('"node2" is no longer supported, use "node" instead and set the "protocol" attribute to "inspector".')
            };
            properties['name'] = {
                type: 'string',
                description: core_1.nls.localizeByDefault('Name of configuration; appears in the launch configuration dropdown menu.'),
                default: 'Launch'
            };
            properties['request'] = {
                enum: [request],
                description: core_1.nls.localizeByDefault('Request type of configuration. Can be "launch" or "attach".'),
            };
            properties['debugServer'] = {
                type: 'number',
                description: core_1.nls.localizeByDefault('For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode'),
                default: 4711
            };
            properties['preLaunchTask'] = {
                anyOf: [taskSchema, {
                        type: ['string'],
                    }],
                default: '',
                description: core_1.nls.localizeByDefault('Task to run before debug session starts.')
            };
            properties['postDebugTask'] = {
                anyOf: [taskSchema, {
                        type: ['string'],
                    }],
                default: '',
                description: core_1.nls.localizeByDefault('Task to run after debug session ends.')
            };
            properties['internalConsoleOptions'] = {
                enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],
                default: 'openOnFirstSessionStart',
                description: core_1.nls.localizeByDefault('Controls when the internal Debug Console should open.')
            };
            properties['suppressMultipleSessionWarning'] = {
                type: 'boolean',
                description: core_1.nls.localizeByDefault('Disable the warning when trying to start the same debug configuration more than once.'),
                default: true
            };
            const osProperties = Object.assign({}, properties);
            properties['windows'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('Windows specific launch configuration attributes.'),
                properties: osProperties
            };
            properties['osx'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('OS X specific launch configuration attributes.'),
                properties: osProperties
            };
            properties['linux'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('Linux specific launch configuration attributes.'),
                properties: osProperties
            };
            Object.keys(attributes.properties).forEach(name => {
                // Use schema allOf property to get independent error reporting #21113
                attributes.properties[name].pattern = attributes.properties[name].pattern || '^(?!.*\\$\\{(env|config|command)\\.)';
                attributes.properties[name].patternErrorMessage = attributes.properties[name].patternErrorMessage ||
                    core_1.nls.localizeByDefault("'env.', 'config.' and 'command.' are deprecated, use 'env:', 'config:' and 'command:' instead.");
            });
            return attributes;
        });
    }
    async getConfigurationSnippets() {
        let snippets = await this.delegated.getConfigurationSnippets();
        for (const contribution of this.debuggers) {
            if (contribution.configurationSnippets) {
                snippets = snippets.concat(contribution.configurationSnippets);
            }
        }
        return snippets;
    }
    async createDebugSession(config, workspaceFolder) {
        const contributor = this.contributors.get(config.type);
        if (contributor) {
            const sessionId = await contributor.createDebugSession(config, workspaceFolder);
            this.sessionId2contrib.set(sessionId, contributor);
            return sessionId;
        }
        else {
            return this.delegated.createDebugSession(config, workspaceFolder);
        }
    }
    async terminateDebugSession(sessionId) {
        const contributor = this.sessionId2contrib.get(sessionId);
        if (contributor) {
            this.sessionId2contrib.delete(sessionId);
            return contributor.terminateDebugSession(sessionId);
        }
        else {
            return this.delegated.terminateDebugSession(sessionId);
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
};
exports.PluginDebugService = PluginDebugService;
tslib_1.__decorate([
    (0, inversify_1.inject)(ws_connection_provider_1.WebSocketConnectionProvider),
    tslib_1.__metadata("design:type", ws_connection_provider_1.WebSocketConnectionProvider)
], PluginDebugService.prototype, "connectionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], PluginDebugService.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginDebugService.prototype, "init", null);
exports.PluginDebugService = PluginDebugService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginDebugService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugSessionContributionRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const debug_session_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-contribution */ "../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const contribution_provider_1 = __webpack_require__(/*! @theia/core/lib/common/contribution-provider */ "../node_modules/@theia/core/lib/common/contribution-provider.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
/**
 * Plugin debug session contribution registry implementation with functionality
 * to register / unregister plugin contributions.
 */
let PluginDebugSessionContributionRegistry = class PluginDebugSessionContributionRegistry {
    constructor() {
        this.contribs = new Map();
    }
    init() {
        for (const contrib of this.contributions.getContributions()) {
            this.contribs.set(contrib.debugType, contrib);
        }
    }
    get(debugType) {
        return this.contribs.get(debugType);
    }
    registerDebugSessionContribution(contrib) {
        const { debugType } = contrib;
        if (this.contribs.has(debugType)) {
            console.warn(`Debug session contribution already registered for ${debugType}`);
            return disposable_1.Disposable.NULL;
        }
        this.contribs.set(debugType, contrib);
        return disposable_1.Disposable.create(() => this.unregisterDebugSessionContribution(debugType));
    }
    unregisterDebugSessionContribution(debugType) {
        this.contribs.delete(debugType);
    }
};
exports.PluginDebugSessionContributionRegistry = PluginDebugSessionContributionRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(contribution_provider_1.ContributionProvider),
    (0, inversify_1.named)(debug_session_contribution_1.DebugSessionContribution),
    tslib_1.__metadata("design:type", Object)
], PluginDebugSessionContributionRegistry.prototype, "contributions", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginDebugSessionContributionRegistry.prototype, "init", null);
exports.PluginDebugSessionContributionRegistry = PluginDebugSessionContributionRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginDebugSessionContributionRegistry);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugSessionFactory = exports.PluginDebugSession = void 0;
const debug_session_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-contribution */ "../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const debug_session_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session */ "../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_session_connection_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-connection */ "../node_modules/@theia/debug/lib/browser/debug-session-connection.js");
class PluginDebugSession extends debug_session_1.DebugSession {
    constructor(id, options, parentSession, testService, testRun, sessionManager, connection, terminalServer, editorManager, breakpoints, labelProvider, messages, fileService, terminalOptionsExt, debugContributionProvider, workspaceService) {
        super(id, options, parentSession, testService, testRun, sessionManager, connection, terminalServer, editorManager, breakpoints, labelProvider, messages, fileService, debugContributionProvider, workspaceService);
        this.id = id;
        this.options = options;
        this.parentSession = parentSession;
        this.connection = connection;
        this.terminalServer = terminalServer;
        this.editorManager = editorManager;
        this.breakpoints = breakpoints;
        this.labelProvider = labelProvider;
        this.messages = messages;
        this.fileService = fileService;
        this.terminalOptionsExt = terminalOptionsExt;
        this.debugContributionProvider = debugContributionProvider;
        this.workspaceService = workspaceService;
    }
    async doCreateTerminal(terminalWidgetOptions) {
        terminalWidgetOptions = Object.assign({}, terminalWidgetOptions, this.terminalOptionsExt);
        return super.doCreateTerminal(terminalWidgetOptions);
    }
}
exports.PluginDebugSession = PluginDebugSession;
/**
 * Session factory for a client debug session that communicates with debug adapter contributed as plugin.
 * The main difference is to use a connection factory that creates [Channel](#Channel) over Rpc channel.
 */
class PluginDebugSessionFactory extends debug_session_contribution_1.DefaultDebugSessionFactory {
    constructor(terminalService, editorManager, breakpoints, labelProvider, messages, outputChannelManager, debugPreferences, connectionFactory, fileService, terminalOptionsExt, debugContributionProvider, testService, workspaceService) {
        super();
        this.terminalService = terminalService;
        this.editorManager = editorManager;
        this.breakpoints = breakpoints;
        this.labelProvider = labelProvider;
        this.messages = messages;
        this.outputChannelManager = outputChannelManager;
        this.debugPreferences = debugPreferences;
        this.connectionFactory = connectionFactory;
        this.fileService = fileService;
        this.terminalOptionsExt = terminalOptionsExt;
        this.debugContributionProvider = debugContributionProvider;
        this.testService = testService;
        this.workspaceService = workspaceService;
    }
    get(manager, sessionId, options, parentSession) {
        const connection = new debug_session_connection_1.DebugSessionConnection(sessionId, this.connectionFactory, this.getTraceOutputChannel());
        return new PluginDebugSession(sessionId, options, parentSession, this.testService, options.testRun, manager, connection, this.terminalService, this.editorManager, this.breakpoints, this.labelProvider, this.messages, this.fileService, this.terminalOptionsExt, this.debugContributionProvider, this.workspaceService);
    }
}
exports.PluginDebugSessionFactory = PluginDebugSessionFactory;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecorationsMainImpl = void 0;
// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const decorations_service_1 = __webpack_require__(/*! @theia/core/lib/browser/decorations-service */ "../node_modules/@theia/core/lib/browser/decorations-service.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.52.1/src/vs/workbench/api/browser/mainThreadDecorations.ts#L85
class DecorationRequestsQueue {
    constructor(proxy, handle) {
        this.proxy = proxy;
        this.handle = handle;
        this.idPool = 0;
        this.requests = new Map();
        this.resolver = new Map();
    }
    enqueue(uri, token) {
        const id = ++this.idPool;
        const result = new Promise(resolve => {
            this.requests.set(id, { id, uri: vscode_uri_1.URI.parse(uri.toString()) });
            this.resolver.set(id, resolve);
            this.processQueue();
        });
        token.onCancellationRequested(() => {
            this.requests.delete(id);
            this.resolver.delete(id);
        });
        return result;
    }
    processQueue() {
        if (typeof this.timer === 'number') {
            // already queued
            return;
        }
        this.timer = setTimeout(() => {
            // make request
            const requests = this.requests;
            const resolver = this.resolver;
            this.proxy.$provideDecorations(this.handle, [...requests.values()], cancellation_1.CancellationToken.None).then(data => {
                for (const [id, resolve] of resolver) {
                    resolve(data[id]);
                }
            });
            // reset
            this.requests = new Map();
            this.resolver = new Map();
            this.timer = undefined;
        }, 0);
    }
}
class DecorationsMainImpl {
    constructor(rpc, container) {
        this.providers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DECORATIONS_EXT);
        this.decorationsService = container.get(decorations_service_1.DecorationsService);
    }
    dispose() {
        this.providers.forEach(value => value.forEach(v => v.dispose()));
        this.providers.clear();
    }
    async $registerDecorationProvider(handle) {
        const emitter = new event_1.Emitter();
        const queue = new DecorationRequestsQueue(this.proxy, handle);
        const registration = this.decorationsService.registerDecorationsProvider({
            onDidChange: emitter.event,
            provideDecorations: async (uri, token) => {
                const data = await queue.enqueue(uri, token);
                if (!data) {
                    return undefined;
                }
                const [bubble, tooltip, letter, themeColor] = data;
                return {
                    weight: 10,
                    bubble: bubble !== null && bubble !== void 0 ? bubble : false,
                    colorId: themeColor === null || themeColor === void 0 ? void 0 : themeColor.id,
                    tooltip,
                    letter
                };
            }
        });
        this.providers.set(handle, [emitter, registration]);
    }
    $onDidChange(handle, resources) {
        const providerSet = this.providers.get(handle);
        if (providerSet) {
            const [emitter] = providerSet;
            emitter.fire(resources && resources.map(r => new uri_1.default(vscode_uri_1.URI.revive(r).toString())));
        }
    }
    $unregisterDecorationProvider(handle) {
        const provider = this.providers.get(handle);
        if (provider) {
            provider.forEach(p => p.dispose());
            this.providers.delete(handle);
        }
    }
}
exports.DecorationsMainImpl = DecorationsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DialogsMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../node_modules/@theia/filesystem/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const file_upload_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-upload-service */ "../node_modules/@theia/filesystem/lib/browser/file-upload-service.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../node_modules/@theia/core/lib/common/env-variables/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class DialogsMainImpl {
    constructor(rpc, container) {
        this.workspaceService = container.get(browser_2.WorkspaceService);
        this.fileService = container.get(file_service_1.FileService);
        this.environments = container.get(env_variables_1.EnvVariablesServer);
        this.fileDialogService = container.get(browser_1.FileDialogService);
        this.uploadService = container.get(file_upload_service_1.FileUploadService);
    }
    async getRootStat(defaultUri) {
        let rootStat;
        // Try to use default URI as root
        if (defaultUri) {
            try {
                rootStat = await this.fileService.resolve(new uri_1.default(defaultUri));
            }
            catch {
                rootStat = undefined;
            }
            // Try to use as root the parent folder of existing file URI/non existing URI
            if (rootStat && !rootStat.isDirectory || !rootStat) {
                try {
                    rootStat = await this.fileService.resolve(new uri_1.default(defaultUri).parent);
                }
                catch {
                    rootStat = undefined;
                }
            }
        }
        // Try to use workspace service root if there is no pre-configured URI
        if (!rootStat) {
            rootStat = (await this.workspaceService.roots)[0];
        }
        // Try to use current user home if root folder is still not taken
        if (!rootStat) {
            const homeDirUri = await this.environments.getHomeDirUri();
            try {
                rootStat = await this.fileService.resolve(new uri_1.default(homeDirUri));
            }
            catch { }
        }
        return rootStat;
    }
    async $showOpenDialog(options) {
        const rootStat = await this.getRootStat(options.defaultUri ? options.defaultUri : undefined);
        if (!rootStat) {
            throw new Error('Unable to find the rootStat');
        }
        try {
            const canSelectFiles = typeof options.canSelectFiles === 'boolean' ? options.canSelectFiles : true;
            const canSelectFolders = typeof options.canSelectFolders === 'boolean' ? options.canSelectFolders : true;
            let title = options.title;
            if (!title) {
                if (canSelectFiles && canSelectFolders) {
                    title = 'Open';
                }
                else {
                    if (canSelectFiles) {
                        title = 'Open File';
                    }
                    else {
                        title = 'Open Folder';
                    }
                    if (options.canSelectMany) {
                        title += '(s)';
                    }
                }
            }
            // Create open file dialog props
            const dialogProps = {
                title: title,
                openLabel: options.openLabel,
                canSelectFiles: options.canSelectFiles,
                canSelectFolders: options.canSelectFolders,
                canSelectMany: options.canSelectMany,
                filters: options.filters
            };
            const result = await this.fileDialogService.showOpenDialog(dialogProps, rootStat);
            if (Array.isArray(result)) {
                return result.map(uri => uri.path.toString());
            }
            else {
                return result ? [result].map(uri => uri.path.toString()) : undefined;
            }
        }
        catch (error) {
            console.error(error);
        }
        return undefined;
    }
    async $showSaveDialog(options) {
        var _a;
        const rootStat = await this.getRootStat(options.defaultUri ? options.defaultUri : undefined);
        // File name field should be empty unless the URI is a file
        let fileNameValue = '';
        if (options.defaultUri) {
            let defaultURIStat;
            try {
                defaultURIStat = await this.fileService.resolve(new uri_1.default(options.defaultUri));
            }
            catch { }
            if (defaultURIStat && !defaultURIStat.isDirectory || !defaultURIStat) {
                fileNameValue = new uri_1.default(options.defaultUri).path.base;
            }
        }
        try {
            // Create save file dialog props
            const dialogProps = {
                title: (_a = options.title) !== null && _a !== void 0 ? _a : core_1.nls.localizeByDefault('Save'),
                saveLabel: options.saveLabel,
                filters: options.filters,
                inputValue: fileNameValue
            };
            const result = await this.fileDialogService.showSaveDialog(dialogProps, rootStat);
            if (result) {
                return result.path.toString();
            }
            return undefined;
        }
        catch (error) {
            console.error(error);
        }
        return undefined;
    }
    async $showUploadDialog(options) {
        const rootStat = await this.getRootStat(options.defaultUri);
        // Fail if root not fount
        if (!rootStat) {
            throw new Error('Failed to resolve base directory where files should be uploaded');
        }
        const uploadResult = await this.uploadService.upload(rootStat.resource.toString());
        if (uploadResult) {
            return uploadResult.uploaded;
        }
        return undefined;
    }
}
exports.DialogsMainImpl = DialogsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModalNotification = exports.MessageType = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const dialogs_1 = __webpack_require__(/*! @theia/core/lib/browser/dialogs */ "../node_modules/@theia/core/lib/browser/dialogs.js");
__webpack_require__(/*! ../../../../src/main/browser/dialogs/style/modal-notification.css */ "../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
var MessageType;
(function (MessageType) {
    MessageType["Error"] = "error";
    MessageType["Warning"] = "warning";
    MessageType["Info"] = "info";
})(MessageType || (exports.MessageType = MessageType = {}));
const NOTIFICATION = 'modal-Notification';
const ICON = 'icon';
const TEXT = 'text';
const DETAIL = 'detail';
let ModalNotification = class ModalNotification extends dialogs_1.AbstractDialog {
    constructor() {
        super({ title: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName });
    }
    onCloseRequest(msg) {
        this.actionTitle = undefined;
        this.accept();
    }
    get value() {
        return this.actionTitle;
    }
    showDialog(messageType, text, options, actions) {
        this.contentNode.appendChild(this.createMessageNode(messageType, text, options, actions));
        return this.open();
    }
    createMessageNode(messageType, text, options, actions) {
        const messageNode = document.createElement('div');
        messageNode.classList.add(NOTIFICATION);
        const iconContainer = messageNode.appendChild(document.createElement('div'));
        iconContainer.classList.add(ICON);
        const iconElement = iconContainer.appendChild(document.createElement('i'));
        iconElement.classList.add(...this.toIconClass(messageType), messageType.toString());
        const textContainer = messageNode.appendChild(document.createElement('div'));
        textContainer.classList.add(TEXT);
        const textElement = textContainer.appendChild(document.createElement('p'));
        textElement.textContent = text;
        if (options.detail) {
            const detailContainer = textContainer.appendChild(document.createElement('div'));
            detailContainer.classList.add(DETAIL);
            const detailElement = detailContainer.appendChild(document.createElement('p'));
            detailElement.textContent = options.detail;
        }
        actions.forEach((action, index) => {
            const button = index === 0
                ? this.appendAcceptButton(action.title)
                : this.createButton(action.title);
            button.classList.add('main');
            this.controlPanel.appendChild(button);
            this.addKeyListener(button, browser_1.Key.ENTER, () => {
                this.actionTitle = action.title;
                this.accept();
            }, 'click');
        });
        if (actions.length <= 0) {
            this.appendAcceptButton();
        }
        else if (!actions.some(action => action.isCloseAffordance === true)) {
            this.appendCloseButton(nls_1.nls.localizeByDefault('Close'));
        }
        return messageNode;
    }
    toIconClass(icon) {
        if (icon === MessageType.Error) {
            return (0, browser_1.codiconArray)('error');
        }
        if (icon === MessageType.Warning) {
            return (0, browser_1.codiconArray)('warning');
        }
        return (0, browser_1.codiconArray)('info');
    }
};
exports.ModalNotification = ModalNotification;
exports.ModalNotification = ModalNotification = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ModalNotification);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsMainImpl = exports.ModelReferenceCollection = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const disposable_util_1 = __webpack_require__(/*! ../../common/disposable-util */ "../node_modules/@theia/plugin-ext/lib/common/disposable-util.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class ModelReferenceCollection {
    constructor(maxAge = 1000 * 60 * 3, maxLength = 1024 * 1024 * 80) {
        this.maxAge = maxAge;
        this.maxLength = maxLength;
        this.data = new Array();
        this.length = 0;
    }
    dispose() {
        this.data = (0, disposable_util_1.dispose)(this.data) || [];
    }
    add(ref) {
        const length = ref.object.textEditorModel.getValueLength();
        const handle = setTimeout(_dispose, this.maxAge);
        const entry = { length, dispose: _dispose };
        const self = this;
        function _dispose() {
            const idx = self.data.indexOf(entry);
            if (idx >= 0) {
                self.length -= length;
                ref.dispose();
                clearTimeout(handle);
                self.data.splice(idx, 1);
            }
        }
        ;
        this.data.push(entry);
        this.length += length;
        this.cleanup();
    }
    cleanup() {
        while (this.length > this.maxLength) {
            this.data[0].dispose();
        }
    }
}
exports.ModelReferenceCollection = ModelReferenceCollection;
class DocumentsMainImpl {
    constructor(editorsAndDocuments, notebookDocuments, modelService, rpc, openerService, shell, untitledResourceResolver, languageService) {
        this.modelService = modelService;
        this.openerService = openerService;
        this.shell = shell;
        this.untitledResourceResolver = untitledResourceResolver;
        this.languageService = languageService;
        this.syncedModels = new Map();
        this.modelReferenceCache = new ModelReferenceCollection();
        this.saveTimeout = 1750;
        this.toDispose = new core_1.DisposableCollection(this.modelReferenceCache);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DOCUMENTS_EXT);
        this.toDispose.push(editorsAndDocuments);
        this.toDispose.push(editorsAndDocuments.onDocumentAdd(documents => documents.forEach(this.onModelAdded, this)));
        this.toDispose.push(editorsAndDocuments.onDocumentRemove(documents => documents.forEach(this.onModelRemoved, this)));
        this.toDispose.push(modelService.onModelModeChanged(this.onModelChanged, this));
        this.toDispose.push(notebookDocuments.onDidAddNotebookCellModel(this.onModelAdded, this));
        this.toDispose.push(modelService.onModelSaved(m => {
            this.proxy.$acceptModelSaved(m.textEditorModel.uri);
        }));
        this.toDispose.push(modelService.onModelWillSave(onWillSaveModelEvent => {
            onWillSaveModelEvent.waitUntil(new Promise(async (resolve, reject) => {
                setTimeout(() => reject(new Error(`Aborted onWillSaveTextDocument-event after ${this.saveTimeout}ms`)), this.saveTimeout);
                const edits = await this.proxy.$acceptModelWillSave(onWillSaveModelEvent.model.textEditorModel.uri, onWillSaveModelEvent.reason, this.saveTimeout);
                const editOperations = [];
                for (const edit of edits) {
                    const { range, text } = edit;
                    if (!range && !text) {
                        continue;
                    }
                    if (range && range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn && !edit.text) {
                        continue;
                    }
                    editOperations.push({
                        range: range ? monaco.Range.lift(range) : onWillSaveModelEvent.model.textEditorModel.getFullModelRange(),
                        /* eslint-disable-next-line no-null/no-null */
                        text: text || null,
                        forceMoveMarkers: edit.forceMoveMarkers
                    });
                }
                resolve(editOperations);
            }));
        }));
        this.toDispose.push(modelService.onModelDirtyChanged(m => {
            this.proxy.$acceptDirtyStateChanged(m.textEditorModel.uri, m.dirty);
        }));
    }
    dispose() {
        this.toDispose.dispose();
    }
    onModelChanged(event) {
        const modelUrl = event.model.textEditorModel.uri;
        if (this.syncedModels.has(modelUrl.toString())) {
            this.proxy.$acceptModelModeChanged(modelUrl, event.oldModeId, event.model.languageId);
        }
    }
    onModelAdded(model) {
        const modelUri = model.textEditorModel.uri;
        const key = modelUri.toString();
        const toDispose = new core_1.DisposableCollection(model.textEditorModel.onDidChangeContent(e => this.proxy.$acceptModelChanged(modelUri, {
            eol: e.eol,
            versionId: e.versionId,
            reason: e.isRedoing ? types_impl_1.TextDocumentChangeReason.Redo : e.isUndoing ? types_impl_1.TextDocumentChangeReason.Undo : undefined,
            changes: e.changes.map(c => ({
                text: c.text,
                range: c.range,
                rangeLength: c.rangeLength,
                rangeOffset: c.rangeOffset
            }))
        }, model.dirty)), core_1.Disposable.create(() => this.syncedModels.delete(key)));
        this.syncedModels.set(key, toDispose);
        this.toDispose.push(toDispose);
    }
    onModelRemoved(url) {
        const model = this.syncedModels.get(url.toString());
        if (model) {
            model.dispose();
        }
    }
    async $tryCreateDocument(options) {
        const language = (options === null || options === void 0 ? void 0 : options.language) && this.languageService.getExtension(options.language);
        const content = options === null || options === void 0 ? void 0 : options.content;
        const resource = await this.untitledResourceResolver.createUntitledResource(content, language);
        return monaco.Uri.parse(resource.uri.toString());
    }
    async $tryShowDocument(uri, options) {
        // Removing try-catch block here makes it not possible to handle errors.
        // Following message is appeared in browser console
        //   - Uncaught (in promise) Error: Cannot read property 'message' of undefined.
        try {
            const editorOptions = DocumentsMainImpl.toEditorOpenerOptions(this.shell, options);
            const uriArg = new uri_1.default(vscode_uri_1.URI.revive(uri));
            const opener = await this.openerService.getOpener(uriArg, editorOptions);
            await opener.open(uriArg, editorOptions);
        }
        catch (err) {
            throw new Error(err);
        }
    }
    async $trySaveDocument(uri) {
        return this.modelService.save(new uri_1.default(vscode_uri_1.URI.revive(uri)));
    }
    async $tryOpenDocument(uri) {
        const ref = await this.modelService.createModelReference(new uri_1.default(vscode_uri_1.URI.revive(uri)));
        if (ref.object) {
            this.modelReferenceCache.add(ref);
            return true;
        }
        else {
            ref.dispose();
            return false;
        }
    }
    static toEditorOpenerOptions(shell, options) {
        if (!options) {
            return undefined;
        }
        let range;
        if (options.selection) {
            const selection = options.selection;
            range = {
                start: { line: selection.startLineNumber - 1, character: selection.startColumn - 1 },
                end: { line: selection.endLineNumber - 1, character: selection.endColumn - 1 }
            };
        }
        /* fall back to side group -> split relative to the active widget */
        let widgetOptions = { mode: 'split-right' };
        let viewColumn = options.viewColumn;
        if (viewColumn === -2) {
            /* show besides -> compute current column and adjust viewColumn accordingly */
            const tabBars = shell.mainAreaTabBars;
            const currentTabBar = shell.currentTabBar;
            if (currentTabBar) {
                const currentColumn = tabBars.indexOf(currentTabBar);
                if (currentColumn > -1) {
                    // +2 because conversion from 0-based to 1-based index and increase of 1
                    viewColumn = currentColumn + 2;
                }
            }
        }
        if (viewColumn === undefined || viewColumn === -1) {
            /* active group -> skip (default behaviour) */
            widgetOptions = undefined;
        }
        else if (viewColumn > 0 && shell.mainAreaTabBars.length > 0) {
            const tabBars = shell.mainAreaTabBars;
            if (viewColumn <= tabBars.length) {
                // convert to zero-based index
                const tabBar = tabBars[viewColumn - 1];
                if (tabBar === null || tabBar === void 0 ? void 0 : tabBar.currentTitle) {
                    widgetOptions = { ref: tabBar.currentTitle.owner };
                }
            }
            else {
                const tabBar = tabBars[tabBars.length - 1];
                if (tabBar === null || tabBar === void 0 ? void 0 : tabBar.currentTitle) {
                    widgetOptions.ref = tabBar.currentTitle.owner;
                }
            }
        }
        return {
            selection: range,
            mode: options.preserveFocus ? 'reveal' : 'activate',
            preview: options.preview,
            widgetOptions
        };
    }
}
exports.DocumentsMainImpl = DocumentsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorsAndDocumentsMain = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const text_editor_model_service_1 = __webpack_require__(/*! ./text-editor-model-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const text_editor_main_1 = __webpack_require__(/*! ./text-editor-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const saveable_service_1 = __webpack_require__(/*! @theia/core/lib/browser/saveable-service */ "../node_modules/@theia/core/lib/browser/saveable-service.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
class EditorsAndDocumentsMain {
    constructor(rpc, container, tabsMain) {
        this.textEditors = new Map();
        this.onTextEditorAddEmitter = new core_1.Emitter();
        this.onTextEditorRemoveEmitter = new core_1.Emitter();
        this.onDocumentAddEmitter = new core_1.Emitter();
        this.onDocumentRemoveEmitter = new core_1.Emitter();
        this.onTextEditorAdd = this.onTextEditorAddEmitter.event;
        this.onTextEditorRemove = this.onTextEditorRemoveEmitter.event;
        this.onDocumentAdd = this.onDocumentAddEmitter.event;
        this.onDocumentRemove = this.onDocumentRemoveEmitter.event;
        this.toDispose = new core_1.DisposableCollection(disposable_1.Disposable.create(() => this.textEditors.clear()));
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.EDITORS_AND_DOCUMENTS_EXT);
        this.editorManager = container.get(browser_1.EditorManager);
        this.modelService = container.get(text_editor_model_service_1.EditorModelService);
        this.saveResourceService = container.get(saveable_service_1.SaveableService);
        this.stateComputer = new EditorAndDocumentStateComputer(d => this.onDelta(d), this.editorManager, container.get(browser_2.NotebookCellEditorService), container.get(browser_2.NotebookEditorWidgetService), this.modelService, tabsMain);
        this.toDispose.push(this.stateComputer);
        this.toDispose.push(this.onTextEditorAddEmitter);
        this.toDispose.push(this.onTextEditorRemoveEmitter);
        this.toDispose.push(this.onDocumentAddEmitter);
        this.toDispose.push(this.onDocumentRemoveEmitter);
    }
    listen() {
        this.stateComputer.listen();
    }
    dispose() {
        this.toDispose.dispose();
    }
    onDelta(delta) {
        const removedEditors = new Array();
        const addedEditors = new Array();
        const removedDocuments = delta.removedDocuments.map(d => d.textEditorModel.uri);
        for (const editor of delta.addedEditors) {
            const textEditorMain = new text_editor_main_1.TextEditorMain(editor.id, editor.editor.getControl().getModel(), editor.editor);
            this.textEditors.set(editor.id, textEditorMain);
            this.toDispose.push(textEditorMain);
            addedEditors.push(textEditorMain);
        }
        for (const { id } of delta.removedEditors) {
            const textEditorMain = this.textEditors.get(id);
            if (textEditorMain) {
                textEditorMain.dispose();
                this.textEditors.delete(id);
                removedEditors.push(id);
            }
        }
        const deltaExt = {};
        let empty = true;
        if (delta.newActiveEditor !== undefined) {
            empty = false;
            deltaExt.newActiveEditor = delta.newActiveEditor;
        }
        if (removedDocuments.length > 0) {
            empty = false;
            deltaExt.removedDocuments = removedDocuments;
        }
        if (removedEditors.length > 0) {
            empty = false;
            deltaExt.removedEditors = removedEditors;
        }
        if (delta.addedDocuments.length > 0) {
            empty = false;
            deltaExt.addedDocuments = delta.addedDocuments.map(d => this.toModelAddData(d));
        }
        if (delta.addedEditors.length > 0) {
            empty = false;
            deltaExt.addedEditors = addedEditors.map(e => this.toTextEditorAddData(e));
        }
        if (!empty) {
            this.proxy.$acceptEditorsAndDocumentsDelta(deltaExt);
            this.onDocumentRemoveEmitter.fire(removedDocuments);
            this.onDocumentAddEmitter.fire(delta.addedDocuments);
            this.onTextEditorRemoveEmitter.fire(removedEditors);
            this.onTextEditorAddEmitter.fire(addedEditors);
        }
    }
    toModelAddData(model) {
        return {
            uri: model.textEditorModel.uri,
            versionId: model.textEditorModel.getVersionId(),
            lines: model.textEditorModel.getLinesContent(),
            languageId: model.getLanguageId(),
            EOL: model.textEditorModel.getEOL(),
            modeId: model.languageId,
            isDirty: model.dirty
        };
    }
    toTextEditorAddData(textEditor) {
        const properties = textEditor.getProperties();
        return {
            id: textEditor.getId(),
            documentUri: textEditor.getModel().uri,
            options: properties.options,
            selections: properties.selections,
            visibleRanges: properties.visibleRanges,
            editorPosition: this.findEditorPosition(textEditor)
        };
    }
    findEditorPosition(editor) {
        return plugin_api_rpc_1.EditorPosition.ONE; // TODO: fix this when Theia has support splitting editors
    }
    getEditor(id) {
        return this.textEditors.get(id);
    }
    async save(uri) {
        const editor = await this.editorManager.getByUri(uri);
        if (!editor) {
            return undefined;
        }
        return this.saveResourceService.save(editor);
    }
    async saveAs(uri) {
        const editor = await this.editorManager.getByUri(uri);
        if (!editor) {
            return undefined;
        }
        if (!this.saveResourceService.canSaveAs(editor)) {
            return undefined;
        }
        return this.saveResourceService.saveAs(editor);
    }
    saveAll(includeUntitled) {
        return this.modelService.saveAll(includeUntitled);
    }
    hideEditor(id) {
        for (const editorWidget of this.editorManager.all) {
            const monacoEditor = monaco_editor_1.MonacoEditor.get(editorWidget);
            if (monacoEditor) {
                if (id === new EditorSnapshot(monacoEditor).id) {
                    editorWidget.close();
                    break;
                }
            }
        }
        return Promise.resolve();
    }
}
exports.EditorsAndDocumentsMain = EditorsAndDocumentsMain;
class EditorAndDocumentStateComputer {
    constructor(callback, editorService, cellEditorService, notebookWidgetService, modelService, tabsMain) {
        this.callback = callback;
        this.editorService = editorService;
        this.cellEditorService = cellEditorService;
        this.notebookWidgetService = notebookWidgetService;
        this.modelService = modelService;
        this.tabsMain = tabsMain;
        this.editors = new Map();
        this.toDispose = new core_1.DisposableCollection(disposable_1.Disposable.create(() => this.currentState = undefined));
    }
    listen() {
        if (this.toDispose.disposed) {
            return;
        }
        this.toDispose.push(this.editorService.onCreated(async (widget) => {
            await this.tabsMain.waitForWidget(widget);
            this.onTextEditorAdd(widget);
            this.update();
        }));
        this.toDispose.push(this.editorService.onCurrentEditorChanged(async (widget) => {
            if (widget) {
                await this.tabsMain.waitForWidget(widget);
            }
            this.update();
        }));
        this.toDispose.push(this.modelService.onModelAdded(this.onModelAdded, this));
        this.toDispose.push(this.modelService.onModelRemoved(() => this.update()));
        this.toDispose.push(this.cellEditorService.onDidChangeCellEditors(() => this.update()));
        this.toDispose.push(this.notebookWidgetService.onDidChangeCurrentEditor(() => {
            this.currentState = this.currentState && new EditorAndDocumentState(this.currentState.documents, this.currentState.editors, undefined);
        }));
        for (const widget of this.editorService.all) {
            this.onTextEditorAdd(widget);
        }
        this.update();
    }
    dispose() {
        this.toDispose.dispose();
    }
    onModelAdded(model) {
        if (!this.currentState) {
            this.update();
            return;
        }
        this.currentState = new EditorAndDocumentState(this.currentState.documents.add(model), this.currentState.editors, this.currentState.activeEditor);
        this.callback(new EditorAndDocumentStateDelta([], [model], [], [], undefined, undefined));
    }
    onTextEditorAdd(widget) {
        const editor = monaco_editor_1.MonacoEditor.get(widget);
        if (!editor) {
            return;
        }
        const id = editor.getControl().getId();
        const toDispose = new core_1.DisposableCollection(editor.onDispose(() => this.onTextEditorRemove(editor)), disposable_1.Disposable.create(() => this.editors.delete(id)));
        this.editors.set(id, toDispose);
        this.toDispose.push(toDispose);
    }
    onTextEditorRemove(e) {
        const toDispose = this.editors.get(e.getControl().getId());
        if (toDispose) {
            toDispose.dispose();
            this.update();
        }
    }
    update() {
        var _a, _b;
        const models = new Set();
        for (const model of this.modelService.getModels()) {
            models.add(model);
        }
        let activeId = null;
        const activeEditor = (_a = monaco_editor_1.MonacoEditor.getCurrent(this.editorService)) !== null && _a !== void 0 ? _a : this.cellEditorService.getActiveCell();
        const editors = new Map();
        for (const widget of this.editorService.all) {
            const editor = monaco_editor_1.MonacoEditor.get(widget);
            // VS Code tracks only visible widgets
            if (!editor || !widget.isVisible) {
                continue;
            }
            const model = editor.getControl().getModel();
            if (model && !model.isDisposed()) {
                const editorSnapshot = new EditorSnapshot(editor);
                editors.set(editorSnapshot.id, editorSnapshot);
                if (activeEditor === editor) {
                    activeId = editorSnapshot.id;
                }
            }
        }
        for (const editor of this.cellEditorService.allCellEditors) {
            if ((_b = editor.getControl()) === null || _b === void 0 ? void 0 : _b.getModel()) {
                const editorSnapshot = new EditorSnapshot(editor);
                editors.set(editorSnapshot.id, editorSnapshot);
                if (activeEditor === editor) {
                    activeId = editorSnapshot.id;
                }
            }
        }
        ;
        const newState = new EditorAndDocumentState(models, editors, activeId);
        const delta = EditorAndDocumentState.compute(this.currentState, newState);
        if (!delta.isEmpty) {
            this.currentState = newState;
            this.callback(delta);
        }
    }
}
class EditorAndDocumentStateDelta {
    constructor(removedDocuments, addedDocuments, removedEditors, addedEditors, oldActiveEditor, newActiveEditor) {
        this.removedDocuments = removedDocuments;
        this.addedDocuments = addedDocuments;
        this.removedEditors = removedEditors;
        this.addedEditors = addedEditors;
        this.oldActiveEditor = oldActiveEditor;
        this.newActiveEditor = newActiveEditor;
        this.isEmpty = this.removedDocuments.length === 0
            && this.addedDocuments.length === 0
            && this.addedEditors.length === 0
            && this.removedEditors.length === 0
            && this.newActiveEditor === this.oldActiveEditor;
    }
}
class EditorAndDocumentState {
    constructor(documents, editors, activeEditor) {
        this.documents = documents;
        this.editors = editors;
        this.activeEditor = activeEditor;
    }
    static compute(before, after) {
        if (!before) {
            return new EditorAndDocumentStateDelta([], Array.from(after.documents), [], Array.from(after.editors.values()), undefined, after.activeEditor);
        }
        const documentDelta = Delta.ofSets(before.documents, after.documents);
        const editorDelta = Delta.ofMaps(before.editors, after.editors);
        const oldActiveEditor = before.activeEditor !== after.activeEditor ? before.activeEditor : undefined;
        const newActiveEditor = before.activeEditor !== after.activeEditor ? after.activeEditor : undefined;
        return new EditorAndDocumentStateDelta(documentDelta.removed, documentDelta.added, editorDelta.removed, editorDelta.added, oldActiveEditor, newActiveEditor);
    }
}
class EditorSnapshot {
    constructor(editor) {
        this.editor = editor;
        this.id = `${editor.getControl().getId()},${editor.getControl().getModel().id}`;
    }
}
var Delta;
(function (Delta) {
    function ofSets(before, after) {
        const removed = [];
        const added = [];
        before.forEach(element => {
            if (!after.has(element)) {
                removed.push(element);
            }
        });
        after.forEach(element => {
            if (!before.has(element)) {
                added.push(element);
            }
        });
        return { removed, added };
    }
    Delta.ofSets = ofSets;
    function ofMaps(before, after) {
        const removed = [];
        const added = [];
        before.forEach((value, index) => {
            if (!after.has(index)) {
                removed.push(value);
            }
        });
        after.forEach((value, index) => {
            if (!before.has(index)) {
                added.push(value);
            }
        });
        return { removed, added };
    }
    Delta.ofMaps = ofMaps;
})(Delta || (Delta = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQueryParameters = exports.EnvMainImpl = void 0;
var env_main_1 = __webpack_require__(/*! ../common/env-main */ "../node_modules/@theia/plugin-ext/lib/main/common/env-main.js");
Object.defineProperty(exports, "EnvMainImpl", ({ enumerable: true, get: function () { return env_main_1.EnvMainImpl; } }));
/**
 * Returns query parameters from current page.
 */
function getQueryParameters() {
    const queryParameters = {};
    if (window.location.search !== '') {
        const queryParametersString = window.location.search.substring(1); // remove question mark
        const params = queryParametersString.split('&');
        for (const pair of params) {
            if (pair === '') {
                continue;
            }
            const keyValue = pair.split('=');
            let key = keyValue[0];
            let value = keyValue[1] ? keyValue[1] : '';
            try {
                key = decodeURIComponent(key);
                if (value !== '') {
                    value = decodeURIComponent(value);
                }
            }
            catch (error) {
                // skip malformed URI sequence
                continue;
            }
            const existedValue = queryParameters[key];
            if (existedValue) {
                if (existedValue instanceof Array) {
                    existedValue.push(value);
                }
                else {
                    // existed value is string
                    queryParameters[key] = [existedValue, value];
                }
            }
            else {
                queryParameters[key] = value;
            }
        }
    }
    return queryParameters;
}
exports.getQueryParameters = getQueryParameters;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/browser/mainThreadFileSystem.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemMainImpl = void 0;
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/tslint/config */
/* eslint-disable @typescript-eslint/no-explicit-any */
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../node_modules/@theia/filesystem/lib/common/files.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
class FileSystemMainImpl {
    constructor(rpc, container) {
        this._fileProvider = new Map();
        this._disposables = new disposable_1.DisposableCollection();
        this._proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.FILE_SYSTEM_EXT);
        this._fileService = container.get(file_service_1.FileService);
        for (const { scheme, capabilities } of this._fileService.listCapabilities()) {
            this._proxy.$acceptProviderInfos(scheme, capabilities);
        }
        this._disposables.push(this._fileService.onDidChangeFileSystemProviderRegistrations(e => { var _a; return this._proxy.$acceptProviderInfos(e.scheme, (_a = e.provider) === null || _a === void 0 ? void 0 : _a.capabilities); }));
        this._disposables.push(this._fileService.onDidChangeFileSystemProviderCapabilities(e => this._proxy.$acceptProviderInfos(e.scheme, e.provider.capabilities)));
        this._disposables.push(disposable_1.Disposable.create(() => this._fileProvider.forEach(value => value.dispose())));
        this._disposables.push(disposable_1.Disposable.create(() => this._fileProvider.clear()));
    }
    dispose() {
        this._disposables.dispose();
    }
    $registerFileSystemProvider(handle, scheme, capabilities, readonlyMessage) {
        this._fileProvider.set(handle, new RemoteFileSystemProvider(this._fileService, scheme, capabilities, handle, this._proxy, readonlyMessage));
    }
    $unregisterProvider(handle) {
        const provider = this._fileProvider.get(handle);
        if (provider) {
            provider.dispose();
            this._fileProvider.delete(handle);
        }
    }
    $onFileSystemChange(handle, changes) {
        const fileProvider = this._fileProvider.get(handle);
        if (!fileProvider) {
            throw new Error('Unknown file provider');
        }
        fileProvider.$onFileSystemChange(changes);
    }
    // --- consumer fs, vscode.workspace.fs
    $stat(uri) {
        return this._fileService.resolve(new uri_1.default(vscode_uri_1.URI.revive(uri)), { resolveMetadata: true }).then(stat => ({
            ctime: stat.ctime,
            mtime: stat.mtime,
            size: stat.size,
            type: files_1.FileStat.asFileType(stat)
        })).catch(FileSystemMainImpl._handleError);
    }
    $readdir(uri) {
        return this._fileService.resolve(new uri_1.default(vscode_uri_1.URI.revive(uri)), { resolveMetadata: false }).then(stat => {
            if (!stat.isDirectory) {
                const err = new Error(stat.name);
                err.name = files_1.FileSystemProviderErrorCode.FileNotADirectory;
                throw err;
            }
            return !stat.children ? [] : stat.children.map(child => [child.name, files_1.FileStat.asFileType(child)]);
        }).catch(FileSystemMainImpl._handleError);
    }
    $readFile(uri) {
        return this._fileService.readFile(new uri_1.default(vscode_uri_1.URI.revive(uri))).then(file => file.value).catch(FileSystemMainImpl._handleError);
    }
    $writeFile(uri, content) {
        return this._fileService.writeFile(new uri_1.default(vscode_uri_1.URI.revive(uri)), content)
            .then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $rename(source, target, opts) {
        return this._fileService.move(new uri_1.default(vscode_uri_1.URI.revive(source)), new uri_1.default(vscode_uri_1.URI.revive(target)), {
            ...opts,
            fromUserGesture: false
        }).then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $copy(source, target, opts) {
        return this._fileService.copy(new uri_1.default(vscode_uri_1.URI.revive(source)), new uri_1.default(vscode_uri_1.URI.revive(target)), {
            ...opts,
            fromUserGesture: false
        }).then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $mkdir(uri) {
        return this._fileService.createFolder(new uri_1.default(vscode_uri_1.URI.revive(uri)), { fromUserGesture: false })
            .then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $delete(uri, opts) {
        return this._fileService.delete(new uri_1.default(vscode_uri_1.URI.revive(uri)), opts).catch(FileSystemMainImpl._handleError);
    }
    static _handleError(err) {
        if (err instanceof files_1.FileOperationError) {
            switch (err.fileOperationResult) {
                case 1 /* FileOperationResult.FILE_NOT_FOUND */:
                    err.name = files_1.FileSystemProviderErrorCode.FileNotFound;
                    break;
                case 0 /* FileOperationResult.FILE_IS_DIRECTORY */:
                    err.name = files_1.FileSystemProviderErrorCode.FileIsADirectory;
                    break;
                case 6 /* FileOperationResult.FILE_PERMISSION_DENIED */:
                    err.name = files_1.FileSystemProviderErrorCode.NoPermissions;
                    break;
                case 4 /* FileOperationResult.FILE_MOVE_CONFLICT */:
                    err.name = files_1.FileSystemProviderErrorCode.FileExists;
                    break;
            }
        }
        throw err;
    }
}
exports.FileSystemMainImpl = FileSystemMainImpl;
class RemoteFileSystemProvider {
    constructor(fileService, scheme, capabilities, _handle, _proxy, readOnlyMessage = undefined) {
        this._handle = _handle;
        this._proxy = _proxy;
        this.readOnlyMessage = readOnlyMessage;
        this._onDidChange = new event_1.Emitter();
        this.onDidChangeFile = this._onDidChange.event;
        this.onFileWatchError = new event_1.Emitter().event; // dummy, never fired
        this.onDidChangeCapabilities = event_1.Event.None;
        this.onDidChangeReadOnlyMessage = event_1.Event.None;
        this.capabilities = capabilities;
        this._registration = fileService.registerProvider(scheme, this);
    }
    dispose() {
        this._registration.dispose();
        this._onDidChange.dispose();
    }
    watch(resource, opts) {
        const session = Math.random();
        this._proxy.$watch(this._handle, session, resource['codeUri'], opts);
        return disposable_1.Disposable.create(() => {
            this._proxy.$unwatch(this._handle, session);
        });
    }
    $onFileSystemChange(changes) {
        this._onDidChange.fire(changes.map(RemoteFileSystemProvider._createFileChange));
    }
    static _createFileChange(dto) {
        return { resource: new uri_1.default(vscode_uri_1.URI.revive(dto.resource)), type: dto.type };
    }
    // --- forwarding calls
    stat(resource) {
        return this._proxy.$stat(this._handle, resource['codeUri']).then(undefined, err => {
            throw err;
        });
    }
    readFile(resource) {
        return this._proxy.$readFile(this._handle, resource['codeUri']).then(buffer => buffer.buffer);
    }
    writeFile(resource, content, opts) {
        return this._proxy.$writeFile(this._handle, resource['codeUri'], buffer_1.BinaryBuffer.wrap(content), opts);
    }
    delete(resource, opts) {
        return this._proxy.$delete(this._handle, resource['codeUri'], opts);
    }
    mkdir(resource) {
        return this._proxy.$mkdir(this._handle, resource['codeUri']);
    }
    readdir(resource) {
        return this._proxy.$readdir(this._handle, resource['codeUri']);
    }
    rename(resource, target, opts) {
        return this._proxy.$rename(this._handle, resource['codeUri'], target['codeUri'], opts);
    }
    copy(resource, target, opts) {
        return this._proxy.$copy(this._handle, resource['codeUri'], target['codeUri'], opts);
    }
    open(resource, opts) {
        return this._proxy.$open(this._handle, resource['codeUri'], opts);
    }
    close(fd) {
        return this._proxy.$close(this._handle, fd);
    }
    read(fd, pos, data, offset, length) {
        return this._proxy.$read(this._handle, fd, pos, length).then(readData => {
            data.set(readData.buffer, offset);
            return readData.byteLength;
        });
    }
    write(fd, pos, data, offset, length) {
        return this._proxy.$write(this._handle, fd, pos, buffer_1.BinaryBuffer.wrap(data).slice(offset, offset + length));
    }
}


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeybindingsContributionPointHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const keybinding_1 = __webpack_require__(/*! @theia/core/lib/browser/keybinding */ "../node_modules/@theia/core/lib/browser/keybinding.js");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "../node_modules/@theia/core/lib/common/os.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
let KeybindingsContributionPointHandler = class KeybindingsContributionPointHandler {
    handle(contributions) {
        if (!contributions || !contributions.keybindings) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new core_1.DisposableCollection();
        for (const raw of contributions.keybindings) {
            const keybinding = this.toKeybinding(raw);
            if (keybinding) {
                toDispose.push(this.keybindingRegistry.registerKeybinding(keybinding));
            }
        }
        return toDispose;
    }
    toKeybinding(pluginKeybinding) {
        const keybinding = this.toOSKeybinding(pluginKeybinding);
        if (!keybinding) {
            return undefined;
        }
        const { command, when, args } = pluginKeybinding;
        return { keybinding, command, when, args };
    }
    toOSKeybinding(pluginKeybinding) {
        let keybinding;
        const os = os_1.OS.type();
        if (os === os_1.OS.Type.Windows) {
            keybinding = pluginKeybinding.win;
        }
        else if (os === os_1.OS.Type.OSX) {
            keybinding = pluginKeybinding.mac;
        }
        else {
            keybinding = pluginKeybinding.linux;
        }
        return keybinding || pluginKeybinding.keybinding;
    }
};
exports.KeybindingsContributionPointHandler = KeybindingsContributionPointHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(keybinding_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", keybinding_1.KeybindingRegistry)
], KeybindingsContributionPointHandler.prototype, "keybindingRegistry", void 0);
exports.KeybindingsContributionPointHandler = KeybindingsContributionPointHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], KeybindingsContributionPointHandler);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LabelServiceMainImpl = void 0;
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
class LabelServiceMainImpl {
    constructor(container) {
        this.resourceLabelFormatters = new Map();
        this.contributionProvider = container.getNamed(common_1.ContributionProvider, browser_1.LabelProviderContribution);
    }
    $registerResourceLabelFormatter(handle, formatter) {
        // Dynamically registered formatters should have priority over those contributed via package.json
        formatter.priority = true;
        const disposables = new disposable_1.DisposableCollection();
        for (const contribution of this.contributionProvider.getContributions()) {
            if (contribution instanceof browser_1.DefaultUriLabelProviderContribution) {
                disposables.push(contribution.registerFormatter(formatter));
            }
        }
        this.resourceLabelFormatters.set(handle, disposables);
    }
    $unregisterResourceLabelFormatter(handle) {
        const toDispose = this.resourceLabelFormatters.get(handle);
        if (toDispose) {
            toDispose.dispose();
        }
        this.resourceLabelFormatters.delete(handle);
    }
}
exports.LabelServiceMainImpl = LabelServiceMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toMonacoWorkspaceEdit = exports.LanguagesMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Method `$changeLanguage` copied and modified
// from https://github.com/microsoft/vscode/blob/e9c50663154c369a06355ce752b447af5b580dc3/src/vs/workbench/api/browser/mainThreadLanguages.ts#L30-L42
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../common/plugin-api-rpc-model */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const monaco_languages_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-languages */ "../node_modules/@theia/monaco/lib/browser/monaco-languages.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/markers/lib/browser */ "../node_modules/@theia/markers/lib/browser/index.js");
const vst = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const browser_2 = __webpack_require__(/*! @theia/callhierarchy/lib/browser */ "../node_modules/@theia/callhierarchy/lib/browser/index.js");
const hierarchy_types_converters_1 = __webpack_require__(/*! ./hierarchy/hierarchy-types-converters */ "../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js");
const browser_3 = __webpack_require__(/*! @theia/typehierarchy/lib/browser */ "../node_modules/@theia/typehierarchy/lib/browser/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const object_identifier_1 = __webpack_require__(/*! ../../common/object-identifier */ "../node_modules/@theia/plugin-ext/lib/common/object-identifier.js");
const types_1 = __webpack_require__(/*! ../../common/types */ "../node_modules/@theia/plugin-ext/lib/common/types.js");
const paths_util_1 = __webpack_require__(/*! ../../common/paths-util */ "../node_modules/@theia/plugin-ext/lib/common/paths-util.js");
const semantic_tokens_dto_1 = __webpack_require__(/*! ../../common/semantic-tokens-dto */ "../node_modules/@theia/plugin-ext/lib/common/semantic-tokens-dto.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const extensions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/extensions/common/extensions */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/extensions/common/extensions.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const markers_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/markers/common/markers */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/markers/common/markers.js");
const MonacoPath = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/path */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/path.js");
const editor_language_status_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/language-status/editor-language-status-service */ "../node_modules/@theia/editor/lib/browser/language-status/editor-language-status-service.js");
const languageFeatures_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const file_upload_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-upload-service */ "../node_modules/@theia/filesystem/lib/browser/file-upload-service.js");
let LanguagesMainImpl = class LanguagesMainImpl {
    constructor(rpc) {
        this.services = new Map();
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.LANGUAGES_EXT);
    }
    dispose() {
        this.toDispose.dispose();
    }
    $getLanguages() {
        return Promise.resolve(monaco.languages.getLanguages().map(l => l.id));
    }
    $changeLanguage(resource, languageId) {
        const uri = monaco.Uri.revive(resource);
        const model = monaco.editor.getModel(uri);
        if (!model) {
            return Promise.reject(new Error('Invalid uri'));
        }
        const langId = monaco.languages.getEncodedLanguageId(languageId);
        if (!langId) {
            return Promise.reject(new Error(`Unknown language ID: ${languageId}`));
        }
        monaco.editor.setModelLanguage(model, languageId);
        return Promise.resolve(undefined);
    }
    register(handle, service) {
        this.services.set(handle, service);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregister(handle)));
    }
    $unregister(handle) {
        const disposable = this.services.get(handle);
        if (disposable) {
            this.services.delete(handle);
            disposable.dispose();
        }
    }
    $setLanguageConfiguration(handle, languageId, configuration) {
        const config = {
            comments: configuration.comments,
            brackets: configuration.brackets,
            wordPattern: reviveRegExp(configuration.wordPattern),
            indentationRules: reviveIndentationRule(configuration.indentationRules),
            onEnterRules: reviveOnEnterRules(configuration.onEnterRules),
            autoClosingPairs: configuration.autoClosingPairs
        };
        this.register(handle, monaco.languages.setLanguageConfiguration(languageId, config));
    }
    $registerCompletionSupport(handle, pluginInfo, selector, triggerCharacters, supportsResolveDetails) {
        this.register(handle, monaco.languages.registerCompletionItemProvider(this.toLanguageSelector(selector), {
            triggerCharacters,
            provideCompletionItems: (model, position, context, token) => this.provideCompletionItems(handle, model, position, context, token),
            resolveCompletionItem: supportsResolveDetails
                ? (suggestion, token) => Promise.resolve(this.resolveCompletionItem(handle, suggestion, token))
                : undefined
        }));
    }
    provideCompletionItems(handle, model, position, context, token) {
        return this.proxy.$provideCompletionItems(handle, model.uri, position, context, token).then(result => {
            if (!result) {
                return undefined;
            }
            return {
                suggestions: result.completions.map(c => Object.assign(c, {
                    range: c.range || result.defaultRange
                })),
                incomplete: result.incomplete,
                dispose: () => this.proxy.$releaseCompletionItems(handle, result.id)
            };
        });
    }
    resolveCompletionItem(handle, item, token) {
        const { parentId, id } = item;
        return this.proxy.$resolveCompletionItem(handle, [parentId, id], token).then(resolved => {
            if (resolved) {
                (0, types_1.mixin)(item, resolved, true);
            }
            return item;
        });
    }
    $registerDefinitionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const definitionProvider = this.createDefinitionProvider(handle);
        this.register(handle, monaco.languages.registerDefinitionProvider(languageSelector, definitionProvider));
    }
    $registerDeclarationProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const declarationProvider = this.createDeclarationProvider(handle);
        this.register(handle, monaco.languages.registerDeclarationProvider(languageSelector, declarationProvider));
    }
    $registerReferenceProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const referenceProvider = this.createReferenceProvider(handle);
        this.register(handle, monaco.languages.registerReferenceProvider(languageSelector, referenceProvider));
    }
    createReferenceProvider(handle) {
        return {
            provideReferences: (model, position, context, token) => this.provideReferences(handle, model, position, context, token)
        };
    }
    provideReferences(handle, model, position, context, token) {
        return this.proxy.$provideReferences(handle, model.uri, position, context, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                const references = [];
                for (const item of result) {
                    references.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return references;
            }
            return undefined;
        });
    }
    $registerSignatureHelpProvider(handle, pluginInfo, selector, metadata) {
        const languageSelector = this.toLanguageSelector(selector);
        const signatureHelpProvider = this.createSignatureHelpProvider(handle, metadata);
        this.register(handle, monaco.languages.registerSignatureHelpProvider(languageSelector, signatureHelpProvider));
    }
    $clearDiagnostics(id) {
        for (const uri of this.problemManager.getUris()) {
            this.problemManager.setMarkers(new uri_1.URI(uri), id, []);
        }
    }
    $changeDiagnostics(id, delta) {
        for (const [uriString, markers] of delta) {
            const uri = new uri_1.URI(uriString);
            this.problemManager.setMarkers(uri, id, markers.map(reviveMarker));
        }
    }
    $registerImplementationProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const implementationProvider = this.createImplementationProvider(handle);
        this.register(handle, monaco.languages.registerImplementationProvider(languageSelector, implementationProvider));
    }
    createImplementationProvider(handle) {
        return {
            provideImplementation: (model, position, token) => this.provideImplementation(handle, model, position, token)
        };
    }
    provideImplementation(handle, model, position, token) {
        return this.proxy.$provideImplementation(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    $registerTypeDefinitionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const typeDefinitionProvider = this.createTypeDefinitionProvider(handle);
        this.register(handle, monaco.languages.registerTypeDefinitionProvider(languageSelector, typeDefinitionProvider));
    }
    createTypeDefinitionProvider(handle) {
        return {
            provideTypeDefinition: (model, position, token) => this.provideTypeDefinition(handle, model, position, token)
        };
    }
    provideTypeDefinition(handle, model, position, token) {
        return this.proxy.$provideTypeDefinition(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    $registerHoverProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const hoverProvider = this.createHoverProvider(handle);
        this.register(handle, monaco.languages.registerHoverProvider(languageSelector, hoverProvider));
    }
    createHoverProvider(handle) {
        return {
            provideHover: (model, position, token) => this.provideHover(handle, model, position, token)
        };
    }
    provideHover(handle, model, position, token) {
        return this.proxy.$provideHover(handle, model.uri, position, token);
    }
    $registerEvaluatableExpressionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const evaluatableExpressionProvider = this.createEvaluatableExpressionProvider(handle);
        this.register(handle, standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).evaluatableExpressionProvider.register(languageSelector, evaluatableExpressionProvider));
    }
    createEvaluatableExpressionProvider(handle) {
        return {
            provideEvaluatableExpression: (model, position, token) => this.provideEvaluatableExpression(handle, model, position, token)
        };
    }
    provideEvaluatableExpression(handle, model, position, token) {
        return this.proxy.$provideEvaluatableExpression(handle, model.uri, position, token);
    }
    $registerInlineValuesProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const inlineValuesProvider = this.createInlineValuesProvider(handle);
        this.register(handle, standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).inlineValuesProvider.register(languageSelector, inlineValuesProvider));
    }
    createInlineValuesProvider(handle) {
        return {
            provideInlineValues: (model, range, context, token) => this.provideInlineValues(handle, model, range, context, token)
        };
    }
    provideInlineValues(handle, model, range, context, token) {
        return this.proxy.$provideInlineValues(handle, model.uri, range, context, token);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitInlineValuesEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerDocumentHighlightProvider(handle, _pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const documentHighlightProvider = this.createDocumentHighlightProvider(handle);
        this.register(handle, monaco.languages.registerDocumentHighlightProvider(languageSelector, documentHighlightProvider));
    }
    createDocumentHighlightProvider(handle) {
        return {
            provideDocumentHighlights: (model, position, token) => this.provideDocumentHighlights(handle, model, position, token)
        };
    }
    provideDocumentHighlights(handle, model, position, token) {
        return this.proxy.$provideDocumentHighlights(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                const highlights = [];
                for (const item of result) {
                    highlights.push({
                        ...item,
                        kind: (item.kind ? item.kind : monaco.languages.DocumentHighlightKind.Text)
                    });
                }
                return highlights;
            }
            return undefined;
        });
    }
    $registerWorkspaceSymbolProvider(handle, pluginInfo) {
        const workspaceSymbolProvider = this.createWorkspaceSymbolProvider(handle);
        this.register(handle, this.monacoLanguages.registerWorkspaceSymbolProvider(workspaceSymbolProvider));
    }
    createWorkspaceSymbolProvider(handle) {
        return {
            provideWorkspaceSymbols: (params, token) => this.provideWorkspaceSymbols(handle, params, token),
            resolveWorkspaceSymbol: (symbol, token) => this.resolveWorkspaceSymbol(handle, symbol, token)
        };
    }
    provideWorkspaceSymbols(handle, params, token) {
        return this.proxy.$provideWorkspaceSymbols(handle, params.query, token);
    }
    resolveWorkspaceSymbol(handle, symbol, token) {
        return this.proxy.$resolveWorkspaceSymbol(handle, symbol, token);
    }
    $registerDocumentLinkProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const linkProvider = this.createLinkProvider(handle);
        this.register(handle, monaco.languages.registerLinkProvider(languageSelector, linkProvider));
    }
    createLinkProvider(handle) {
        return {
            provideLinks: async (model, token) => this.provideLinks(handle, model, token),
            resolveLink: async (link, token) => this.resolveLink(handle, link, token)
        };
    }
    async provideLinks(handle, model, token) {
        const links = await this.proxy.$provideDocumentLinks(handle, model.uri, token);
        if (!links) {
            return undefined;
        }
        return {
            links: links.map(link => this.toMonacoLink(link)),
            dispose: () => {
                if (links && Array.isArray(links)) {
                    this.proxy.$releaseDocumentLinks(handle, links.map(link => object_identifier_1.ObjectIdentifier.of(link)));
                }
            }
        };
    }
    async resolveLink(handle, link, token) {
        const resolved = await this.proxy.$resolveDocumentLink(handle, link, token);
        return resolved && this.toMonacoLink(resolved);
    }
    toMonacoLink(link) {
        return {
            ...link,
            url: !!link.url && typeof link.url !== 'string' ? monaco.Uri.revive(link.url) : link.url
        };
    }
    $registerCodeLensSupport(handle, pluginInfo, selector, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const lensProvider = this.createCodeLensProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            lensProvider.onDidChange = emitter.event;
        }
        this.register(handle, monaco.languages.registerCodeLensProvider(languageSelector, lensProvider));
    }
    createCodeLensProvider(handle) {
        return {
            provideCodeLenses: async (model, token) => this.provideCodeLenses(handle, model, token),
            resolveCodeLens: (model, codeLens, token) => this.resolveCodeLens(handle, model, codeLens, token)
        };
    }
    async provideCodeLenses(handle, model, token) {
        const lenses = await this.proxy.$provideCodeLenses(handle, model.uri, token);
        if (!lenses) {
            return undefined;
        }
        return {
            lenses,
            dispose: () => {
                if (lenses && Array.isArray(lenses)) {
                    this.proxy.$releaseCodeLenses(handle, lenses.map(symbol => object_identifier_1.ObjectIdentifier.of(symbol)));
                }
            }
        };
    }
    resolveCodeLens(handle, model, codeLens, token) {
        return this.proxy.$resolveCodeLens(handle, model.uri, codeLens, token);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitCodeLensEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerOutlineSupport(handle, pluginInfo, selector, displayName) {
        const languageSelector = this.toLanguageSelector(selector);
        const symbolProvider = this.createDocumentSymbolProvider(handle, displayName);
        this.register(handle, monaco.languages.registerDocumentSymbolProvider(languageSelector, symbolProvider));
    }
    createDocumentSymbolProvider(handle, displayName) {
        return {
            displayName,
            provideDocumentSymbols: (model, token) => this.provideDocumentSymbols(handle, model, token)
        };
    }
    provideDocumentSymbols(handle, model, token) {
        return this.proxy.$provideDocumentSymbols(handle, model.uri, token);
    }
    createDefinitionProvider(handle) {
        return {
            provideDefinition: (model, position, token) => this.provideDefinition(handle, model, position, token)
        };
    }
    createDeclarationProvider(handle) {
        return {
            provideDeclaration: (model, position, token) => this.provideDeclaration(handle, model, position, token)
        };
    }
    provideDeclaration(handle, model, position, token) {
        return this.proxy.$provideDeclaration(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    provideDefinition(handle, model, position, token) {
        return this.proxy.$provideDefinition(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    createSignatureHelpProvider(handle, metadata) {
        return {
            signatureHelpTriggerCharacters: metadata.triggerCharacters,
            signatureHelpRetriggerCharacters: metadata.retriggerCharacters,
            provideSignatureHelp: async (model, position, token, context) => this.provideSignatureHelp(handle, model, position, token, context)
        };
    }
    async provideSignatureHelp(handle, model, position, token, context) {
        // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
        const value = await this.proxy.$provideSignatureHelp(handle, model.uri, position, context, token);
        if (!value) {
            return undefined;
        }
        return {
            value,
            dispose: () => {
                if (typeof value.id === 'number') {
                    this.proxy.$releaseSignatureHelp(handle, value.id);
                }
            }
        };
    }
    $registerDocumentFormattingSupport(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const documentFormattingEditSupport = this.createDocumentFormattingSupport(handle, pluginInfo);
        this.register(handle, monaco.languages.registerDocumentFormattingEditProvider(languageSelector, documentFormattingEditSupport));
    }
    createDocumentFormattingSupport(handle, pluginInfo) {
        const provider = {
            extensionId: new extensions_1.ExtensionIdentifier(pluginInfo.id),
            displayName: pluginInfo.name,
            provideDocumentFormattingEdits: (model, options, token) => this.provideDocumentFormattingEdits(handle, model, options, token)
        };
        return provider;
    }
    provideDocumentFormattingEdits(handle, model, options, token) {
        return this.proxy.$provideDocumentFormattingEdits(handle, model.uri, options, token);
    }
    $registerRangeFormattingSupport(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const rangeFormattingEditProvider = this.createRangeFormattingSupport(handle, pluginInfo);
        this.register(handle, monaco.languages.registerDocumentRangeFormattingEditProvider(languageSelector, rangeFormattingEditProvider));
    }
    createRangeFormattingSupport(handle, pluginInfo) {
        const provider = {
            extensionId: new extensions_1.ExtensionIdentifier(pluginInfo.id),
            displayName: pluginInfo.name,
            provideDocumentRangeFormattingEdits: (model, range, options, token) => this.provideDocumentRangeFormattingEdits(handle, model, range, options, token)
        };
        return provider;
    }
    provideDocumentRangeFormattingEdits(handle, model, range, options, token) {
        return this.proxy.$provideDocumentRangeFormattingEdits(handle, model.uri, range, options, token);
    }
    $registerOnTypeFormattingProvider(handle, pluginInfo, selector, autoFormatTriggerCharacters) {
        const languageSelector = this.toLanguageSelector(selector);
        const onTypeFormattingProvider = this.createOnTypeFormattingProvider(handle, autoFormatTriggerCharacters);
        this.register(handle, monaco.languages.registerOnTypeFormattingEditProvider(languageSelector, onTypeFormattingProvider));
    }
    createOnTypeFormattingProvider(handle, autoFormatTriggerCharacters) {
        return {
            autoFormatTriggerCharacters,
            provideOnTypeFormattingEdits: (model, position, ch, options, token) => this.provideOnTypeFormattingEdits(handle, model, position, ch, options, token)
        };
    }
    provideOnTypeFormattingEdits(handle, model, position, ch, options, token) {
        return this.proxy.$provideOnTypeFormattingEdits(handle, model.uri, position, ch, options, token);
    }
    $registerDocumentDropEditProvider(handle, selector, metadata) {
        this.register(handle, standaloneServices_1.StandaloneServices
            .get(languageFeatures_1.ILanguageFeaturesService)
            .documentDropEditProvider
            .register(selector, this.createDocumentDropEditProvider(handle, metadata)));
    }
    createDocumentDropEditProvider(handle, _metadata) {
        return {
            // @monaco-uplift id and dropMimeTypes should be supported by the monaco drop editor provider after 1.82.0
            // id?: string;
            // dropMimeTypes: metadata?.dropMimeTypes ?? ['*/*'],
            provideDocumentDropEdits: async (model, position, dataTransfer, token) => this.provideDocumentDropEdits(handle, model, position, dataTransfer, token)
        };
    }
    async provideDocumentDropEdits(handle, model, position, dataTransfer, token) {
        await this.fileUploadService.upload(new uri_1.URI(), { source: dataTransfer, leaveInTemp: true });
        return undefined;
    }
    $registerFoldingRangeProvider(handle, pluginInfo, selector, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = this.createFoldingRangeProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.services.set(eventHandle, emitter);
            provider.onDidChange = emitter.event;
        }
        this.register(handle, monaco.languages.registerFoldingRangeProvider(languageSelector, provider));
    }
    createFoldingRangeProvider(handle) {
        return {
            provideFoldingRanges: (model, context, token) => this.provideFoldingRanges(handle, model, context, token)
        };
    }
    $emitFoldingRangeEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    provideFoldingRanges(handle, model, context, token) {
        return this.proxy.$provideFoldingRange(handle, model.uri, context, token);
    }
    $registerSelectionRangeProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = this.createSelectionRangeProvider(handle);
        this.register(handle, monaco.languages.registerSelectionRangeProvider(languageSelector, provider));
    }
    createSelectionRangeProvider(handle) {
        return {
            provideSelectionRanges: (model, positions, token) => this.provideSelectionRanges(handle, model, positions, token)
        };
    }
    provideSelectionRanges(handle, model, positions, token) {
        return this.proxy.$provideSelectionRanges(handle, model.uri, positions, token);
    }
    $registerDocumentColorProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const colorProvider = this.createColorProvider(handle);
        this.register(handle, monaco.languages.registerColorProvider(languageSelector, colorProvider));
    }
    createColorProvider(handle) {
        return {
            provideDocumentColors: (model, token) => this.provideDocumentColors(handle, model, token),
            provideColorPresentations: (model, colorInfo, token) => this.provideColorPresentations(handle, model, colorInfo, token)
        };
    }
    provideDocumentColors(handle, model, token) {
        return this.proxy.$provideDocumentColors(handle, model.uri, token).then(documentColors => documentColors.map(documentColor => {
            const [red, green, blue, alpha] = documentColor.color;
            const color = {
                red: red,
                green: green,
                blue: blue,
                alpha: alpha
            };
            return {
                color,
                range: documentColor.range
            };
        }));
    }
    provideColorPresentations(handle, model, colorInfo, token) {
        return this.proxy.$provideColorPresentations(handle, model.uri, {
            color: [
                colorInfo.color.red,
                colorInfo.color.green,
                colorInfo.color.blue,
                colorInfo.color.alpha
            ],
            range: colorInfo.range
        }, token);
    }
    $registerInlayHintsProvider(handle, pluginInfo, selector, displayName, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const inlayHintsProvider = this.createInlayHintsProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            inlayHintsProvider.onDidChangeInlayHints = emitter.event;
        }
        this.register(handle, monaco.languages.registerInlayHintsProvider(languageSelector, inlayHintsProvider));
    }
    createInlayHintsProvider(handle) {
        return {
            provideInlayHints: async (model, range, token) => {
                const result = await this.proxy.$provideInlayHints(handle, model.uri, range, token);
                if (!result) {
                    return;
                }
                return {
                    hints: result.hints.map(hint => reviveHint(hint)),
                    dispose: () => {
                        if (typeof result.cacheId === 'number') {
                            this.proxy.$releaseInlayHints(handle, result.cacheId);
                        }
                    }
                };
            },
            resolveInlayHint: async (hint, token) => {
                // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                const dto = hint;
                if (typeof dto.cacheId !== 'number') {
                    return hint;
                }
                const result = await this.proxy.$resolveInlayHint(handle, dto.cacheId, token);
                if (token.isCancellationRequested) {
                    return undefined;
                }
                if (!result) {
                    return hint;
                }
                return {
                    ...hint,
                    tooltip: result.tooltip,
                    label: reviveInlayLabel(result.label)
                };
            },
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitInlayHintsEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerInlineCompletionsSupport(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = {
            provideInlineCompletions: async (model, position, context, token) => this.proxy.$provideInlineCompletions(handle, model.uri, position, context, token),
            freeInlineCompletions: (completions) => {
                this.proxy.$freeInlineCompletionsList(handle, completions.pid);
            }
        };
        this.register(handle, monaco.languages.registerInlineCompletionsProvider(languageSelector, provider));
    }
    $registerQuickFixProvider(handle, pluginInfo, selector, providedCodeActionKinds, documentation) {
        const languageSelector = this.toLanguageSelector(selector);
        const quickFixProvider = {
            provideCodeActions: (model, range, context, token) => {
                const markers = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService)
                    .read({ resource: model.uri })
                    .filter(m => monaco.Range.areIntersectingOrTouching(m, range));
                return this.provideCodeActions(handle, model, range, { ...context, markers }, token);
            },
            resolveCodeAction: (codeAction, token) => this.resolveCodeAction(handle, codeAction, token)
        };
        this.register(handle, monaco.languages.registerCodeActionProvider(languageSelector, quickFixProvider, {
            documentation: documentation,
            providedCodeActionKinds
        }));
    }
    async provideCodeActions(handle, model, rangeOrSelection, context, token) {
        try {
            const actions = await this.proxy.$provideCodeActions(handle, model.uri, rangeOrSelection, this.toModelCodeActionContext(context), token);
            if (!actions) {
                return undefined;
            }
            return {
                actions: actions.map(a => toMonacoAction(a)),
                dispose: () => this.proxy.$releaseCodeActions(handle, actions.map(a => a.cacheId))
            };
        }
        catch (e) {
            console.error(e);
            return undefined;
        }
    }
    toModelCodeActionContext(context) {
        return {
            ...context,
            trigger: this.toCodeActionTriggerKind(context.trigger)
        };
    }
    toCodeActionTriggerKind(type) {
        switch (type) {
            case monaco.languages.CodeActionTriggerType.Auto:
                return types_impl_1.CodeActionTriggerKind.Automatic;
            case monaco.languages.CodeActionTriggerType.Invoke:
                return types_impl_1.CodeActionTriggerKind.Invoke;
        }
    }
    async resolveCodeAction(handle, codeAction, token) {
        // The cacheId is kept in toMonacoAction when converting a received CodeAction DTO to a monaco code action
        const cacheId = codeAction.cacheId;
        if (cacheId !== undefined) {
            const resolvedEdit = await this.proxy.$resolveCodeAction(handle, cacheId, token);
            codeAction.edit = resolvedEdit && toMonacoWorkspaceEdit(resolvedEdit);
        }
        return codeAction;
    }
    $registerRenameProvider(handle, pluginInfo, selector, supportsResolveLocation) {
        const languageSelector = this.toLanguageSelector(selector);
        const renameProvider = this.createRenameProvider(handle, supportsResolveLocation);
        this.register(handle, monaco.languages.registerRenameProvider(languageSelector, renameProvider));
    }
    createRenameProvider(handle, supportsResolveLocation) {
        return {
            provideRenameEdits: (model, position, newName, token) => this.provideRenameEdits(handle, model, position, newName, token),
            resolveRenameLocation: supportsResolveLocation
                ? (model, position, token) => this.resolveRenameLocation(handle, model, position, token)
                : undefined
        };
    }
    provideRenameEdits(handle, model, position, newName, token) {
        return this.proxy.$provideRenameEdits(handle, model.uri, position, newName, token).then(toMonacoWorkspaceEdit);
    }
    $registerCallHierarchyProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const callHierarchyService = this.createCallHierarchyService(handle, languageSelector);
        this.register(handle, this.callHierarchyServiceContributionRegistry.add(callHierarchyService));
    }
    createCallHierarchyService(handle, language) {
        return {
            selector: language,
            getRootDefinition: (uri, position, cancellationToken) => this.proxy.$provideRootDefinition(handle, (0, hierarchy_types_converters_1.toUriComponents)(uri), (0, hierarchy_types_converters_1.fromPosition)(position), cancellationToken)
                .then(def => {
                if (!def) {
                    return undefined;
                }
                const defs = Array.isArray(def) ? def : [def];
                return { dispose: () => { var _a; return this.proxy.$releaseCallHierarchy(handle, (_a = defs[0]) === null || _a === void 0 ? void 0 : _a._sessionId); }, items: defs.map(item => (0, hierarchy_types_converters_1.toItemHierarchyDefinition)(item)) };
            }),
            getCallers: (definition, cancellationToken) => this.proxy.$provideCallers(handle, (0, hierarchy_types_converters_1.fromItemHierarchyDefinition)(definition), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                if (Array.isArray(result)) {
                    return result.map(hierarchy_types_converters_1.toCaller);
                }
                return undefined;
            }),
            getCallees: (definition, cancellationToken) => this.proxy.$provideCallees(handle, (0, hierarchy_types_converters_1.fromItemHierarchyDefinition)(definition), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                if (Array.isArray(result)) {
                    return result.map(hierarchy_types_converters_1.toCallee);
                }
                return undefined;
            })
        };
    }
    resolveRenameLocation(handle, model, position, token) {
        return this.proxy.$resolveRenameLocation(handle, model.uri, position, token);
    }
    // --- type hierarchy
    $registerTypeHierarchyProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const typeHierarchyService = this.createTypeHierarchyService(handle, languageSelector);
        this.register(handle, this.typeHierarchyServiceContributionRegistry.add(typeHierarchyService));
    }
    createTypeHierarchyService(handle, language) {
        return {
            selector: language,
            prepareSession: (uri, position, cancellationToken) => this.proxy.$prepareTypeHierarchy(handle, (0, hierarchy_types_converters_1.toUriComponents)(uri), (0, hierarchy_types_converters_1.fromPosition)(position), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                const items = Array.isArray(result) ? result : [result];
                return {
                    dispose: () => { var _a; return this.proxy.$releaseTypeHierarchy(handle, (_a = items[0]) === null || _a === void 0 ? void 0 : _a._sessionId); },
                    items: items.map(item => (0, hierarchy_types_converters_1.toItemHierarchyDefinition)(item))
                };
            }),
            provideSuperTypes: (sessionId, itemId, cancellationToken) => this.proxy.$provideSuperTypes(handle, sessionId, itemId, cancellationToken)
                .then(results => {
                if (!results) {
                    return undefined;
                }
                if (Array.isArray(results)) {
                    return results.map(hierarchy_types_converters_1.toItemHierarchyDefinition);
                }
                return undefined;
            }),
            provideSubTypes: async (sessionId, itemId, cancellationToken) => this.proxy.$provideSubTypes(handle, sessionId, itemId, cancellationToken)
                .then(results => {
                if (!results) {
                    return undefined;
                }
                if (Array.isArray(results)) {
                    return results.map(hierarchy_types_converters_1.toItemHierarchyDefinition);
                }
                return undefined;
            })
        };
    }
    // --- semantic tokens
    $registerDocumentSemanticTokensProvider(handle, pluginInfo, selector, legend, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        let event = undefined;
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            event = emitter.event;
        }
        const provider = this.createDocumentSemanticTokensProvider(handle, legend, event);
        this.register(handle, monaco.languages.registerDocumentSemanticTokensProvider(languageSelector, provider));
    }
    createDocumentSemanticTokensProvider(handle, legend, event) {
        return {
            releaseDocumentSemanticTokens: resultId => {
                if (resultId) {
                    this.proxy.$releaseDocumentSemanticTokens(handle, parseInt(resultId, 10));
                }
            },
            getLegend: () => legend,
            provideDocumentSemanticTokens: async (model, lastResultId, token) => {
                const nLastResultId = lastResultId ? parseInt(lastResultId, 10) : 0;
                const encodedDto = await this.proxy.$provideDocumentSemanticTokens(handle, model.uri, nLastResultId, token);
                if (!encodedDto) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = (0, semantic_tokens_dto_1.decodeSemanticTokensDto)(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                return {
                    resultId: String(dto.id),
                    edits: dto.deltas
                };
            }
        };
    }
    $emitDocumentSemanticTokensEvent(eventHandle) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(undefined);
        }
    }
    $registerDocumentRangeSemanticTokensProvider(handle, pluginInfo, selector, legend) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = this.createDocumentRangeSemanticTokensProvider(handle, legend);
        this.register(handle, monaco.languages.registerDocumentRangeSemanticTokensProvider(languageSelector, provider));
    }
    createDocumentRangeSemanticTokensProvider(handle, legend) {
        return {
            getLegend: () => legend,
            provideDocumentRangeSemanticTokens: async (model, range, token) => {
                const encodedDto = await this.proxy.$provideDocumentRangeSemanticTokens(handle, model.uri, range, token);
                if (!encodedDto) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = (0, semantic_tokens_dto_1.decodeSemanticTokensDto)(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                throw new Error('Unexpected');
            }
        };
    }
    // --- suggest
    toLanguageSelector(filters) {
        return filters.map(filter => {
            let pattern;
            if (typeof filter.pattern === 'string') {
                pattern = filter.pattern;
            }
            else if (filter.pattern) {
                pattern = {
                    base: MonacoPath.normalize(filter.pattern.baseUri.toString()),
                    pattern: filter.pattern.pattern,
                    pathToRelative: paths_util_1.relative
                };
            }
            return {
                language: filter.language,
                scheme: filter.scheme,
                pattern
            };
        });
    }
    // --- linked editing range
    $registerLinkedEditingRangeProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const linkedEditingRangeProvider = this.createLinkedEditingRangeProvider(handle);
        this.register(handle, monaco.languages.registerLinkedEditingRangeProvider(languageSelector, linkedEditingRangeProvider));
    }
    createLinkedEditingRangeProvider(handle) {
        return {
            provideLinkedEditingRanges: async (model, position, token) => {
                const res = await this.proxy.$provideLinkedEditingRanges(handle, model.uri, position, token);
                if (res) {
                    return {
                        ranges: res.ranges,
                        wordPattern: reviveRegExp(res.wordPattern)
                    };
                }
                return undefined;
            }
        };
    }
    ;
    // -- Language status
    $setLanguageStatus(handle, status) {
        const internal = { ...status, selector: this.toLanguageSelector(status.selector) };
        this.languageStatusService.setLanguageStatusItem(handle, internal);
    }
    ;
    $removeLanguageStatus(handle) {
        this.languageStatusService.removeLanguageStatusItem(handle);
    }
    ;
};
exports.LanguagesMainImpl = LanguagesMainImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_languages_1.MonacoLanguages),
    tslib_1.__metadata("design:type", monaco_languages_1.MonacoLanguages)
], LanguagesMainImpl.prototype, "monacoLanguages", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ProblemManager),
    tslib_1.__metadata("design:type", browser_1.ProblemManager)
], LanguagesMainImpl.prototype, "problemManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.CallHierarchyServiceProvider),
    tslib_1.__metadata("design:type", browser_2.CallHierarchyServiceProvider)
], LanguagesMainImpl.prototype, "callHierarchyServiceContributionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.TypeHierarchyServiceProvider),
    tslib_1.__metadata("design:type", browser_3.TypeHierarchyServiceProvider)
], LanguagesMainImpl.prototype, "typeHierarchyServiceContributionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_language_status_service_1.EditorLanguageStatusService),
    tslib_1.__metadata("design:type", editor_language_status_service_1.EditorLanguageStatusService)
], LanguagesMainImpl.prototype, "languageStatusService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_upload_service_1.FileUploadService),
    tslib_1.__metadata("design:type", file_upload_service_1.FileUploadService)
], LanguagesMainImpl.prototype, "fileUploadService", void 0);
exports.LanguagesMainImpl = LanguagesMainImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(rpc_protocol_1.RPCProtocol)),
    tslib_1.__metadata("design:paramtypes", [Object])
], LanguagesMainImpl);
function reviveMarker(marker) {
    const monacoMarker = {
        code: marker.code,
        severity: reviveSeverity(marker.severity),
        range: reviveRange(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn),
        message: marker.message,
        source: marker.source,
        relatedInformation: undefined
    };
    if (marker.relatedInformation) {
        monacoMarker.relatedInformation = marker.relatedInformation.map(reviveRelated);
    }
    if (marker.tags) {
        monacoMarker.tags = marker.tags.map(reviveTag);
    }
    return monacoMarker;
}
function reviveSeverity(severity) {
    switch (severity) {
        case plugin_api_rpc_model_1.MarkerSeverity.Error: return vst.DiagnosticSeverity.Error;
        case plugin_api_rpc_model_1.MarkerSeverity.Warning: return vst.DiagnosticSeverity.Warning;
        case plugin_api_rpc_model_1.MarkerSeverity.Info: return vst.DiagnosticSeverity.Information;
        case plugin_api_rpc_model_1.MarkerSeverity.Hint: return vst.DiagnosticSeverity.Hint;
    }
}
function reviveRange(startLine, startColumn, endLine, endColumn) {
    // note: language server range is 0-based, marker is 1-based, so need to deduct 1 here
    return {
        start: {
            line: startLine - 1,
            character: startColumn - 1
        },
        end: {
            line: endLine - 1,
            character: endColumn - 1
        }
    };
}
function reviveRelated(related) {
    return {
        message: related.message,
        location: {
            uri: related.resource,
            range: reviveRange(related.startLineNumber, related.startColumn, related.endLineNumber, related.endColumn)
        }
    };
}
function reviveTag(tag) {
    switch (tag) {
        case 1: return vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary;
        case 2: return vscode_languageserver_protocol_1.DiagnosticTag.Deprecated;
    }
}
function reviveRegExp(regExp) {
    if (typeof regExp === 'undefined' || regExp === null) {
        return undefined;
    }
    return new RegExp(regExp.pattern, regExp.flags);
}
function reviveIndentationRule(indentationRule) {
    if (typeof indentationRule === 'undefined' || indentationRule === null) {
        return undefined;
    }
    return {
        increaseIndentPattern: reviveRegExp(indentationRule.increaseIndentPattern),
        decreaseIndentPattern: reviveRegExp(indentationRule.decreaseIndentPattern),
        indentNextLinePattern: reviveRegExp(indentationRule.indentNextLinePattern),
        unIndentedLinePattern: reviveRegExp(indentationRule.unIndentedLinePattern),
    };
}
function reviveOnEnterRule(onEnterRule) {
    return {
        beforeText: reviveRegExp(onEnterRule.beforeText),
        afterText: reviveRegExp(onEnterRule.afterText),
        previousLineText: reviveRegExp(onEnterRule.previousLineText),
        action: onEnterRule.action,
    };
}
function reviveOnEnterRules(onEnterRules) {
    if (typeof onEnterRules === 'undefined' || onEnterRules === null) {
        return undefined;
    }
    return onEnterRules.map(reviveOnEnterRule);
}
function reviveInlayLabel(label) {
    var _a;
    let monacoLabel;
    if (typeof label === 'string') {
        monacoLabel = label;
    }
    else {
        const parts = [];
        for (const part of label) {
            const result = {
                ...part,
                location: !!part.location ? { range: (_a = part.location) === null || _a === void 0 ? void 0 : _a.range, uri: monaco.Uri.revive(part.location.uri) } : undefined
            };
            parts.push(result);
        }
        monacoLabel = parts;
    }
    return monacoLabel;
}
function reviveHint(hint) {
    return {
        ...hint,
        label: reviveInlayLabel(hint.label)
    };
}
function toMonacoAction(action) {
    var _a;
    return {
        ...action,
        diagnostics: action.diagnostics ? action.diagnostics.map(m => toMonacoMarkerData(m)) : undefined,
        disabled: (_a = action.disabled) === null || _a === void 0 ? void 0 : _a.reason,
        edit: action.edit ? toMonacoWorkspaceEdit(action.edit) : undefined
    };
}
function toMonacoMarkerData(marker) {
    return {
        ...marker,
        relatedInformation: marker.relatedInformation
            ? marker.relatedInformation.map(i => toMonacoRelatedInformation(i))
            : undefined
    };
}
function toMonacoRelatedInformation(relatedInfo) {
    return {
        ...relatedInfo,
        resource: monaco.Uri.parse(relatedInfo.resource)
    };
}
function toMonacoWorkspaceEdit(data) {
    return {
        edits: (data && data.edits || []).map(edit => {
            if (plugin_api_rpc_1.WorkspaceTextEditDto.is(edit)) {
                return {
                    resource: monaco.Uri.revive(edit.resource),
                    textEdit: edit.textEdit,
                    metadata: edit.metadata
                };
            }
            else {
                const fileEdit = edit;
                return {
                    newResource: monaco.Uri.revive(fileEdit.newResource),
                    oldResource: monaco.Uri.revive(fileEdit.oldResource),
                    options: fileEdit.options,
                    metadata: fileEdit.metadata
                };
            }
        })
    };
}
exports.toMonacoWorkspaceEdit = toMonacoWorkspaceEdit;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalizationMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const language_pack_service_1 = __webpack_require__(/*! ../../common/language-pack-service */ "../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js");
class LocalizationMainImpl {
    constructor(container) {
        this.languagePackService = container.get(language_pack_service_1.LanguagePackService);
    }
    async $fetchBundle(id) {
        var _a;
        const bundle = await this.languagePackService.getBundle(id, (_a = core_1.nls.locale) !== null && _a !== void 0 ? _a : core_1.nls.defaultLocale);
        return bundle;
    }
}
exports.LocalizationMainImpl = LocalizationMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2025 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
class LoggerMainImpl {
    constructor(container) {
        this.container = container;
    }
    $log(level, name, message, params) {
        let logger;
        if (name) {
            logger = this.container.getNamed(core_1.ILogger, name);
        }
        else {
            logger = this.container.get(core_1.ILogger);
        }
        switch (level) {
            case common_1.LogLevel.Trace:
                logger.trace(message, ...params);
                break;
            case common_1.LogLevel.Debug:
                logger.debug(message, ...params);
                break;
            case common_1.LogLevel.Info:
                logger.info(message, ...params);
                break;
            case common_1.LogLevel.Warn:
                logger.warn(message, ...params);
                break;
            case common_1.LogLevel.Error:
                logger.error(message, ...params);
                break;
        }
    }
}
exports.LoggerMainImpl = LoggerMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setUpPluginApi = void 0;
const command_registry_main_1 = __webpack_require__(/*! ./command-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js");
const preference_registry_main_1 = __webpack_require__(/*! ./preference-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js");
const quick_open_main_1 = __webpack_require__(/*! ./quick-open-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const message_registry_main_1 = __webpack_require__(/*! ./message-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js");
const window_state_main_1 = __webpack_require__(/*! ./window-state-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js");
const workspace_main_1 = __webpack_require__(/*! ./workspace-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js");
const status_bar_message_registry_main_1 = __webpack_require__(/*! ./status-bar-message-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js");
const env_main_1 = __webpack_require__(/*! ./env-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js");
const editors_and_documents_main_1 = __webpack_require__(/*! ./editors-and-documents-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js");
const terminal_main_1 = __webpack_require__(/*! ./terminal-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js");
const dialogs_main_1 = __webpack_require__(/*! ./dialogs-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js");
const tree_views_main_1 = __webpack_require__(/*! ./view/tree-views-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js");
const notification_main_1 = __webpack_require__(/*! ./notification-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js");
const connection_1 = __webpack_require__(/*! ../../common/connection */ "../node_modules/@theia/plugin-ext/lib/common/connection.js");
const webviews_main_1 = __webpack_require__(/*! ./webviews-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js");
const tasks_main_1 = __webpack_require__(/*! ./tasks-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js");
const plugin_storage_1 = __webpack_require__(/*! ./plugin-storage */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js");
const debug_main_1 = __webpack_require__(/*! ./debug/debug-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js");
const file_system_main_impl_1 = __webpack_require__(/*! ./file-system-main-impl */ "../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js");
const scm_main_1 = __webpack_require__(/*! ./scm-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js");
const decorations_main_1 = __webpack_require__(/*! ./decorations/decorations-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js");
const clipboard_main_1 = __webpack_require__(/*! ./clipboard-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js");
const documents_main_1 = __webpack_require__(/*! ./documents-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js");
const text_editors_main_1 = __webpack_require__(/*! ./text-editors-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js");
const text_editor_model_service_1 = __webpack_require__(/*! ./text-editor-model-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../node_modules/@theia/core/lib/browser/opener-service.js");
const application_shell_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell */ "../node_modules/@theia/core/lib/browser/shell/application-shell.js");
const main_file_system_event_service_1 = __webpack_require__(/*! ./main-file-system-event-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js");
const label_service_main_1 = __webpack_require__(/*! ./label-service-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js");
const timeline_main_1 = __webpack_require__(/*! ./timeline-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js");
const authentication_main_1 = __webpack_require__(/*! ./authentication-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js");
const theming_main_1 = __webpack_require__(/*! ./theming-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js");
const comments_main_1 = __webpack_require__(/*! ./comments/comments-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js");
const custom_editors_main_1 = __webpack_require__(/*! ./custom-editors/custom-editors-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js");
const secrets_main_1 = __webpack_require__(/*! ./secrets-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js");
const webview_views_main_1 = __webpack_require__(/*! ./webview-views/webview-views-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js");
const monaco_languages_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-languages */ "../node_modules/@theia/monaco/lib/browser/monaco-languages.js");
const resource_1 = __webpack_require__(/*! @theia/core/lib/common/resource */ "../node_modules/@theia/core/lib/common/resource.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
const tabs_main_1 = __webpack_require__(/*! ./tabs/tabs-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js");
const notebooks_main_1 = __webpack_require__(/*! ./notebooks/notebooks-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js");
const localization_main_1 = __webpack_require__(/*! ./localization-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js");
const notebook_renderers_main_1 = __webpack_require__(/*! ./notebooks/notebook-renderers-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js");
const notebook_editors_main_1 = __webpack_require__(/*! ./notebooks/notebook-editors-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js");
const notebook_documents_main_1 = __webpack_require__(/*! ./notebooks/notebook-documents-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js");
const notebook_kernels_main_1 = __webpack_require__(/*! ./notebooks/notebook-kernels-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js");
const notebook_documents_and_editors_main_1 = __webpack_require__(/*! ./notebooks/notebook-documents-and-editors-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js");
const test_main_1 = __webpack_require__(/*! ./test-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js");
const uri_main_1 = __webpack_require__(/*! ./uri-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js");
const logger_main_1 = __webpack_require__(/*! ./logger-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js");
function setUpPluginApi(rpc, container) {
    const loggerMain = new logger_main_1.LoggerMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LOGGER_MAIN, loggerMain);
    const authenticationMain = new authentication_main_1.AuthenticationMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.AUTHENTICATION_MAIN, authenticationMain);
    const commandRegistryMain = new command_registry_main_1.CommandRegistryMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMAND_REGISTRY_MAIN, commandRegistryMain);
    const quickOpenMain = new quick_open_main_1.QuickOpenMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.QUICK_OPEN_MAIN, quickOpenMain);
    const workspaceMain = new workspace_main_1.WorkspaceMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WORKSPACE_MAIN, workspaceMain);
    const dialogsMain = new dialogs_main_1.DialogsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DIALOGS_MAIN, dialogsMain);
    const messageRegistryMain = new message_registry_main_1.MessageRegistryMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.MESSAGE_REGISTRY_MAIN, messageRegistryMain);
    const preferenceRegistryMain = new preference_registry_main_1.PreferenceRegistryMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.PREFERENCE_REGISTRY_MAIN, preferenceRegistryMain);
    const tabsMain = new tabs_main_1.TabsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TABS_MAIN, tabsMain);
    const editorsAndDocuments = new editors_and_documents_main_1.EditorsAndDocumentsMain(rpc, container, tabsMain);
    const notebookDocumentsMain = new notebook_documents_main_1.NotebookDocumentsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_MAIN, notebookDocumentsMain);
    const modelService = container.get(text_editor_model_service_1.EditorModelService);
    const openerService = container.get(opener_service_1.OpenerService);
    const shell = container.get(application_shell_1.ApplicationShell);
    const untitledResourceResolver = container.get(resource_1.UntitledResourceResolver);
    const languageService = container.get(monaco_languages_1.MonacoLanguages);
    const documentsMain = new documents_main_1.DocumentsMainImpl(editorsAndDocuments, notebookDocumentsMain, modelService, rpc, openerService, shell, untitledResourceResolver, languageService);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DOCUMENTS_MAIN, documentsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOKS_MAIN, new notebooks_main_1.NotebooksMainImpl(rpc, container, commandRegistryMain));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_MAIN, new notebook_renderers_main_1.NotebookRenderersMainImpl(rpc, container));
    const notebookEditorsMain = new notebook_editors_main_1.NotebookEditorsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_EDITORS_MAIN, notebookEditorsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_AND_EDITORS_MAIN, new notebook_documents_and_editors_main_1.NotebooksAndEditorsMain(rpc, container, tabsMain, notebookDocumentsMain, notebookEditorsMain));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_KERNELS_MAIN, new notebook_kernels_main_1.NotebookKernelsMainImpl(rpc, container));
    const editorsMain = new text_editors_main_1.TextEditorsMainImpl(editorsAndDocuments, documentsMain, rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TEXT_EDITORS_MAIN, editorsMain);
    // start listening only after all clients are subscribed to events
    editorsAndDocuments.listen();
    const statusBarMessageRegistryMain = new status_bar_message_registry_main_1.StatusBarMessageRegistryMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STATUS_BAR_MESSAGE_REGISTRY_MAIN, statusBarMessageRegistryMain);
    const envMain = new env_main_1.EnvMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.ENV_MAIN, envMain);
    const notificationMain = new notification_main_1.NotificationMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTIFICATION_MAIN, notificationMain);
    const testingMain = new test_main_1.TestingMainImpl(rpc, container, commandRegistryMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TESTING_MAIN, testingMain);
    const terminalMain = new terminal_main_1.TerminalServiceMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TERMINAL_MAIN, terminalMain);
    const treeViewsMain = new tree_views_main_1.TreeViewsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TREE_VIEWS_MAIN, treeViewsMain);
    const outputChannelRegistryFactory = container.get(plugin_api_rpc_1.OutputChannelRegistryFactory);
    const outputChannelRegistryMain = outputChannelRegistryFactory();
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.OUTPUT_CHANNEL_REGISTRY_MAIN, outputChannelRegistryMain);
    const languagesMainFactory = container.get(plugin_api_rpc_1.LanguagesMainFactory);
    const languagesMain = languagesMainFactory(rpc);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LANGUAGES_MAIN, languagesMain);
    const webviewsMain = new webviews_main_1.WebviewsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEWS_MAIN, webviewsMain);
    const customEditorsMain = new custom_editors_main_1.CustomEditorsMainImpl(rpc, container, webviewsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CUSTOM_EDITORS_MAIN, customEditorsMain);
    const webviewViewsMain = new webview_views_main_1.WebviewViewsMainImpl(rpc, container, webviewsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEW_VIEWS_MAIN, webviewViewsMain);
    const storageMain = new plugin_storage_1.StorageMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STORAGE_MAIN, storageMain);
    const connectionMain = new connection_1.ConnectionImpl(rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CONNECTION_EXT));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CONNECTION_MAIN, connectionMain);
    const tasksMain = new tasks_main_1.TasksMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TASKS_MAIN, tasksMain);
    const debugMain = new debug_main_1.DebugMainImpl(rpc, connectionMain, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DEBUG_MAIN, debugMain);
    const fs = new file_system_main_impl_1.FileSystemMainImpl(rpc, container);
    const fsEventService = new main_file_system_event_service_1.MainFileSystemEventService(rpc, container);
    const disposeFS = fs.dispose.bind(fs);
    fs.dispose = () => {
        fsEventService.dispose();
        disposeFS();
    };
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.FILE_SYSTEM_MAIN, fs);
    const scmMain = new scm_main_1.ScmMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.SCM_MAIN, scmMain);
    const secretsMain = new secrets_main_1.SecretsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.SECRETS_MAIN, secretsMain);
    const decorationsMain = new decorations_main_1.DecorationsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DECORATIONS_MAIN, decorationsMain);
    const windowMain = new window_state_main_1.WindowStateMain(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WINDOW_MAIN, windowMain);
    const clipboardMain = new clipboard_main_1.ClipboardMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CLIPBOARD_MAIN, clipboardMain);
    const labelServiceMain = new label_service_main_1.LabelServiceMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LABEL_SERVICE_MAIN, labelServiceMain);
    const timelineMain = new timeline_main_1.TimelineMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TIMELINE_MAIN, timelineMain);
    const themingMain = new theming_main_1.ThemingMainImpl(rpc, container.get(theming_1.ThemeService));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.THEMING_MAIN, themingMain);
    const commentsMain = new comments_main_1.CommentsMainImp(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMENTS_MAIN, commentsMain);
    const localizationMain = new localization_main_1.LocalizationMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LOCALIZATION_MAIN, localizationMain);
    const uriMain = new uri_main_1.UriMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.URI_MAIN, uriMain);
}
exports.setUpPluginApi = setUpPluginApi;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/browser/mainThreadFileSystemEventService.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainFileSystemEventService = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
class MainFileSystemEventService {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        const proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.ExtHostFileSystemEventService);
        const fileService = container.get(file_service_1.FileService);
        this.toDispose.push(fileService.onDidFilesChange(event => {
            // file system events - (changes the editor and others make)
            const events = {
                created: [],
                changed: [],
                deleted: []
            };
            for (const change of event.changes) {
                switch (change.type) {
                    case 1 /* FileChangeType.ADDED */:
                        events.created.push(change.resource['codeUri']);
                        break;
                    case 0 /* FileChangeType.UPDATED */:
                        events.changed.push(change.resource['codeUri']);
                        break;
                    case 2 /* FileChangeType.DELETED */:
                        events.deleted.push(change.resource['codeUri']);
                        break;
                }
            }
            proxy.$onFileEvent(events);
        }));
        // BEFORE file operation
        fileService.addFileOperationParticipant({
            participate: (target, source, operation, timeout, token) => proxy.$onWillRunFileOperation(operation, target['codeUri'], source === null || source === void 0 ? void 0 : source['codeUri'], timeout, token)
        });
        // AFTER file operation
        this.toDispose.push(fileService.onDidRunUserOperation(e => { var _a; return proxy.$onDidRunFileOperation(e.operation, e.target['codeUri'], (_a = e.source) === null || _a === void 0 ? void 0 : _a['codeUri']); }));
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.MainFileSystemEventService = MainFileSystemEventService;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenusContributionPointHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const tab_bar_toolbar_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/tab-bar-toolbar */ "../node_modules/@theia/core/lib/browser/shell/tab-bar-toolbar/index.js");
const scm_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-widget */ "../node_modules/@theia/scm/lib/browser/scm-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const vscode_theia_menu_mappings_1 = __webpack_require__(/*! ./vscode-theia-menu-mappings */ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js");
const plugin_menu_command_adapter_1 = __webpack_require__(/*! ./plugin-menu-command-adapter */ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js");
const contextkey_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/contextkey/common/contextkey */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/contextkey/common/contextkey.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
let MenusContributionPointHandler = class MenusContributionPointHandler {
    constructor() {
        this.titleContributionContextKeys = new plugin_menu_command_adapter_1.ReferenceCountingSet();
        this.onDidChangeTitleContributionEmitter = new core_1.Emitter();
        this.initialized = false;
    }
    initialize() {
        this.initialized = true;
        this.commandAdapterRegistry.registerAdapter(this.commandAdapter);
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_MENU, widget => this.codeEditorWidgetUtil.is(widget));
        this.tabBarToolbar.registerItem({
            id: this.tabBarToolbar.toElementId(vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_RUN_MENU), menuPath: vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_RUN_MENU,
            icon: 'debug-alt', text: core_1.nls.localizeByDefault('Run or Debug...'),
            command: '', group: 'navigation', isVisible: widget => this.codeEditorWidgetUtil.is(widget)
        });
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_SCM_TITLE_MENU, widget => widget instanceof scm_widget_1.ScmWidget);
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_VIEW_TITLE_MENU, widget => !this.codeEditorWidgetUtil.is(widget));
        this.tabBarToolbar.registerItem({ id: 'plugin-menu-contribution-title-contribution', command: '_never_', onDidChange: this.onDidChangeTitleContributionEmitter.event });
        this.contextKeyService.onDidChange(event => {
            if (event.affects(this.titleContributionContextKeys)) {
                this.onDidChangeTitleContributionEmitter.fire();
            }
        });
    }
    getMatchingMenu(contributionPoint) {
        return vscode_theia_menu_mappings_1.codeToTheiaMappings.get(contributionPoint);
    }
    handle(plugin) {
        var _a, _b, _c, _d;
        const allMenus = (_a = plugin.contributes) === null || _a === void 0 ? void 0 : _a.menus;
        if (!allMenus) {
            return core_1.Disposable.NULL;
        }
        if (!this.initialized) {
            this.initialize();
        }
        const toDispose = new core_1.DisposableCollection();
        const submenus = (_c = (_b = plugin.contributes) === null || _b === void 0 ? void 0 : _b.submenus) !== null && _c !== void 0 ? _c : [];
        for (const submenu of submenus) {
            const iconClass = submenu.icon && this.toIconClass(submenu.icon, toDispose);
            this.menuRegistry.registerIndependentSubmenu(submenu.id, submenu.label, iconClass ? { iconClass } : undefined);
        }
        for (const [contributionPoint, items] of Object.entries(allMenus)) {
            for (const item of items) {
                try {
                    if (contributionPoint === 'commandPalette') {
                        toDispose.push(this.registerCommandPaletteAction(item));
                    }
                    else {
                        this.checkTitleContribution(contributionPoint, item, toDispose);
                        const targets = (_d = this.getMatchingMenu(contributionPoint)) !== null && _d !== void 0 ? _d : [contributionPoint];
                        const { group, order } = this.parseGroup(item.group);
                        const { submenu, command } = item;
                        if (submenu && command) {
                            console.warn(`Menu item ${command} from plugin ${plugin.metadata.model.id} contributed both submenu and command. Only command will be registered.`);
                        }
                        if (command) {
                            toDispose.push(this.commandAdapter.addCommand(command));
                            targets.forEach(target => {
                                const node = new core_1.ActionMenuNode({
                                    commandId: command,
                                    when: item.when,
                                    order
                                }, this.commands);
                                const parent = this.menuRegistry.getMenuNode(target, group);
                                toDispose.push(parent.addNode(node));
                            });
                        }
                        else if (submenu) {
                            targets.forEach(target => toDispose.push(this.menuRegistry.linkSubmenu(target, submenu, { order, when: item.when }, group)));
                        }
                    }
                }
                catch (error) {
                    console.warn(`Failed to register a menu item for plugin ${plugin.metadata.model.id} contributed to ${contributionPoint}`, item, error);
                }
            }
        }
        return toDispose;
    }
    parseGroup(rawGroup) {
        if (!rawGroup) {
            return {};
        }
        const separatorIndex = rawGroup.lastIndexOf('@');
        if (separatorIndex > -1) {
            return { group: rawGroup.substring(0, separatorIndex), order: rawGroup.substring(separatorIndex + 1) || undefined };
        }
        return { group: rawGroup };
    }
    registerCommandPaletteAction(menu) {
        if (menu.command && menu.when) {
            return this.quickCommandService.pushCommandContext(menu.command, menu.when);
        }
        return core_1.Disposable.NULL;
    }
    checkTitleContribution(contributionPoint, contribution, toDispose) {
        if (contribution.when && contributionPoint.endsWith('title')) {
            const expression = contextkey_1.ContextKeyExpr.deserialize(contribution.when);
            if (expression) {
                for (const key of expression.keys()) {
                    this.titleContributionContextKeys.add(key);
                    toDispose.push(core_1.Disposable.create(() => this.titleContributionContextKeys.delete(key)));
                }
                toDispose.push(core_1.Disposable.create(() => this.onDidChangeTitleContributionEmitter.fire()));
            }
        }
    }
    toIconClass(url, toDispose) {
        if (typeof url === 'string') {
            const asThemeIcon = themables_1.ThemeIcon.fromString(url);
            if (asThemeIcon) {
                return themables_1.ThemeIcon.asClassName(asThemeIcon);
            }
        }
        const reference = this.style.toIconClass(url);
        toDispose.push(reference);
        return reference.object.iconClass;
    }
};
exports.MenusContributionPointHandler = MenusContributionPointHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", common_1.MenuModelRegistry)
], MenusContributionPointHandler.prototype, "menuRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], MenusContributionPointHandler.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(tab_bar_toolbar_1.TabBarToolbarRegistry),
    tslib_1.__metadata("design:type", tab_bar_toolbar_1.TabBarToolbarRegistry)
], MenusContributionPointHandler.prototype, "tabBarToolbar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(vscode_theia_menu_mappings_1.CodeEditorWidgetUtil),
    tslib_1.__metadata("design:type", vscode_theia_menu_mappings_1.CodeEditorWidgetUtil)
], MenusContributionPointHandler.prototype, "codeEditorWidgetUtil", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_menu_command_adapter_1.PluginMenuCommandAdapter),
    tslib_1.__metadata("design:type", plugin_menu_command_adapter_1.PluginMenuCommandAdapter)
], MenusContributionPointHandler.prototype, "commandAdapter", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuCommandAdapterRegistry),
    tslib_1.__metadata("design:type", Object)
], MenusContributionPointHandler.prototype, "commandAdapterRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], MenusContributionPointHandler.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], MenusContributionPointHandler.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickCommandService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", browser_1.QuickCommandService)
], MenusContributionPointHandler.prototype, "quickCommandService", void 0);
exports.MenusContributionPointHandler = MenusContributionPointHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MenusContributionPointHandler);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginMenuCommandAdapter = exports.ReferenceCountingSet = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const resource_context_key_1 = __webpack_require__(/*! @theia/core/lib/browser/resource-context-key */ "../node_modules/@theia/core/lib/browser/resource-context-key.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const tree_widget_selection_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-widget-selection */ "../node_modules/@theia/core/lib/browser/tree/tree-widget-selection.js");
const scm_repository_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-repository */ "../node_modules/@theia/scm/lib/browser/scm-repository.js");
const scm_service_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const dirty_diff_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/dirty-diff-widget */ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
const diff_computer_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/diff-computer */ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const test_types_1 = __webpack_require__(/*! ../../../common/test-types */ "../node_modules/@theia/plugin-ext/lib/common/test-types.js");
const scm_main_1 = __webpack_require__(/*! ../scm-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js");
const tree_view_widget_1 = __webpack_require__(/*! ../view/tree-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const vscode_theia_menu_mappings_1 = __webpack_require__(/*! ./vscode-theia-menu-mappings */ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js");
const tab_bar_toolbar_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/tab-bar-toolbar */ "../node_modules/@theia/core/lib/browser/shell/tab-bar-toolbar/index.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
class ReferenceCountingSet {
    constructor(initialMembers) {
        this.references = new Map();
        if (initialMembers) {
            for (const member of initialMembers) {
                this.add(member);
            }
        }
    }
    add(newMember) {
        var _a;
        const value = (_a = this.references.get(newMember)) !== null && _a !== void 0 ? _a : 0;
        this.references.set(newMember, value + 1);
        return this;
    }
    /** @returns true if the deletion results in the removal of the element from the set */
    delete(member) {
        const value = this.references.get(member);
        if (value === undefined) { }
        else if (value <= 1) {
            this.references.delete(member);
            return true;
        }
        else {
            this.references.set(member, value - 1);
        }
        return false;
    }
    has(maybeMember) {
        return this.references.has(maybeMember);
    }
}
exports.ReferenceCountingSet = ReferenceCountingSet;
let PluginMenuCommandAdapter = class PluginMenuCommandAdapter {
    constructor() {
        this.commands = new ReferenceCountingSet();
        this.argumentAdapters = new Map();
        this.separator = ':)(:';
        /* eslint-enable @typescript-eslint/no-explicit-any */
    }
    init() {
        const toCommentArgs = (...args) => this.toCommentArgs(...args);
        const toTestMessageArgs = (...args) => this.toTestMessageArgs(...args);
        const firstArgOnly = (...args) => [args[0]];
        const noArgs = () => [];
        const toScmArgs = (...args) => this.toScmArgs(...args);
        const selectedResource = () => this.getSelectedResources();
        const widgetURI = widget => this.codeEditorUtil.is(widget) ? [this.codeEditorUtil.getResourceUri(widget)] : [];
        [
            ['comments/comment/context', toCommentArgs],
            ['comments/comment/title', toCommentArgs],
            ['comments/commentThread/context', toCommentArgs],
            ['debug/callstack/context', firstArgOnly],
            ['debug/variables/context', firstArgOnly],
            ['debug/toolBar', noArgs],
            ['editor/context', selectedResource],
            ['editor/title', widgetURI],
            ['editor/title/context', selectedResource],
            ['editor/title/run', widgetURI],
            ['explorer/context', selectedResource],
            ['scm/resourceFolder/context', toScmArgs],
            ['scm/resourceGroup/context', toScmArgs],
            ['scm/resourceState/context', toScmArgs],
            ['scm/title', () => [this.toScmArg(this.scmService.selectedRepository)]],
            ['testing/message/context', toTestMessageArgs],
            ['testing/profiles/context', noArgs],
            ['scm/change/title', (...args) => this.toScmChangeArgs(...args)],
            ['timeline/item/context', (...args) => this.toTimelineArgs(...args)],
            ['view/item/context', (...args) => this.toTreeArgs(...args)],
            ['view/title', noArgs],
            ['webview/context', firstArgOnly],
            ['extension/context', noArgs],
            ['terminal/context', noArgs],
            ['terminal/title/context', noArgs],
        ].forEach(([contributionPoint, adapter]) => {
            if (adapter) {
                const paths = vscode_theia_menu_mappings_1.codeToTheiaMappings.get(contributionPoint);
                if (paths) {
                    paths.forEach(path => this.addArgumentAdapter(path, adapter));
                }
            }
        });
        this.addArgumentAdapter(tab_bar_toolbar_1.TAB_BAR_TOOLBAR_CONTEXT_MENU, widgetURI);
    }
    canHandle(menuPath, command, ...commandArgs) {
        if (this.commands.has(command) && this.getArgumentAdapterForMenu(menuPath)) {
            return 500;
        }
        return -1;
    }
    executeCommand(menuPath, command, ...commandArgs) {
        const argumentAdapter = this.getAdapterOrThrow(menuPath);
        return this.commandRegistry.executeCommand(command, ...argumentAdapter(...commandArgs));
    }
    isVisible(menuPath, command, ...commandArgs) {
        const argumentAdapter = this.getAdapterOrThrow(menuPath);
        return this.commandRegistry.isVisible(command, ...argumentAdapter(...commandArgs));
    }
    isEnabled(menuPath, command, ...commandArgs) {
        const argumentAdapter = this.getAdapterOrThrow(menuPath);
        return this.commandRegistry.isEnabled(command, ...argumentAdapter(...commandArgs));
    }
    isToggled(menuPath, command, ...commandArgs) {
        const argumentAdapter = this.getAdapterOrThrow(menuPath);
        return this.commandRegistry.isToggled(command, ...argumentAdapter(...commandArgs));
    }
    getAdapterOrThrow(menuPath) {
        const argumentAdapter = this.getArgumentAdapterForMenu(menuPath);
        if (!argumentAdapter) {
            throw new Error('PluginMenuCommandAdapter attempted to execute command for unregistered menu: ' + JSON.stringify(menuPath));
        }
        return argumentAdapter;
    }
    addCommand(commandId) {
        this.commands.add(commandId);
        return core_1.Disposable.create(() => this.commands.delete(commandId));
    }
    getArgumentAdapterForMenu(menuPath) {
        let result;
        let length = 0;
        for (const [key, value] of this.argumentAdapters.entries()) {
            const candidate = key.split(this.separator);
            if (this.isPrefixOf(candidate, menuPath) && candidate.length > length) {
                result = value;
                length = candidate.length;
            }
        }
        return result;
    }
    isPrefixOf(candidate, menuPath) {
        if (candidate.length > menuPath.length) {
            return false;
        }
        for (let i = 0; i < candidate.length; i++) {
            if (candidate[i] !== menuPath[i]) {
                return false;
            }
        }
        return true;
    }
    addArgumentAdapter(menuPath, adapter) {
        this.argumentAdapters.set(menuPath.join(this.separator), adapter);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    toCommentArgs(...args) {
        const arg = args[0];
        if ('text' in arg) {
            if ('commentUniqueId' in arg) {
                return [{
                        commentControlHandle: arg.thread.controllerHandle,
                        commentThreadHandle: arg.thread.commentThreadHandle,
                        text: arg.text,
                        commentUniqueId: arg.commentUniqueId
                    }];
            }
            return [{
                    commentControlHandle: arg.thread.controllerHandle,
                    commentThreadHandle: arg.thread.commentThreadHandle,
                    text: arg.text
                }];
        }
        return [{
                commentControlHandle: arg.thread.controllerHandle,
                commentThreadHandle: arg.thread.commentThreadHandle,
                commentUniqueId: arg.commentUniqueId
            }];
    }
    toScmArgs(...args) {
        const scmArgs = [];
        for (const arg of args) {
            const scmArg = this.toScmArg(arg);
            if (scmArg) {
                scmArgs.push(scmArg);
            }
        }
        return scmArgs;
    }
    toScmArg(arg) {
        if (arg instanceof scm_repository_1.ScmRepository && arg.provider instanceof scm_main_1.PluginScmProvider) {
            return {
                sourceControlHandle: arg.provider.handle
            };
        }
        if (arg instanceof scm_main_1.PluginScmResourceGroup) {
            return {
                sourceControlHandle: arg.provider.handle,
                resourceGroupHandle: arg.handle
            };
        }
        if (arg instanceof scm_main_1.PluginScmResource) {
            return {
                sourceControlHandle: arg.group.provider.handle,
                resourceGroupHandle: arg.group.handle,
                resourceStateHandle: arg.handle
            };
        }
    }
    toScmChangeArgs(...args) {
        const arg = args[0];
        if (arg instanceof dirty_diff_widget_1.DirtyDiffWidget) {
            const toIChange = (change) => {
                const convert = (range) => {
                    let startLineNumber;
                    let endLineNumber;
                    if (!diff_computer_1.LineRange.isEmpty(range)) {
                        startLineNumber = range.start + 1;
                        endLineNumber = range.end;
                    }
                    else {
                        startLineNumber = range.start;
                        endLineNumber = 0;
                    }
                    return [startLineNumber, endLineNumber];
                };
                const { previousRange, currentRange } = change;
                const [originalStartLineNumber, originalEndLineNumber] = convert(previousRange);
                const [modifiedStartLineNumber, modifiedEndLineNumber] = convert(currentRange);
                return {
                    originalStartLineNumber,
                    originalEndLineNumber,
                    modifiedStartLineNumber,
                    modifiedEndLineNumber
                };
            };
            return [
                arg.uri['codeUri'],
                arg.changes.map(toIChange),
                arg.currentChangeIndex
            ];
        }
        return [];
    }
    toTimelineArgs(...args) {
        var _a;
        const timelineArgs = [];
        const arg = args[0];
        timelineArgs.push(this.toTimelineArg(arg));
        timelineArgs.push(vscode_uri_1.URI.parse(arg.uri));
        timelineArgs.push((_a = arg.source) !== null && _a !== void 0 ? _a : '');
        return timelineArgs;
    }
    toTestMessageArgs(...args) {
        let testItem;
        let testMessage;
        for (const arg of args) {
            if (test_service_1.TestItem.is(arg)) {
                testItem = arg;
            }
            else if (Array.isArray(arg) && test_service_1.TestMessage.is(arg[0])) {
                testMessage = arg[0];
            }
        }
        if (testMessage) {
            const testItemReference = (testItem && testItem.controller) ? test_types_1.TestItemReference.create(testItem.controller.id, testItem.path) : undefined;
            const testMessageDTO = {
                message: testMessage.message,
                actual: testMessage.actual,
                expected: testMessage.expected,
                contextValue: testMessage.contextValue,
                location: testMessage.location,
                stackTrace: testMessage.stackTrace
            };
            return [test_types_1.TestMessageArg.create(testItemReference, testMessageDTO)];
        }
        return [];
    }
    toTimelineArg(arg) {
        return {
            timelineHandle: arg.handle,
            source: arg.source,
            uri: arg.uri
        };
    }
    toTreeArgs(...args) {
        const treeArgs = [];
        for (const arg of args) {
            if (common_1.TreeViewItemReference.is(arg)) {
                treeArgs.push(arg);
            }
            else if (Array.isArray(arg)) {
                treeArgs.push(arg.filter(common_1.TreeViewItemReference.is));
            }
        }
        return treeArgs;
    }
    getSelectedResources() {
        var _a, _b;
        const selection = this.selectionService.selection;
        const resourceKey = this.resourceContextKey.get();
        const resourceUri = resourceKey ? vscode_uri_1.URI.parse(resourceKey) : undefined;
        const firstMember = tree_widget_selection_1.TreeWidgetSelection.is(selection) && selection.source instanceof tree_view_widget_1.TreeViewWidget && selection[0]
            ? selection.source.toTreeViewItemReference(selection[0])
            : (_b = (_a = core_1.UriSelection.getUri(selection)) === null || _a === void 0 ? void 0 : _a['codeUri']) !== null && _b !== void 0 ? _b : resourceUri;
        const secondMember = tree_widget_selection_1.TreeWidgetSelection.is(selection)
            ? core_1.UriSelection.getUris(selection).map(uri => uri['codeUri'])
            : undefined;
        return [firstMember, secondMember];
    }
};
exports.PluginMenuCommandAdapter = PluginMenuCommandAdapter;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], PluginMenuCommandAdapter.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(vscode_theia_menu_mappings_1.CodeEditorWidgetUtil),
    tslib_1.__metadata("design:type", vscode_theia_menu_mappings_1.CodeEditorWidgetUtil)
], PluginMenuCommandAdapter.prototype, "codeEditorUtil", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], PluginMenuCommandAdapter.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.SelectionService),
    tslib_1.__metadata("design:type", core_1.SelectionService)
], PluginMenuCommandAdapter.prototype, "selectionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(resource_context_key_1.ResourceContextKey),
    tslib_1.__metadata("design:type", resource_context_key_1.ResourceContextKey)
], PluginMenuCommandAdapter.prototype, "resourceContextKey", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginMenuCommandAdapter.prototype, "init", null);
exports.PluginMenuCommandAdapter = PluginMenuCommandAdapter = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginMenuCommandAdapter);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeEditorWidgetUtil = exports.codeToTheiaMappings = exports.implementedVSCodeContributionPoints = exports.PLUGIN_VIEW_TITLE_MENU = exports.PLUGIN_SCM_TITLE_MENU = exports.PLUGIN_EDITOR_TITLE_RUN_MENU = exports.PLUGIN_EDITOR_TITLE_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const navigatable_1 = __webpack_require__(/*! @theia/core/lib/browser/navigatable */ "../node_modules/@theia/core/lib/browser/navigatable.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const debug_stack_frames_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-stack-frames-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js");
const debug_threads_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-threads-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js");
const debug_toolbar_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-toolbar-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-toolbar-widget.js");
const debug_variables_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-variables-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const navigator_contribution_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-contribution */ "../node_modules/@theia/navigator/lib/browser/navigator-contribution.js");
const scm_tree_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-tree-widget */ "../node_modules/@theia/scm/lib/browser/scm-tree-widget.js");
const dirty_diff_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/dirty-diff-widget */ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
const timeline_tree_widget_1 = __webpack_require__(/*! @theia/timeline/lib/browser/timeline-tree-widget */ "../node_modules/@theia/timeline/lib/browser/timeline-tree-widget.js");
const comment_thread_widget_1 = __webpack_require__(/*! ../comments/comment-thread-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js");
const tree_view_widget_1 = __webpack_require__(/*! ../view/tree-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const editor_linenumber_contribution_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-linenumber-contribution */ "../node_modules/@theia/editor/lib/browser/editor-linenumber-contribution.js");
const test_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const test_run_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-run-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-run-view-contribution.js");
const terminal_frontend_contribution_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-frontend-contribution */ "../node_modules/@theia/terminal/lib/browser/terminal-frontend-contribution.js");
exports.PLUGIN_EDITOR_TITLE_MENU = ['plugin_editor/title'];
exports.PLUGIN_EDITOR_TITLE_RUN_MENU = ['plugin_editor/title/run'];
exports.PLUGIN_SCM_TITLE_MENU = ['plugin_scm/title'];
exports.PLUGIN_VIEW_TITLE_MENU = ['plugin_view/title'];
exports.implementedVSCodeContributionPoints = [
    'comments/comment/context',
    'comments/comment/title',
    'comments/commentThread/context',
    'debug/callstack/context',
    'debug/variables/context',
    'debug/toolBar',
    'editor/context',
    'editor/title',
    'editor/title/context',
    'editor/title/run',
    'editor/lineNumber/context',
    'explorer/context',
    'scm/change/title',
    'scm/resourceFolder/context',
    'scm/resourceGroup/context',
    'scm/resourceState/context',
    'scm/title',
    'timeline/item/context',
    'testing/item/context',
    'testing/message/context',
    'testing/profiles/context',
    'view/item/context',
    'view/title',
    'webview/context',
    'extension/context',
    'terminal/context',
    'terminal/title/context'
];
/** The values are menu paths to which the VSCode contribution points correspond */
exports.codeToTheiaMappings = new Map([
    ['comments/comment/context', [comment_thread_widget_1.COMMENT_CONTEXT]],
    ['comments/comment/title', [comment_thread_widget_1.COMMENT_TITLE]],
    ['comments/commentThread/context', [comment_thread_widget_1.COMMENT_THREAD_CONTEXT]],
    ['debug/callstack/context', [debug_stack_frames_widget_1.DebugStackFramesWidget.CONTEXT_MENU, debug_threads_widget_1.DebugThreadsWidget.CONTEXT_MENU]],
    ['debug/variables/context', [debug_variables_widget_1.DebugVariablesWidget.CONTEXT_MENU]],
    ['debug/toolBar', [debug_toolbar_widget_1.DebugToolBar.MENU]],
    ['editor/context', [browser_2.EDITOR_CONTEXT_MENU]],
    ['editor/title', [exports.PLUGIN_EDITOR_TITLE_MENU]],
    ['editor/title/context', [browser_1.SHELL_TABBAR_CONTEXT_MENU]],
    ['editor/title/run', [exports.PLUGIN_EDITOR_TITLE_RUN_MENU]],
    ['editor/lineNumber/context', [editor_linenumber_contribution_1.EDITOR_LINENUMBER_CONTEXT_MENU]],
    ['explorer/context', [navigator_contribution_1.NAVIGATOR_CONTEXT_MENU]],
    ['scm/change/title', [dirty_diff_widget_1.PLUGIN_SCM_CHANGE_TITLE_MENU]],
    ['scm/resourceFolder/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU]],
    ['scm/resourceGroup/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU]],
    ['scm/resourceState/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_CONTEXT_MENU]],
    ['scm/title', [exports.PLUGIN_SCM_TITLE_MENU]],
    ['testing/item/context', [test_view_contribution_1.TEST_VIEW_CONTEXT_MENU]],
    ['testing/message/context', [test_run_view_contribution_1.TEST_RUNS_CONTEXT_MENU]],
    ['testing/profiles/context', [test_view_contribution_1.PLUGIN_TEST_VIEW_TITLE_MENU]],
    ['timeline/item/context', [timeline_tree_widget_1.TIMELINE_ITEM_CONTEXT_MENU]],
    ['view/item/context', [tree_view_widget_1.VIEW_ITEM_CONTEXT_MENU]],
    ['view/title', [exports.PLUGIN_VIEW_TITLE_MENU]],
    ['webview/context', [webview_1.WEBVIEW_CONTEXT_MENU]],
    ['extension/context', [['extensions_context_menu', '3_contribution']]],
    ['terminal/context', [terminal_frontend_contribution_1.TerminalMenus.TERMINAL_CONTRIBUTIONS]],
    ['terminal/title/context', [terminal_frontend_contribution_1.TerminalMenus.TERMINAL_TITLE_CONTRIBUTIONS]]
]);
let CodeEditorWidgetUtil = class CodeEditorWidgetUtil {
    is(arg) {
        return arg instanceof browser_2.EditorWidget || arg instanceof webview_1.WebviewWidget;
    }
    getResourceUri(editor) {
        const resourceUri = navigatable_1.Navigatable.is(editor) && editor.getResourceUri();
        return resourceUri ? resourceUri['codeUri'] : undefined;
    }
};
exports.CodeEditorWidgetUtil = CodeEditorWidgetUtil;
exports.CodeEditorWidgetUtil = CodeEditorWidgetUtil = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CodeEditorWidgetUtil);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRegistryMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const modal_notification_1 = __webpack_require__(/*! ./dialogs/modal-notification */ "../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js");
const basic_message_registry_main_1 = __webpack_require__(/*! ../common/basic-message-registry-main */ "../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js");
/**
 * Message registry implementation that adds support for the model option via dialog in the browser.
 */
class MessageRegistryMainImpl extends basic_message_registry_main_1.BasicMessageRegistryMainImpl {
    constructor(container) {
        super(container);
    }
    async doShowMessage(type, message, options, actions) {
        if (options.modal) {
            const messageType = type === plugin_api_rpc_1.MainMessageType.Error ? modal_notification_1.MessageType.Error :
                type === plugin_api_rpc_1.MainMessageType.Warning ? modal_notification_1.MessageType.Warning :
                    modal_notification_1.MessageType.Info;
            const modalNotification = new modal_notification_1.ModalNotification();
            return modalNotification.showDialog(messageType, message, options, actions);
        }
        return super.doShowMessage(type, message, options, actions);
    }
}
exports.MessageRegistryMainImpl = MessageRegistryMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksAndEditorsMain = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const collections_1 = __webpack_require__(/*! ../../../common/collections */ "../node_modules/@theia/plugin-ext/lib/common/collections.js");
const async_mutex_1 = __webpack_require__(/*! async-mutex */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/index.js");
class NotebookAndEditorState {
    static computeDelta(before, after) {
        if (!before) {
            return {
                addedDocuments: [...after.documents],
                removedDocuments: [],
                addedEditors: [...after.textEditors.values()],
                removedEditors: [],
                visibleEditors: [...after.visibleEditors].map(editor => editor[0])
            };
        }
        const documentDelta = (0, collections_1.diffSets)(before.documents, after.documents);
        const editorDelta = (0, collections_1.diffMaps)(before.textEditors, after.textEditors);
        const visibleEditorDelta = (0, collections_1.diffMaps)(before.visibleEditors, after.visibleEditors);
        return {
            addedDocuments: documentDelta.added,
            removedDocuments: documentDelta.removed.map(e => e.uri.toComponents()),
            addedEditors: editorDelta.added,
            removedEditors: editorDelta.removed.map(removed => removed.id),
            newActiveEditor: after.activeEditor,
            visibleEditors: visibleEditorDelta.added.length === 0 && visibleEditorDelta.removed.length === 0
                ? undefined
                : [...after.visibleEditors].map(editor => editor[0])
        };
    }
    constructor(documents, textEditors, activeEditor, visibleEditors) {
        this.documents = documents;
        this.textEditors = textEditors;
        this.activeEditor = activeEditor;
        this.visibleEditors = visibleEditors;
        //
    }
}
class NotebooksAndEditorsMain {
    constructor(rpc, container, tabsMain, notebookDocumentsMain, notebookEditorsMain) {
        this.notebookDocumentsMain = notebookDocumentsMain;
        this.notebookEditorsMain = notebookEditorsMain;
        this.disposables = new core_1.DisposableCollection();
        this.editorListeners = new Map();
        this.updateMutex = new async_mutex_1.Mutex();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOKS_EXT);
        this.notebookService = container.get(browser_1.NotebookService);
        this.notebookEditorService = container.get(browser_1.NotebookEditorWidgetService);
        this.WidgetManager = container.get(browser_2.WidgetManager);
        const notebookCellEditorService = container.get(browser_1.NotebookCellEditorService);
        notebookCellEditorService.onDidChangeFocusedCellEditor(editor => { var _a; return this.proxy.$acceptActiveCellEditorChange((_a = editor === null || editor === void 0 ? void 0 : editor.uri.toString()) !== null && _a !== void 0 ? _a : null); }, this, this.disposables);
        this.notebookService.onDidAddNotebookDocument(async () => this.updateState(), this, this.disposables);
        this.notebookService.onDidRemoveNotebookDocument(async () => this.updateState(), this, this.disposables);
        // this.WidgetManager.onActiveEditorChanged(() => this.updateState(), this, this.disposables);
        this.notebookEditorService.onDidAddNotebookEditor(async (editor) => this.handleEditorAdd(editor), this, this.disposables);
        this.notebookEditorService.onDidRemoveNotebookEditor(async (editor) => this.handleEditorRemove(editor), this, this.disposables);
        this.notebookEditorService.onDidChangeCurrentEditor(async (editor) => {
            if (editor) {
                await tabsMain.waitForWidget(editor);
            }
            this.updateState(editor);
        }, this, this.disposables);
    }
    dispose() {
        this.notebookDocumentsMain.dispose();
        this.notebookEditorsMain.dispose();
        this.disposables.dispose();
        this.editorListeners.forEach(listeners => listeners.forEach(listener => listener.dispose()));
    }
    async handleEditorAdd(editor) {
        const listeners = this.editorListeners.get(editor.id);
        const disposable = editor.onDidChangeModel(() => this.updateState());
        if (listeners) {
            listeners.push(disposable);
        }
        else {
            this.editorListeners.set(editor.id, [disposable]);
        }
        await this.updateState();
    }
    handleEditorRemove(editor) {
        const listeners = this.editorListeners.get(editor.id);
        listeners === null || listeners === void 0 ? void 0 : listeners.forEach(listener => listener.dispose());
        this.editorListeners.delete(editor.id);
        this.updateState();
    }
    async updateState(focusedEditor) {
        await this.updateMutex.runExclusive(async () => this.doUpdateState(focusedEditor));
    }
    async doUpdateState(focusedEditor) {
        const editors = new Map();
        const visibleEditorsMap = new Map();
        for (const editor of this.notebookEditorService.getNotebookEditors()) {
            editors.set(editor.id, editor);
        }
        const activeNotebookEditor = this.notebookEditorService.focusedEditor;
        let activeEditor = null;
        if (activeNotebookEditor) {
            activeEditor = activeNotebookEditor.id;
        }
        else if (focusedEditor === null || focusedEditor === void 0 ? void 0 : focusedEditor.model) {
            activeEditor = focusedEditor.id;
        }
        if (activeEditor && !editors.has(activeEditor)) {
            activeEditor = null;
        }
        const notebookEditors = this.WidgetManager.getWidgets(browser_1.NotebookEditorWidget.ID);
        for (const notebookEditor of notebookEditors) {
            if (editors.has(notebookEditor.id) && notebookEditor.isVisible) {
                visibleEditorsMap.set(notebookEditor.id, notebookEditor);
            }
        }
        const newState = new NotebookAndEditorState(new Set(this.notebookService.listNotebookDocuments()), editors, activeEditor, visibleEditorsMap);
        await this.onDelta(NotebookAndEditorState.computeDelta(this.currentState, newState));
        this.currentState = newState;
    }
    async onDelta(delta) {
        if (NotebooksAndEditorsMain.isDeltaEmpty(delta)) {
            return;
        }
        const dto = {
            removedDocuments: delta.removedDocuments,
            removedEditors: delta.removedEditors,
            newActiveEditor: delta.newActiveEditor,
            visibleEditors: delta.visibleEditors,
            addedDocuments: delta.addedDocuments.map(NotebooksAndEditorsMain.asModelAddData),
            addedEditors: delta.addedEditors.map(NotebooksAndEditorsMain.asEditorAddData),
        };
        // Handle internally first
        // In case the plugin wants to perform documents edits immediately
        // we want to make sure that all events have already been setup
        this.notebookEditorsMain.handleEditorsRemoved(delta.removedEditors);
        this.notebookDocumentsMain.handleNotebooksRemoved(delta.removedDocuments);
        this.notebookDocumentsMain.handleNotebooksAdded(delta.addedDocuments);
        this.notebookEditorsMain.handleEditorsAdded(delta.addedEditors);
        // Send to plugin last
        await this.proxy.$acceptDocumentsAndEditorsDelta(dto);
    }
    static isDeltaEmpty(delta) {
        var _a, _b, _c, _d, _e;
        if ((_a = delta.addedDocuments) === null || _a === void 0 ? void 0 : _a.length) {
            return false;
        }
        if ((_b = delta.removedDocuments) === null || _b === void 0 ? void 0 : _b.length) {
            return false;
        }
        if ((_c = delta.addedEditors) === null || _c === void 0 ? void 0 : _c.length) {
            return false;
        }
        if ((_d = delta.removedEditors) === null || _d === void 0 ? void 0 : _d.length) {
            return false;
        }
        if ((_e = delta.visibleEditors) === null || _e === void 0 ? void 0 : _e.length) {
            return false;
        }
        if (delta.newActiveEditor !== undefined) {
            return false;
        }
        return true;
    }
    static asModelAddData(e) {
        return {
            viewType: e.viewType,
            uri: e.uri.toComponents(),
            metadata: e.metadata,
            versionId: 1, // TODO implement versionID support
            cells: e.cells.map(notebook_dto_1.NotebookDto.toNotebookCellDto)
        };
    }
    static asEditorAddData(notebookEditor) {
        const uri = notebookEditor.getResourceUri();
        if (!uri) {
            throw new Error('Notebook editor without resource URI');
        }
        return {
            id: notebookEditor.id,
            documentUri: uri.toComponents(),
            selections: [{ start: 0, end: 0 }],
            visibleRanges: []
        };
    }
}
exports.NotebooksAndEditorsMain = NotebooksAndEditorsMain;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentsMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../node_modules/@theia/notebook/lib/common/index.js");
const notebook_monaco_text_model_service_1 = __webpack_require__(/*! @theia/notebook/lib/browser/service/notebook-monaco-text-model-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js");
const common_2 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const notebook_open_handler_1 = __webpack_require__(/*! @theia/notebook/lib/browser/notebook-open-handler */ "../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js");
class NotebookDocumentsMainImpl {
    constructor(rpc, container) {
        this.disposables = new core_1.DisposableCollection();
        this.documentEventListenersMapping = new Map();
        this.proxy = rpc.getProxy(common_2.MAIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_EXT);
        this.notebookModelResolverService = container.get(browser_1.NotebookModelResolverService);
        this.notebookOpenHandler = container.get(notebook_open_handler_1.NotebookOpenHandler);
        // forward dirty and save events
        this.disposables.push(this.notebookModelResolverService.onDidChangeDirty(model => this.proxy.$acceptDirtyStateChanged(model.uri.toComponents(), model.isDirty())));
        this.disposables.push(this.notebookModelResolverService.onDidSaveNotebook(e => this.proxy.$acceptModelSaved(e)));
        this.notebookMonacoTextModelService = container.get(notebook_monaco_text_model_service_1.NotebookMonacoTextModelService);
    }
    get onDidAddNotebookCellModel() {
        return this.notebookMonacoTextModelService.onDidCreateNotebookCellModel;
    }
    dispose() {
        this.disposables.dispose();
        // this.modelReferenceCollection.dispose();
        this.documentEventListenersMapping.forEach(value => value.dispose());
    }
    handleNotebooksAdded(notebooks) {
        for (const notebook of notebooks) {
            const listener = notebook.onDidChangeContent(events => {
                const eventDto = {
                    versionId: 1, // TODO implement version ID support
                    rawEvents: []
                };
                for (const e of events) {
                    switch (e.kind) {
                        case common_1.NotebookCellsChangeType.ModelChange:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                changes: e.changes.map(diff => ({ ...diff, newItems: diff.newItems.map(notebook_dto_1.NotebookDto.toNotebookCellDto) }))
                            });
                            break;
                        case common_1.NotebookCellsChangeType.Move:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                length: e.length,
                                newIdx: e.newIdx,
                            });
                            break;
                        case common_1.NotebookCellsChangeType.Output:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                outputs: e.outputs.map(notebook_dto_1.NotebookDto.toNotebookOutputDto)
                            });
                            break;
                        case common_1.NotebookCellsChangeType.OutputItem:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                outputId: e.outputId,
                                outputItems: e.outputItems.map(notebook_dto_1.NotebookDto.toNotebookOutputItemDto),
                                append: e.append
                            });
                            break;
                        case common_1.NotebookCellsChangeType.ChangeCellLanguage:
                        case common_1.NotebookCellsChangeType.ChangeCellContent:
                        case common_1.NotebookCellsChangeType.ChangeCellMetadata:
                        case common_1.NotebookCellsChangeType.ChangeCellInternalMetadata:
                            eventDto.rawEvents.push(e);
                            break;
                        case common_1.NotebookCellsChangeType.ChangeDocumentMetadata:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                metadata: e.metadata
                            });
                            break;
                    }
                }
                const hasDocumentMetadataChangeEvent = events.find(e => e.kind === common_1.NotebookCellsChangeType.ChangeDocumentMetadata);
                // using the model resolver service to know if the model is dirty or not.
                // assuming this is the first listener it can mean that at first the model
                // is marked as dirty and that another event is fired
                this.proxy.$acceptModelChanged(notebook.uri.toComponents(), eventDto, notebook.isDirty(), hasDocumentMetadataChangeEvent ? notebook.metadata : undefined);
            });
            this.documentEventListenersMapping.set(notebook.uri.toString(), new core_1.DisposableCollection(listener));
        }
    }
    handleNotebooksRemoved(uris) {
        var _a;
        for (const uri of uris) {
            (_a = this.documentEventListenersMapping.get(uri.toString())) === null || _a === void 0 ? void 0 : _a.dispose();
            this.documentEventListenersMapping.delete(uri.toString());
        }
    }
    async $tryCreateNotebook(options) {
        const ref = await this.notebookModelResolverService.resolveUntitledResource({ untitledResource: undefined }, options.viewType);
        // untitled notebooks are disposed when they get saved. we should not hold a reference
        // to such a disposed notebook and therefore dispose the reference as well
        // ref.onWillDispose(() => {
        //     ref.dispose();
        // });
        const uriComponents = ref.uri.toComponents();
        // untitled notebooks are dirty by default
        this.proxy.$acceptDirtyStateChanged(uriComponents, true);
        // apply content changes...
        if (options.content) {
            const data = notebook_dto_1.NotebookDto.fromNotebookDataDto(options.content);
            ref.setData(data);
            // Create and send a change events
            const rawEvents = [];
            if (options.content.cells && options.content.cells.length > 0) {
                rawEvents.push({
                    kind: common_1.NotebookCellsChangeType.ModelChange,
                    changes: [{ start: 0, startHandle: 0, deleteCount: 0, newItems: ref.cells.map(notebook_dto_1.NotebookDto.toNotebookCellDto) }]
                });
            }
            if (options.content.metadata) {
                rawEvents.push({
                    kind: common_1.NotebookCellsChangeType.ChangeDocumentMetadata,
                    metadata: options.content.metadata
                });
            }
            if (rawEvents.length > 0) {
                this.proxy.$acceptModelChanged(uriComponents, { versionId: 1, rawEvents }, true);
            }
        }
        return uriComponents;
    }
    async $tryOpenNotebook(uriComponents) {
        const uri = uri_1.URI.fromComponents(uriComponents);
        await this.notebookModelResolverService.resolve(uri);
        return uri.toComponents();
    }
    async $trySaveNotebook(uriComponents) {
        const uri = uri_1.URI.fromComponents(uriComponents);
        const ref = await this.notebookModelResolverService.resolve(uri);
        await ref.save();
        ref.dispose();
        return true;
    }
}
exports.NotebookDocumentsMainImpl = NotebookDocumentsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDto = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../node_modules/@theia/notebook/lib/common/index.js");
var NotebookDto;
(function (NotebookDto) {
    function toNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            valueBytes: item.data
        };
    }
    NotebookDto.toNotebookOutputItemDto = toNotebookOutputItemDto;
    function toNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            items: output.outputs.map(toNotebookOutputItemDto)
        };
    }
    NotebookDto.toNotebookOutputDto = toNotebookOutputDto;
    function toNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            internalMetadata: cell.internalMetadata,
            metadata: cell.metadata,
            outputs: cell.outputs.map(toNotebookOutputDto)
        };
    }
    NotebookDto.toNotebookCellDataDto = toNotebookCellDataDto;
    function toNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(toNotebookCellDataDto)
        };
    }
    NotebookDto.toNotebookDataDto = toNotebookDataDto;
    function fromNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            data: item.valueBytes
        };
    }
    NotebookDto.fromNotebookOutputItemDto = fromNotebookOutputItemDto;
    function fromNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            outputs: output.items.map(fromNotebookOutputItemDto)
        };
    }
    NotebookDto.fromNotebookOutputDto = fromNotebookOutputDto;
    function fromNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            outputs: cell.outputs.map(fromNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata
        };
    }
    NotebookDto.fromNotebookCellDataDto = fromNotebookCellDataDto;
    function fromNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(fromNotebookCellDataDto)
        };
    }
    NotebookDto.fromNotebookDataDto = fromNotebookDataDto;
    function toNotebookCellDto(cell) {
        const eol = core_1.OS.backend.EOL;
        return {
            handle: cell.handle,
            uri: cell.uri.toComponents(),
            source: cell.text.split(/\r?\n/g),
            eol,
            language: cell.language,
            cellKind: cell.cellKind,
            outputs: cell.outputs.map(toNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata,
        };
    }
    NotebookDto.toNotebookCellDto = toNotebookCellDto;
    function fromCellExecuteUpdateDto(data) {
        if (data.editType === common_1.CellExecutionUpdateType.Output) {
            return {
                editType: data.editType,
                cellHandle: data.cellHandle,
                append: data.append,
                outputs: data.outputs.map(fromNotebookOutputDto)
            };
        }
        else if (data.editType === common_1.CellExecutionUpdateType.OutputItems) {
            return {
                editType: data.editType,
                outputId: data.outputId,
                append: data.append,
                items: data.items.map(fromNotebookOutputItemDto)
            };
        }
        else {
            return data;
        }
    }
    NotebookDto.fromCellExecuteUpdateDto = fromCellExecuteUpdateDto;
    function fromCellExecuteCompleteDto(data) {
        return data;
    }
    NotebookDto.fromCellExecuteCompleteDto = fromCellExecuteCompleteDto;
})(NotebookDto || (exports.NotebookDto = NotebookDto = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorsMainImpl = void 0;
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_open_handler_1 = __webpack_require__(/*! @theia/notebook/lib/browser/notebook-open-handler */ "../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js");
class NotebookEditorsMainImpl {
    constructor(rpc, container) {
        this.mainThreadEditors = new Map();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_EDITORS_EXT);
        this.notebookService = container.get(browser_1.NotebookService);
        this.notebookOpenHandler = container.get(notebook_open_handler_1.NotebookOpenHandler);
    }
    async $tryShowNotebookDocument(uriComponents, viewType, options) {
        const editor = await this.notebookOpenHandler.open(uri_1.URI.fromComponents(uriComponents), {
            notebookType: viewType
        });
        await editor.ready;
        return editor.id;
    }
    $tryRevealRange(id, range, revealType) {
        throw new Error('Method not implemented.');
    }
    $trySetSelections(id, range) {
        var _a;
        if (!this.mainThreadEditors.has(id)) {
            throw new Error('Editor not found');
        }
        const editor = this.mainThreadEditors.get(id);
        (_a = editor === null || editor === void 0 ? void 0 : editor.model) === null || _a === void 0 ? void 0 : _a.setSelectedCell(editor.model.cells[range[0].start]);
    }
    async handleEditorsAdded(editors) {
        for (const editor of editors) {
            this.mainThreadEditors.set(editor.id, editor);
            const model = await editor.ready;
            model.onDidChangeSelectedCell(e => {
                const newCellIndex = e.cell ? model.cells.indexOf(e.cell) : -1;
                this.proxy.$acceptEditorPropertiesChanged(editor.id, {
                    selections: {
                        selections: newCellIndex >= 0 ? [{ start: newCellIndex, end: newCellIndex }] : []
                    }
                });
            });
        }
    }
    handleEditorsRemoved(editorIds) {
        var _a;
        for (const id of editorIds) {
            (_a = this.mainThreadEditors.get(id)) === null || _a === void 0 ? void 0 : _a.dispose();
            this.mainThreadEditors.delete(id);
        }
    }
    dispose() {
    }
}
exports.NotebookEditorsMainImpl = NotebookEditorsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookKernelsMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../node_modules/@theia/core/lib/browser/language-service.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
class NotebookKernel {
    get preloadUris() {
        return this.preloads.map(p => p.uri);
    }
    get preloadProvides() {
        return this.preloads.map(p => p.provides).flat();
    }
    constructor(handle, data, languageService) {
        var _a, _b, _c, _d;
        this.handle = handle;
        this.languageService = languageService;
        this.onDidChangeEmitter = new core_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.id = data.id;
        this.viewType = data.notebookType;
        this.extensionId = data.extensionId;
        this.implementsInterrupt = (_a = data.supportsInterrupt) !== null && _a !== void 0 ? _a : false;
        this.label = data.label;
        this.description = data.description;
        this.detail = data.detail;
        this.supportedLanguages = (data.supportedLanguages && data.supportedLanguages.length > 0) ? data.supportedLanguages : languageService.languages.map(lang => lang.id);
        this.implementsExecutionOrder = (_b = data.supportsExecutionOrder) !== null && _b !== void 0 ? _b : false;
        this.localResourceRoot = core_1.URI.fromComponents(data.extensionLocation);
        this.preloads = (_d = (_c = data.preloads) === null || _c === void 0 ? void 0 : _c.map(u => ({ uri: core_1.URI.fromComponents(u.uri), provides: u.provides }))) !== null && _d !== void 0 ? _d : [];
    }
    update(data) {
        const event = Object.create(null);
        if (data.label !== undefined) {
            this.label = data.label;
            event.label = true;
        }
        if (data.description !== undefined) {
            this.description = data.description;
            event.description = true;
        }
        if (data.detail !== undefined) {
            this.detail = data.detail;
            event.detail = true;
        }
        if (data.supportedLanguages !== undefined) {
            this.supportedLanguages = (data.supportedLanguages && data.supportedLanguages.length > 0) ?
                data.supportedLanguages :
                this.languageService.languages.map(lang => lang.id);
            event.supportedLanguages = true;
        }
        if (data.supportsExecutionOrder !== undefined) {
            this.implementsExecutionOrder = data.supportsExecutionOrder;
            event.hasExecutionOrder = true;
        }
        if (data.supportsInterrupt !== undefined) {
            this.implementsInterrupt = data.supportsInterrupt;
            event.hasInterruptHandler = true;
        }
        this.onDidChangeEmitter.fire(event);
    }
}
class NotebookKernelsMainImpl {
    constructor(rpc, container) {
        this.kernels = new Map();
        this.kernelDetectionTasks = new Map();
        this.kernelSourceActionProviders = new Map();
        this.kernelSourceActionProvidersEventRegistrations = new Map();
        this.executions = new Map();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_KERNELS_EXT);
        this.notebookKernelService = container.get(browser_1.NotebookKernelService);
        this.notebookExecutionStateService = container.get(browser_1.NotebookExecutionStateService);
        this.notebookService = container.get(browser_1.NotebookService);
        this.languageService = container.get(language_service_1.LanguageService);
        this.notebookEditorWidgetService = container.get(browser_1.NotebookEditorWidgetService);
        this.notebookEditorWidgetService.onDidAddNotebookEditor(editor => {
            editor.onDidReceiveKernelMessage(async (message) => {
                const kernel = this.notebookKernelService.getSelectedOrSuggestedKernel(editor.model);
                if (kernel) {
                    this.proxy.$acceptKernelMessageFromRenderer(kernel.handle, editor.id, message);
                }
            });
        });
        this.notebookKernelService.onDidChangeSelectedKernel(e => {
            var _a, _b;
            if (e.newKernel) {
                const newKernelHandle = (_a = Array.from(this.kernels.entries()).find(([_, [kernel]]) => kernel.id === e.newKernel)) === null || _a === void 0 ? void 0 : _a[0];
                if (newKernelHandle !== undefined) {
                    this.proxy.$acceptNotebookAssociation(newKernelHandle, e.notebook.toComponents(), true);
                }
            }
            else {
                const oldKernelHandle = (_b = Array.from(this.kernels.entries()).find(([_, [kernel]]) => kernel.id === e.oldKernel)) === null || _b === void 0 ? void 0 : _b[0];
                if (oldKernelHandle !== undefined) {
                    this.proxy.$acceptNotebookAssociation(oldKernelHandle, e.notebook.toComponents(), false);
                }
            }
        });
    }
    async $postMessage(handle, editorId, message) {
        const tuple = this.kernels.get(handle);
        if (!tuple) {
            throw new Error('kernel already disposed');
        }
        const [kernel] = tuple;
        let didSend = false;
        for (const editor of this.notebookEditorWidgetService.getNotebookEditors()) {
            if (!editor.model) {
                continue;
            }
            if (this.notebookKernelService.getMatchingKernel(editor.model).selected !== kernel) {
                // different kernel
                continue;
            }
            if (editorId === undefined) {
                // all editors
                editor.postKernelMessage(message);
                didSend = true;
            }
            else if (editor.id === editorId) {
                // selected editors
                editor.postKernelMessage(message);
                didSend = true;
                break;
            }
        }
        return didSend;
    }
    async $addKernel(handle, data) {
        const that = this;
        const kernel = new class extends NotebookKernel {
            async executeNotebookCellsRequest(uri, handles) {
                await that.proxy.$executeCells(handle, uri.toComponents(), handles);
            }
            async cancelNotebookCellExecution(uri, handles) {
                await that.proxy.$cancelCells(handle, uri.toComponents(), handles);
            }
        }(handle, data, this.languageService);
        // this is for when a kernel is bound to a notebook while being registered
        const autobindListener = this.notebookKernelService.onDidChangeSelectedKernel(e => {
            if (e.newKernel === kernel.id) {
                this.proxy.$acceptNotebookAssociation(handle, e.notebook.toComponents(), true);
            }
        });
        const registration = this.notebookKernelService.registerKernel(kernel);
        this.kernels.set(handle, [kernel, registration]);
        autobindListener.dispose();
    }
    $updateKernel(handle, data) {
        const tuple = this.kernels.get(handle);
        if (tuple) {
            tuple[0].update(data);
        }
    }
    $removeKernel(handle) {
        const tuple = this.kernels.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernels.delete(handle);
        }
    }
    $updateNotebookPriority(handle, uri, value) {
        throw new Error('Method not implemented.');
    }
    $createExecution(handle, controllerId, uriComponents, cellHandle) {
        var _a;
        const uri = core_1.URI.fromComponents(uriComponents);
        const notebook = this.notebookService.getNotebookEditorModel(uri);
        if (!notebook) {
            throw new Error(`Notebook not found: ${uri.toString()}`);
        }
        const kernel = this.notebookKernelService.getMatchingKernel(notebook);
        if (!kernel.selected || kernel.selected.id !== controllerId) {
            throw new Error(`Kernel is not selected: ${(_a = kernel.selected) === null || _a === void 0 ? void 0 : _a.id} !== ${controllerId}`);
        }
        const execution = this.notebookExecutionStateService.getOrCreateCellExecution(uri, cellHandle);
        execution.confirm();
        this.executions.set(handle, execution);
    }
    $updateExecution(handle, updates) {
        const execution = this.executions.get(handle);
        execution === null || execution === void 0 ? void 0 : execution.update(updates.map(notebook_dto_1.NotebookDto.fromCellExecuteUpdateDto));
    }
    $completeExecution(handle, data) {
        try {
            const execution = this.executions.get(handle);
            execution === null || execution === void 0 ? void 0 : execution.complete(notebook_dto_1.NotebookDto.fromCellExecuteCompleteDto(data));
        }
        finally {
            this.executions.delete(handle);
        }
    }
    // TODO implement notebook execution (special api for executing full notebook instead of just cells)
    $createNotebookExecution(handle, controllerId, uri) {
        throw new Error('Method not implemented.');
    }
    $beginNotebookExecution(handle) {
        throw new Error('Method not implemented.');
    }
    $completeNotebookExecution(handle) {
        throw new Error('Method not implemented.');
    }
    async $addKernelDetectionTask(handle, notebookType) {
        const registration = this.notebookKernelService.registerNotebookKernelDetectionTask(notebookType);
        this.kernelDetectionTasks.set(handle, [notebookType, registration]);
    }
    $removeKernelDetectionTask(handle) {
        const tuple = this.kernelDetectionTasks.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernelDetectionTasks.delete(handle);
        }
    }
    async $addKernelSourceActionProvider(handle, eventHandle, notebookType) {
        const kernelSourceActionProvider = {
            viewType: notebookType,
            provideKernelSourceActions: async () => {
                const actions = await this.proxy.$provideKernelSourceActions(handle, core_1.CancellationToken.None);
                return actions.map(action => ({
                    label: action.label,
                    command: action.command,
                    description: action.description,
                    detail: action.detail,
                    documentation: action.documentation,
                }));
            }
        };
        if (typeof eventHandle === 'number') {
            const emitter = new core_1.Emitter();
            this.kernelSourceActionProvidersEventRegistrations.set(eventHandle, emitter);
            kernelSourceActionProvider.onDidChangeSourceActions = emitter.event;
        }
        const registration = this.notebookKernelService.registerKernelSourceActionProvider(notebookType, kernelSourceActionProvider);
        this.kernelSourceActionProviders.set(handle, [kernelSourceActionProvider, registration]);
    }
    $removeKernelSourceActionProvider(handle, eventHandle) {
        const tuple = this.kernelSourceActionProviders.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernelSourceActionProviders.delete(handle);
        }
        if (typeof eventHandle === 'number') {
            this.kernelSourceActionProvidersEventRegistrations.delete(eventHandle);
        }
    }
    $emitNotebookKernelSourceActionsChangeEvent(eventHandle) {
    }
    dispose() {
        this.kernels.forEach(kernel => kernel[1].dispose());
    }
}
exports.NotebookKernelsMainImpl = NotebookKernelsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRenderersMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
class NotebookRenderersMainImpl {
    constructor(rpc, container) {
        this.disposables = new core_1.DisposableCollection();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_EXT);
        this.rendererMessagingService = container.get(browser_1.NotebookRendererMessagingService);
        this.rendererMessagingService.onPostMessage(e => {
            this.proxy.$postRendererMessage(e.editorId, e.rendererId, e.message);
        });
    }
    $postMessage(editorId, rendererId, message) {
        return this.rendererMessagingService.receiveMessage(editorId, rendererId, message);
    }
    dispose() {
        this.disposables.dispose();
    }
}
exports.NotebookRenderersMainImpl = NotebookRenderersMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toNotebookWorspaceEdit = exports.NotebooksMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../node_modules/@theia/notebook/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const common_2 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const notebook_model_1 = __webpack_require__(/*! @theia/notebook/lib/browser/view-model/notebook-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-model.js");
const notebook_cell_model_1 = __webpack_require__(/*! @theia/notebook/lib/browser/view-model/notebook-cell-model */ "../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js");
const notebook_cell_status_bar_service_1 = __webpack_require__(/*! @theia/notebook/lib/browser/service/notebook-cell-status-bar-service */ "../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js");
class NotebooksMainImpl {
    constructor(rpc, container, commands) {
        this.disposables = new core_1.DisposableCollection();
        this.notebookSerializer = new Map();
        this.notebookCellStatusBarRegistrations = new Map();
        this.notebookService = container.get(browser_1.NotebookService);
        this.cellStatusBarService = container.get(notebook_cell_status_bar_service_1.NotebookCellStatusBarService);
        const plugins = container.get(hosted_plugin_1.HostedPluginSupport);
        this.proxy = rpc.getProxy(common_2.MAIN_RPC_CONTEXT.NOTEBOOKS_EXT);
        this.notebookService.onWillUseNotebookSerializer(event => plugins.activateByNotebookSerializer(event));
        this.notebookService.markReady();
        commands.registerArgumentProcessor({
            processArgument: arg => {
                if (arg instanceof notebook_model_1.NotebookModel) {
                    return common_1.NotebookModelResource.create(arg.uri);
                }
                else if (arg instanceof notebook_cell_model_1.NotebookCellModel) {
                    return common_1.NotebookCellModelResource.create(arg.uri);
                }
                return arg;
            }
        });
    }
    dispose() {
        this.disposables.dispose();
        for (const disposable of this.notebookSerializer.values()) {
            disposable.dispose();
        }
    }
    $registerNotebookSerializer(handle, viewType, options) {
        const disposables = new core_1.DisposableCollection();
        disposables.push(this.notebookService.registerNotebookSerializer(viewType, {
            options,
            toNotebook: async (data) => {
                const dto = await this.proxy.$dataToNotebook(handle, data, core_1.CancellationToken.None);
                return notebook_dto_1.NotebookDto.fromNotebookDataDto(dto);
            },
            fromNotebook: (data) => this.proxy.$notebookToData(handle, notebook_dto_1.NotebookDto.toNotebookDataDto(data), core_1.CancellationToken.None)
        }));
        this.notebookSerializer.set(handle, disposables);
    }
    $unregisterNotebookSerializer(handle) {
        var _a;
        (_a = this.notebookSerializer.get(handle)) === null || _a === void 0 ? void 0 : _a.dispose();
        this.notebookSerializer.delete(handle);
    }
    $emitCellStatusBarEvent(eventHandle) {
        const emitter = this.notebookCellStatusBarRegistrations.get(eventHandle);
        if (emitter instanceof core_1.Emitter) {
            emitter.fire(undefined);
        }
    }
    async $registerNotebookCellStatusBarItemProvider(handle, eventHandle, viewType) {
        const that = this;
        const provider = {
            async provideCellStatusBarItems(notebookUri, index, token) {
                var _a;
                const result = await that.proxy.$provideNotebookCellStatusBarItems(handle, notebookUri.toComponents(), index, token);
                return {
                    items: (_a = result === null || result === void 0 ? void 0 : result.items) !== null && _a !== void 0 ? _a : [],
                    dispose() {
                        if (result) {
                            that.proxy.$releaseNotebookCellStatusBarItems(result.cacheId);
                        }
                    }
                };
            },
            viewType
        };
        if (typeof eventHandle === 'number') {
            const emitter = new core_1.Emitter();
            this.notebookCellStatusBarRegistrations.set(eventHandle, emitter);
            provider.onDidChangeStatusBarItems = emitter.event;
        }
        const disposable = this.cellStatusBarService.registerCellStatusBarItemProvider(provider);
        this.notebookCellStatusBarRegistrations.set(handle, disposable);
    }
    async $unregisterNotebookCellStatusBarItemProvider(handle, eventHandle) {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const unregisterThing = (statusBarHandle) => {
            var _a;
            const entry = this.notebookCellStatusBarRegistrations.get(statusBarHandle);
            if (entry) {
                (_a = this.notebookCellStatusBarRegistrations.get(statusBarHandle)) === null || _a === void 0 ? void 0 : _a.dispose();
                this.notebookCellStatusBarRegistrations.delete(statusBarHandle);
            }
        };
        unregisterThing(handle);
        if (typeof eventHandle === 'number') {
            unregisterThing(eventHandle);
        }
    }
}
exports.NotebooksMainImpl = NotebooksMainImpl;
function toNotebookWorspaceEdit(dto) {
    return {
        edits: dto.edits.map((edit) => ({
            resource: core_1.URI.fromComponents(edit.resource),
            edit: edit.cellEdit.editType === 1 /* CellEditType.Replace */ ? {
                ...edit.cellEdit,
                cells: edit.cellEdit.cells.map(cell => notebook_dto_1.NotebookDto.fromNotebookCellDataDto(cell))
            } : edit.cellEdit
        }))
    };
}
exports.toNotebookWorspaceEdit = toNotebookWorspaceEdit;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const basic_notification_main_1 = __webpack_require__(/*! ../common/basic-notification-main */ "../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js");
class NotificationMainImpl extends basic_notification_main_1.BasicNotificationMainImpl {
    constructor(rpc, container) {
        super(rpc, container, common_1.MAIN_RPC_CONTEXT.NOTIFICATION_EXT);
    }
}
exports.NotificationMainImpl = NotificationMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginContributionHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const textmate_1 = __webpack_require__(/*! @theia/monaco/lib/browser/textmate */ "../node_modules/@theia/monaco/lib/browser/textmate/index.js");
const menus_contribution_handler_1 = __webpack_require__(/*! ./menus/menus-contribution-handler */ "../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js");
const plugin_view_registry_1 = __webpack_require__(/*! ./view/plugin-view-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ./custom-editors/plugin-custom-editor-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const keybindings_contribution_handler_1 = __webpack_require__(/*! ./keybindings/keybindings-contribution-handler */ "../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js");
const monaco_snippet_suggest_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-snippet-suggest-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-snippet-suggest-provider.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_2 = __webpack_require__(/*! @theia/task/lib/browser */ "../node_modules/@theia/task/lib/browser/index.js");
const browser_3 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const plugin_debug_service_1 = __webpack_require__(/*! ./debug/plugin-debug-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js");
const debug_schema_updater_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-schema-updater */ "../node_modules/@theia/debug/lib/browser/debug-schema-updater.js");
const monaco_theming_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-theming-service */ "../node_modules/@theia/monaco/lib/browser/monaco-theming-service.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const plugin_icon_service_1 = __webpack_require__(/*! ./plugin-icon-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js");
const plugin_icon_theme_service_1 = __webpack_require__(/*! ./plugin-icon-theme-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js");
const common_2 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const terminal_profile_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-profile-service */ "../node_modules/@theia/terminal/lib/browser/terminal-profile-service.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const plugin_terminal_registry_1 = __webpack_require__(/*! ./plugin-terminal-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../node_modules/@theia/core/lib/browser/language-service.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
let PluginContributionHandler = class PluginContributionHandler {
    constructor() {
        this.injections = new Map();
        this.commandHandlers = new Map();
        this.onDidRegisterCommandHandlerEmitter = new event_1.Emitter();
        this.onDidRegisterCommandHandler = this.onDidRegisterCommandHandlerEmitter.event;
    }
    /**
     * Always synchronous in order to simplify handling disconnections.
     * @throws never, loading of each contribution should handle errors
     * in order to avoid preventing loading of other contributions or extensions
     */
    handleContributions(clientId, plugin) {
        const contributions = plugin.contributes;
        if (!contributions) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const logError = (message, ...args) => console.error(`[${clientId}][${plugin.metadata.model.id}]: ${message}`, ...args);
        const logWarning = (message, ...args) => console.warn(`[${clientId}][${plugin.metadata.model.id}]: ${message}`, ...args);
        const pushContribution = (id, contribute) => {
            if (toDispose.disposed) {
                return;
            }
            try {
                toDispose.push(contribute());
            }
            catch (e) {
                logError(`Failed to load '${id}' contribution.`, e);
            }
        };
        const configuration = contributions.configuration;
        if (configuration) {
            for (const config of configuration) {
                pushContribution('configuration', () => this.preferenceSchemaProvider.setSchema(config));
            }
        }
        const configurationDefaults = contributions.configurationDefaults;
        if (configurationDefaults) {
            pushContribution('configurationDefaults', () => this.updateDefaultOverridesSchema(configurationDefaults));
        }
        const languages = contributions.languages;
        if (languages && languages.length) {
            for (const lang of languages) {
                // it is not possible to unregister a language
                monaco.languages.register({
                    id: lang.id,
                    aliases: lang.aliases,
                    extensions: lang.extensions,
                    filenamePatterns: lang.filenamePatterns,
                    filenames: lang.filenames,
                    firstLine: lang.firstLine,
                    mimetypes: lang.mimetypes
                });
                if (lang.icon) {
                    const languageIcon = this.style.toFileIconClass(lang.icon);
                    pushContribution(`language.${lang.id}.icon`, () => languageIcon);
                    pushContribution(`language.${lang.id}.iconRegistration`, () => this.languageService.registerIcon(lang.id, languageIcon.object.iconClass));
                }
                const langConfiguration = lang.configuration;
                if (langConfiguration) {
                    pushContribution(`language.${lang.id}.configuration`, () => monaco.languages.setLanguageConfiguration(lang.id, {
                        wordPattern: this.createRegex(langConfiguration.wordPattern),
                        autoClosingPairs: langConfiguration.autoClosingPairs,
                        brackets: langConfiguration.brackets,
                        comments: langConfiguration.comments,
                        folding: this.convertFolding(langConfiguration.folding),
                        surroundingPairs: langConfiguration.surroundingPairs,
                        indentationRules: this.convertIndentationRules(langConfiguration.indentationRules),
                        onEnterRules: this.convertOnEnterRules(langConfiguration.onEnterRules),
                    }));
                }
            }
        }
        const grammars = contributions.grammars;
        if (grammars && grammars.length) {
            const grammarsWithLanguage = [];
            for (const grammar of grammars) {
                if (grammar.injectTo) {
                    for (const injectScope of grammar.injectTo) {
                        pushContribution(`grammar.injectTo.${injectScope}`, () => {
                            const injections = this.injections.get(injectScope) || [];
                            injections.push(grammar.scope);
                            this.injections.set(injectScope, injections);
                            return disposable_1.Disposable.create(() => {
                                const index = injections.indexOf(grammar.scope);
                                if (index !== -1) {
                                    injections.splice(index, 1);
                                }
                            });
                        });
                    }
                }
                if (grammar.language) {
                    // processing is deferred.
                    grammarsWithLanguage.push(grammar);
                }
                pushContribution(`grammar.textmate.scope.${grammar.scope}`, () => this.grammarsRegistry.registerTextmateGrammarScope(grammar.scope, {
                    async getGrammarDefinition() {
                        return {
                            format: grammar.format,
                            content: grammar.grammar || '',
                            location: grammar.grammarLocation
                        };
                    },
                    getInjections: (scopeName) => this.injections.get(scopeName)
                }));
            }
            // load grammars on next tick to await registration of languages from all plugins in current tick
            // see https://github.com/eclipse-theia/theia/issues/6907#issuecomment-578600243
            setTimeout(() => {
                for (const grammar of grammarsWithLanguage) {
                    const language = grammar.language;
                    pushContribution(`grammar.language.${language}.scope`, () => this.grammarsRegistry.mapLanguageIdToTextmateGrammar(language, grammar.scope));
                    pushContribution(`grammar.language.${language}.configuration`, () => {
                        var _a;
                        return this.grammarsRegistry.registerGrammarConfiguration(language, {
                            embeddedLanguages: this.convertEmbeddedLanguages(grammar.embeddedLanguages, logWarning),
                            tokenTypes: this.convertTokenTypes(grammar.tokenTypes),
                            balancedBracketSelectors: (_a = grammar.balancedBracketScopes) !== null && _a !== void 0 ? _a : ['*'],
                            unbalancedBracketSelectors: grammar.balancedBracketScopes,
                        });
                    });
                }
                // activate grammars only once everything else is loaded.
                // see https://github.com/eclipse-theia/theia-cpp-extensions/issues/100#issuecomment-610643866
                setTimeout(() => {
                    for (const grammar of grammarsWithLanguage) {
                        const language = grammar.language;
                        pushContribution(`grammar.language.${language}.activation`, () => this.monacoTextmateService.activateLanguage(language));
                    }
                });
            });
        }
        pushContribution('commands', () => this.registerCommands(contributions));
        pushContribution('menus', () => this.menusContributionHandler.handle(plugin));
        pushContribution('keybindings', () => this.keybindingsContributionHandler.handle(contributions));
        if (contributions.customEditors) {
            for (const customEditor of contributions.customEditors) {
                pushContribution(`customEditors.${customEditor.viewType}`, () => this.customEditorRegistry.registerCustomEditor(customEditor, plugin));
            }
        }
        if (contributions.viewsContainers) {
            for (const location in contributions.viewsContainers) {
                if (contributions.viewsContainers.hasOwnProperty(location)) {
                    for (const viewContainer of contributions.viewsContainers[location]) {
                        pushContribution(`viewContainers.${viewContainer.id}`, () => this.viewRegistry.registerViewContainer(location, viewContainer));
                    }
                }
            }
        }
        if (contributions.views) {
            // eslint-disable-next-line guard-for-in
            for (const location in contributions.views) {
                for (const view of contributions.views[location]) {
                    pushContribution(`views.${view.id}`, () => this.viewRegistry.registerView(location, view));
                }
            }
        }
        if (contributions.viewsWelcome) {
            for (const [index, viewWelcome] of contributions.viewsWelcome.entries()) {
                pushContribution(`viewsWelcome.${viewWelcome.view}.${index}`, () => this.viewRegistry.registerViewWelcome(viewWelcome));
            }
        }
        if (contributions.snippets) {
            for (const snippet of contributions.snippets) {
                pushContribution(`snippets.${snippet.uri}`, () => this.snippetSuggestProvider.fromURI(snippet.uri, {
                    language: snippet.language,
                    source: snippet.source
                }));
            }
        }
        if (contributions.themes && contributions.themes.length) {
            const pending = {};
            for (const theme of contributions.themes) {
                pushContribution(`themes.${theme.uri}`, () => this.monacoThemingService.register(theme, pending));
            }
        }
        if (contributions.iconThemes && contributions.iconThemes.length) {
            for (const iconTheme of contributions.iconThemes) {
                pushContribution(`iconThemes.${iconTheme.uri}`, () => this.iconThemeService.register(iconTheme, plugin));
            }
        }
        if (contributions.icons && contributions.icons.length) {
            for (const icon of contributions.icons) {
                const defaultIcon = icon.defaults;
                let key;
                if (common_1.IconContribution.isIconDefinition(defaultIcon)) {
                    key = defaultIcon.location;
                }
                else {
                    key = defaultIcon.id;
                }
                pushContribution(`icons.${key}`, () => this.iconService.register(icon, plugin));
            }
        }
        const colors = contributions.colors;
        if (colors) {
            pushContribution('colors', () => this.colors.register(...colors));
        }
        if (contributions.taskDefinitions) {
            for (const taskDefinition of contributions.taskDefinitions) {
                pushContribution(`taskDefinitions.${taskDefinition.taskType}`, () => this.taskDefinitionRegistry.register(taskDefinition));
            }
        }
        if (contributions.problemPatterns) {
            for (const problemPattern of contributions.problemPatterns) {
                pushContribution(`problemPatterns.${problemPattern.name || problemPattern.regexp}`, () => this.problemPatternRegistry.register(problemPattern));
            }
        }
        if (contributions.problemMatchers) {
            for (const problemMatcher of contributions.problemMatchers) {
                pushContribution(`problemMatchers.${problemMatcher.label}`, () => this.problemMatcherRegistry.register(problemMatcher));
            }
        }
        if (contributions.debuggers && contributions.debuggers.length) {
            toDispose.push(disposable_1.Disposable.create(() => this.debugSchema.update()));
            for (const contribution of contributions.debuggers) {
                pushContribution(`debuggers.${contribution.type}`, () => this.debugService.registerDebugger(contribution));
            }
            this.debugSchema.update();
        }
        if (contributions.resourceLabelFormatters) {
            for (const formatter of contributions.resourceLabelFormatters) {
                for (const contribution of this.contributionProvider.getContributions()) {
                    if (contribution instanceof browser_1.DefaultUriLabelProviderContribution) {
                        pushContribution(`resourceLabelFormatters.${formatter.scheme}`, () => contribution.registerFormatter(formatter));
                    }
                }
            }
        }
        const self = this;
        if (contributions.terminalProfiles) {
            for (const profile of contributions.terminalProfiles) {
                pushContribution(`terminalProfiles.${profile.id}`, () => {
                    this.contributedProfileStore.registerTerminalProfile(profile.title, {
                        async start() {
                            const terminalId = await self.pluginTerminalRegistry.start(profile.id);
                            const result = self.terminalService.getById(terminalId);
                            if (!result) {
                                throw new Error(`Error starting terminal from profile ${profile.id}`);
                            }
                            return result;
                        }
                    });
                    return disposable_1.Disposable.create(() => {
                        this.contributedProfileStore.unregisterTerminalProfile(profile.id);
                    });
                });
            }
        }
        if (contributions.notebooks) {
            for (const notebook of contributions.notebooks) {
                pushContribution(`notebook.${notebook.type}`, () => this.notebookTypeRegistry.registerNotebookType(notebook, plugin.metadata.model.displayName));
            }
        }
        if (contributions.notebookRenderer) {
            for (const renderer of contributions.notebookRenderer) {
                pushContribution(`notebookRenderer.${renderer.id}`, () => this.notebookRendererRegistry.registerNotebookRenderer(renderer, common_1.PluginPackage.toPluginUrl(plugin.metadata.model, '')));
            }
        }
        if (contributions.notebookPreload) {
            for (const preload of contributions.notebookPreload) {
                pushContribution(`notebookPreloads.${preload.type}:${preload.entrypoint}`, () => this.notebookRendererRegistry.registerStaticNotebookPreload(preload.type, preload.entrypoint, common_1.PluginPackage.toPluginUrl(plugin.metadata.model, '')));
            }
        }
        return toDispose;
    }
    registerCommands(contribution) {
        if (!contribution.commands) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        for (const { iconUrl, themeIcon, command, category, shortTitle, title, originalTitle, enablement } of contribution.commands) {
            const reference = iconUrl && this.style.toIconClass(iconUrl);
            const icon = themeIcon && themables_1.ThemeIcon.fromString(themeIcon);
            let iconClass;
            if (reference) {
                toDispose.push(reference);
                iconClass = reference.object.iconClass;
            }
            else if (icon) {
                iconClass = themables_1.ThemeIcon.asClassName(icon);
            }
            toDispose.push(this.registerCommand({ id: command, category, shortTitle, label: title, originalLabel: originalTitle, iconClass }, enablement));
        }
        return toDispose;
    }
    registerCommand(command, enablement) {
        if (this.hasCommand(command.id)) {
            console.warn(`command '${command.id}' already registered`);
            return disposable_1.Disposable.NULL;
        }
        const commandHandler = {
            execute: async (...args) => {
                const handler = this.commandHandlers.get(command.id);
                if (!handler) {
                    throw new Error(`command '${command.id}' not found`);
                }
                return handler(...args);
            },
            // Always enabled - a command can be executed programmatically or via the commands palette.
            isEnabled: () => {
                if (enablement) {
                    return this.contextKeyService.match(enablement);
                }
                return true;
            },
            // Visibility rules are defined via the `menus` contribution point.
            isVisible() { return true; }
        };
        if (enablement) {
            const contextKeys = this.contextKeyService.parseKeys(enablement);
            if (contextKeys && contextKeys.size > 0) {
                commandHandler.onDidChangeEnabled = (listener) => this.contextKeyService.onDidChange(e => {
                    if (e.affects(contextKeys)) {
                        listener();
                    }
                });
            }
        }
        const toDispose = new disposable_1.DisposableCollection();
        if (this.commands.getCommand(command.id)) {
            // overriding built-in command, i.e. `type` by the VSCodeVim extension
            toDispose.push(this.commands.registerHandler(command.id, commandHandler));
        }
        else {
            toDispose.push(this.commands.registerCommand(command, commandHandler));
        }
        this.commandHandlers.set(command.id, undefined);
        toDispose.push(disposable_1.Disposable.create(() => this.commandHandlers.delete(command.id)));
        return toDispose;
    }
    registerCommandHandler(id, execute) {
        if (this.hasCommandHandler(id)) {
            console.warn(`command handler '${id}' already registered`);
            return disposable_1.Disposable.NULL;
        }
        this.commandHandlers.set(id, execute);
        this.onDidRegisterCommandHandlerEmitter.fire(id);
        return disposable_1.Disposable.create(() => this.commandHandlers.set(id, undefined));
    }
    hasCommand(id) {
        return this.commandHandlers.has(id);
    }
    hasCommandHandler(id) {
        return !!this.commandHandlers.get(id);
    }
    updateDefaultOverridesSchema(configurationDefaults) {
        const defaultOverrides = {
            id: preferences_1.DefaultOverridesPreferenceSchemaId,
            title: 'Default Configuration Overrides',
            properties: {}
        };
        // eslint-disable-next-line guard-for-in
        for (const key in configurationDefaults) {
            const defaultValue = configurationDefaults[key];
            if (this.preferenceOverrideService.testOverrideValue(key, defaultValue)) {
                // language specific override
                defaultOverrides.properties[key] = {
                    type: 'object',
                    default: defaultValue,
                    description: `Configure editor settings to be overridden for ${key} language.`
                };
            }
            else {
                // regular configuration override
                defaultOverrides.properties[key] = {
                    default: defaultValue,
                    description: `Configure default setting for ${key}.`
                };
            }
        }
        if (Object.keys(defaultOverrides.properties).length) {
            return this.preferenceSchemaProvider.setSchema(defaultOverrides);
        }
        return disposable_1.Disposable.NULL;
    }
    createRegex(value) {
        if (typeof value === 'string') {
            return new RegExp(value, '');
        }
        if (typeof value == 'undefined') {
            return undefined;
        }
        return new RegExp(value.pattern, value.flags);
    }
    convertIndentationRules(rules) {
        if (!rules) {
            return undefined;
        }
        return {
            decreaseIndentPattern: this.createRegex(rules.decreaseIndentPattern),
            increaseIndentPattern: this.createRegex(rules.increaseIndentPattern),
            indentNextLinePattern: this.createRegex(rules.indentNextLinePattern),
            unIndentedLinePattern: this.createRegex(rules.unIndentedLinePattern)
        };
    }
    convertFolding(folding) {
        if (!folding) {
            return undefined;
        }
        const result = {
            offSide: folding.offSide
        };
        if (folding.markers) {
            result.markers = {
                end: this.createRegex(folding.markers.end),
                start: this.createRegex(folding.markers.start)
            };
        }
        return result;
    }
    convertTokenTypes(tokenTypes) {
        if (typeof tokenTypes === 'undefined' || tokenTypes === null) {
            return undefined;
        }
        const result = Object.create(null);
        const scopes = Object.keys(tokenTypes);
        const len = scopes.length;
        for (let i = 0; i < len; i++) {
            const scope = scopes[i];
            const tokenType = tokenTypes[scope];
            switch (tokenType) {
                case 'string':
                    result[scope] = 2 /* StandardTokenType.String */;
                    break;
                case 'other':
                    result[scope] = 0 /* StandardTokenType.Other */;
                    break;
                case 'comment':
                    result[scope] = 1 /* StandardTokenType.Comment */;
                    break;
            }
        }
        return result;
    }
    convertEmbeddedLanguages(languages, logWarning) {
        if (typeof languages === 'undefined' || languages === null) {
            return undefined;
        }
        const result = Object.create(null);
        const scopes = Object.keys(languages);
        const len = scopes.length;
        for (let i = 0; i < len; i++) {
            const scope = scopes[i];
            const langId = languages[scope];
            result[scope] = (0, textmate_1.getEncodedLanguageId)(langId);
            if (!result[scope]) {
                logWarning(`Language for '${scope}' not found.`);
            }
        }
        return result;
    }
    convertOnEnterRules(onEnterRules) {
        if (!onEnterRules) {
            return undefined;
        }
        const result = [];
        for (const onEnterRule of onEnterRules) {
            const rule = {
                beforeText: this.createRegex(onEnterRule.beforeText),
                afterText: this.createRegex(onEnterRule.afterText),
                previousLineText: this.createRegex(onEnterRule.previousLineText),
                action: this.createEnterAction(onEnterRule.action),
            };
            result.push(rule);
        }
        return result;
    }
    createEnterAction(action) {
        let indentAction;
        switch (action.indent) {
            case 'indent':
                indentAction = monaco.languages.IndentAction.Indent;
                break;
            case 'indentOutdent':
                indentAction = monaco.languages.IndentAction.IndentOutdent;
                break;
            case 'outdent':
                indentAction = monaco.languages.IndentAction.Outdent;
                break;
            default:
                indentAction = monaco.languages.IndentAction.None;
                break;
        }
        return { indentAction, appendText: action.appendText, removeText: action.removeText };
    }
};
exports.PluginContributionHandler = PluginContributionHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(textmate_1.TextmateRegistry),
    tslib_1.__metadata("design:type", textmate_1.TextmateRegistry)
], PluginContributionHandler.prototype, "grammarsRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_view_registry_1.PluginViewRegistry),
    tslib_1.__metadata("design:type", plugin_view_registry_1.PluginViewRegistry)
], PluginContributionHandler.prototype, "viewRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_custom_editor_registry_1.PluginCustomEditorRegistry),
    tslib_1.__metadata("design:type", plugin_custom_editor_registry_1.PluginCustomEditorRegistry)
], PluginContributionHandler.prototype, "customEditorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menus_contribution_handler_1.MenusContributionPointHandler),
    tslib_1.__metadata("design:type", menus_contribution_handler_1.MenusContributionPointHandler)
], PluginContributionHandler.prototype, "menusContributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceSchemaProvider),
    tslib_1.__metadata("design:type", browser_1.PreferenceSchemaProvider)
], PluginContributionHandler.prototype, "preferenceSchemaProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceLanguageOverrideService),
    tslib_1.__metadata("design:type", preferences_1.PreferenceLanguageOverrideService)
], PluginContributionHandler.prototype, "preferenceOverrideService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(textmate_1.MonacoTextmateService),
    tslib_1.__metadata("design:type", textmate_1.MonacoTextmateService)
], PluginContributionHandler.prototype, "monacoTextmateService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(keybindings_contribution_handler_1.KeybindingsContributionPointHandler),
    tslib_1.__metadata("design:type", keybindings_contribution_handler_1.KeybindingsContributionPointHandler)
], PluginContributionHandler.prototype, "keybindingsContributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_snippet_suggest_provider_1.MonacoSnippetSuggestProvider),
    tslib_1.__metadata("design:type", monaco_snippet_suggest_provider_1.MonacoSnippetSuggestProvider)
], PluginContributionHandler.prototype, "snippetSuggestProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginContributionHandler.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], PluginContributionHandler.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginContributionHandler.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", browser_2.TaskDefinitionRegistry)
], PluginContributionHandler.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ProblemMatcherRegistry),
    tslib_1.__metadata("design:type", browser_2.ProblemMatcherRegistry)
], PluginContributionHandler.prototype, "problemMatcherRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ProblemPatternRegistry),
    tslib_1.__metadata("design:type", browser_2.ProblemPatternRegistry)
], PluginContributionHandler.prototype, "problemPatternRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_debug_service_1.PluginDebugService),
    tslib_1.__metadata("design:type", plugin_debug_service_1.PluginDebugService)
], PluginContributionHandler.prototype, "debugService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_schema_updater_1.DebugSchemaUpdater),
    tslib_1.__metadata("design:type", debug_schema_updater_1.DebugSchemaUpdater)
], PluginContributionHandler.prototype, "debugSchema", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_theming_service_1.MonacoThemingService),
    tslib_1.__metadata("design:type", monaco_theming_service_1.MonacoThemingService)
], PluginContributionHandler.prototype, "monacoThemingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], PluginContributionHandler.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_icon_service_1.PluginIconService),
    tslib_1.__metadata("design:type", plugin_icon_service_1.PluginIconService)
], PluginContributionHandler.prototype, "iconService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_icon_theme_service_1.PluginIconThemeService),
    tslib_1.__metadata("design:type", plugin_icon_theme_service_1.PluginIconThemeService)
], PluginContributionHandler.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_terminal_registry_1.PluginTerminalRegistry),
    tslib_1.__metadata("design:type", plugin_terminal_registry_1.PluginTerminalRegistry)
], PluginContributionHandler.prototype, "pluginTerminalRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_profile_service_1.ContributedTerminalProfileStore),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contributedProfileStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", browser_3.NotebookTypeRegistry)
], PluginContributionHandler.prototype, "notebookTypeRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.NotebookRendererRegistry),
    tslib_1.__metadata("design:type", browser_3.NotebookRendererRegistry)
], PluginContributionHandler.prototype, "notebookRendererRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_2.ContributionProvider),
    (0, inversify_1.named)(browser_1.LabelProviderContribution),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contributionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contextKeyService", void 0);
exports.PluginContributionHandler = PluginContributionHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginContributionHandler);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIconService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const monaco_icon_registry_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-icon-registry */ "../node_modules/@theia/monaco/lib/browser/monaco-icon-registry.js");
const path = __webpack_require__(/*! path */ "../node_modules/path-browserify/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
let PluginIconService = class PluginIconService {
    constructor() {
        this.toDispose = new disposable_1.DisposableCollection();
        this.styleSheet = '';
    }
    register(contribution, plugin) {
        const defaultIcon = contribution.defaults;
        if (plugin_protocol_1.IconContribution.isIconDefinition(defaultIcon)) {
            this.registerFontIcon(contribution, defaultIcon);
        }
        else {
            this.registerRegularIcon(contribution, defaultIcon.id);
        }
        return disposable_1.Disposable.NULL;
    }
    dispose() {
        this.toDispose.dispose();
    }
    registerFontIcon(contribution, defaultIcon) {
        const location = this.toPluginUrl(contribution.extensionId, getIconRelativePath(vscode_uri_1.URI.parse(defaultIcon.location).path));
        const format = getFileExtension(location.path);
        const fontId = getFontId(contribution.extensionId, location.path);
        const definition = this.iconRegistry.registerIconFont(fontId, { src: [{ location: location, format }] });
        this.iconRegistry.registerIcon(contribution.id, {
            fontCharacter: defaultIcon.fontCharacter,
            font: {
                id: fontId,
                definition
            }
        }, contribution.description);
    }
    registerRegularIcon(contribution, defaultIconId) {
        this.iconRegistry.registerIcon(contribution.id, { id: defaultIconId }, contribution.description);
    }
    toPluginUrl(id, relativePath) {
        return vscode_uri_1.URI.from(new browser_1.Endpoint({
            path: `hostedPlugin/${this.formatExtensionId(id)}/${encodeURIComponent(relativePath)}`
        }).getRestUrl().toComponents());
    }
    formatExtensionId(id) {
        return id.replace(/\W/g, '_');
    }
};
exports.PluginIconService = PluginIconService;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_icon_registry_1.MonacoIconRegistry),
    tslib_1.__metadata("design:type", monaco_icon_registry_1.MonacoIconRegistry)
], PluginIconService.prototype, "iconRegistry", void 0);
exports.PluginIconService = PluginIconService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconService);
function getIconRelativePath(iconPath) {
    const index = iconPath.indexOf('extension');
    return index === -1 ? '' : iconPath.substring(index + 'extension'.length + 1);
}
function getFontId(extensionId, fontPath) {
    return path.join(extensionId, fontPath);
}
function getFileExtension(filePath) {
    const index = filePath.lastIndexOf('.');
    return index === -1 ? '' : filePath.substring(index + 1);
}


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code is copied and modified from:
// https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/workbench/services/themes/browser/fileIconThemeData.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIconThemeService = exports.PluginIconTheme = exports.PluginIconThemeDefinition = exports.PluginIconThemeFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const jsoncparser = __webpack_require__(/*! jsonc-parser */ "../node_modules/jsonc-parser/lib/esm/main.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "../node_modules/@theia/core/lib/browser/icon-theme-service.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../node_modules/@theia/core/lib/browser/label-provider.js");
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../node_modules/@theia/filesystem/lib/browser/index.js");
const navigator_tree_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-tree */ "../node_modules/@theia/navigator/lib/browser/navigator-tree.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../node_modules/@theia/core/lib/browser/endpoint.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../node_modules/@theia/filesystem/lib/common/files.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const language_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/languages/language */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/languages/language.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../node_modules/@theia/core/lib/browser/language-service.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
exports.PluginIconThemeFactory = Symbol('PluginIconThemeFactory');
let PluginIconThemeDefinition = class PluginIconThemeDefinition {
};
exports.PluginIconThemeDefinition = PluginIconThemeDefinition;
exports.PluginIconThemeDefinition = PluginIconThemeDefinition = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconThemeDefinition);
class PluginLanguageIconInfo {
    constructor() {
        this.hasSpecificFileIcons = false;
        this.coveredLanguages = {};
    }
}
;
let PluginIconTheme = class PluginIconTheme extends PluginIconThemeDefinition {
    constructor() {
        super(...arguments);
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDeactivate = new disposable_1.DisposableCollection();
        this.toUnload = new disposable_1.DisposableCollection();
        this.toDisposeStyleElement = new disposable_1.DisposableCollection();
        this.toDispose = new disposable_1.DisposableCollection(this.toDeactivate, this.toDisposeStyleElement, this.toUnload, this.onDidChangeEmitter);
        this.icons = new Set();
        this.reload = debounce(() => {
            this.toUnload.dispose();
            this.doActivate();
        }, 50);
        this.fileIcon = plugin_shared_style_1.PLUGIN_FILE_ICON_CLASS;
        this.folderIcon = 'theia-plugin-folder-icon';
        this.folderExpandedIcon = 'theia-plugin-folder-expanded-icon';
        this.rootFolderIcon = 'theia-plugin-root-folder-icon';
        this.rootFolderExpandedIcon = 'theia-plugin-root-folder-expanded-icon';
    }
    init() {
        Object.assign(this, this.definition);
        this.packageRootUri = new uri_1.default(this.packageUri);
        this.locationUri = new uri_1.default(this.uri).parent;
    }
    dispose() {
        this.toDispose.dispose();
    }
    fireDidChange() {
        this.onDidChangeEmitter.fire({ affects: () => true });
    }
    activate() {
        if (!this.toDeactivate.disposed) {
            return this.toDeactivate;
        }
        this.toDeactivate.push(disposable_1.Disposable.create(() => this.fireDidChange()));
        this.doActivate();
        return this.toDeactivate;
    }
    async doActivate() {
        await this.load();
        this.updateStyleElement();
    }
    updateStyleElement() {
        this.toDisposeStyleElement.dispose();
        if (this.toDeactivate.disposed || !this.styleSheetContent) {
            return;
        }
        const styleElement = document.createElement('style');
        styleElement.type = 'text/css';
        styleElement.className = 'theia-icon-theme';
        styleElement.innerText = this.styleSheetContent;
        document.head.appendChild(styleElement);
        const toRemoveStyleElement = disposable_1.Disposable.create(() => styleElement.remove());
        this.toDisposeStyleElement.push(toRemoveStyleElement);
        this.toDeactivate.push(toRemoveStyleElement);
        this.fireDidChange();
    }
    /**
     * This should be aligned with
     * https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/workbench/services/themes/browser/fileIconThemeData.ts#L201
     */
    async load() {
        if (this.styleSheetContent !== undefined) {
            return;
        }
        this.styleSheetContent = '';
        this.toUnload.push(disposable_1.Disposable.create(() => {
            this.styleSheetContent = undefined;
            this.hasFileIcons = undefined;
            this.hasFolderIcons = undefined;
            this.hidesExplorerArrows = undefined;
            this.icons.clear();
        }));
        const uri = new uri_1.default(this.uri);
        const result = await this.fileService.read(uri);
        const content = result.value;
        const json = jsoncparser.parse(content, undefined, { disallowComments: false });
        this.hidesExplorerArrows = !!json.hidesExplorerArrows;
        const toUnwatch = this.fileService.watch(uri);
        if (this.toUnload.disposed) {
            toUnwatch.dispose();
        }
        else {
            this.toUnload.push(toUnwatch);
            this.toUnload.push(this.fileService.onDidFilesChange(e => {
                if (e.contains(uri, 1 /* FileChangeType.ADDED */) || e.contains(uri, 0 /* FileChangeType.UPDATED */)) {
                    this.reload();
                }
            }));
        }
        const iconDefinitions = json.iconDefinitions;
        if (!iconDefinitions) {
            return;
        }
        const definitionSelectors = new Map();
        const acceptSelector = (themeType, definitionId, ...icons) => {
            if (!iconDefinitions[definitionId]) {
                return;
            }
            let selector = '';
            for (const icon of icons) {
                if (icon) {
                    selector += '.' + icon;
                    this.icons.add(icon);
                }
            }
            if (!selector) {
                return;
            }
            const selectors = definitionSelectors.get(definitionId) || [];
            if (themeType !== 'dark') {
                selector = '.theia-' + themeType + ' ' + selector;
            }
            selectors.push(selector + '::before');
            definitionSelectors.set(definitionId, selectors);
        };
        let iconInfo = this.collectSelectors(json, acceptSelector.bind(undefined, 'dark'));
        if (json.light) {
            iconInfo = this.collectSelectors(json.light, acceptSelector.bind(undefined, 'light'));
        }
        if (json.highContrast) {
            iconInfo = this.collectSelectors(json.highContrast, acceptSelector.bind(undefined, 'hc'));
        }
        const showLanguageModeIcons = this.showLanguageModeIcons === true
            || json.showLanguageModeIcons === true
            || (iconInfo.hasSpecificFileIcons && json.showLanguageModeIcons !== false);
        const fonts = json.fonts;
        if (Array.isArray(fonts)) {
            for (const font of fonts) {
                if (font) {
                    let src = '';
                    if (Array.isArray(font.src)) {
                        for (const srcLocation of font.src) {
                            if (srcLocation && srcLocation.path) {
                                const cssUrl = this.toCSSUrl(srcLocation.path);
                                if (cssUrl) {
                                    if (src) {
                                        src += ', ';
                                    }
                                    src += `${cssUrl} format('${srcLocation.format}')`;
                                }
                            }
                        }
                    }
                    if (src) {
                        this.styleSheetContent += `@font-face {
    src: ${src};
    font-family: '${font.id}';
    font-weight: ${font.weight};
    font-style: ${font.style};
}
`;
                    }
                }
            }
            const firstFont = fonts[0];
            if (firstFont && firstFont.id) {
                this.styleSheetContent += `.${this.fileIcon}::before, .${this.folderIcon}::before, .${this.rootFolderIcon}::before {
    font-family: '${firstFont.id}';
    font-size: ${firstFont.size || '150%'};
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    vertical-align: top;
}
`;
            }
        }
        for (const definitionId of definitionSelectors.keys()) {
            const iconDefinition = iconDefinitions[definitionId];
            const selectors = definitionSelectors.get(definitionId);
            if (selectors && iconDefinition) {
                const cssUrl = this.toCSSUrl(iconDefinition.iconPath);
                if (cssUrl) {
                    this.styleSheetContent += `${selectors.join(', ')} {
    content: ' ';
    background-image: ${cssUrl};
    background-size: ${plugin_shared_style_1.DEFAULT_ICON_SIZE}px;
    background-position: left center;
    background-repeat: no-repeat;
}
`;
                }
                if (iconDefinition.fontCharacter || iconDefinition.fontColor) {
                    let body = '';
                    if (iconDefinition.fontColor) {
                        body += ` color: ${iconDefinition.fontColor};`;
                    }
                    if (iconDefinition.fontCharacter) {
                        body += ` content: '${iconDefinition.fontCharacter}';`;
                    }
                    if (iconDefinition.fontSize) {
                        body += ` font-size: ${iconDefinition.fontSize};`;
                    }
                    if (iconDefinition.fontId) {
                        body += ` font-family: ${iconDefinition.fontId};`;
                    }
                    this.styleSheetContent += `${selectors.join(', ')} {${body} }\n`;
                }
            }
        }
        if (showLanguageModeIcons) {
            for (const language of this.languageService.languages) {
                // only show language icons if there are no more specific icons in the style document
                if (!iconInfo.coveredLanguages[language.id]) {
                    const icon = this.languageService.getIcon(language.id);
                    if (icon) {
                        this.icons.add(this.fileIcon);
                        this.icons.add(this.languageIcon(language.id));
                        this.icons.add(icon);
                    }
                }
            }
        }
    }
    toCSSUrl(iconPath) {
        if (!iconPath) {
            return undefined;
        }
        const iconUri = this.locationUri.resolve(iconPath);
        const relativePath = this.packageRootUri.path.relative(iconUri.path.normalize());
        return relativePath && `url('${new endpoint_1.Endpoint({
            path: `hostedPlugin/${this.pluginId}/${encodeURIComponent(relativePath.normalize().toString())}`
        }).getRestUrl().toString()}')`;
    }
    escapeCSS(value) {
        value = value.replace(/[^\-a-zA-Z0-9]/g, '-');
        if (value.charAt(0).match(/[0-9\-]/)) {
            value = '-' + value;
        }
        return value;
    }
    folderNameIcon(folderName) {
        return 'theia-plugin-' + this.escapeCSS(folderName.toLowerCase()) + '-folder-name-icon';
    }
    expandedFolderNameIcon(folderName) {
        return 'theia-plugin-' + this.escapeCSS(folderName.toLowerCase()) + '-expanded-folder-name-icon';
    }
    fileNameIcon(fileName) {
        fileName = fileName.toLowerCase();
        const extIndex = fileName.indexOf('.');
        const icons = extIndex !== -1 ? this.fileExtensionIcon(fileName.substring(extIndex + 1)) : [];
        icons.unshift('theia-plugin-' + this.escapeCSS(fileName) + '-file-name-icon');
        return icons;
    }
    fileExtensionIcon(fileExtension) {
        fileExtension = fileExtension.toString();
        const icons = [];
        const segments = fileExtension.split('.');
        if (segments.length) {
            if (segments.length) {
                for (let i = 0; i < segments.length; i++) {
                    icons.push('theia-plugin-' + this.escapeCSS(segments.slice(i).join('.')) + '-ext-file-icon');
                }
                icons.push('theia-plugin-ext-file-icon'); // extra segment to increase file-ext score
            }
        }
        return icons;
    }
    languageIcon(languageId) {
        return 'theia-plugin-' + this.escapeCSS(languageId) + '-lang-file-icon';
    }
    collectSelectors(associations, accept) {
        const iconInfo = new PluginLanguageIconInfo();
        if (associations.folder) {
            accept(associations.folder, this.folderIcon);
            if (associations.folderExpanded === undefined) {
                // Use the same icon for expanded state (issue #12727). Check for
                // undefined folderExpanded property to allow for
                // "folderExpanded": null in case a developer really wants that
                accept(associations.folder, this.folderExpandedIcon);
            }
            this.hasFolderIcons = true;
        }
        if (associations.folderExpanded) {
            accept(associations.folderExpanded, this.folderExpandedIcon);
            this.hasFolderIcons = true;
        }
        const rootFolder = associations.rootFolder || associations.folder;
        if (rootFolder) {
            accept(rootFolder, this.rootFolderIcon);
            this.hasFolderIcons = true;
        }
        const rootFolderExpanded = associations.rootFolderExpanded || associations.folderExpanded;
        if (rootFolderExpanded) {
            accept(rootFolderExpanded, this.rootFolderExpandedIcon);
            this.hasFolderIcons = true;
        }
        if (associations.file) {
            accept(associations.file, this.fileIcon);
            this.hasFileIcons = true;
        }
        const folderNames = associations.folderNames;
        if (folderNames) {
            // eslint-disable-next-line guard-for-in
            for (const folderName in folderNames) {
                accept(folderNames[folderName], this.folderNameIcon(folderName), this.folderIcon);
                this.hasFolderIcons = true;
            }
        }
        const folderNamesExpanded = associations.folderNamesExpanded;
        if (folderNamesExpanded) {
            // eslint-disable-next-line guard-for-in
            for (const folderName in folderNamesExpanded) {
                accept(folderNamesExpanded[folderName], this.expandedFolderNameIcon(folderName), this.folderExpandedIcon);
                this.hasFolderIcons = true;
            }
        }
        const languageIds = associations.languageIds;
        if (languageIds) {
            if (!languageIds.jsonc && languageIds.json) {
                languageIds.jsonc = languageIds.json;
            }
            // eslint-disable-next-line guard-for-in
            for (const languageId in languageIds) {
                accept(languageIds[languageId], this.languageIcon(languageId), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
                iconInfo.coveredLanguages[languageId] = true;
            }
        }
        const fileExtensions = associations.fileExtensions;
        if (fileExtensions) {
            // eslint-disable-next-line guard-for-in
            for (const fileExtension in fileExtensions) {
                accept(fileExtensions[fileExtension], ...this.fileExtensionIcon(fileExtension), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
            }
        }
        const fileNames = associations.fileNames;
        if (fileNames) {
            // eslint-disable-next-line guard-for-in
            for (const fileName in fileNames) {
                accept(fileNames[fileName], ...this.fileNameIcon(fileName), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
            }
        }
        return iconInfo;
    }
    /**
     * This should be aligned with
     * https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/editor/common/services/getIconClasses.ts#L5
     */
    getIcon(element) {
        let icon = '';
        for (const className of this.getClassNames(element)) {
            if (this.icons.has(className)) {
                if (icon) {
                    icon += ' ';
                }
                icon += className;
            }
        }
        return icon;
    }
    getClassNames(element) {
        if (navigator_tree_1.WorkspaceRootNode.is(element)) {
            const name = this.labelProvider.getName(element);
            if (element.expanded) {
                return [this.rootFolderExpandedIcon, this.expandedFolderNameIcon(name)];
            }
            return [this.rootFolderIcon, this.folderNameIcon(name)];
        }
        if (browser_1.DirNode.is(element)) {
            if (element.expanded) {
                const name = this.labelProvider.getName(element);
                return [this.folderExpandedIcon, this.expandedFolderNameIcon(name)];
            }
            return this.getFolderClassNames(element);
        }
        if (browser_1.FileStatNode.is(element)) {
            return this.getFileClassNames(element, element.fileStat.resource.toString());
        }
        if (files_1.FileStat.is(element)) {
            if (element.isDirectory) {
                return this.getFolderClassNames(element);
            }
            return this.getFileClassNames(element, element.resource.toString());
        }
        if (label_provider_1.URIIconReference.is(element)) {
            if (element.id === 'folder') {
                return this.getFolderClassNames(element);
            }
            return this.getFileClassNames(element, element.uri && element.uri.toString());
        }
        return this.getFileClassNames(element, element.toString());
    }
    getFolderClassNames(element) {
        const name = this.labelProvider.getName(element);
        return [this.folderIcon, this.folderNameIcon(name)];
    }
    getFileClassNames(element, uri) {
        var _a;
        const name = this.labelProvider.getName(element);
        const classNames = this.fileNameIcon(name);
        if (uri) {
            const parsedURI = new uri_1.default(uri);
            const isRoot = (_a = this.workspaceService.getWorkspaceRootUri(new uri_1.default(uri))) === null || _a === void 0 ? void 0 : _a.isEqual(parsedURI);
            if (isRoot) {
                classNames.unshift(this.rootFolderIcon);
            }
            else {
                classNames.unshift(this.fileIcon);
            }
            const language = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService).createByFilepathOrFirstLine(parsedURI['codeUri']);
            classNames.push(this.languageIcon(language.languageId));
            const defaultLanguageIcon = this.languageService.getIcon(language.languageId);
            if (defaultLanguageIcon) {
                classNames.push(defaultLanguageIcon);
            }
        }
        return classNames;
    }
};
exports.PluginIconTheme = PluginIconTheme;
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], PluginIconTheme.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], PluginIconTheme.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginIconThemeDefinition),
    tslib_1.__metadata("design:type", PluginIconThemeDefinition)
], PluginIconTheme.prototype, "definition", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], PluginIconTheme.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], PluginIconTheme.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginIconTheme.prototype, "init", null);
exports.PluginIconTheme = PluginIconTheme = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconTheme);
let PluginIconThemeService = class PluginIconThemeService {
    constructor() {
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    fireDidChange() {
        this.onDidChangeEmitter.fire({ affects: () => true });
    }
    register(contribution, plugin) {
        const pluginId = (0, plugin_protocol_1.getPluginId)(plugin.metadata.model);
        const packageUri = plugin.metadata.model.packageUri;
        const iconTheme = this.iconThemeFactory({
            id: contribution.id,
            label: contribution.label || new uri_1.default(contribution.uri).path.base,
            description: contribution.description,
            uri: contribution.uri,
            uiTheme: contribution.uiTheme,
            pluginId,
            packageUri
        });
        return new disposable_1.DisposableCollection(iconTheme, iconTheme.onDidChange(() => this.fireDidChange()), this.iconThemeService.register(iconTheme));
    }
    canHandle(element) {
        const current = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (current instanceof PluginIconTheme && ((element instanceof uri_1.default && element.scheme === 'file') || label_provider_1.URIIconReference.is(element) || files_1.FileStat.is(element) || browser_1.FileStatNode.is(element))) {
            return Number.MAX_SAFE_INTEGER;
        }
        return 0;
    }
    getIcon(element) {
        const current = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (current instanceof PluginIconTheme) {
            return current.getIcon(element);
        }
        return undefined;
    }
};
exports.PluginIconThemeService = PluginIconThemeService;
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], PluginIconThemeService.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.PluginIconThemeFactory),
    tslib_1.__metadata("design:type", Function)
], PluginIconThemeService.prototype, "iconThemeFactory", void 0);
exports.PluginIconThemeService = PluginIconThemeService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconThemeService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginSharedStyle_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginSharedStyle = exports.DEFAULT_ICON_SIZE = exports.PLUGIN_FILE_ICON_CLASS = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
const reference_1 = __webpack_require__(/*! @theia/core/lib/common/reference */ "../node_modules/@theia/core/lib/common/reference.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../node_modules/@theia/core/lib/browser/endpoint.js");
exports.PLUGIN_FILE_ICON_CLASS = 'theia-plugin-file-icon';
exports.DEFAULT_ICON_SIZE = 16;
let PluginSharedStyle = PluginSharedStyle_1 = class PluginSharedStyle {
    constructor() {
        this.rules = [];
        this.toUpdate = new disposable_1.DisposableCollection();
        this.icons = new reference_1.SyncReferenceCollection(key => this.createPluginIcon(key));
        this.iconSequence = 0;
    }
    init() {
        this.update();
        this.themeService.onDidColorThemeChange(() => this.update());
    }
    update() {
        this.toUpdate.dispose();
        const style = this.style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        document.getElementsByTagName('head')[0].appendChild(style);
        this.toUpdate.push(disposable_1.Disposable.create(() => document.getElementsByTagName('head')[0].removeChild(style)));
        for (const rule of this.rules) {
            this.doInsertRule(rule);
        }
    }
    insertRule(selector, body) {
        const rule = { selector, body };
        this.rules.push(rule);
        this.doInsertRule(rule);
        return disposable_1.Disposable.create(() => {
            const index = this.rules.indexOf(rule);
            if (index !== -1) {
                this.rules.splice(index, 1);
                this.deleteRule(selector);
            }
        });
    }
    doInsertRule({ selector, body }) {
        const sheet = this.style.sheet;
        const cssBody = body(this.themeService.getCurrentTheme());
        sheet.insertRule(selector + ' {\n' + cssBody + '\n}', 0);
    }
    deleteRule(selector) {
        const sheet = this.style.sheet;
        const rules = sheet.rules || sheet.cssRules || [];
        for (let i = rules.length - 1; i >= 0; i--) {
            const rule = rules[i];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (rule.selectorText.indexOf(selector) !== -1) {
                sheet.deleteRule(i);
            }
        }
    }
    toIconClass(url, { size } = { size: exports.DEFAULT_ICON_SIZE }) {
        return this.icons.acquire({ url, size });
    }
    toFileIconClass(url) {
        return this.icons.acquire({ url, type: 'file' });
    }
    createPluginIcon(key) {
        var _a, _b;
        const iconUrl = key.url;
        const size = (_a = key.size) !== null && _a !== void 0 ? _a : exports.DEFAULT_ICON_SIZE;
        const type = (_b = key.type) !== null && _b !== void 0 ? _b : 'icon';
        const darkIconUrl = PluginSharedStyle_1.toExternalIconUrl(`${typeof iconUrl === 'object' ? iconUrl.dark : iconUrl}`);
        const lightIconUrl = PluginSharedStyle_1.toExternalIconUrl(`${typeof iconUrl === 'object' ? iconUrl.light : iconUrl}`);
        const toDispose = new disposable_1.DisposableCollection();
        let iconClass = 'plugin-icon-' + this.iconSequence++;
        if (type === 'icon') {
            toDispose.push(this.insertRule('.' + iconClass + '::before', theme => `
                    content: "";
                    background-position: 2px;
                    display: block;
                    width: ${size}px;
                    height: ${size}px;
                    background: center no-repeat url("${theme.type === 'light' ? lightIconUrl : darkIconUrl}");
                    background-size: ${size}px;
                `));
        }
        else {
            toDispose.push(this.insertRule('.' + iconClass + '::before', theme => `
                    content: "";
                    background-image: url("${theme.type === 'light' ? lightIconUrl : darkIconUrl}");
                    background-size: ${exports.DEFAULT_ICON_SIZE}px;
                    background-position: left center;
                    background-repeat: no-repeat;
                `));
            iconClass += ' ' + exports.PLUGIN_FILE_ICON_CLASS;
        }
        return { iconClass, dispose: () => toDispose.dispose() };
    }
    static toExternalIconUrl(iconUrl) {
        if (iconUrl.startsWith('hostedPlugin/')) {
            return new endpoint_1.Endpoint({ path: iconUrl }).getRestUrl().toString();
        }
        return iconUrl;
    }
};
exports.PluginSharedStyle = PluginSharedStyle;
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], PluginSharedStyle.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginSharedStyle.prototype, "init", null);
exports.PluginSharedStyle = PluginSharedStyle = PluginSharedStyle_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginSharedStyle);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageMainImpl = void 0;
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../node_modules/@theia/workspace/lib/browser/workspace-service.js");
class StorageMainImpl {
    constructor(container) {
        this.pluginServer = container.get(plugin_protocol_1.PluginServer);
        this.workspaceService = container.get(workspace_service_1.WorkspaceService);
    }
    $set(key, value, isGlobal) {
        return this.pluginServer.setStorageValue(key, value, this.toKind(isGlobal));
    }
    $get(key, isGlobal) {
        return this.pluginServer.getStorageValue(key, this.toKind(isGlobal));
    }
    $getAll(isGlobal) {
        return this.pluginServer.getAllStorageValues(this.toKind(isGlobal));
    }
    toKind(isGlobal) {
        var _a;
        if (isGlobal) {
            return undefined;
        }
        return {
            workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
            roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
        };
    }
}
exports.StorageMainImpl = StorageMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginTerminalRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let PluginTerminalRegistry = class PluginTerminalRegistry {
    start(profileId) {
        return this.startCallback(profileId);
    }
};
exports.PluginTerminalRegistry = PluginTerminalRegistry;
exports.PluginTerminalRegistry = PluginTerminalRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTerminalRegistry);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferenceRegistryMainImpl = exports.getPreferences = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
function getPreferences(preferenceProviderProvider, rootFolders) {
    const folders = rootFolders.map(root => root.resource.toString());
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return preferences_1.PreferenceScope.getScopes().reduce((result, scope) => {
        result[scope] = {};
        const provider = preferenceProviderProvider(scope);
        if (scope === preferences_1.PreferenceScope.Folder) {
            for (const f of folders) {
                const folderPrefs = provider.getPreferences(f);
                result[scope][f] = folderPrefs;
            }
        }
        else {
            result[scope] = provider.getPreferences();
        }
        return result;
    }, {});
}
exports.getPreferences = getPreferences;
class PreferenceRegistryMainImpl {
    constructor(prc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = prc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.PREFERENCE_REGISTRY_EXT);
        this.preferenceService = container.get(preferences_1.PreferenceService);
        const preferenceProviderProvider = container.get(preferences_1.PreferenceProviderProvider);
        const preferenceServiceImpl = container.get(preferences_1.PreferenceServiceImpl);
        const workspaceService = container.get(browser_1.WorkspaceService);
        this.toDispose.push(preferenceServiceImpl.onPreferencesChanged(changes => {
            // it HAS to be synchronous to propagate changes before update/remove response
            const roots = workspaceService.tryGetRoots();
            const data = getPreferences(preferenceProviderProvider, roots);
            const eventData = Object.values(changes).map(({ scope, newValue, domain, preferenceName }) => {
                const extScope = scope === preferences_1.PreferenceScope.User ? undefined : domain === null || domain === void 0 ? void 0 : domain[0];
                return { preferenceName, newValue, scope: extScope };
            });
            this.proxy.$acceptConfigurationChanged(data, eventData);
        }));
    }
    dispose() {
        this.toDispose.dispose();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $updateConfigurationOption(target, key, value, resource, withLanguageOverride) {
        const scope = this.parseConfigurationTarget(target, resource);
        const effectiveKey = this.getEffectiveKey(key, scope, withLanguageOverride, resource);
        await this.preferenceService.set(effectiveKey, value, scope, resource);
    }
    async $removeConfigurationOption(target, key, resource, withLanguageOverride) {
        const scope = this.parseConfigurationTarget(target, resource);
        const effectiveKey = this.getEffectiveKey(key, scope, withLanguageOverride, resource);
        await this.preferenceService.set(effectiveKey, undefined, scope, resource);
    }
    parseConfigurationTarget(target, resource) {
        if (typeof target === 'boolean') {
            return target ? preferences_1.PreferenceScope.User : preferences_1.PreferenceScope.Workspace;
        }
        switch (target) {
            case types_impl_1.ConfigurationTarget.Global:
                return preferences_1.PreferenceScope.User;
            case types_impl_1.ConfigurationTarget.Workspace:
                return preferences_1.PreferenceScope.Workspace;
            case types_impl_1.ConfigurationTarget.WorkspaceFolder:
                return preferences_1.PreferenceScope.Folder;
            default:
                return resource ? preferences_1.PreferenceScope.Folder : preferences_1.PreferenceScope.Workspace;
        }
    }
    // If the caller does not set `withLanguageOverride = true`, we have to check whether the setting exists with that override already.
    getEffectiveKey(key, scope, withLanguageOverride, resource) {
        if (withLanguageOverride) {
            return key;
        }
        const overridden = this.preferenceService.overriddenPreferenceName(key);
        if (!overridden) {
            return key;
        }
        const value = this.preferenceService.inspectInScope(key, scope, resource, withLanguageOverride);
        return value === undefined ? overridden.preferenceName : key;
    }
}
exports.PreferenceRegistryMainImpl = PreferenceRegistryMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickOpenMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const monaco_quick_input_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-quick-input-service */ "../node_modules/@theia/monaco/lib/browser/monaco-quick-input-service.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
class QuickOpenMainImpl {
    constructor(rpc, container) {
        this.items = {};
        this.toDispose = new disposable_1.DisposableCollection();
        this.sessions = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.QUICK_OPEN_EXT);
        this.delegate = container.get(monaco_quick_input_service_1.MonacoQuickInputService);
        this.quickInputService = container.get(browser_1.QuickInputService);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $show(instance, options, token) {
        const contents = new Promise((resolve, reject) => {
            this.items[instance] = { resolve, reject };
        });
        const activeItem = await options.activeItem;
        const transformedOptions = {
            ...options,
            onDidFocus: (el) => {
                if (el) {
                    this.proxy.$onItemSelected(Number.parseInt(el.id));
                }
            },
            activeItem: this.isItem(activeItem) ? this.toQuickPickItem(activeItem) : undefined
        };
        const result = await this.delegate.pick(contents, transformedOptions, token);
        if (Array.isArray(result)) {
            return result.map(({ id }) => Number.parseInt(id));
        }
        else if (result) {
            return Number.parseInt(result.id);
        }
        return undefined;
    }
    isItem(item) {
        return (item === null || item === void 0 ? void 0 : item.kind) === 'item';
    }
    toIconClasses(path) {
        const iconClasses = [];
        if (themables_1.ThemeIcon.isThemeIcon(path)) {
            const codicon = (0, browser_1.codiconArray)(path.id);
            iconClasses.push(...codicon);
        }
        else if (path) {
            const iconReference = this.sharedStyle.toIconClass(path);
            this.toDispose.push(iconReference);
            iconClasses.push(iconReference.object.iconClass);
        }
        return iconClasses;
    }
    toIconClass(path) {
        return this.toIconClasses(path).join(' ');
    }
    toQuickPickItem(item) {
        if (!item) {
            return undefined;
        }
        else if (item.kind === 'separator') {
            return {
                type: 'separator',
                label: item.label
            };
        }
        return {
            type: 'item',
            id: item.handle.toString(),
            label: item.label,
            description: item.description,
            detail: item.detail,
            alwaysShow: item.alwaysShow,
            iconClasses: this.toIconClasses(item.iconUrl),
            buttons: item.buttons ? this.convertToQuickInputButtons(item.buttons) : undefined
        };
    }
    $setItems(instance, items) {
        if (this.items[instance]) {
            this.items[instance].resolve(items.map(item => this.toQuickPickItem(item)));
            delete this.items[instance];
        }
        return Promise.resolve();
    }
    $setError(instance, error) {
        if (this.items[instance]) {
            this.items[instance].reject(error);
            delete this.items[instance];
        }
        return Promise.resolve();
    }
    $input(options, validateInput, token) {
        var _a;
        const inputOptions = Object.create(null);
        if (options) {
            inputOptions.title = options.title;
            inputOptions.password = options.password;
            inputOptions.placeHolder = options.placeHolder;
            inputOptions.valueSelection = options.valueSelection;
            inputOptions.prompt = options.prompt;
            inputOptions.value = options.value;
            inputOptions.ignoreFocusLost = options.ignoreFocusOut;
        }
        if (validateInput) {
            inputOptions.validateInput = (val) => this.proxy.$validateInput(val);
        }
        return (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.input(inputOptions, token);
    }
    async $showInputBox(options, validateInput) {
        return new Promise((resolve, reject) => {
            var _a;
            const sessionId = options.id;
            const toDispose = new disposable_1.DisposableCollection();
            const inputBox = (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.createInputBox();
            inputBox.prompt = options.prompt;
            inputBox.placeholder = options.placeHolder;
            inputBox.value = options.value;
            if (options.busy) {
                inputBox.busy = options.busy;
            }
            if (options.enabled) {
                inputBox.enabled = options.enabled;
            }
            inputBox.ignoreFocusOut = options.ignoreFocusOut;
            inputBox.contextKey = options.contextKey;
            if (options.password) {
                inputBox.password = options.password;
            }
            inputBox.step = options.step;
            inputBox.title = options.title;
            inputBox.description = options.description;
            inputBox.totalSteps = options.totalSteps;
            inputBox.buttons = options.buttons ? this.convertToQuickInputButtons(options.buttons) : [];
            inputBox.validationMessage = options.validationMessage;
            if (validateInput) {
                options.validateInput = (val) => {
                    this.proxy.$validateInput(val);
                };
            }
            toDispose.push(inputBox.onDidAccept(() => {
                this.proxy.$acceptOnDidAccept(sessionId);
                resolve(inputBox.value);
            }));
            toDispose.push(inputBox.onDidChangeValue((value) => {
                this.proxy.$acceptDidChangeValue(sessionId, value);
                inputBox.validationMessage = options.validateInput(value);
            }));
            toDispose.push(inputBox.onDidTriggerButton((button) => {
                this.proxy.$acceptOnDidTriggerButton(sessionId, button);
            }));
            toDispose.push(inputBox.onDidHide(() => {
                if (toDispose.disposed) {
                    return;
                }
                this.proxy.$acceptOnDidHide(sessionId);
                toDispose.dispose();
                resolve(undefined);
            }));
            this.toDispose.push(toDispose);
            inputBox.show();
        });
    }
    $createOrUpdate(params) {
        const sessionId = params.id;
        let session;
        const candidate = this.sessions.get(sessionId);
        if (!candidate) {
            if (params.type === 'quickPick') {
                const quickPick = this.quickInputService.createQuickPick();
                quickPick.onDidAccept(() => {
                    this.proxy.$acceptOnDidAccept(sessionId);
                });
                quickPick.onDidChangeActive((items) => {
                    this.proxy.$onDidChangeActive(sessionId, items.map(item => Number.parseInt(item.id)));
                });
                quickPick.onDidChangeSelection((items) => {
                    this.proxy.$onDidChangeSelection(sessionId, items.map(item => Number.parseInt(item.id)));
                });
                quickPick.onDidTriggerButton((button) => {
                    this.proxy.$acceptOnDidTriggerButton(sessionId, button);
                });
                quickPick.onDidTriggerItemButton(e => {
                    this.proxy.$onDidTriggerItemButton(sessionId, Number.parseInt(e.item.id), e.button.handle);
                });
                quickPick.onDidChangeValue((value) => {
                    this.proxy.$acceptDidChangeValue(sessionId, value);
                });
                quickPick.onDidHide(() => {
                    this.proxy.$acceptOnDidHide(sessionId);
                });
                session = {
                    input: quickPick,
                    handlesToItems: new Map()
                };
            }
            else {
                const inputBox = this.quickInputService.createInputBox();
                inputBox.onDidAccept(() => {
                    this.proxy.$acceptOnDidAccept(sessionId);
                });
                inputBox.onDidTriggerButton((button) => {
                    this.proxy.$acceptOnDidTriggerButton(sessionId, button);
                });
                inputBox.onDidChangeValue((value) => {
                    this.proxy.$acceptDidChangeValue(sessionId, value);
                });
                inputBox.onDidHide(() => {
                    this.proxy.$acceptOnDidHide(sessionId);
                });
                session = {
                    input: inputBox,
                    handlesToItems: new Map()
                };
            }
            this.sessions.set(sessionId, session);
        }
        else {
            session = candidate;
        }
        if (session) {
            const { input, handlesToItems } = session;
            for (const param in params) {
                if (param === 'id' || param === 'type') {
                    continue;
                }
                if (param === 'visible') {
                    if (params.visible) {
                        input.show();
                    }
                    else {
                        input.hide();
                    }
                }
                else if (param === 'items') {
                    handlesToItems.clear();
                    const items = [];
                    params[param].forEach((transferItem) => {
                        const item = this.toQuickPickItem(transferItem);
                        items.push(item);
                        handlesToItems.set(transferItem.handle, item);
                    });
                    input[param] = items;
                }
                else if (param === 'activeItems' || param === 'selectedItems') {
                    input[param] = params[param]
                        .filter((handle) => handlesToItems.has(handle))
                        .map((handle) => handlesToItems.get(handle));
                }
                else if (param === 'buttons') {
                    input[param] = params.buttons.map(button => {
                        if (button.handle === -1) {
                            return this.quickInputService.backButton;
                        }
                        const { iconUrl, tooltip, handle } = button;
                        return {
                            tooltip,
                            handle,
                            iconClass: this.toIconClass(iconUrl)
                        };
                    });
                }
                else {
                    input[param] = params[param];
                }
            }
        }
        return Promise.resolve(undefined);
    }
    $hide() {
        this.delegate.hide();
    }
    $dispose(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            session.input.dispose();
            this.sessions.delete(sessionId);
        }
        return Promise.resolve(undefined);
    }
    convertToQuickInputButtons(buttons) {
        return buttons.map((button, i) => ({
            iconClass: this.toIconClass(button.iconUrl),
            tooltip: button.tooltip,
            handle: button === types_impl_1.QuickInputButtons.Back ? -1 : i,
        }));
    }
}
exports.QuickOpenMainImpl = QuickOpenMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019-2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmMainImpl = exports.PluginScmProvider = exports.PluginScmResource = exports.PluginScmResourceGroup = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// code copied and modified from https://github.com/microsoft/vscode/blob/1.52.1/src/vs/workbench/api/browser/mainThreadSCM.ts
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const scm_service_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
class PluginScmResourceGroup {
    get hideWhenEmpty() { return !!this.features.hideWhenEmpty; }
    constructor(handle, provider, features, label, id) {
        this.handle = handle;
        this.provider = provider;
        this.features = features;
        this.label = label;
        this.id = id;
        this.resources = [];
        this.onDidSpliceEmitter = new event_1.Emitter();
        this.onDidSplice = this.onDidSpliceEmitter.event;
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    splice(start, deleteCount, toInsert) {
        this.resources.splice(start, deleteCount, ...toInsert);
        this.onDidSpliceEmitter.fire({ start, deleteCount, toInsert });
    }
    updateGroup(features) {
        this.features = { ...this.features, ...features };
        this.onDidChangeEmitter.fire();
    }
    updateGroupLabel(label) {
        this.label = label;
        this.onDidChangeEmitter.fire();
    }
    dispose() { }
}
exports.PluginScmResourceGroup = PluginScmResourceGroup;
class PluginScmResource {
    constructor(proxy, sourceControlHandle, groupHandle, handle, sourceUri, group, decorations, contextValue, command) {
        this.proxy = proxy;
        this.sourceControlHandle = sourceControlHandle;
        this.groupHandle = groupHandle;
        this.handle = handle;
        this.sourceUri = sourceUri;
        this.group = group;
        this.decorations = decorations;
        this.contextValue = contextValue;
        this.command = command;
    }
    open() {
        return this.proxy.$executeResourceCommand(this.sourceControlHandle, this.groupHandle, this.handle);
    }
}
exports.PluginScmResource = PluginScmResource;
class PluginScmProvider {
    get id() { return this._id; }
    get handle() { return this._handle; }
    get label() { return this._label; }
    get rootUri() { return this._rootUri ? this._rootUri.toString() : ''; }
    get contextValue() { return this._contextValue; }
    get commitTemplate() { return this.features.commitTemplate || ''; }
    get acceptInputCommand() {
        const command = this.features.acceptInputCommand;
        if (command) {
            const scmCommand = command;
            scmCommand.command = command.id;
            return scmCommand;
        }
    }
    get statusBarCommands() {
        const commands = this.features.statusBarCommands;
        return commands === null || commands === void 0 ? void 0 : commands.map(command => {
            const scmCommand = command;
            scmCommand.command = command.id;
            return scmCommand;
        });
    }
    get count() { return this.features.count; }
    get onDidChangeStatusBarCommands() { return this.onDidChangeStatusBarCommandsEmitter.event; }
    constructor(proxy, colors, sharedStyle, _handle, _contextValue, _label, _rootUri, disposables) {
        this.proxy = proxy;
        this.colors = colors;
        this.sharedStyle = sharedStyle;
        this._handle = _handle;
        this._contextValue = _contextValue;
        this._label = _label;
        this._rootUri = _rootUri;
        this.disposables = disposables;
        this._id = this.contextValue;
        this.groups = [];
        this.groupsByHandle = Object.create(null);
        this.onDidChangeResourcesEmitter = new event_1.Emitter();
        this.onDidChangeResources = this.onDidChangeResourcesEmitter.event;
        this.features = {};
        this.onDidChangeCommitTemplateEmitter = new event_1.Emitter();
        this.onDidChangeCommitTemplate = this.onDidChangeCommitTemplateEmitter.event;
        this.onDidChangeStatusBarCommandsEmitter = new event_1.Emitter();
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    updateSourceControl(features) {
        this.features = { ...this.features, ...features };
        this.onDidChangeEmitter.fire();
        if (typeof features.commitTemplate !== 'undefined') {
            this.onDidChangeCommitTemplateEmitter.fire(this.commitTemplate);
        }
        if (typeof features.statusBarCommands !== 'undefined') {
            this.onDidChangeStatusBarCommandsEmitter.fire(this.statusBarCommands);
        }
    }
    registerGroups(resourceGroups) {
        const groups = resourceGroups.map(resourceGroup => {
            const { handle, id, label, features } = resourceGroup;
            const group = new PluginScmResourceGroup(handle, this, features, label, id);
            this.groupsByHandle[handle] = group;
            return group;
        });
        this.groups.splice(this.groups.length, 0, ...groups);
    }
    updateGroup(handle, features) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        group.updateGroup(features);
    }
    updateGroupLabel(handle, label) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        group.updateGroupLabel(label);
    }
    spliceGroupResourceStates(splices) {
        for (const splice of splices) {
            const groupHandle = splice.handle;
            const groupSlices = splice.splices;
            const group = this.groupsByHandle[groupHandle];
            if (!group) {
                console.warn(`SCM group ${groupHandle} not found in provider ${this.label}`);
                continue;
            }
            // reverse the splices sequence in order to apply them correctly
            groupSlices.reverse();
            for (const groupSlice of groupSlices) {
                const { start, deleteCount, rawResources } = groupSlice;
                const resources = rawResources.map(rawResource => {
                    const { handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command } = rawResource;
                    const icon = this.toIconClass(icons[0]);
                    const iconDark = this.toIconClass(icons[1]) || icon;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const colorVariable = rawResource.colorId && this.colors.toCssVariableName(rawResource.colorId);
                    const decorations = {
                        icon,
                        iconDark,
                        tooltip,
                        strikeThrough,
                        // TODO remove the letter and colorId fields when the FileDecorationProvider is applied, see https://github.com/eclipse-theia/theia/pull/8911
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        letter: rawResource.letter || '',
                        color: colorVariable && `var(${colorVariable})`,
                        faded
                    };
                    return new PluginScmResource(this.proxy, this.handle, groupHandle, handle, new uri_1.default(vscode_uri_1.URI.revive(sourceUri)), group, decorations, contextValue || undefined, command);
                });
                group.splice(start, deleteCount, resources);
            }
        }
        this.onDidChangeResourcesEmitter.fire();
    }
    toIconClass(icon) {
        if (!icon) {
            return undefined;
        }
        if (themables_1.ThemeIcon.isThemeIcon(icon)) {
            return themables_1.ThemeIcon.asClassName(icon);
        }
        const reference = this.sharedStyle.toIconClass(icon);
        this.disposables.push(reference);
        return reference.object.iconClass;
    }
    unregisterGroup(handle) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        delete this.groupsByHandle[handle];
        this.groups.splice(this.groups.indexOf(group), 1);
    }
    dispose() { }
}
exports.PluginScmProvider = PluginScmProvider;
class ScmMainImpl {
    constructor(rpc, container) {
        this.repositories = new Map();
        this.repositoryDisposables = new Map();
        this.disposables = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.SCM_EXT);
        this.scmService = container.get(scm_service_1.ScmService);
        this.colors = container.get(color_registry_1.ColorRegistry);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
    }
    dispose() {
        this.repositories.forEach(r => r.dispose());
        this.repositories.clear();
        this.repositoryDisposables.forEach(d => d.dispose());
        this.repositoryDisposables.clear();
        this.disposables.dispose();
    }
    async $registerSourceControl(handle, id, label, rootUri) {
        const provider = new PluginScmProvider(this.proxy, this.colors, this.sharedStyle, handle, id, label, rootUri ? vscode_uri_1.URI.revive(rootUri) : undefined, this.disposables);
        const repository = this.scmService.registerScmProvider(provider, {
            input: {
                validator: async (value) => {
                    const result = await this.proxy.$validateInput(handle, value, value.length);
                    return result && { message: result[0], type: result[1] };
                }
            }
        });
        this.repositories.set(handle, repository);
        const disposables = new disposable_1.DisposableCollection(this.scmService.onDidChangeSelectedRepository(r => {
            if (r === repository) {
                this.proxy.$setSelectedSourceControl(handle);
            }
        }), repository.input.onDidChange(() => this.proxy.$onInputBoxValueChange(handle, repository.input.value)));
        if (this.scmService.selectedRepository === repository) {
            setTimeout(() => this.proxy.$setSelectedSourceControl(handle), 0);
        }
        if (repository.input.value) {
            setTimeout(() => this.proxy.$onInputBoxValueChange(handle, repository.input.value), 0);
        }
        this.repositoryDisposables.set(handle, disposables);
    }
    async $updateSourceControl(handle, features) {
        const repository = this.repositories.get(handle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateSourceControl(features);
    }
    async $unregisterSourceControl(handle) {
        const repository = this.repositories.get(handle);
        if (!repository) {
            return;
        }
        this.repositoryDisposables.get(handle).dispose();
        this.repositoryDisposables.delete(handle);
        repository.dispose();
        this.repositories.delete(handle);
    }
    $registerGroups(sourceControlHandle, groups, splices) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.registerGroups(groups);
        provider.spliceGroupResourceStates(splices);
    }
    $updateGroup(sourceControlHandle, groupHandle, features) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateGroup(groupHandle, features);
    }
    $updateGroupLabel(sourceControlHandle, groupHandle, label) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateGroupLabel(groupHandle, label);
    }
    $spliceResourceStates(sourceControlHandle, splices) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.spliceGroupResourceStates(splices);
    }
    $unregisterGroup(sourceControlHandle, handle) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.unregisterGroup(handle);
    }
    $setInputBoxValue(sourceControlHandle, value) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.value = value;
    }
    $setInputBoxPlaceholder(sourceControlHandle, placeholder) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.placeholder = placeholder;
    }
    $setInputBoxVisible(sourceControlHandle, visible) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.visible = visible;
    }
    $setInputBoxEnabled(sourceControlHandle, enabled) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.enabled = enabled;
    }
}
exports.ScmMainImpl = ScmMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecretsMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const credentials_service_1 = __webpack_require__(/*! @theia/core/lib/browser/credentials-service */ "../node_modules/@theia/core/lib/browser/credentials-service.js");
class SecretsMainImpl {
    constructor(rpc, container) {
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.SECRETS_EXT);
        this.credentialsService = container.get(credentials_service_1.CredentialsService);
        this.credentialsService.onDidChangePassword(e => {
            const extensionId = e.service.substring(window.location.hostname.length + 1);
            this.proxy.$onDidChangePassword({ extensionId, key: e.account });
        });
    }
    static getFullKey(extensionId) {
        return `${window.location.hostname}-${extensionId}`;
    }
    async $getPassword(extensionId, key) {
        const fullKey = SecretsMainImpl.getFullKey(extensionId);
        const passwordData = await this.credentialsService.getPassword(fullKey, key);
        if (passwordData) {
            try {
                const data = JSON.parse(passwordData);
                if (data.extensionId === extensionId) {
                    return data.content;
                }
            }
            catch (e) {
                throw new Error('Cannot get password');
            }
        }
        return undefined;
    }
    async $setPassword(extensionId, key, value) {
        const fullKey = SecretsMainImpl.getFullKey(extensionId);
        const passwordData = JSON.stringify({
            extensionId,
            content: value
        });
        return this.credentialsService.setPassword(fullKey, key, passwordData);
    }
    async $deletePassword(extensionId, key) {
        try {
            const fullKey = SecretsMainImpl.getFullKey(extensionId);
            await this.credentialsService.deletePassword(fullKey, key);
        }
        catch (e) {
            throw new Error('Cannot delete password');
        }
    }
}
exports.SecretsMainImpl = SecretsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarMessageRegistryMainImpl = void 0;
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const types = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const status_bar_1 = __webpack_require__(/*! @theia/core/lib/browser/status-bar/status-bar */ "../node_modules/@theia/core/lib/browser/status-bar/status-bar.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
class StatusBarMessageRegistryMainImpl {
    constructor(container) {
        this.entries = new Map();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        this.delegate = container.get(status_bar_1.StatusBar);
        this.colorRegistry = container.get(color_registry_1.ColorRegistry);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $setMessage(id, name, text, priority, alignment, color, backgroundColor, tooltip, command, accessibilityInformation, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    args) {
        const ariaLabel = accessibilityInformation === null || accessibilityInformation === void 0 ? void 0 : accessibilityInformation.label;
        const role = accessibilityInformation === null || accessibilityInformation === void 0 ? void 0 : accessibilityInformation.role;
        const entry = {
            name,
            text: text || '',
            ariaLabel,
            role,
            priority,
            alignment: alignment === types.StatusBarAlignment.Left ? status_bar_1.StatusBarAlignment.LEFT : status_bar_1.StatusBarAlignment.RIGHT,
            color: color && (this.colorRegistry.getCurrentColor(color) || color),
            // In contrast to color, the backgroundColor must be a theme color. Thus, do not hand in the plain string if it cannot be resolved.
            backgroundColor: backgroundColor && (this.colorRegistry.getCurrentColor(backgroundColor)),
            tooltip,
            command,
            accessibilityInformation,
            args
        };
        this.entries.set(id, entry);
        await this.delegate.setElement(id, entry);
        if (this.toDispose.disposed) {
            this.$dispose(id);
        }
        else {
            this.toDispose.push(disposable_1.Disposable.create(() => this.$dispose(id)));
        }
    }
    $dispose(id) {
        const entry = this.entries.get(id);
        if (entry) {
            this.entries.delete(id);
            this.delegate.removeElement(id);
        }
    }
}
exports.StatusBarMessageRegistryMainImpl = StatusBarMessageRegistryMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabsMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const editor_preview_widget_1 = __webpack_require__(/*! @theia/editor-preview/lib/browser/editor-preview-widget */ "../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
const hierarchy_types_converters_1 = __webpack_require__(/*! ../hierarchy/hierarchy-types-converters */ "../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js");
const terminal_widget_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-widget */ "../node_modules/@theia/terminal/lib/browser/base/terminal-widget.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
class TabsMainImpl {
    constructor(rpc, container) {
        this.tabGroupModel = new Map();
        this.tabInfoLookup = new Map();
        this.waitQueue = new Map();
        this.disposableTabBarListeners = new core_1.DisposableCollection();
        this.disposableTitleListeners = new Map();
        this.toDisposeOnDestroy = new core_1.DisposableCollection();
        this.groupIdCounter = 1;
        this.tabGroupChanged = false;
        this.defaultTabGroup = {
            groupId: 0,
            tabs: [],
            isActive: true,
            viewColumn: 0
        };
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TABS_EXT);
        this.applicationShell = container.get(browser_1.ApplicationShell);
        this.createTabsModel();
        const tabBars = this.applicationShell.mainPanel.tabBars();
        for (let tabBar; tabBar = tabBars.next();) {
            this.attachListenersToTabBar(tabBar);
        }
        this.toDisposeOnDestroy.push(this.applicationShell.mainPanelRenderer.onDidCreateTabBar(tabBar => {
            this.attachListenersToTabBar(tabBar);
            this.onTabGroupCreated(tabBar);
        }));
        this.connectToSignal(this.toDisposeOnDestroy, this.applicationShell.mainPanel.widgetAdded, (mainPanel, widget) => {
            if (this.tabGroupChanged || this.tabGroupModel.size === 0) {
                this.tabGroupChanged = false;
                this.createTabsModel();
                // tab Open event is done in backend
            }
            else {
                const tabBar = mainPanel.findTabBar(widget.title);
                const oldTabInfo = this.tabInfoLookup.get(widget.title);
                const group = this.tabGroupModel.get(tabBar);
                if (group !== (oldTabInfo === null || oldTabInfo === void 0 ? void 0 : oldTabInfo.group)) {
                    if (oldTabInfo) {
                        this.onTabClosed(oldTabInfo, widget.title);
                    }
                    this.onTabCreated(tabBar, { index: tabBar.titles.indexOf(widget.title), title: widget.title });
                }
            }
        });
        this.connectToSignal(this.toDisposeOnDestroy, this.applicationShell.mainPanel.widgetRemoved, (mainPanel, widget) => {
            if (!(widget instanceof browser_1.TabBar)) {
                const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, widget.title);
                this.onTabClosed(tabInfo, widget.title);
                if (this.tabGroupChanged) {
                    this.tabGroupChanged = false;
                    this.createTabsModel();
                }
            }
        });
    }
    waitForWidget(widget) {
        const deferred = new promise_util_1.Deferred();
        this.waitQueue.set(widget, deferred);
        const timeout = setTimeout(() => {
            deferred.resolve(); // resolve to unblock the event
        }, 1000);
        deferred.promise.then(() => {
            clearTimeout(timeout);
        });
        return deferred.promise;
    }
    createTabsModel() {
        var _a, _b;
        if (this.applicationShell.mainAreaTabBars.length === 0) {
            this.proxy.$acceptEditorTabModel([this.defaultTabGroup]);
            return;
        }
        const newTabGroupModel = new Map();
        this.tabInfoLookup.clear();
        this.disposableTitleListeners.forEach(disposable => disposable.dispose());
        this.disposableTabBarListeners.dispose();
        this.applicationShell.mainAreaTabBars
            .forEach(tabBar => {
            this.attachListenersToTabBar(tabBar);
            const groupDto = this.createTabGroupDto(tabBar);
            tabBar.titles.forEach((title, index) => this.tabInfoLookup.set(title, { group: groupDto, tab: groupDto.tabs[index], tabIndex: index }));
            newTabGroupModel.set(tabBar, groupDto);
        });
        if (newTabGroupModel.size > 0 && Array.from(newTabGroupModel.values()).indexOf(this.currentActiveGroup) < 0) {
            this.currentActiveGroup = (_b = (_a = this.tabInfoLookup.get(this.applicationShell.mainPanel.currentTitle)) === null || _a === void 0 ? void 0 : _a.group) !== null && _b !== void 0 ? _b : newTabGroupModel.values().next().value;
            this.currentActiveGroup.isActive = true;
        }
        this.tabGroupModel = newTabGroupModel;
        this.proxy.$acceptEditorTabModel(Array.from(this.tabGroupModel.values()));
        // Resolve all waiting widget promises
        this.waitQueue.forEach(deferred => deferred.resolve());
        this.waitQueue.clear();
    }
    createTabDto(tabTitle, groupId, newTab = false) {
        var _a;
        const widget = tabTitle.owner;
        const active = newTab || ((_a = this.getTabBar(tabTitle)) === null || _a === void 0 ? void 0 : _a.currentTitle) === tabTitle;
        return {
            id: this.createTabId(tabTitle, groupId),
            label: tabTitle.label,
            input: this.evaluateTabDtoInput(widget),
            isActive: active,
            isPinned: tabTitle.className.includes(browser_1.PINNED_CLASS),
            isDirty: browser_1.Saveable.isDirty(widget),
            isPreview: widget instanceof editor_preview_widget_1.EditorPreviewWidget && widget.isPreview
        };
    }
    getTabBar(tabTitle) {
        return this.applicationShell.mainPanel.findTabBar(tabTitle);
    }
    createTabId(tabTitle, groupId) {
        return `${groupId}~${tabTitle.owner.id}`;
    }
    createTabGroupDto(tabBar) {
        var _a;
        const oldDto = this.tabGroupModel.get(tabBar);
        const groupId = (_a = oldDto === null || oldDto === void 0 ? void 0 : oldDto.groupId) !== null && _a !== void 0 ? _a : this.groupIdCounter++;
        const tabs = tabBar.titles.map(title => this.createTabDto(title, groupId));
        const viewColumn = 0; // TODO: Implement correct viewColumn handling
        return {
            groupId,
            tabs,
            isActive: false,
            viewColumn
        };
    }
    getTitleDisposables(title) {
        let disposable = this.disposableTitleListeners.get(title.owner.id);
        if (!disposable) {
            disposable = new core_1.DisposableCollection();
            this.disposableTitleListeners.set(title.owner.id, disposable);
        }
        return disposable;
    }
    attachListenersToTabBar(tabBar) {
        if (!tabBar) {
            return;
        }
        tabBar.titles.forEach(title => {
            this.connectToSignal(this.getTitleDisposables(title), title.changed, this.onTabTitleChanged);
        });
        this.connectToSignal(this.disposableTabBarListeners, tabBar.tabMoved, this.onTabMoved);
        this.connectToSignal(this.disposableTabBarListeners, tabBar.disposed, this.onTabGroupClosed);
    }
    evaluateTabDtoInput(widget) {
        var _a, _b;
        if (widget instanceof editor_preview_widget_1.EditorPreviewWidget) {
            if (widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                return {
                    kind: 2 /* TabInputKind.TextDiffInput */,
                    original: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.originalModel.uri),
                    modified: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.modifiedModel.uri)
                };
            }
            else {
                return {
                    kind: 1 /* TabInputKind.TextInput */,
                    uri: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.uri.toString())
                };
            }
        }
        else if (widget instanceof browser_1.ViewContainer) {
            return {
                kind: 7 /* TabInputKind.WebviewEditorInput */,
                viewType: widget.id
            };
        }
        else if (widget instanceof terminal_widget_1.TerminalWidget) {
            return {
                kind: 8 /* TabInputKind.TerminalEditorInput */
            };
        }
        else if (widget instanceof browser_2.NotebookEditorWidget) {
            return {
                kind: 4 /* TabInputKind.NotebookInput */,
                notebookType: widget.notebookType,
                uri: (0, hierarchy_types_converters_1.toUriComponents)((_b = (_a = widget.model) === null || _a === void 0 ? void 0 : _a.uri.toString()) !== null && _b !== void 0 ? _b : '')
            };
        }
        return { kind: 0 /* TabInputKind.UnknownInput */ };
    }
    connectToSignal(disposableList, signal, listener) {
        signal.connect(listener, this);
        disposableList.push(vscode_languageserver_protocol_1.Disposable.create(() => signal.disconnect(listener, this)));
    }
    tabDtosEqual(a, b) {
        return a.isActive === b.isActive &&
            a.isDirty === b.isDirty &&
            a.isPinned === b.isPinned &&
            a.isPreview === b.isPreview &&
            a.id === b.id;
    }
    getOrRebuildModel(map, key) {
        // something broke so we rebuild the model
        let item = map.get(key);
        if (!item) {
            this.createTabsModel();
            item = map.get(key);
        }
        return item;
    }
    // #region event listeners
    onTabCreated(tabBar, args) {
        var _a;
        const group = this.getOrRebuildModel(this.tabGroupModel, tabBar);
        this.connectToSignal(this.getTitleDisposables(args.title), args.title.changed, this.onTabTitleChanged);
        const tabDto = this.createTabDto(args.title, group.groupId, true);
        this.tabInfoLookup.set(args.title, { group, tab: tabDto, tabIndex: args.index });
        group.tabs.splice(args.index, 0, tabDto);
        this.proxy.$acceptTabOperation({
            kind: 0 /* TabModelOperationKind.TAB_OPEN */,
            index: args.index,
            tabDto,
            groupId: group.groupId
        });
        (_a = this.waitQueue.get(args.title.owner)) === null || _a === void 0 ? void 0 : _a.resolve();
        this.waitQueue.delete(args.title.owner);
    }
    onTabTitleChanged(title) {
        var _a;
        const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, title);
        if (!tabInfo) {
            return;
        }
        const oldTabDto = tabInfo.tab;
        const newTabDto = this.createTabDto(title, tabInfo.group.groupId);
        if (!oldTabDto.isActive && newTabDto.isActive) {
            this.currentActiveGroup.tabs.filter(tab => tab.isActive).forEach(tab => tab.isActive = false);
        }
        if (newTabDto.isActive && !tabInfo.group.isActive) {
            tabInfo.group.isActive = true;
            this.currentActiveGroup.isActive = false;
            this.currentActiveGroup = tabInfo.group;
            this.proxy.$acceptTabGroupUpdate(tabInfo.group);
        }
        if (!this.tabDtosEqual(oldTabDto, newTabDto)) {
            tabInfo.group.tabs[tabInfo.tabIndex] = newTabDto;
            tabInfo.tab = newTabDto;
            this.proxy.$acceptTabOperation({
                kind: 2 /* TabModelOperationKind.TAB_UPDATE */,
                index: tabInfo.tabIndex,
                tabDto: newTabDto,
                groupId: tabInfo.group.groupId
            });
        }
        (_a = this.waitQueue.get(title.owner)) === null || _a === void 0 ? void 0 : _a.resolve();
        this.waitQueue.delete(title.owner);
    }
    onTabClosed(tabInfo, title) {
        var _a;
        (_a = this.disposableTitleListeners.get(title.owner.id)) === null || _a === void 0 ? void 0 : _a.dispose();
        this.disposableTitleListeners.delete(title.owner.id);
        tabInfo.group.tabs.splice(tabInfo.tabIndex, 1);
        this.tabInfoLookup.delete(title);
        this.updateTabIndices(tabInfo, tabInfo.tabIndex);
        this.proxy.$acceptTabOperation({
            kind: 1 /* TabModelOperationKind.TAB_CLOSE */,
            index: tabInfo.tabIndex,
            tabDto: this.createTabDto(title, tabInfo.group.groupId),
            groupId: tabInfo.group.groupId
        });
    }
    onTabMoved(tabBar, args) {
        const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, args.title);
        tabInfo.tabIndex = args.toIndex;
        const tabDto = this.createTabDto(args.title, tabInfo.group.groupId);
        tabInfo.group.tabs.splice(args.fromIndex, 1);
        tabInfo.group.tabs.splice(args.toIndex, 0, tabDto);
        this.updateTabIndices(tabInfo, args.fromIndex);
        this.proxy.$acceptTabOperation({
            kind: 3 /* TabModelOperationKind.TAB_MOVE */,
            index: args.toIndex,
            tabDto,
            groupId: tabInfo.group.groupId,
            oldIndex: args.fromIndex
        });
    }
    onTabGroupCreated(tabBar) {
        this.tabGroupChanged = true;
    }
    onTabGroupClosed(tabBar) {
        this.tabGroupChanged = true;
    }
    // #endregion
    // #region Messages received from Ext Host
    $moveTab(tabId, index, viewColumn, preserveFocus) {
        return;
    }
    updateTabIndices(tabInfo, startIndex) {
        for (const tab of this.tabInfoLookup.values()) {
            if (tab.group === tabInfo.group && tab.tabIndex >= startIndex) {
                tab.tabIndex = tab.group.tabs.indexOf(tab.tab);
            }
        }
    }
    async $closeTab(tabIds, preserveFocus) {
        const widgets = [];
        for (const tabId of tabIds) {
            const cleanedId = tabId.substring(tabId.indexOf('~') + 1);
            const widget = this.applicationShell.getWidgetById(cleanedId);
            if (widget) {
                widgets.push(widget);
            }
        }
        await this.applicationShell.closeMany(widgets);
        return true;
    }
    async $closeGroup(groupIds, preserveFocus) {
        for (const groupId of groupIds) {
            tabGroupModel: for (const [bar, groupDto] of this.tabGroupModel) {
                if (groupDto.groupId === groupId) {
                    this.applicationShell.closeTabs(bar);
                    break tabGroupModel;
                }
            }
        }
        return true;
    }
    // #endregion
    dispose() {
        this.toDisposeOnDestroy.dispose();
        this.disposableTabBarListeners.dispose();
        this.disposableTitleListeners.forEach(disposable => disposable.dispose());
        this.disposableTitleListeners.clear();
    }
}
exports.TabsMainImpl = TabsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TasksMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const task_contribution_1 = __webpack_require__(/*! @theia/task/lib/browser/task-contribution */ "../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_protocol_1 = __webpack_require__(/*! @theia/task/lib/common/task-protocol */ "../node_modules/@theia/task/lib/common/task-protocol.js");
const task_watcher_1 = __webpack_require__(/*! @theia/task/lib/common/task-watcher */ "../node_modules/@theia/task/lib/common/task-watcher.js");
const task_service_1 = __webpack_require__(/*! @theia/task/lib/browser/task-service */ "../node_modules/@theia/task/lib/browser/task-service.js");
const browser_1 = __webpack_require__(/*! @theia/task/lib/browser */ "../node_modules/@theia/task/lib/browser/index.js");
const revealKindMap = new Map([
    [1, task_protocol_1.RevealKind.Always],
    [2, task_protocol_1.RevealKind.Silent],
    [3, task_protocol_1.RevealKind.Never],
    [task_protocol_1.RevealKind.Always, 1],
    [task_protocol_1.RevealKind.Silent, 2],
    [task_protocol_1.RevealKind.Never, 3]
]);
const panelKindMap = new Map([
    [1, task_protocol_1.PanelKind.Shared],
    [2, task_protocol_1.PanelKind.Dedicated],
    [3, task_protocol_1.PanelKind.New],
    [task_protocol_1.PanelKind.Shared, 1],
    [task_protocol_1.PanelKind.Dedicated, 2],
    [task_protocol_1.PanelKind.New, 3]
]);
class TasksMainImpl {
    constructor(rpc, container) {
        this.taskProviders = new Map();
        this.toDispose = new common_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TASKS_EXT);
        this.taskProviderRegistry = container.get(task_contribution_1.TaskProviderRegistry);
        this.taskResolverRegistry = container.get(task_contribution_1.TaskResolverRegistry);
        this.taskWatcher = container.get(task_watcher_1.TaskWatcher);
        this.taskService = container.get(task_service_1.TaskService);
        this.taskDefinitionRegistry = container.get(browser_1.TaskDefinitionRegistry);
        this.toDispose.push(this.taskWatcher.onTaskCreated((event) => {
            this.proxy.$onDidStartTask({
                id: event.taskId,
                task: this.fromTaskConfiguration(event.config)
            }, event.terminalId);
        }));
        this.toDispose.push(this.taskWatcher.onTaskExit((event) => {
            this.proxy.$onDidEndTask(event.taskId);
        }));
        this.toDispose.push(this.taskWatcher.onDidStartTaskProcess((event) => {
            if (event.processId !== undefined) {
                this.proxy.$onDidStartTaskProcess(event.processId, {
                    id: event.taskId,
                    task: this.fromTaskConfiguration(event.config)
                });
            }
        }));
        this.toDispose.push(this.taskWatcher.onDidEndTaskProcess((event) => {
            if (event.code !== undefined) {
                this.proxy.$onDidEndTaskProcess(event.code, event.taskId);
            }
        }));
        // Inform proxy about running tasks form previous session
        this.$taskExecutions().then(executions => {
            if (executions.length > 0) {
                this.proxy.$initLoadedTasks(executions);
            }
        });
    }
    dispose() {
        this.toDispose.dispose();
    }
    $registerTaskProvider(handle, type) {
        const taskProvider = this.createTaskProvider(handle);
        const taskResolver = this.createTaskResolver(handle);
        const toDispose = new common_1.DisposableCollection(this.taskProviderRegistry.register(type, taskProvider, handle), this.taskResolverRegistry.registerTaskResolver(type, taskResolver), common_1.Disposable.create(() => this.taskProviders.delete(handle)));
        this.taskProviders.set(handle, toDispose);
        this.toDispose.push(toDispose);
    }
    $unregister(handle) {
        const disposable = this.taskProviders.get(handle);
        if (disposable) {
            disposable.dispose();
        }
    }
    async $fetchTasks(taskVersion, taskType) {
        if (taskVersion && !taskVersion.startsWith('2.')) { // Theia does not support 1.x or earlier task versions
            return [];
        }
        const token = this.taskService.startUserAction();
        const [configured, provided] = await Promise.all([
            this.taskService.getConfiguredTasks(token),
            this.taskService.getProvidedTasks(token)
        ]);
        const result = [];
        for (const tasks of [configured, provided]) {
            for (const task of tasks) {
                if (!taskType || (!!this.taskDefinitionRegistry.getDefinition(task) ? task._source === taskType : task.type === taskType)) {
                    result.push(this.fromTaskConfiguration(task));
                }
            }
        }
        return result;
    }
    async $executeTask(taskDto) {
        const taskConfig = this.toTaskConfiguration(taskDto);
        const taskInfo = await this.taskService.runTask(taskConfig);
        if (taskInfo) {
            return {
                id: taskInfo.taskId,
                task: this.fromTaskConfiguration(taskInfo.config)
            };
        }
    }
    async $taskExecutions() {
        const runningTasks = await this.taskService.getRunningTasks();
        return runningTasks.map(taskInfo => ({
            id: taskInfo.taskId,
            task: this.fromTaskConfiguration(taskInfo.config)
        }));
    }
    $terminateTask(id) {
        this.taskService.kill(id);
    }
    async $customExecutionComplete(id, exitCode) {
        this.taskService.customExecutionComplete(id, exitCode);
    }
    createTaskProvider(handle) {
        return {
            provideTasks: () => this.proxy.$provideTasks(handle).then(tasks => tasks.map(taskDto => this.toTaskConfiguration(taskDto)))
        };
    }
    createTaskResolver(handle) {
        return {
            resolveTask: taskConfig => this.proxy.$resolveTask(handle, this.fromTaskConfiguration(taskConfig)).then(task => this.toTaskConfiguration(task))
        };
    }
    toTaskConfiguration(taskDto) {
        const { group, presentation, scope, source, runOptions, ...common } = taskDto !== null && taskDto !== void 0 ? taskDto : {};
        const partialConfig = {};
        if (presentation) {
            partialConfig.presentation = this.convertTaskPresentation(presentation);
        }
        if (group) {
            partialConfig.group = {
                kind: group.kind,
                isDefault: group.isDefault
            };
        }
        return {
            ...common,
            ...partialConfig,
            runOptions,
            _scope: scope,
            _source: source,
        };
    }
    fromTaskConfiguration(task) {
        const { group, presentation, _scope, _source, ...common } = task;
        const partialDto = {};
        if (presentation) {
            partialDto.presentation = this.convertTaskPresentation(presentation);
        }
        if (group === 'build' || group === 'test') {
            partialDto.group = {
                kind: group,
                isDefault: false
            };
        }
        else if (typeof group === 'object') {
            partialDto.group = group;
        }
        return {
            ...common,
            ...partialDto,
            scope: _scope,
            source: _source,
        };
    }
    convertTaskPresentation(presentationFrom) {
        if (presentationFrom) {
            const { reveal, panel, ...common } = presentationFrom;
            const presentationTo = {};
            if (reveal) {
                presentationTo.reveal = revealKindMap.get(reveal);
            }
            if (panel) {
                presentationTo.panel = panelKindMap.get(panel);
            }
            return {
                ...common,
                ...presentationTo,
            };
        }
    }
}
exports.TasksMainImpl = TasksMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalServiceMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const terminal_widget_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-widget */ "../node_modules/@theia/terminal/lib/browser/base/terminal-widget.js");
const terminal_profile_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-profile-service */ "../node_modules/@theia/terminal/lib/browser/terminal-profile-service.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const shell_terminal_protocol_1 = __webpack_require__(/*! @theia/terminal/lib/common/shell-terminal-protocol */ "../node_modules/@theia/terminal/lib/common/shell-terminal-protocol.js");
const terminal_link_provider_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-link-provider */ "../node_modules/@theia/terminal/lib/browser/terminal-link-provider.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const plugin_terminal_registry_1 = __webpack_require__(/*! ./plugin-terminal-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
/**
 * Plugin api service allows working with terminal emulator.
 */
class TerminalServiceMainImpl {
    constructor(rpc, container) {
        this.terminalLinkProviders = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.observers = new Map();
        this.terminals = container.get(terminal_service_1.TerminalService);
        this.terminalProfileService = container.get(terminal_profile_service_1.TerminalProfileService);
        this.pluginTerminalRegistry = container.get(plugin_terminal_registry_1.PluginTerminalRegistry);
        this.hostedPluginSupport = container.get(hosted_plugin_1.HostedPluginSupport);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
        this.shell = container.get(browser_1.ApplicationShell);
        this.shellTerminalServer = container.get(shell_terminal_protocol_1.ShellTerminalServerProxy);
        this.extProxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TERMINAL_EXT);
        this.toDispose.push(this.terminals.onDidCreateTerminal(terminal => this.trackTerminal(terminal)));
        for (const terminal of this.terminals.all) {
            this.trackTerminal(terminal);
        }
        this.toDispose.push(this.terminals.onDidChangeCurrentTerminal(() => this.updateCurrentTerminal()));
        this.updateCurrentTerminal();
        this.shellTerminalServer.getEnvVarCollections().then(collections => this.extProxy.$initEnvironmentVariableCollections(collections));
        this.pluginTerminalRegistry.startCallback = id => this.startProfile(id);
        container.bind(terminal_link_provider_1.TerminalLinkProvider).toDynamicValue(() => this);
        this.toDispose.push(this.terminalProfileService.onDidChangeDefaultShell(shell => {
            this.extProxy.$setShell(shell);
        }));
    }
    async startProfile(id) {
        await this.hostedPluginSupport.activateByTerminalProfile(id);
        return this.extProxy.$startProfile(id, core_1.CancellationToken.None);
    }
    $setEnvironmentVariableCollection(persistent, extensionIdentifier, rootUri, collection) {
        if (collection) {
            this.shellTerminalServer.setCollection(extensionIdentifier, rootUri, persistent, collection, collection.description);
        }
        else {
            this.shellTerminalServer.deleteCollection(extensionIdentifier);
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
    updateCurrentTerminal() {
        const { currentTerminal } = this.terminals;
        this.extProxy.$currentTerminalChanged(currentTerminal && currentTerminal.id);
    }
    async trackTerminal(terminal) {
        let name = terminal.title.label;
        this.extProxy.$terminalCreated(terminal.id, name);
        const updateTitle = () => {
            if (name !== terminal.title.label) {
                name = terminal.title.label;
                this.extProxy.$terminalNameChanged(terminal.id, name);
            }
        };
        terminal.title.changed.connect(updateTitle);
        this.toDispose.push(disposable_1.Disposable.create(() => terminal.title.changed.disconnect(updateTitle)));
        const updateProcessId = () => terminal.processId.then(processId => this.extProxy.$terminalOpened(terminal.id, processId, terminal.terminalId, terminal.dimensions.cols, terminal.dimensions.rows), () => { });
        updateProcessId();
        this.toDispose.push(terminal.onDidOpen(() => updateProcessId()));
        this.toDispose.push(terminal.onTerminalDidClose(term => this.extProxy.$terminalClosed(term.id, term.exitStatus)));
        this.toDispose.push(terminal.onSizeChanged(({ cols, rows }) => {
            this.extProxy.$terminalSizeChanged(terminal.id, cols, rows);
        }));
        this.toDispose.push(terminal.onData(data => {
            this.extProxy.$terminalOnInput(terminal.id, data);
            this.extProxy.$terminalStateChanged(terminal.id);
        }));
        this.observers.forEach((observer, id) => this.observeTerminal(id, terminal, observer));
    }
    $write(id, data) {
        const terminal = this.terminals.getById(id);
        if (!terminal) {
            return;
        }
        terminal.write(data);
    }
    $resize(id, cols, rows) {
        const terminal = this.terminals.getById(id);
        if (!terminal) {
            return;
        }
        terminal.resize(cols, rows);
    }
    async $createTerminal(id, options, parentId, isPseudoTerminal) {
        const terminal = await this.terminals.newTerminal({
            id,
            title: options.name,
            iconClass: this.toIconClass(options),
            shellPath: options.shellPath,
            shellArgs: options.shellArgs,
            cwd: options.cwd ? new uri_1.URI(options.cwd) : undefined,
            env: options.env,
            strictEnv: options.strictEnv,
            destroyTermOnClose: true,
            useServerTitle: false,
            attributes: options.attributes,
            hideFromUser: options.hideFromUser,
            location: this.getTerminalLocation(options, parentId),
            isPseudoTerminal,
            isTransient: options.isTransient
        });
        if (options.message) {
            terminal.writeLine(options.message);
        }
        terminal.start();
        return terminal.id;
    }
    getTerminalLocation(options, parentId) {
        if (typeof options.location === 'number' && Object.values(terminal_widget_1.TerminalLocation).includes(options.location)) {
            return options.location;
        }
        else if (options.location && typeof options.location === 'object') {
            if ('parentTerminal' in options.location) {
                if (!parentId) {
                    throw new Error('parentTerminal is set but no parentId is provided');
                }
                return { 'parentTerminal': parentId };
            }
            else {
                return options.location;
            }
        }
        return undefined;
    }
    $sendText(id, text, shouldExecute) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            text = text.replace(/\r?\n/g, '\r');
            if (shouldExecute && text.charAt(text.length - 1) !== '\r') {
                text += '\r';
            }
            terminal.sendText(text);
        }
    }
    $show(id, preserveFocus) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            const options = {};
            if (preserveFocus) {
                options.mode = 'reveal';
            }
            this.terminals.open(terminal, options);
        }
    }
    $hide(id) {
        const terminal = this.terminals.getById(id);
        if (terminal && terminal.isVisible) {
            const area = this.shell.getAreaFor(terminal);
            if (area) {
                this.shell.collapsePanel(area);
            }
        }
    }
    $dispose(id) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            terminal.dispose();
        }
    }
    $setName(id, name) {
        var _a;
        (_a = this.terminals.getById(id)) === null || _a === void 0 ? void 0 : _a.setTitle(name);
    }
    $sendTextByTerminalId(id, text, addNewLine) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            text = text.replace(/\r?\n/g, '\r');
            if (addNewLine && text.charAt(text.length - 1) !== '\r') {
                text += '\r';
            }
            terminal.sendText(text);
        }
    }
    $writeByTerminalId(id, data) {
        const terminal = this.terminals.getByTerminalId(id);
        if (!terminal) {
            return;
        }
        terminal.write(data);
    }
    $resizeByTerminalId(id, cols, rows) {
        const terminal = this.terminals.getByTerminalId(id);
        if (!terminal) {
            return;
        }
        terminal.resize(cols, rows);
    }
    $showByTerminalId(id, preserveFocus) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            const options = {};
            if (preserveFocus) {
                options.mode = 'reveal';
            }
            this.terminals.open(terminal, options);
        }
    }
    $hideByTerminalId(id) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal && terminal.isVisible) {
            const area = this.shell.getAreaFor(terminal);
            if (area) {
                this.shell.collapsePanel(area);
            }
        }
    }
    $disposeByTerminalId(id, waitOnExit) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            if (waitOnExit) {
                terminal.waitOnExit(waitOnExit);
                return;
            }
            terminal.dispose();
        }
    }
    $setNameByTerminalId(id, name) {
        var _a;
        (_a = this.terminals.getByTerminalId(id)) === null || _a === void 0 ? void 0 : _a.setTitle(name);
    }
    async $registerTerminalLinkProvider(providerId) {
        this.terminalLinkProviders.push(providerId);
    }
    async $unregisterTerminalLinkProvider(providerId) {
        const index = this.terminalLinkProviders.indexOf(providerId);
        if (index > -1) {
            this.terminalLinkProviders.splice(index, 1);
        }
    }
    $registerTerminalObserver(id, nrOfLinesToMatch, outputMatcherRegex) {
        const observerData = {
            nrOfLinesToMatch: nrOfLinesToMatch,
            outputMatcherRegex: new RegExp(outputMatcherRegex, 'm'),
            disposables: new disposable_1.DisposableCollection()
        };
        this.observers.set(id, observerData);
        this.terminals.all.forEach(terminal => {
            this.observeTerminal(id, terminal, observerData);
        });
    }
    observeTerminal(observerId, terminal, observerData) {
        const doMatch = debounce(() => {
            const lineCount = Math.min(observerData.nrOfLinesToMatch, terminal.buffer.length);
            const lines = terminal.buffer.getLines(terminal.buffer.length - lineCount, lineCount);
            const result = lines.join('\n').match(observerData.outputMatcherRegex);
            if (result) {
                this.extProxy.$reportOutputMatch(observerId, result.map(value => value));
            }
        });
        observerData.disposables.push(terminal.onOutput(output => {
            doMatch();
        }));
    }
    toIconClass(options) {
        const iconColor = (0, core_1.isObject)(options.color) && typeof options.color.id === 'string' ? options.color.id : undefined;
        let iconClass;
        if (options.iconUrl) {
            if (typeof options.iconUrl === 'object' && 'id' in options.iconUrl) {
                iconClass = (0, browser_1.codicon)(options.iconUrl.id);
            }
            else {
                const iconReference = this.sharedStyle.toIconClass(options.iconUrl);
                this.toDispose.push(iconReference);
                iconClass = iconReference.object.iconClass;
            }
        }
        else {
            iconClass = (0, browser_1.codicon)('terminal');
        }
        return iconColor ? { id: iconClass, color: { id: iconColor } } : iconClass;
    }
    $unregisterTerminalObserver(id) {
        const observer = this.observers.get(id);
        if (observer) {
            observer.disposables.dispose();
            this.observers.delete(id);
        }
        else {
            throw new Error(`Unregistering unknown terminal observer: ${id}`);
        }
    }
    async provideLinks(line, terminal, cancellationToken) {
        if (this.terminalLinkProviders.length < 1) {
            return [];
        }
        const links = await this.extProxy.$provideTerminalLinks(line, terminal.id, cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : core_1.CancellationToken.None);
        return links.map(link => ({ ...link, handle: () => this.extProxy.$handleTerminalLink(link) }));
    }
}
exports.TerminalServiceMainImpl = TerminalServiceMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 ST Microelectronics, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestingMainImpl = exports.TestItemImpl = exports.TestItemCollection = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const collections_1 = __webpack_require__(/*! @theia/test/lib/common/collections */ "../node_modules/@theia/test/lib/common/collections.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const test_execution_progress_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-execution-progress-service */ "../node_modules/@theia/test/lib/browser/test-execution-progress-service.js");
const tree_delta_1 = __webpack_require__(/*! @theia/test/lib/common/tree-delta */ "../node_modules/@theia/test/lib/common/tree-delta.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const test_types_1 = __webpack_require__(/*! ../../common/test-types */ "../node_modules/@theia/plugin-ext/lib/common/test-types.js");
class TestItemCollection extends collections_1.TreeCollection {
    add(item) {
        item.realParent = this.owner;
        return super.add(item);
    }
}
exports.TestItemCollection = TestItemCollection;
class TestItemImpl {
    update(value) {
        if ('label' in value) {
            this.label = value.label;
        }
        if ('range' in value) {
            this.range = convertRange(value.range);
        }
        if ('sortKey' in value) {
            this.sortKey = value.sortKey;
        }
        if ('tags' in value) {
            this.tags = value.tags;
        }
        if ('busy' in value) {
            this.busy = value.busy;
        }
        if ('sortKey' in value) {
            this.sortKey = value.sortKey;
        }
        if ('canResolveChildren' in value) {
            this.canResolveChildren = value.canResolveChildren;
        }
        if ('description' in value) {
            this.description = value.description;
        }
        if ('error' in value) {
            this.error = value.error;
        }
    }
    constructor(uri, id) {
        this.uri = uri;
        this.id = id;
        this.label = '';
        this.tags = [];
        this.busy = false;
        this.canResolveChildren = false;
        this.items = new TestItemCollection(this, (v) => v.path, (v) => v.deltaBuilder);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    notifyPropertyChange(property, value) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const val = {};
        val[property] = value;
        if (this.path) {
            (_a = this.deltaBuilder) === null || _a === void 0 ? void 0 : _a.reportChanged(this.path, val);
        }
    }
    get deltaBuilder() {
        if (this._deltaBuilder) {
            return this._deltaBuilder;
        }
        else if (this.realParent) {
            this._deltaBuilder = this.realParent.deltaBuilder;
            return this._deltaBuilder;
        }
        else {
            return undefined;
        }
    }
    get path() {
        if (this._path) {
            return this._path;
        }
        else if (this.realParent instanceof TestItemImpl) {
            this._path = [...this.realParent.path, this.id];
            return this._path;
        }
        else {
            return [this.id];
        }
    }
    ;
    get parent() {
        const realParent = this.realParent;
        if (realParent instanceof TestItemImpl) {
            return realParent;
        }
        return undefined;
    }
    get realParent() {
        return this._parent;
    }
    set realParent(v) {
        this.iterate(item => {
            item._path = undefined;
            return true;
        });
        this._parent = v;
    }
    get controller() {
        var _a;
        return (_a = this.realParent) === null || _a === void 0 ? void 0 : _a.controller;
    }
    iterate(toDo) {
        if (toDo(this)) {
            for (let i = 0; i < this.items.values.length; i++) {
                if (!this.items.values[i].iterate(toDo)) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    get tests() {
        return this.items.values;
    }
    resolveChildren() {
        var _a;
        if (this.canResolveChildren) {
            (_a = this.controller) === null || _a === void 0 ? void 0 : _a.resolveChildren(this);
        }
    }
}
exports.TestItemImpl = TestItemImpl;
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", String)
], TestItemImpl.prototype, "label", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "range", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "sortKey", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Array)
], TestItemImpl.prototype, "tags", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestItemImpl.prototype, "busy", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestItemImpl.prototype, "canResolveChildren", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "description", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "error", void 0);
function itemToPath(item) {
    if (!(item instanceof TestItemImpl)) {
        throw new Error(`Not a TestItemImpl: ${item.id}`);
    }
    return item.path;
}
class TestRunProfileImpl {
    set isDefault(isDefault) {
        this._isDefault = isDefault;
        this.proxy.$onDidChangeDefault(this.controllerId, this.id, isDefault);
    }
    get isDefault() {
        return this._isDefault;
    }
    update(update) {
        if ('label' in update) {
            this.label = update.label;
        }
        if ('isDefault' in update) {
            this._isDefault = update.isDefault;
        }
        if ('tag' in update) {
            this.tag = update.tag;
        }
        if ('canConfigure' in update) {
            this.canConfigure = update.canConfigure;
        }
    }
    constructor(proxy, controllerId, id, kind, label, isDefault, tag) {
        this.proxy = proxy;
        this.controllerId = controllerId;
        this.id = id;
        this.kind = kind;
        this.label = label;
        this.isDefault = isDefault;
        this.tag = tag;
    }
    configure() {
        this.proxy.$onConfigureRunProfile(this.controllerId, this.id);
    }
    run(name, included, excluded, preserveFocus) {
        this.proxy.$onRunControllerTests([{
                controllerId: this.controllerId,
                name,
                profileId: this.id,
                includedTests: included.map(item => itemToPath(item)),
                excludedTests: excluded.map(item => itemToPath(item)),
                preserveFocus
            }]);
    }
}
class TestRunImpl {
    constructor(controller, proxy, id, name) {
        this.controller = controller;
        this.proxy = proxy;
        this.id = id;
        this.testStates = new Map();
        this.outputIndices = new Map();
        this.outputs = [];
        this.onDidChangePropertyEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeProperty = this.onDidChangePropertyEmitter.event;
        this.onDidChangeTestStateEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeTestState = this.onDidChangeTestStateEmitter.event;
        this.onDidChangeTestOutputEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeTestOutput = this.onDidChangeTestOutputEmitter.event;
        this.name = name;
        this.isRunning = false;
    }
    ended() {
        const stateEvents = [];
        this.testStates.forEach((state, item) => {
            if (state.state <= test_types_1.TestExecutionState.Running) {
                stateEvents.push({
                    oldState: state,
                    newState: undefined,
                    test: item
                });
                this.testStates.delete(item);
            }
        });
        if (stateEvents.length > 0) {
            this.onDidChangeTestStateEmitter.fire(stateEvents);
        }
        this.isRunning = false;
    }
    notifyPropertyChange(property, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const val = {};
        val[property] = value;
        this.onDidChangePropertyEmitter.fire(val);
    }
    cancel() {
        this.proxy.$onCancelTestRun(this.controller.id, this.id);
    }
    getTestState(item) {
        return this.testStates.get(item);
    }
    getOutput(item) {
        if (!item) {
            return this.outputs;
        }
        else {
            const indices = this.outputIndices.get(item);
            if (!indices) {
                return [];
            }
            else {
                return indices.map(index => this.outputs[index]);
            }
        }
    }
    applyChanges(stateChanges, outputChanges) {
        const stateEvents = [];
        stateChanges.forEach(change => {
            const item = this.controller.findItem(change.itemPath);
            if (item) {
                const oldState = this.testStates.get(item);
                this.testStates.set(item, change);
                stateEvents.push({ test: item, oldState: oldState, newState: change });
            }
        });
        const outputEvents = [];
        outputChanges.forEach(change => {
            const output = {
                output: change.output,
                location: convertLocation(change.location)
            };
            this.outputs.push(output);
            let item = undefined;
            if (change.itemPath) {
                item = this.controller.findItem(change.itemPath);
                if (item) {
                    let indices = this.outputIndices.get(item);
                    if (!indices) {
                        indices = [];
                        this.outputIndices.set(item, indices);
                    }
                    indices.push(this.outputs.length - 1);
                }
            }
            outputEvents.push([item, output]);
        });
        this.onDidChangeTestStateEmitter.fire(stateEvents);
        this.onDidChangeTestOutputEmitter.fire(outputEvents);
    }
    get items() {
        return [...this.testStates.keys()];
    }
}
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestRunImpl.prototype, "isRunning", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", String)
], TestRunImpl.prototype, "name", void 0);
function convertLocation(location) {
    if (!location) {
        return undefined;
    }
    return {
        uri: location.uri.toString(),
        range: convertRange(location.range)
    };
}
function convertRange(range) {
    if (range) {
        return {
            start: {
                line: range.startLineNumber,
                character: range.startColumn
            }, end: {
                line: range.endLineNumber,
                character: range.endColumn
            }
        };
    }
    return undefined;
}
class TestControllerImpl {
    constructor(proxy, id, label) {
        this.proxy = proxy;
        this.id = id;
        this.label = label;
        this._profiles = new collections_1.SimpleObservableCollection();
        this._runs = new collections_1.SimpleObservableCollection();
        this.deltaBuilder = new tree_delta_1.AccumulatingTreeDeltaEmitter(300);
        this.canResolveChildren = false;
        this.items = new TestItemCollection(this, item => item.path, () => this.deltaBuilder);
        this.onProfilesChanged = this._profiles.onChanged;
        this.onRunsChanged = this._runs.onChanged;
        this.onItemsChanged = this.deltaBuilder.onDidFlush;
    }
    refreshTests(token) {
        return this.proxy.$refreshTests(this.id, token);
    }
    applyDelta(diff) {
        this.applyDeltasToCollection(this, diff);
    }
    withProfile(profileId) {
        const profile = this._profiles.values.find(p => p.id === profileId);
        if (!profile) {
            throw new Error(`No test profile ${profileId} found in controller with id ${this.id} found`);
        }
        return profile;
    }
    withRun(runId) {
        const run = this._runs.values.find(p => p.id === runId);
        if (!run) {
            throw new Error(`No test profile ${runId} found in controller with id ${this.id} found`);
        }
        return run;
    }
    applyDeltasToCollection(root, deltas) {
        deltas.forEach(delta => this.applyDeltaToCollection(root, delta));
    }
    applyDeltaToCollection(root, delta) {
        if (delta.type === tree_delta_1.DeltaKind.ADDED || delta.type === tree_delta_1.DeltaKind.REMOVED) {
            const node = this.findNodeInRoot(root, delta.path.slice(0, delta.path.length - 1), 0);
            if (node) {
                if (delta.type === tree_delta_1.DeltaKind.ADDED) {
                    node.items.add(this.createTestItem(delta.value));
                }
                else {
                    node.items.remove(delta.path[delta.path.length - 1]);
                }
            }
        }
        else {
            const node = this.findNodeInRoot(root, delta.path, 0);
            if (node) {
                if (delta.type === tree_delta_1.DeltaKind.CHANGED) {
                    node.update(delta.value);
                }
                if (delta.childDeltas) {
                    this.applyDeltasToCollection(node, delta.childDeltas);
                }
            }
        }
    }
    findItem(path) {
        if (path.length === 0) {
            console.warn('looking for item with zero-path');
            return undefined;
        }
        return this.findNodeInRoot(this, path, 0);
    }
    findNodeInRoot(root, path, startIndex) {
        if (startIndex >= path.length) {
            return root;
        }
        const child = root.items.get(path[startIndex]);
        if (!child) {
            return undefined;
        }
        return this.findNodeInRoot(child, path, startIndex + 1);
    }
    createTestItem(value) {
        var _a;
        const item = new TestItemImpl(core_1.URI.fromComponents(value.uri), value === null || value === void 0 ? void 0 : value.id);
        item.update(value);
        (_a = value.children) === null || _a === void 0 ? void 0 : _a.forEach(child => item.items.add(this.createTestItem(child)));
        return item;
    }
    get controller() {
        return this;
    }
    get testRunProfiles() {
        return this._profiles.values;
    }
    update(change) {
        if ('canRefresh' in change) {
            this.canRefresh = change.canRefresh;
        }
        if ('canResolve' in change) {
            this.canResolveChildren = change.canResolve;
        }
        if ('label' in change) {
            this.label = change.label;
        }
    }
    addProfile(profile) {
        this._profiles.add(profile);
    }
    addRun(runId, runName, isRunning) {
        const run = new TestRunImpl(this, this.proxy, runId, runName);
        run.isRunning = isRunning;
        this._runs.add(run);
        return run;
    }
    removeProfile(profileId) {
        this._profiles.remove(this.withProfile(profileId));
    }
    get testRuns() {
        return this._runs.values;
    }
    get tests() {
        return this.items.values;
    }
    resolveChildren(item) {
        if (this.canResolveChildren) {
            this.proxy.$onResolveChildren(this.id, itemToPath(item));
        }
    }
    clearRuns() {
        this._runs.clear();
    }
}
class TestingMainImpl {
    constructor(rpc, container, commandRegistry) {
        this.controllerRegistrations = new Map();
        this.testService = container.get(test_service_1.TestService);
        this.testExecutionProgressService = container.get(test_execution_progress_service_1.TestExecutionProgressService);
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.TESTING_EXT);
        commandRegistry.registerArgumentProcessor({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            processArgument(arg) {
                if (arg instanceof TestItemImpl) {
                    if (!arg.controller || !arg.path) {
                        throw new Error(`Passing unattached test item ${arg.id} as a command argument`);
                    }
                    return test_types_1.TestItemReference.create(arg.controller.id, arg.path);
                }
                return arg;
            }
        });
    }
    $registerTestController(controllerId, label) {
        const controller = new TestControllerImpl(this.proxy, controllerId, label);
        this.controllerRegistrations.set(controllerId, [controller, this.testService.registerTestController(controller)]);
    }
    $updateController(controllerId, patch) {
        this.withController(controllerId).update(patch);
    }
    $unregisterTestController(controllerId) {
        const registered = this.controllerRegistrations.get(controllerId);
        if (registered) {
            this.controllerRegistrations.delete(controllerId);
            registered[1].dispose();
        }
    }
    withController(controllerId) {
        const registration = this.controllerRegistrations.get(controllerId);
        if (!registration) {
            throw new Error(`No test controller with id ${controllerId} found`);
        }
        return registration[0];
    }
    $notifyDelta(controllerId, diff) {
        this.withController(controllerId).applyDelta(diff);
    }
    $notifyTestRunProfileCreated(controllerId, profile) {
        const registration = this.controllerRegistrations.get(controllerId);
        if (!registration) {
            throw new Error(`No test controller with id ${controllerId} found`);
        }
        registration[0].addProfile(new TestRunProfileImpl(this.proxy, controllerId, profile.id, profile.kind, profile.label, profile.isDefault, profile.tag));
    }
    $updateTestRunProfile(controllerId, profileId, update) {
        this.withController(controllerId).withProfile(profileId).update(update);
    }
    $removeTestRunProfile(controllerId, profileId) {
        this.withController(controllerId).removeProfile(profileId);
    }
    $notifyTestRunCreated(controllerId, run, preserveFocus) {
        this.testExecutionProgressService.onTestRunRequested(preserveFocus);
        this.withController(controllerId).addRun(run.id, run.name, run.isRunning);
    }
    $notifyTestStateChanged(controllerId, runId, stateChanges, outputChanges) {
        this.withController(controllerId).withRun(runId).applyChanges(stateChanges, outputChanges);
    }
    $notifyTestRunEnded(controllerId, runId) {
        this.withController(controllerId).withRun(runId).ended();
    }
}
exports.TestingMainImpl = TestingMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorPropertiesMain = exports.TextEditorMain = void 0;
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const editor_options_1 = __webpack_require__(/*! ../../common/editor-options */ "../node_modules/@theia/plugin-ext/lib/common/editor-options.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const simple_monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/simple-monaco-editor */ "../node_modules/@theia/monaco/lib/browser/simple-monaco-editor.js");
class TextEditorMain {
    constructor(id, model, editor) {
        this.id = id;
        this.model = model;
        this.onPropertiesChangedEmitter = new core_1.Emitter();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.properties = undefined), this.onPropertiesChangedEmitter);
        this.toDisposeOnEditor = new disposable_1.DisposableCollection();
        this.toDispose.push(this.model.onDidChangeOptions(() => this.updateProperties(undefined)));
        this.setEditor(editor);
        this.updateProperties(undefined);
    }
    dispose() {
        this.toDispose.dispose();
    }
    updateProperties(source) {
        this.setProperties(TextEditorPropertiesMain.readFromEditor(this.properties, this.model, this.editor), source);
    }
    setProperties(newProperties, source) {
        const result = newProperties.generateDelta(this.properties, source);
        this.properties = newProperties;
        if (result) {
            this.onPropertiesChangedEmitter.fire(result);
        }
    }
    setEditor(editor) {
        if (this.editor === editor) {
            return;
        }
        this.toDisposeOnEditor.dispose();
        this.toDispose.push(this.toDisposeOnEditor);
        this.editor = editor;
        this.toDisposeOnEditor.push(disposable_1.Disposable.create(() => this.editor = undefined));
        if (this.editor) {
            const monacoEditor = this.editor.getControl();
            this.toDisposeOnEditor.push(this.editor.onSelectionChanged(_ => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeModel(() => {
                this.setEditor(undefined);
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeCursorSelection(e => {
                this.updateProperties(e.source);
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeConfiguration(() => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidLayoutChange(() => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidScrollChange(() => {
                this.updateProperties();
            }));
            this.updateProperties();
        }
    }
    getId() {
        return this.id;
    }
    getModel() {
        return this.model;
    }
    getProperties() {
        return this.properties;
    }
    get onPropertiesChangedEvent() {
        return this.onPropertiesChangedEmitter.event;
    }
    setSelections(selections) {
        if (this.editor) {
            this.editor.getControl().setSelections(selections);
            return;
        }
        const monacoSelections = selections.map(TextEditorMain.toMonacoSelections);
        this.setProperties(new TextEditorPropertiesMain(monacoSelections, this.properties.options, this.properties.visibleRanges), undefined);
    }
    setConfiguration(newConfiguration) {
        this.setIndentConfiguration(newConfiguration);
        if (!this.editor) {
            return;
        }
        if (newConfiguration.cursorStyle) {
            const newCursorStyle = (0, editor_options_1.cursorStyleToString)(newConfiguration.cursorStyle);
            this.editor.getControl().updateOptions({
                cursorStyle: newCursorStyle
            });
        }
        if (typeof newConfiguration.lineNumbers !== 'undefined') {
            let lineNumbers;
            switch (newConfiguration.lineNumbers) {
                case types_impl_1.TextEditorLineNumbersStyle.On:
                    lineNumbers = 'on';
                    break;
                case types_impl_1.TextEditorLineNumbersStyle.Relative:
                    lineNumbers = 'relative';
                    break;
                case types_impl_1.TextEditorLineNumbersStyle.Interval:
                    lineNumbers = 'interval';
                    break;
                default:
                    lineNumbers = 'off';
            }
            this.editor.getControl().updateOptions({
                lineNumbers: lineNumbers
            });
        }
    }
    setIndentConfiguration(newConfiguration) {
        if (newConfiguration.tabSize === 'auto' || newConfiguration.insertSpaces === 'auto') {
            const creationOpts = this.model.getOptions();
            let insertSpaces = creationOpts.insertSpaces;
            let tabSize = creationOpts.tabSize;
            if (newConfiguration.insertSpaces !== 'auto' && typeof newConfiguration.insertSpaces !== 'undefined') {
                insertSpaces = newConfiguration.insertSpaces;
            }
            if (newConfiguration.tabSize !== 'auto' && typeof newConfiguration.tabSize !== 'undefined') {
                tabSize = newConfiguration.tabSize;
            }
            this.model.detectIndentation(insertSpaces, tabSize);
            return;
        }
        const newOpts = {};
        if (typeof newConfiguration.insertSpaces !== 'undefined') {
            newOpts.insertSpaces = newConfiguration.insertSpaces;
        }
        if (typeof newConfiguration.tabSize !== 'undefined') {
            newOpts.tabSize = newConfiguration.tabSize;
        }
        if (typeof newConfiguration.indentSize !== 'undefined') {
            if (newConfiguration.indentSize === 'tabSize') {
                newOpts.indentSize = newConfiguration.tabSize;
            }
            else if (typeof newConfiguration.indentSize == 'number') {
                newOpts.indentSize = newConfiguration.indentSize;
            }
        }
        this.model.updateOptions(newOpts);
    }
    revealRange(range, revealType) {
        if (!this.editor || this.editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            return;
        }
        switch (revealType) {
            case plugin_api_rpc_1.TextEditorRevealType.Default:
                this.editor.getControl().revealRange(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.InCenter:
                this.editor.getControl().revealRangeInCenter(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.InCenterIfOutsideViewport:
                this.editor.getControl().revealRangeInCenterIfOutsideViewport(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.AtTop:
                this.editor.getControl().revealRangeAtTop(range, monaco.editor.ScrollType.Smooth);
                break;
            default:
                console.warn(`Unknown revealType: ${revealType}`);
                break;
        }
    }
    applyEdits(versionId, edits, opts) {
        if (this.model.getVersionId() !== versionId) {
            // model changed in the meantime
            return false;
        }
        if (!this.editor) {
            return false;
        }
        if (opts.setEndOfLine === types_impl_1.EndOfLine.CRLF && !this.isSimpleWidget(this.model)) {
            this.model.setEOL(monaco.editor.EndOfLineSequence.CRLF);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.LF && !this.isSimpleWidget(this.model)) {
            this.model.setEOL(monaco.editor.EndOfLineSequence.LF);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.CRLF && this.isSimpleWidget(this.model)) {
            this.model.setEOL(1 /* EndOfLineSequence.CRLF */);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.LF && this.isSimpleWidget(this.model)) {
            this.model.setEOL(1 /* EndOfLineSequence.CRLF */);
        }
        const editOperations = [];
        for (const edit of edits) {
            const { range, text } = edit;
            if (!range && !text) {
                continue;
            }
            if (range && range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn && !edit.text) {
                continue;
            }
            editOperations.push({
                range: range ? monaco.Range.lift(range) : this.editor.getControl().getModel().getFullModelRange(),
                /* eslint-disable-next-line no-null/no-null */
                text: text || null,
                forceMoveMarkers: edit.forceMoveMarkers
            });
        }
        if (opts.undoStopBefore) {
            this.editor.getControl().pushUndoStop();
        }
        this.editor.getControl().executeEdits('MainThreadTextEditor', editOperations);
        if (opts.undoStopAfter) {
            this.editor.getControl().pushUndoStop();
        }
        return true;
    }
    insertSnippet(template, ranges, opts) {
        var _a;
        const snippetController = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().getContribution('snippetController2');
        if (!snippetController || !this.editor) {
            return false;
        }
        const selections = ranges.map(r => new monaco.Selection(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn));
        this.editor.getControl().setSelections(selections);
        this.editor.focus();
        snippetController.insert(template, 0, 0, opts.undoStopBefore, opts.undoStopAfter);
        return true;
    }
    setDecorations(key, ranges) {
        if (!this.editor) {
            return;
        }
        this.editor.getControl()
            .setDecorationsByType('Plugin decorations', key, ranges.map(option => Object.assign(option, { color: undefined })));
    }
    setDecorationsFast(key, _ranges) {
        if (!this.editor) {
            return;
        }
        const ranges = [];
        const len = Math.floor(_ranges.length / 4);
        for (let i = 0; i < len; i++) {
            ranges[i] = new monaco.Range(_ranges[4 * i], _ranges[4 * i + 1], _ranges[4 * i + 2], _ranges[4 * i + 3]);
        }
        this.editor.getControl().setDecorationsByTypeFast(key, ranges);
    }
    static toMonacoSelections(selection) {
        return new monaco.Selection(selection.selectionStartLineNumber, selection.selectionStartColumn, selection.positionLineNumber, selection.positionColumn);
    }
    isSimpleWidget(model) {
        return !!model.isForSimpleWidget;
    }
}
exports.TextEditorMain = TextEditorMain;
class TextEditorPropertiesMain {
    constructor(selections, options, visibleRanges) {
        this.selections = selections;
        this.options = options;
        this.visibleRanges = visibleRanges;
    }
    generateDelta(old, source) {
        const result = {
            options: undefined,
            selections: undefined,
            visibleRanges: undefined
        };
        if (!old || !TextEditorPropertiesMain.selectionsEqual(old.selections, this.selections)) {
            result.selections = {
                selections: this.selections,
                source: source
            };
        }
        if (!old || !TextEditorPropertiesMain.optionsEqual(old.options, this.options)) {
            result.options = this.options;
        }
        if (!old || !TextEditorPropertiesMain.rangesEqual(old.visibleRanges, this.visibleRanges)) {
            result.visibleRanges = this.visibleRanges;
        }
        if (result.selections || result.visibleRanges || result.options) {
            return result;
        }
        return undefined;
    }
    static readFromEditor(prevProperties, model, editor) {
        const selections = TextEditorPropertiesMain.getSelectionsFromEditor(prevProperties, editor);
        const options = TextEditorPropertiesMain.getOptionsFromEditor(prevProperties, model, editor);
        const visibleRanges = TextEditorPropertiesMain.getVisibleRangesFromEditor(prevProperties, editor);
        return new TextEditorPropertiesMain(selections, options, visibleRanges);
    }
    static getSelectionsFromEditor(prevProperties, editor) {
        var _a;
        let result = undefined;
        if (editor && editor instanceof monaco_editor_1.MonacoEditor) {
            result = editor.getControl().getSelections() || undefined;
        }
        else if (editor && editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            result = (_a = editor.getControl().getSelections()) === null || _a === void 0 ? void 0 : _a.map(selection => {
                const monacoSelection = new monaco.Selection(selection.selectionStartLineNumber, selection.selectionStartColumn, selection.positionLineNumber, selection.positionColumn);
                monacoSelection.setStartPosition(selection.startLineNumber, selection.startColumn);
                monacoSelection.setEndPosition(selection.endLineNumber, selection.endColumn);
                return monacoSelection;
            });
        }
        if (!result && prevProperties) {
            result = prevProperties.selections;
        }
        if (!result) {
            result = [new monaco.Selection(1, 1, 1, 1)];
        }
        return result;
    }
    static getOptionsFromEditor(prevProperties, model, editor) {
        if (model.isDisposed()) {
            return prevProperties.options;
        }
        let cursorStyle;
        let lineNumbers;
        if (editor && editor instanceof monaco_editor_1.MonacoEditor) {
            const editorOptions = editor.getControl().getOptions();
            const lineNumbersOpts = editorOptions.get(monaco.editor.EditorOption.lineNumbers);
            cursorStyle = editorOptions.get(monaco.editor.EditorOption.cursorStyle);
            switch (lineNumbersOpts.renderType) {
                case monaco.editor.RenderLineNumbersType.Off:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Off;
                    break;
                case monaco.editor.RenderLineNumbersType.Relative:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Relative;
                    break;
                case monaco.editor.RenderLineNumbersType.Interval:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Interval;
                    break;
                default:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
                    break;
            }
        }
        else if (editor && editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            const editorOptions = editor.getControl().getOptions();
            const lineNumbersOpts = editorOptions.get(69 /* EditorOption.lineNumbers */);
            cursorStyle = editorOptions.get(28 /* EditorOption.cursorStyle */);
            switch (lineNumbersOpts.renderType) {
                case 0 /* RenderLineNumbersType.Off */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Off;
                    break;
                case 2 /* RenderLineNumbersType.Relative */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Relative;
                    break;
                case 3 /* RenderLineNumbersType.Interval */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Interval;
                    break;
                default:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
                    break;
            }
        }
        else if (prevProperties) {
            cursorStyle = prevProperties.options.cursorStyle;
            lineNumbers = prevProperties.options.lineNumbers;
        }
        else {
            cursorStyle = editor_options_1.TextEditorCursorStyle.Line;
            lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
        }
        const modelOptions = model.getOptions();
        return {
            insertSpaces: modelOptions.insertSpaces,
            indentSize: modelOptions.indentSize,
            tabSize: modelOptions.tabSize,
            cursorStyle,
            lineNumbers,
        };
    }
    static getVisibleRangesFromEditor(prevProperties, editor) {
        if (editor) {
            return editor.getControl().getVisibleRanges();
        }
        return [];
    }
    static selectionsEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!a[i].equalsSelection(b[i])) {
                return false;
            }
        }
        return true;
    }
    static optionsEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        return (a.tabSize === b.tabSize
            && a.insertSpaces === b.insertSpaces
            && a.indentSize === b.indentSize
            && a.cursorStyle === b.cursorStyle
            && a.lineNumbers === b.lineNumbers);
    }
    static rangesEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!a[i].equalsRange(b[i])) {
                return false;
            }
        }
        return true;
    }
}
exports.TextEditorPropertiesMain = TextEditorPropertiesMain;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorModelService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const monaco_text_model_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-text-model-service */ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const monaco_workspace_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-workspace */ "../node_modules/@theia/monaco/lib/browser/monaco-workspace.js");
const uri_components_1 = __webpack_require__(/*! ../../common/uri-components */ "../node_modules/@theia/plugin-ext/lib/common/uri-components.js");
let EditorModelService = class EditorModelService {
    constructor(monacoModelService, monacoWorkspace) {
        this.modelModeChangedEmitter = new core_1.Emitter();
        this.onModelRemovedEmitter = new core_1.Emitter();
        this.modelDirtyEmitter = new core_1.Emitter();
        this.modelSavedEmitter = new core_1.Emitter();
        this.onModelWillSavedEmitter = new core_1.Emitter();
        this.onModelDirtyChanged = this.modelDirtyEmitter.event;
        this.onModelSaved = this.modelSavedEmitter.event;
        this.onModelModeChanged = this.modelModeChangedEmitter.event;
        this.onModelRemoved = this.onModelRemovedEmitter.event;
        this.onModelWillSave = this.onModelWillSavedEmitter.event;
        this.monacoModelService = monacoModelService;
        monacoModelService.models.forEach(model => this.modelCreated(model));
        monacoModelService.onDidCreate(this.modelCreated, this);
        monacoWorkspace.onDidCloseTextDocument(model => {
            setTimeout(() => {
                this.onModelRemovedEmitter.fire(model);
            }, 1);
        });
    }
    modelCreated(model) {
        model.textEditorModel.onDidChangeLanguage(e => {
            this.modelModeChangedEmitter.fire({ model, oldModeId: e.oldLanguage });
        });
        model.onDidSaveModel(_ => {
            this.modelSavedEmitter.fire(model);
        });
        model.onDirtyChanged(_ => {
            this.modelDirtyEmitter.fire(model);
        });
        model.onWillSaveModel(willSaveModelEvent => {
            this.onModelWillSavedEmitter.fire(willSaveModelEvent);
        });
    }
    get onModelAdded() {
        return this.monacoModelService.onDidCreate;
    }
    getModels() {
        return this.monacoModelService.models;
    }
    async save(uri) {
        const model = this.monacoModelService.get(uri.toString());
        if (model) {
            await model.save();
            return true;
        }
        return false;
    }
    async saveAll(includeUntitled) {
        const saves = [];
        for (const model of this.monacoModelService.models) {
            const { uri } = model.textEditorModel;
            if (model.dirty && (includeUntitled || uri.scheme !== uri_components_1.Schemes.untitled)) {
                saves.push((async () => {
                    try {
                        await model.save();
                        return true;
                    }
                    catch (e) {
                        console.error('Failed to save ', uri.toString(), e);
                        return false;
                    }
                })());
            }
        }
        const results = await Promise.all(saves);
        return results.reduce((a, b) => a && b, true);
    }
    async createModelReference(uri) {
        return this.monacoModelService.createModelReference(uri);
    }
};
exports.EditorModelService = EditorModelService;
exports.EditorModelService = EditorModelService = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(monaco_text_model_service_1.MonacoTextModelService)),
    tslib_1.__param(1, (0, inversify_1.inject)(monaco_workspace_1.MonacoWorkspace)),
    tslib_1.__metadata("design:paramtypes", [monaco_text_model_service_1.MonacoTextModelService,
        monaco_workspace_1.MonacoWorkspace])
], EditorModelService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const errors_1 = __webpack_require__(/*! ../../common/errors */ "../node_modules/@theia/plugin-ext/lib/common/errors.js");
const languages_main_1 = __webpack_require__(/*! ./languages-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js");
const monaco_bulk_edit_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-bulk-edit-service */ "../node_modules/@theia/monaco/lib/browser/monaco-bulk-edit-service.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../node_modules/@theia/core/lib/browser/endpoint.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const bulkEditService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/services/bulkEditService */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/services/bulkEditService.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const codeEditorService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const notebooks_main_1 = __webpack_require__(/*! ./notebooks/notebooks-main */ "../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../node_modules/@theia/notebook/lib/browser/index.js");
class TextEditorsMainImpl {
    constructor(editorsAndDocuments, documents, rpc, container) {
        this.editorsAndDocuments = editorsAndDocuments;
        this.documents = documents;
        this.toDispose = new disposable_1.DisposableCollection();
        this.editorsToDispose = new Map();
        this.fileEndpoint = new endpoint_1.Endpoint({ path: 'file' }).getRestUrl();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TEXT_EDITORS_EXT);
        this.bulkEditService = container.get(monaco_bulk_edit_service_1.MonacoBulkEditService);
        this.notebookService = container.get(browser_1.NotebookService);
        this.toDispose.push(editorsAndDocuments);
        this.toDispose.push(editorsAndDocuments.onTextEditorAdd(editors => editors.forEach(this.onTextEditorAdd, this)));
        this.toDispose.push(editorsAndDocuments.onTextEditorRemove(editors => editors.forEach(this.onTextEditorRemove, this)));
    }
    dispose() {
        this.toDispose.dispose();
    }
    onTextEditorAdd(editor) {
        const id = editor.getId();
        const toDispose = new disposable_1.DisposableCollection(editor.onPropertiesChangedEvent(e => {
            this.proxy.$acceptEditorPropertiesChanged(id, e);
        }), disposable_1.Disposable.create(() => this.editorsToDispose.delete(id)));
        this.editorsToDispose.set(id, toDispose);
        this.toDispose.push(toDispose);
    }
    onTextEditorRemove(id) {
        const disposables = this.editorsToDispose.get(id);
        if (disposables) {
            disposables.dispose();
        }
    }
    $tryShowTextDocument(uri, options) {
        return this.documents.$tryShowDocument(uri, options);
    }
    $trySetOptions(id, options) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor: ${id}`));
        }
        this.editorsAndDocuments.getEditor(id).setConfiguration(options);
        return Promise.resolve();
    }
    $trySetSelections(id, selections) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor: ${id}`));
        }
        this.editorsAndDocuments.getEditor(id).setSelections(selections);
        return Promise.resolve();
    }
    $tryRevealRange(id, range, revealType) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).revealRange(new monaco.Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn), revealType);
        return Promise.resolve();
    }
    $tryApplyEdits(id, modelVersionId, edits, opts) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        return Promise.resolve(this.editorsAndDocuments.getEditor(id).applyEdits(modelVersionId, edits, opts));
    }
    async $tryApplyWorkspaceEdit(dto, metadata) {
        const [notebookEdits, monacoEdits] = core_1.ArrayUtils.partition(dto.edits, edit => plugin_api_rpc_1.WorkspaceNotebookCellEditDto.is(edit));
        try {
            if (notebookEdits.length > 0) {
                const workspaceEdit = (0, notebooks_main_1.toNotebookWorspaceEdit)({ edits: notebookEdits });
                return this.notebookService.applyWorkspaceEdit(workspaceEdit);
            }
            if (monacoEdits.length > 0) {
                const workspaceEdit = (0, languages_main_1.toMonacoWorkspaceEdit)({ edits: monacoEdits });
                const edits = bulkEditService_1.ResourceEdit.convert(workspaceEdit);
                const { isApplied } = await this.bulkEditService.apply(edits, { respectAutoSaveConfig: metadata === null || metadata === void 0 ? void 0 : metadata.isRefactoring });
                return isApplied;
            }
            return false;
        }
        catch {
            return false;
        }
    }
    $tryInsertSnippet(id, template, ranges, opts) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        return Promise.resolve(this.editorsAndDocuments.getEditor(id).insertSnippet(template, ranges, opts));
    }
    $registerTextEditorDecorationType(key, options) {
        this.injectRemoteUris(options);
        standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService).registerDecorationType('Plugin decoration', key, options);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$removeTextEditorDecorationType(key)));
    }
    injectRemoteUris(options) {
        if (options.before) {
            options.before.contentIconPath = this.toRemoteUri(options.before.contentIconPath);
        }
        if (options.after) {
            options.after.contentIconPath = this.toRemoteUri(options.after.contentIconPath);
        }
        if ('gutterIconPath' in options) {
            options.gutterIconPath = this.toRemoteUri(options.gutterIconPath);
        }
        if ('dark' in options && options.dark) {
            this.injectRemoteUris(options.dark);
        }
        if ('light' in options && options.light) {
            this.injectRemoteUris(options.light);
        }
    }
    toRemoteUri(uri) {
        if (uri && uri.scheme === 'file') {
            return this.fileEndpoint.withQuery(core_1.URI.fromComponents(uri).toString()).toComponents();
        }
        return uri;
    }
    $removeTextEditorDecorationType(key) {
        standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService).removeDecorationType(key);
    }
    $tryHideEditor(id) {
        return this.editorsAndDocuments.hideEditor(id);
    }
    $trySetDecorations(id, key, ranges) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).setDecorations(key, ranges);
        return Promise.resolve();
    }
    $trySetDecorationsFast(id, key, ranges) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).setDecorationsFast(key, ranges);
        return Promise.resolve();
    }
    $save(uri) {
        return this.editorsAndDocuments.save(core_1.URI.fromComponents(uri)).then(u => u === null || u === void 0 ? void 0 : u.toComponents());
    }
    $saveAs(uri) {
        return this.editorsAndDocuments.saveAs(core_1.URI.fromComponents(uri)).then(u => u === null || u === void 0 ? void 0 : u.toComponents());
    }
    $saveAll(includeUntitled) {
        return this.editorsAndDocuments.saveAll(includeUntitled);
    }
}
exports.TextEditorsMainImpl = TextEditorsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemingMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/bafca191f55a234fad20ab67bb689aacc80e7a1a/src/vs/workbench/api/browser/mainThreadTheming.ts
class ThemingMainImpl {
    constructor(rpc, themeService) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.THEMING_EXT);
        this.themeChangeListener = themeService.onDidColorThemeChange(e => this.proxy.$onColorThemeChange(e.newTheme.type));
        this.proxy.$onColorThemeChange(themeService.getCurrentTheme().type);
    }
    dispose() {
        this.themeChangeListener.dispose();
    }
}
exports.ThemingMainImpl = ThemingMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const timeline_service_1 = __webpack_require__(/*! @theia/timeline/lib/browser/timeline-service */ "../node_modules/@theia/timeline/lib/browser/timeline-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/afacd2bdfe7060f09df9b9139521718915949757/src/vs/workbench/api/browser/mainThreadTimeline.ts
class TimelineMainImpl {
    constructor(rpc, container) {
        this.providerEmitters = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TIMELINE_EXT);
        this.timelineService = container.get(timeline_service_1.TimelineService);
    }
    async $registerTimelineProvider(provider) {
        const proxy = this.proxy;
        const emitters = this.providerEmitters;
        let onDidChange = emitters.get(provider.id);
        if (onDidChange === undefined) {
            onDidChange = new common_1.Emitter();
            emitters.set(provider.id, onDidChange);
        }
        this.timelineService.registerTimelineProvider({
            ...provider,
            onDidChange: onDidChange.event,
            provideTimeline(uri, options, internalOptions) {
                return proxy.$getTimeline(provider.id, uri, options, internalOptions);
            },
            dispose() {
                emitters.delete(provider.id);
                if (onDidChange) {
                    onDidChange.dispose();
                }
            }
        });
    }
    async $unregisterTimelineProvider(id) {
        this.timelineService.unregisterTimelineProvider(id);
    }
    async $fireTimelineChanged(e) {
        const emitter = this.providerEmitters.get(e.id);
        if (emitter) {
            emitter.fire(e);
        }
    }
}
exports.TimelineMainImpl = TimelineMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UriMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
class UriMainImpl {
    constructor(rpc, container) {
        var _a, _b;
        this.handlers = new Set();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.URI_EXT);
        this.openerService = container.get(browser_1.OpenerService);
        this.pluginSupport = container.get(hosted_plugin_1.HostedPluginSupport);
        this.openHandler = {
            id: 'theia-plugin-open-handler',
            canHandle: async (uri, options) => {
                if (uri.scheme !== frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().electron.uriScheme) {
                    return 0;
                }
                await this.pluginSupport.activateByUri(uri.scheme, uri.authority);
                if (this.handlers.has(uri.authority)) {
                    return 500;
                }
                return 0;
            },
            open: async (uri, options) => {
                if (!this.handlers.has(uri.authority)) {
                    throw new Error(`No plugin to handle this uri: : '${uri}'`);
                }
                this.proxy.$handleExternalUri(uri.toComponents());
            }
        };
        (_b = (_a = this.openerService).addHandler) === null || _b === void 0 ? void 0 : _b.call(_a, this.openHandler);
    }
    dispose() {
        var _a, _b;
        (_b = (_a = this.openerService).removeHandler) === null || _b === void 0 ? void 0 : _b.call(_a, this.openHandler);
        this.handlers.clear();
    }
    async $registerUriHandler(pluginId, extensionDisplayName) {
        this.handlers.add(pluginId);
    }
    async $unregisterUriHandler(pluginId) {
        this.handlers.delete(pluginId);
    }
}
exports.UriMainImpl = UriMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DnDFileContentStore_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnDFileContentStore = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
let DnDFileContentStore = DnDFileContentStore_1 = class DnDFileContentStore {
    constructor() {
        this.files = new Map();
    }
    addFile(f) {
        const id = (DnDFileContentStore_1.id++).toString();
        this.files.set(id, f);
        return id;
    }
    removeFile(id) {
        return this.files.delete(id);
    }
    getFile(id) {
        const file = this.files.get(id);
        if (file) {
            return file;
        }
        throw new Error(`File with id ${id} not found in dnd operation`);
    }
};
exports.DnDFileContentStore = DnDFileContentStore;
DnDFileContentStore.id = 0;
exports.DnDFileContentStore = DnDFileContentStore = DnDFileContentStore_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DnDFileContentStore);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginViewRegistry_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginViewRegistry = exports.PLUGIN_VIEW_DATA_FACTORY_ID = exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID = exports.PLUGIN_VIEW_FACTORY_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../node_modules/@theia/plugin-ext/lib/common/index.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const debug_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-widget */ "../node_modules/@theia/debug/lib/browser/view/debug-widget.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./plugin-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const scm_contribution_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-contribution */ "../node_modules/@theia/scm/lib/browser/scm-contribution.js");
const browser_2 = __webpack_require__(/*! @theia/navigator/lib/browser */ "../node_modules/@theia/navigator/lib/browser/index.js");
const navigator_contribution_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-contribution */ "../node_modules/@theia/navigator/lib/browser/navigator-contribution.js");
const debug_frontend_application_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-frontend-application-contribution */ "../node_modules/@theia/debug/lib/browser/debug-frontend-application-contribution.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../node_modules/@theia/core/lib/common/menu/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const view_context_key_service_1 = __webpack_require__(/*! ./view-context-key-service */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js");
const problem_widget_1 = __webpack_require__(/*! @theia/markers/lib/browser/problem/problem-widget */ "../node_modules/@theia/markers/lib/browser/problem/problem-widget.js");
const output_widget_1 = __webpack_require__(/*! @theia/output/lib/browser/output-widget */ "../node_modules/@theia/output/lib/browser/output-widget.js");
const debug_console_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/console/debug-console-contribution */ "../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js");
const search_in_workspace_factory_1 = __webpack_require__(/*! @theia/search-in-workspace/lib/browser/search-in-workspace-factory */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-factory.js");
const test_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../node_modules/@theia/core/lib/common/uuid.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
exports.PLUGIN_VIEW_FACTORY_ID = 'plugin-view';
exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID = 'plugin-view-container';
exports.PLUGIN_VIEW_DATA_FACTORY_ID = 'plugin-view-data';
let PluginViewRegistry = PluginViewRegistry_1 = class PluginViewRegistry {
    constructor() {
        this.onDidExpandViewEmitter = new event_1.Emitter();
        this.onDidExpandView = this.onDidExpandViewEmitter.event;
        this.views = new Map();
        this.viewsWelcome = new Map();
        this.viewContainers = new Map();
        this.containerViews = new Map();
        this.viewClauseContexts = new Map();
        this.viewDataProviders = new Map();
        this.viewDataState = new Map();
        this.webviewViewResolvers = new Map();
        this.onNewResolverRegisteredEmitter = new event_1.Emitter();
        this.onNewResolverRegistered = this.onNewResolverRegisteredEmitter.event;
        this.webviewViewRevivals = new Map();
        this.nextViewContainerId = 0;
    }
    init() {
        // TODO workbench.panel.comments - Theia does not have a proper comments view yet
        this.updateFocusedView();
        this.shell.onDidChangeActiveWidget(() => this.updateFocusedView());
        this.widgetManager.onWillCreateWidget(({ factoryId, widget, waitUntil }) => {
            if (factoryId === browser_2.EXPLORER_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('explorer', widget));
            }
            if (factoryId === scm_contribution_1.SCM_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('scm', widget));
            }
            if (factoryId === search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('search', widget));
            }
            if (factoryId === test_view_contribution_1.TEST_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('test', widget));
            }
            if (factoryId === debug_widget_1.DebugWidget.ID && widget instanceof debug_widget_1.DebugWidget) {
                const viewContainer = widget['sessionWidget']['viewContainer'];
                waitUntil(this.prepareViewContainer('debug', viewContainer));
            }
            if (factoryId === exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer(this.toViewContainerId(widget.options), widget));
            }
            if (factoryId === exports.PLUGIN_VIEW_FACTORY_ID && widget instanceof plugin_view_widget_1.PluginViewWidget) {
                waitUntil(this.prepareView(widget));
            }
        });
        this.widgetManager.onDidCreateWidget(event => {
            if (event.widget instanceof browser_2.FileNavigatorWidget) {
                const disposable = new disposable_1.DisposableCollection();
                disposable.push(this.registerViewWelcome({
                    view: 'explorer',
                    content: core_1.nls.localizeByDefault('You have not yet opened a folder.\n{0}', `[${core_1.nls.localizeByDefault('Open Folder')}](command:workbench.action.files.openFolder)`),
                    order: 0
                }));
                disposable.push(event.widget.onDidDispose(() => disposable.dispose()));
            }
        });
        this.contextKeyService.onDidChange(e => {
            for (const [, view] of this.views.values()) {
                const clauseContext = this.viewClauseContexts.get(view.id);
                if (clauseContext && e.affects(clauseContext)) {
                    this.updateViewVisibility(view.id);
                }
            }
            for (const [viewId, viewWelcomes] of this.viewsWelcome) {
                for (const [index] of viewWelcomes.entries()) {
                    const viewWelcomeId = this.toViewWelcomeId(index, viewId);
                    const clauseContext = this.viewClauseContexts.get(viewWelcomeId);
                    if (clauseContext && e.affects(clauseContext)) {
                        this.updateViewWelcomeVisibility(viewId);
                    }
                }
            }
        });
        const hookDockPanelKey = (panel, key) => {
            let toDisposeOnActivate = new disposable_1.DisposableCollection();
            panel.onDidChangeCurrent(title => {
                toDisposeOnActivate.dispose();
                toDisposeOnActivate = new disposable_1.DisposableCollection();
                if (title && title.owner instanceof browser_1.BaseWidget) {
                    const widget = title.owner;
                    let value = PluginViewRegistry_1.ID_MAPPINGS.get(widget.id);
                    if (!value) {
                        if (widget.id.startsWith(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID)) {
                            value = this.toViewContainerId({ id: widget.id });
                        }
                    }
                    const setKey = () => {
                        if (widget.isVisible && value) {
                            key.set(value);
                        }
                        else {
                            key.reset();
                        }
                    };
                    toDisposeOnActivate.push(widget.onDidChangeVisibility(() => {
                        setKey();
                    }));
                    setKey();
                }
            });
        };
        hookDockPanelKey(this.shell.leftPanelHandler.dockPanel, this.viewContextKeys.activeViewlet);
        hookDockPanelKey(this.shell.rightPanelHandler.dockPanel, this.viewContextKeys.activeAuxiliary);
        hookDockPanelKey(this.shell.bottomPanel, this.viewContextKeys.activePanel);
    }
    async updateViewWelcomeVisibility(viewId) {
        const widget = await this.getTreeViewWelcomeWidget(viewId);
        if (widget) {
            widget.handleWelcomeContextChange();
        }
    }
    async updateViewVisibility(viewId) {
        const widget = await this.getView(viewId);
        if (!widget) {
            if (this.isViewVisible(viewId)) {
                await this.openView(viewId);
            }
            return;
        }
        const viewInfo = this.views.get(viewId);
        if (!viewInfo) {
            return;
        }
        const [viewContainerId] = viewInfo;
        const viewContainer = await this.getPluginViewContainer(viewContainerId);
        if (!viewContainer) {
            return;
        }
        const part = viewContainer.getPartFor(widget);
        if (!part) {
            return;
        }
        widget.updateViewVisibility(() => part.setHidden(!this.isViewVisible(viewId)));
    }
    isViewVisible(viewId) {
        const viewInfo = this.views.get(viewId);
        if (!viewInfo) {
            return false;
        }
        const [, view] = viewInfo;
        return view.when === undefined || view.when === 'true' || this.contextKeyService.match(view.when);
    }
    registerViewContainer(location, viewContainer) {
        var _a;
        const containerId = `workbench.view.extension.${viewContainer.id}`;
        if (this.viewContainers.has(containerId)) {
            console.warn('view container such id already registered: ', JSON.stringify(viewContainer));
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        const containerClass = 'theia-plugin-view-container';
        let themeIconClass = '';
        const iconClass = 'plugin-view-container-icon-' + this.nextViewContainerId++; // having dots in class would not work for css, so we need to generate an id.
        if (viewContainer.themeIcon) {
            const icon = themables_1.ThemeIcon.fromString(viewContainer.themeIcon);
            if (icon) {
                themeIconClass = (_a = themables_1.ThemeIcon.asClassName(icon)) !== null && _a !== void 0 ? _a : '';
            }
        }
        if (!themeIconClass) {
            const iconUrl = plugin_shared_style_1.PluginSharedStyle.toExternalIconUrl(viewContainer.iconUrl);
            toDispose.push(this.style.insertRule('.' + containerClass + '.' + iconClass, () => `
                mask: url('${iconUrl}') no-repeat 50% 50%;
                -webkit-mask: url('${iconUrl}') no-repeat 50% 50%;
            `));
        }
        toDispose.push(this.doRegisterViewContainer(containerId, location, {
            label: viewContainer.title,
            // The container class automatically sets a mask; if we're using a theme icon, we don't want one.
            iconClass: (themeIconClass || containerClass) + ' ' + iconClass,
            closeable: true
        }));
        return toDispose;
    }
    async toggleViewContainer(id) {
        let widget = await this.getPluginViewContainer(id);
        if (widget && widget.isAttached) {
            widget.dispose();
        }
        else {
            widget = await this.openViewContainer(id);
            if (widget) {
                this.shell.activateWidget(widget.id);
            }
        }
    }
    doRegisterViewContainer(id, location, options) {
        const toDispose = new disposable_1.DisposableCollection();
        toDispose.push(disposable_1.Disposable.create(() => this.viewContainers.delete(id)));
        const toggleCommandId = `plugin.view-container.${id}.toggle`;
        // Some plugins may register empty view containers.
        // We should not register commands for them immediately, as that leads to bad UX.
        // Instead, we register commands the first time we add a view to them.
        let activate = () => {
            var _a;
            toDispose.push(this.commands.registerCommand({
                id: toggleCommandId,
                category: core_1.nls.localizeByDefault('View'),
                label: core_1.nls.localizeByDefault('Toggle {0}', options.label)
            }, {
                execute: () => this.toggleViewContainer(id)
            }));
            toDispose.push(this.menus.registerMenuAction(browser_1.CommonMenus.VIEW_VIEWS, {
                commandId: toggleCommandId,
                label: options.label
            }));
            toDispose.push((_a = this.quickView) === null || _a === void 0 ? void 0 : _a.registerItem({
                label: options.label,
                open: async () => {
                    const widget = await this.openViewContainer(id);
                    if (widget) {
                        this.shell.activateWidget(widget.id);
                    }
                }
            }));
            toDispose.push(disposable_1.Disposable.create(async () => {
                const widget = await this.getPluginViewContainer(id);
                if (widget) {
                    widget.dispose();
                }
            }));
            // Ignore every subsequent activation call
            activate = () => { };
        };
        this.viewContainers.set(id, {
            id,
            location,
            options,
            onViewAdded: () => activate()
        });
        return toDispose;
    }
    getContainerViews(viewContainerId) {
        return this.containerViews.get(viewContainerId) || [];
    }
    registerView(viewContainerId, view) {
        var _a, _b;
        if (!PluginViewRegistry_1.BUILTIN_VIEW_CONTAINERS.has(viewContainerId)) {
            // if it's not a built-in view container, it must be a contributed view container, see https://github.com/eclipse-theia/theia/issues/13249
            viewContainerId = `workbench.view.extension.${viewContainerId}`;
        }
        if (this.views.has(view.id)) {
            console.warn('view with such id already registered: ', JSON.stringify(view));
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        view.when = (_a = view.when) === null || _a === void 0 ? void 0 : _a.trim();
        this.views.set(view.id, [viewContainerId, view]);
        toDispose.push(disposable_1.Disposable.create(() => this.views.delete(view.id)));
        const containerInfo = this.viewContainers.get(viewContainerId);
        if (containerInfo) {
            containerInfo.onViewAdded();
        }
        const containerViews = this.getContainerViews(viewContainerId);
        containerViews.push(view.id);
        this.containerViews.set(viewContainerId, containerViews);
        toDispose.push(disposable_1.Disposable.create(() => {
            const index = containerViews.indexOf(view.id);
            if (index !== -1) {
                containerViews.splice(index, 1);
            }
        }));
        if (view.when && view.when !== 'false' && view.when !== 'true') {
            const keys = this.contextKeyService.parseKeys(view.when);
            if (keys) {
                this.viewClauseContexts.set(view.id, keys);
                toDispose.push(disposable_1.Disposable.create(() => this.viewClauseContexts.delete(view.id)));
            }
        }
        toDispose.push((_b = this.quickView) === null || _b === void 0 ? void 0 : _b.registerItem({
            label: view.name,
            when: view.when,
            open: () => this.openView(view.id, { activate: true })
        }));
        toDispose.push(this.commands.registerCommand({ id: `${view.id}.focus` }, {
            execute: async () => { await this.openView(view.id, { activate: true }); }
        }));
        return toDispose;
    }
    async resolveWebviewView(viewId, webview, cancellation) {
        const resolver = this.webviewViewResolvers.get(viewId);
        if (resolver) {
            return resolver.resolve(webview, cancellation);
        }
        const pendingRevival = this.webviewViewRevivals.get(viewId);
        if (pendingRevival) {
            return pendingRevival.revival.promise;
        }
        const pending = new promise_util_1.Deferred();
        this.webviewViewRevivals.set(viewId, { webview, revival: pending });
        return pending.promise;
    }
    async registerWebviewView(viewId, resolver) {
        if (this.webviewViewResolvers.has(viewId)) {
            throw new Error(`View resolver already registered for ${viewId}`);
        }
        this.webviewViewResolvers.set(viewId, resolver);
        this.onNewResolverRegisteredEmitter.fire({ viewType: viewId });
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.webviewViewResolvers.delete(viewId)));
        this.initView(viewId, toDispose);
        const pendingRevival = this.webviewViewRevivals.get(viewId);
        if (pendingRevival) {
            resolver.resolve(pendingRevival.webview, cancellation_1.CancellationToken.None).then(() => {
                this.webviewViewRevivals.delete(viewId);
                pendingRevival.revival.resolve();
            });
        }
        return toDispose;
    }
    async createNewWebviewView(viewId) {
        const webview = await this.widgetManager.getOrCreateWidget(webview_1.WebviewWidget.FACTORY_ID, {
            id: (0, uuid_1.generateUuid)(),
            viewId,
        });
        webview.setContentOptions({ allowScripts: true });
        let _description;
        let _resolved = false;
        let _pendingResolution;
        const webviewView = {
            webview,
            get onDidChangeVisibility() { return webview.onDidChangeVisibility; },
            get onDidDispose() { return webview.onDidDispose; },
            get title() { return webview.title.label; },
            set title(value) { webview.title.label = value || ''; },
            get description() { return _description; },
            set description(value) { _description = value; },
            get badge() { return webview.badge; },
            set badge(badge) { webview.badge = badge; },
            get badgeTooltip() { return webview.badgeTooltip; },
            set badgeTooltip(badgeTooltip) { webview.badgeTooltip = badgeTooltip; },
            onDidChangeBadge: webview.onDidChangeBadge,
            onDidChangeBadgeTooltip: webview.onDidChangeBadgeTooltip,
            dispose: () => {
                _resolved = false;
                webview.dispose();
                toDispose.dispose();
            },
            resolve: async () => {
                if (_resolved) {
                    return;
                }
                if (_pendingResolution) {
                    return _pendingResolution;
                }
                _pendingResolution = this.resolveWebviewView(viewId, webviewView, cancellation_1.CancellationToken.None).then(() => {
                    _resolved = true;
                    _pendingResolution = undefined;
                });
                return _pendingResolution;
            },
            show: webview.show
        };
        const toDispose = this.onNewResolverRegistered(resolver => {
            if (resolver.viewType === viewId) {
                // Potentially re-activate if we have a new resolver
                webviewView.resolve();
            }
        });
        webviewView.resolve();
        return webviewView;
    }
    registerViewWelcome(viewWelcome) {
        const toDispose = new disposable_1.DisposableCollection();
        const viewsWelcome = this.viewsWelcome.get(viewWelcome.view) || [];
        if (viewsWelcome.some(e => e.content === viewWelcome.content)) {
            return toDispose;
        }
        viewsWelcome.push(viewWelcome);
        this.viewsWelcome.set(viewWelcome.view, viewsWelcome);
        this.handleViewWelcomeChange(viewWelcome.view);
        toDispose.push(disposable_1.Disposable.create(() => {
            const index = viewsWelcome.indexOf(viewWelcome);
            if (index !== -1) {
                viewsWelcome.splice(index, 1);
            }
            this.handleViewWelcomeChange(viewWelcome.view);
        }));
        if (viewWelcome.when) {
            const index = viewsWelcome.indexOf(viewWelcome);
            const viewWelcomeId = this.toViewWelcomeId(index, viewWelcome.view);
            this.viewClauseContexts.set(viewWelcomeId, this.contextKeyService.parseKeys(viewWelcome.when));
            toDispose.push(disposable_1.Disposable.create(() => this.viewClauseContexts.delete(viewWelcomeId)));
        }
        return toDispose;
    }
    async handleViewWelcomeChange(viewId) {
        const widget = await this.getTreeViewWelcomeWidget(viewId);
        if (widget) {
            widget.handleViewWelcomeContentChange(this.getViewWelcomes(viewId));
        }
    }
    async getTreeViewWelcomeWidget(viewId) {
        switch (viewId) {
            case 'explorer':
                return this.widgetManager.getWidget(browser_2.FILE_NAVIGATOR_ID);
            default:
                return this.widgetManager.getWidget(exports.PLUGIN_VIEW_DATA_FACTORY_ID, { id: viewId });
        }
    }
    getViewWelcomes(viewId) {
        return this.viewsWelcome.get(viewId) || [];
    }
    async getView(viewId) {
        if (!this.views.has(viewId)) {
            return undefined;
        }
        return this.widgetManager.getWidget(exports.PLUGIN_VIEW_FACTORY_ID, this.toPluginViewWidgetIdentifier(viewId));
    }
    async openView(viewId, options) {
        const view = await this.doOpenView(viewId);
        if (view && options) {
            if (options.activate === true) {
                await this.shell.activateWidget(view.id);
            }
            else if (options.reveal === true) {
                await this.shell.revealWidget(view.id);
            }
        }
        return view;
    }
    async doOpenView(viewId) {
        const widget = await this.getView(viewId);
        if (widget) {
            return widget;
        }
        const data = this.views.get(viewId);
        if (!data) {
            return undefined;
        }
        const [containerId] = data;
        await this.openViewContainer(containerId);
        return this.getView(viewId);
    }
    async prepareView(widget) {
        var _a;
        const data = this.views.get(widget.options.viewId);
        if (!data) {
            return;
        }
        const [, view] = data;
        if (!widget.title.label) {
            widget.title.label = view.name;
        }
        const currentDataWidget = widget.widgets[0];
        const webviewId = currentDataWidget instanceof webview_1.WebviewWidget ? (_a = currentDataWidget.identifier) === null || _a === void 0 ? void 0 : _a.id : undefined;
        const viewDataWidget = await this.createViewDataWidget(view.id, webviewId);
        if (widget.isDisposed) {
            viewDataWidget === null || viewDataWidget === void 0 ? void 0 : viewDataWidget.dispose();
            return;
        }
        if (currentDataWidget !== viewDataWidget) {
            if (currentDataWidget) {
                currentDataWidget.dispose();
            }
            if (viewDataWidget) {
                widget.addWidget(viewDataWidget);
            }
        }
    }
    getOrCreateViewContainerWidget(containerId) {
        const identifier = this.toViewContainerIdentifier(containerId);
        return this.widgetManager.getOrCreateWidget(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID, identifier);
    }
    async openViewContainer(containerId) {
        if (containerId === 'explorer') {
            const widget = await this.explorer.openView();
            if (widget.parent instanceof browser_1.ViewContainer) {
                return widget.parent;
            }
            return undefined;
        }
        if (containerId === 'scm') {
            const widget = await this.scm.openView();
            if (widget.parent instanceof browser_1.ViewContainer) {
                return widget.parent;
            }
            return undefined;
        }
        if (containerId === 'debug') {
            const widget = await this.debug.openView();
            return widget['sessionWidget']['viewContainer'];
        }
        const data = this.viewContainers.get(containerId);
        if (!data) {
            return undefined;
        }
        const { location } = data;
        const containerWidget = await this.getOrCreateViewContainerWidget(containerId);
        if (!containerWidget.isAttached) {
            await this.shell.addWidget(containerWidget, {
                area: browser_1.ApplicationShell.isSideArea(location) ? location : 'left',
                rank: Number.MAX_SAFE_INTEGER
            });
        }
        return containerWidget;
    }
    async prepareViewContainer(viewContainerId, containerWidget) {
        const data = this.viewContainers.get(viewContainerId);
        if (data) {
            const { options } = data;
            containerWidget.setTitleOptions(options);
        }
        for (const viewId of this.getContainerViews(viewContainerId)) {
            const identifier = this.toPluginViewWidgetIdentifier(viewId);
            // Keep existing widget in its current container and reregister its part to the plugin view widget events.
            const existingWidget = this.widgetManager.tryGetWidget(exports.PLUGIN_VIEW_FACTORY_ID, identifier);
            if (existingWidget && existingWidget.currentViewContainerId) {
                const currentContainer = await this.getPluginViewContainer(existingWidget.currentViewContainerId);
                if (currentContainer && this.registerWidgetPartEvents(existingWidget, currentContainer)) {
                    continue;
                }
            }
            const widget = await this.widgetManager.getOrCreateWidget(exports.PLUGIN_VIEW_FACTORY_ID, identifier);
            if (containerWidget.getTrackableWidgets().indexOf(widget) === -1) {
                containerWidget.addWidget(widget, {
                    initiallyCollapsed: !!containerWidget.getParts().length,
                    initiallyHidden: !this.isViewVisible(viewId)
                });
            }
            this.registerWidgetPartEvents(widget, containerWidget);
        }
    }
    registerWidgetPartEvents(widget, containerWidget) {
        const part = containerWidget.getPartFor(widget);
        if (part) {
            widget.currentViewContainerId = this.getViewContainerId(containerWidget);
            part.onDidMove(event => { widget.currentViewContainerId = this.getViewContainerId(event); });
            // if a view is explicitly hidden then suppress updating visibility based on `when` closure
            part.onDidChangeVisibility(() => widget.suppressUpdateViewVisibility = part.isHidden);
            const tryFireOnDidExpandView = () => {
                if (widget.widgets.length === 0) {
                    if (!part.collapsed && part.isVisible) {
                        const viewId = this.toViewId(widget.options);
                        this.onDidExpandViewEmitter.fire(viewId);
                    }
                }
                else {
                    toFire.dispose();
                }
            };
            const toFire = new disposable_1.DisposableCollection(part.onCollapsed(tryFireOnDidExpandView), part.onDidChangeVisibility(tryFireOnDidExpandView));
            tryFireOnDidExpandView();
            return part;
        }
    }
    ;
    getViewContainerId(container) {
        var _a;
        const description = this.widgetManager.getDescription(container);
        switch (description === null || description === void 0 ? void 0 : description.factoryId) {
            case browser_2.EXPLORER_VIEW_CONTAINER_ID: return 'explorer';
            case scm_contribution_1.SCM_VIEW_CONTAINER_ID: return 'scm';
            case search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID: return 'search';
            case test_view_contribution_1.TEST_VIEW_CONTAINER_ID: return 'test';
            case undefined: return ((_a = container.parent) === null || _a === void 0 ? void 0 : _a.parent) instanceof debug_widget_1.DebugWidget ? 'debug' : container.id;
            case exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID: return this.toViewContainerId(description.options);
            default: return container.id;
        }
    }
    async getPluginViewContainer(viewContainerId) {
        if (viewContainerId === 'explorer') {
            return this.widgetManager.getWidget(browser_2.EXPLORER_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'scm') {
            return this.widgetManager.getWidget(scm_contribution_1.SCM_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'search') {
            return this.widgetManager.getWidget(search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'test') {
            return this.widgetManager.getWidget(test_view_contribution_1.TEST_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'debug') {
            const debug = await this.widgetManager.getWidget(debug_widget_1.DebugWidget.ID);
            if (debug instanceof debug_widget_1.DebugWidget) {
                return debug['sessionWidget']['viewContainer'];
            }
        }
        const identifier = this.toViewContainerIdentifier(viewContainerId);
        return this.widgetManager.getWidget(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID, identifier);
    }
    async initViewContainer(containerId) {
        let viewContainer = await this.getPluginViewContainer(containerId);
        if (!viewContainer) {
            viewContainer = await this.openViewContainer(containerId);
            if (viewContainer && !viewContainer.getParts().filter(part => !part.isHidden).length) {
                // close view containers without any visible view parts
                viewContainer.dispose();
            }
        }
        else {
            await this.prepareViewContainer(this.toViewContainerId(viewContainer.options), viewContainer);
        }
    }
    async initWidgets() {
        const promises = [];
        for (const id of this.viewContainers.keys()) {
            promises.push((async () => {
                await this.initViewContainer(id);
            })().catch(console.error));
        }
        promises.push((async () => {
            const explorer = await this.widgetManager.getWidget(browser_2.EXPLORER_VIEW_CONTAINER_ID);
            if (explorer instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('explorer', explorer);
            }
        })().catch(console.error));
        promises.push((async () => {
            const scm = await this.widgetManager.getWidget(scm_contribution_1.SCM_VIEW_CONTAINER_ID);
            if (scm instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('scm', scm);
            }
        })().catch(console.error));
        promises.push((async () => {
            const search = await this.widgetManager.getWidget(search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID);
            if (search instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('search', search);
            }
        })().catch(console.error));
        promises.push((async () => {
            const test = await this.widgetManager.getWidget(test_view_contribution_1.TEST_VIEW_CONTAINER_ID);
            if (test instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('test', test);
            }
        })().catch(console.error));
        promises.push((async () => {
            const debug = await this.widgetManager.getWidget(debug_widget_1.DebugWidget.ID);
            if (debug instanceof debug_widget_1.DebugWidget) {
                const viewContainer = debug['sessionWidget']['viewContainer'];
                await this.prepareViewContainer('debug', viewContainer);
            }
        })().catch(console.error));
        await Promise.all(promises);
    }
    async removeStaleWidgets() {
        const views = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_FACTORY_ID);
        for (const view of views) {
            if (view instanceof plugin_view_widget_1.PluginViewWidget) {
                const id = this.toViewId(view.options);
                if (!this.views.has(id)) {
                    view.dispose();
                }
            }
        }
        const viewContainers = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID);
        for (const viewContainer of viewContainers) {
            if (viewContainer instanceof browser_1.ViewContainer) {
                const id = this.toViewContainerId(viewContainer.options);
                if (!this.viewContainers.has(id)) {
                    viewContainer.dispose();
                }
            }
        }
    }
    toViewContainerIdentifier(viewContainerId) {
        return { id: exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID + ':' + viewContainerId, progressLocationId: viewContainerId };
    }
    toViewContainerId(identifier) {
        return identifier.id.substring(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID.length + 1);
    }
    toPluginViewWidgetIdentifier(viewId) {
        return { id: exports.PLUGIN_VIEW_FACTORY_ID + ':' + viewId, viewId };
    }
    toViewId(identifier) {
        return identifier.viewId;
    }
    toViewWelcomeId(index, viewId) {
        return `view-welcome.${viewId}.${index}`;
    }
    /**
     * retrieve restored layout state from previous user session but close widgets
     * widgets should be opened only when view data providers are registered
     */
    onDidInitializeLayout() {
        const widgets = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_DATA_FACTORY_ID);
        for (const widget of widgets) {
            if (browser_1.StatefulWidget.is(widget)) {
                const state = widget.storeState();
                if (state) {
                    this.viewDataState.set(widget.id, state);
                }
            }
            widget.dispose();
        }
    }
    registerViewDataProvider(viewId, provider) {
        if (this.viewDataProviders.has(viewId)) {
            console.error(`data provider for '${viewId}' view is already registered`);
            return disposable_1.Disposable.NULL;
        }
        this.viewDataProviders.set(viewId, provider);
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => {
            this.viewDataProviders.delete(viewId);
            this.viewDataState.delete(viewId);
        }));
        this.initView(viewId, toDispose);
        return toDispose;
    }
    async initView(viewId, toDispose) {
        const view = await this.getView(viewId);
        if (toDispose.disposed) {
            return;
        }
        if (view) {
            if (view.isVisible) {
                await this.prepareView(view);
            }
            else {
                const toDisposeOnDidExpandView = new disposable_1.DisposableCollection(this.onDidExpandView(async (id) => {
                    if (id === viewId) {
                        unsubscribe();
                        await this.prepareView(view);
                    }
                }));
                const unsubscribe = () => toDisposeOnDidExpandView.dispose();
                view.disposed.connect(unsubscribe);
                toDisposeOnDidExpandView.push(disposable_1.Disposable.create(() => view.disposed.disconnect(unsubscribe)));
                toDispose.push(toDisposeOnDidExpandView);
            }
        }
    }
    async createViewDataWidget(viewId, webviewId) {
        var _a;
        const view = this.views.get(viewId);
        if (((_a = view === null || view === void 0 ? void 0 : view[1]) === null || _a === void 0 ? void 0 : _a.type) === common_1.PluginViewType.Webview) {
            return this.createWebviewWidget(viewId, webviewId);
        }
        const provider = this.viewDataProviders.get(viewId);
        if (!view || !provider) {
            return undefined;
        }
        const [, viewInfo] = view;
        const state = this.viewDataState.get(viewId);
        const widget = await provider({ state, viewInfo });
        widget.handleViewWelcomeContentChange(this.getViewWelcomes(viewId));
        if (browser_1.StatefulWidget.is(widget)) {
            this.storeViewDataStateOnDispose(viewId, widget);
        }
        else {
            this.viewDataState.delete(viewId);
        }
        return widget;
    }
    async createWebviewWidget(viewId, webviewId) {
        if (!webviewId) {
            const webviewView = await this.createNewWebviewView(viewId);
            webviewId = webviewView.webview.identifier.id;
        }
        const webviewWidget = this.widgetManager.getWidget(webview_1.WebviewWidget.FACTORY_ID, { id: webviewId, viewId });
        return webviewWidget;
    }
    storeViewDataStateOnDispose(viewId, widget) {
        const dispose = widget.dispose.bind(widget);
        widget.dispose = () => {
            const state = widget.storeState();
            if (state) {
                this.viewDataState.set(viewId, state);
            }
            dispose();
        };
    }
    isVisibleWidget(widget) {
        return !widget.isDisposed && widget.isVisible;
    }
    updateFocusedView() {
        const widget = this.shell.activeWidget;
        if (widget instanceof plugin_view_widget_1.PluginViewWidget) {
            this.viewContextKeys.focusedView.set(widget.options.viewId);
        }
        else {
            this.viewContextKeys.focusedView.reset();
        }
    }
};
exports.PluginViewRegistry = PluginViewRegistry;
PluginViewRegistry.BUILTIN_VIEW_CONTAINERS = new Set([
    'explorer',
    'scm',
    'search',
    'test',
    'debug'
]);
PluginViewRegistry.ID_MAPPINGS = new Map([
    // VS Code Viewlets
    [browser_2.EXPLORER_VIEW_CONTAINER_ID, 'workbench.view.explorer'],
    [scm_contribution_1.SCM_VIEW_CONTAINER_ID, 'workbench.view.scm'],
    [search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID, 'workbench.view.search'],
    [debug_widget_1.DebugWidget.ID, 'workbench.view.debug'],
    ['vsx-extensions-view-container', 'workbench.view.extensions'], // cannot use the id from 'vsx-registry' package because of circular dependency
    [problem_widget_1.PROBLEMS_WIDGET_ID, 'workbench.panel.markers'],
    [test_view_contribution_1.TEST_VIEW_CONTAINER_ID, 'workbench.view.testing'],
    [output_widget_1.OutputWidget.ID, 'workbench.panel.output'],
    [debug_console_contribution_1.DebugConsoleContribution.options.id, 'workbench.panel.repl'],
    // Theia does not have a single terminal widget, but instead each terminal gets its own widget. Therefore "the terminal widget is active" doesn't make sense in Theia
    // [TERMINAL_WIDGET_FACTORY_ID, 'workbench.panel.terminal'],
    // [?? , 'workbench.panel.comments'] not sure what this mean: we don't show comments in sidebars nor the bottom
]);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], PluginViewRegistry.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginViewRegistry.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], PluginViewRegistry.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_contribution_1.ScmContribution),
    tslib_1.__metadata("design:type", scm_contribution_1.ScmContribution)
], PluginViewRegistry.prototype, "scm", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(navigator_contribution_1.FileNavigatorContribution),
    tslib_1.__metadata("design:type", navigator_contribution_1.FileNavigatorContribution)
], PluginViewRegistry.prototype, "explorer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_frontend_application_contribution_1.DebugFrontendApplicationContribution),
    tslib_1.__metadata("design:type", debug_frontend_application_contribution_1.DebugFrontendApplicationContribution)
], PluginViewRegistry.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginViewRegistry.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], PluginViewRegistry.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickViewService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", browser_1.QuickViewService)
], PluginViewRegistry.prototype, "quickView", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginViewRegistry.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(view_context_key_service_1.ViewContextKeyService),
    tslib_1.__metadata("design:type", view_context_key_service_1.ViewContextKeyService)
], PluginViewRegistry.prototype, "viewContextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginViewRegistry.prototype, "init", null);
exports.PluginViewRegistry = PluginViewRegistry = PluginViewRegistry_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginViewRegistry);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginViewWidget = exports.PluginViewWidgetIdentifier = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const widgets_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/widgets */ "../node_modules/@theia/core/shared/@phosphor/widgets/index.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../node_modules/@theia/core/lib/common/menu/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const tree_view_widget_1 = __webpack_require__(/*! ./tree-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const view_container_1 = __webpack_require__(/*! @theia/core/lib/browser/view-container */ "../node_modules/@theia/core/lib/browser/view-container.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let PluginViewWidgetIdentifier = class PluginViewWidgetIdentifier {
};
exports.PluginViewWidgetIdentifier = PluginViewWidgetIdentifier;
exports.PluginViewWidgetIdentifier = PluginViewWidgetIdentifier = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginViewWidgetIdentifier);
let PluginViewWidget = class PluginViewWidget extends widgets_1.Panel {
    get onDidChangeToolbarItems() {
        return this.onDidChangeToolbarItemsEmitter.event;
    }
    constructor() {
        super();
        this._description = '';
        this._suppressUpdateViewVisibility = false;
        this.updatingViewVisibility = false;
        this.onDidChangeDescriptionEmitter = new common_1.Emitter();
        this.onDidChangeBadgeEmitter = new common_1.Emitter();
        this.onDidChangeBadgeTooltipEmitter = new common_1.Emitter();
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeDescriptionEmitter, this.onDidChangeBadgeEmitter, this.onDidChangeBadgeTooltipEmitter);
        this.onDidChangeToolbarItemsEmitter = new common_1.Emitter();
        this.node.tabIndex = -1;
        this.node.style.height = '100%';
    }
    init() {
        this.id = this.options.id;
        const localContext = this.contextKeyService.createScoped(this.node);
        localContext.setContext('view', this.options.viewId);
    }
    get onDidChangeDescription() {
        return this.onDidChangeDescriptionEmitter.event;
    }
    get onDidChangeBadge() {
        return this.onDidChangeBadgeEmitter.event;
    }
    get onDidChangeBadgeTooltip() {
        return this.onDidChangeBadgeTooltipEmitter.event;
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        const widget = this.widgets[0];
        if (widget) {
            widget.activate();
            this.updateWidgetMessage();
        }
        else {
            this.node.focus();
        }
    }
    storeState() {
        return {
            label: this.title.label,
            message: this.message,
            widgets: this.widgets,
            suppressUpdateViewVisibility: this._suppressUpdateViewVisibility,
            currentViewContainerId: this.currentViewContainerId
        };
    }
    restoreState(state) {
        this.title.label = state.label;
        this.message = state.message;
        this.suppressUpdateViewVisibility = state.suppressUpdateViewVisibility;
        this.currentViewContainerId = state.currentViewContainerId;
        for (const widget of state.widgets) {
            this.addWidget(widget);
        }
    }
    set suppressUpdateViewVisibility(suppressUpdateViewVisibility) {
        this._suppressUpdateViewVisibility = !this.updatingViewVisibility && suppressUpdateViewVisibility;
    }
    updateViewVisibility(cb) {
        if (this._suppressUpdateViewVisibility) {
            return;
        }
        try {
            this.updatingViewVisibility = true;
            cb();
        }
        finally {
            this.updatingViewVisibility = false;
        }
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.updateWidgetMessage();
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
        this.onDidChangeDescriptionEmitter.fire();
    }
    get badge() {
        const widget = this.widgets[0];
        if (view_container_1.BadgeWidget.is(widget)) {
            return widget.badge;
        }
        return this._badge;
    }
    set badge(badge) {
        this._badge = badge;
        this.onDidChangeBadgeEmitter.fire();
    }
    get badgeTooltip() {
        const widget = this.widgets[0];
        if (view_container_1.BadgeWidget.is(widget)) {
            return widget.badgeTooltip;
        }
        return this._badgeTooltip;
    }
    set badgeTooltip(badgeTooltip) {
        this._badgeTooltip = badgeTooltip;
        this.onDidChangeBadgeTooltipEmitter.fire();
    }
    updateWidgetMessage() {
        const widget = this.widgets[0];
        if (widget) {
            if (widget instanceof tree_view_widget_1.TreeViewWidget) {
                widget.message = this._message;
            }
        }
    }
    addWidget(widget) {
        super.addWidget(widget);
        if (view_container_1.BadgeWidget.is(widget)) {
            widget.onDidChangeBadge(() => this.onDidChangeBadgeEmitter.fire());
            widget.onDidChangeBadgeTooltip(() => this.onDidChangeBadgeTooltipEmitter.fire());
        }
        this.updateWidgetMessage();
        this.onDidChangeToolbarItemsEmitter.fire();
    }
    insertWidget(index, widget) {
        super.insertWidget(index, widget);
        this.updateWidgetMessage();
        this.onDidChangeToolbarItemsEmitter.fire();
    }
    dispose() {
        this.toDispose.dispose();
        super.dispose();
    }
};
exports.PluginViewWidget = PluginViewWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], PluginViewWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginViewWidget.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginViewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginViewWidgetIdentifier),
    tslib_1.__metadata("design:type", PluginViewWidgetIdentifier)
], PluginViewWidget.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginViewWidget.prototype, "init", null);
exports.PluginViewWidget = PluginViewWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginViewWidget);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018-2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeViewWidget = exports.PluginTreeModel = exports.PluginTree = exports.TreeViewWidgetOptions = exports.CompositeTreeViewNode = exports.ResolvableCompositeTreeViewNode = exports.ResolvableTreeViewNode = exports.TreeViewNode = exports.VIEW_ITEM_INLINE_MENU = exports.VIEW_ITEM_CONTEXT_MENU = exports.TREE_NODE_HYPERLINK = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../node_modules/@theia/core/lib/common/menu/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const widget_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/widget */ "../node_modules/@theia/core/lib/browser/widgets/widget.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../node_modules/@theia/core/lib/common/message-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const tree_decorator_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-decorator */ "../node_modules/@theia/core/lib/browser/tree/tree-decorator.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const types_1 = __webpack_require__(/*! ../../../common/types */ "../node_modules/@theia/plugin-ext/lib/common/types.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const dnd_file_content_store_1 = __webpack_require__(/*! ./dnd-file-content-store */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js");
exports.TREE_NODE_HYPERLINK = 'theia-TreeNodeHyperlink';
exports.VIEW_ITEM_CONTEXT_MENU = ['view-item-context-menu'];
exports.VIEW_ITEM_INLINE_MENU = ['view-item-context-menu', 'inline'];
var TreeViewNode;
(function (TreeViewNode) {
    function is(arg) {
        return !!arg && browser_1.SelectableTreeNode.is(arg) && tree_decorator_1.DecoratedTreeNode.is(arg);
    }
    TreeViewNode.is = is;
})(TreeViewNode || (exports.TreeViewNode = TreeViewNode = {}));
class ResolvableTreeViewNode {
    constructor(treeViewNode, resolve) {
        this._resolved = false;
        (0, types_1.mixin)(this, treeViewNode);
        this.resolve = async (token) => {
            var _a, _b;
            if (this.resolving) {
                return this.resolving.promise;
            }
            if (!this._resolved) {
                this.resolving = new promise_util_1.Deferred();
                const resolvedTreeItem = await resolve(token);
                if (resolvedTreeItem) {
                    this.command = (_a = this.command) !== null && _a !== void 0 ? _a : resolvedTreeItem.command;
                    this.tooltip = (_b = this.tooltip) !== null && _b !== void 0 ? _b : resolvedTreeItem.tooltip;
                }
                this.resolving.resolve();
                this.resolving = undefined;
            }
            if (!token.isCancellationRequested) {
                this._resolved = true;
            }
        };
    }
    reset() {
        this._resolved = false;
        this.resolving = undefined;
        this.command = undefined;
        this.tooltip = undefined;
    }
    get resolved() {
        return this._resolved;
    }
}
exports.ResolvableTreeViewNode = ResolvableTreeViewNode;
class ResolvableCompositeTreeViewNode extends ResolvableTreeViewNode {
    constructor(treeViewNode, resolve) {
        super(treeViewNode, resolve);
        this.expanded = treeViewNode.expanded;
        this.children = treeViewNode.children;
    }
}
exports.ResolvableCompositeTreeViewNode = ResolvableCompositeTreeViewNode;
var CompositeTreeViewNode;
(function (CompositeTreeViewNode) {
    function is(arg) {
        return TreeViewNode.is(arg) && browser_1.ExpandableTreeNode.is(arg) && browser_1.CompositeTreeNode.is(arg);
    }
    CompositeTreeViewNode.is = is;
})(CompositeTreeViewNode || (exports.CompositeTreeViewNode = CompositeTreeViewNode = {}));
let TreeViewWidgetOptions = class TreeViewWidgetOptions {
};
exports.TreeViewWidgetOptions = TreeViewWidgetOptions;
exports.TreeViewWidgetOptions = TreeViewWidgetOptions = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TreeViewWidgetOptions);
let PluginTree = class PluginTree extends browser_1.TreeImpl {
    constructor() {
        super(...arguments);
        this.onDidChangeWelcomeStateEmitter = new event_1.Emitter();
        this.onDidChangeWelcomeState = this.onDidChangeWelcomeStateEmitter.event;
        this._hasTreeItemResolve = Promise.resolve(false);
    }
    set proxy(proxy) {
        this._proxy = proxy;
        if (proxy) {
            this._hasTreeItemResolve = proxy.$hasResolveTreeItem(this.options.id);
        }
        else {
            this._hasTreeItemResolve = Promise.resolve(false);
        }
    }
    get proxy() {
        return this._proxy;
    }
    get hasTreeItemResolve() {
        return this._hasTreeItemResolve;
    }
    set viewInfo(viewInfo) {
        this._viewInfo = viewInfo;
    }
    get isEmpty() {
        return this._isEmpty;
    }
    async resolveChildren(parent) {
        if (!this._proxy) {
            return super.resolveChildren(parent);
        }
        const children = await this.fetchChildren(this._proxy, parent);
        const hasResolve = await this.hasTreeItemResolve;
        return children.map(value => hasResolve ? this.createResolvableTreeNode(value, parent) : this.createTreeNode(value, parent));
    }
    async fetchChildren(proxy, parent) {
        try {
            const children = await proxy.$getChildren(this.options.id, parent.id);
            const oldEmpty = this._isEmpty;
            this._isEmpty = !parent.id && (!children || children.length === 0);
            if (oldEmpty !== this._isEmpty) {
                this.onDidChangeWelcomeStateEmitter.fire();
            }
            return children || [];
        }
        catch (e) {
            if (e) {
                console.error(`Failed to fetch children for '${this.options.id}'`, e);
                const label = this._viewInfo ? this._viewInfo.name : this.options.id;
                this.notification.error(`${label}: ${e.message}`);
            }
            return [];
        }
    }
    createTreeNode(item, parent) {
        const update = this.createTreeNodeUpdate(item);
        const node = this.getNode(item.id);
        if (item.collapsibleState !== undefined && item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None) {
            if (CompositeTreeViewNode.is(node)) {
                return Object.assign(node, update);
            }
            return Object.assign({
                id: item.id,
                parent,
                visible: true,
                selected: false,
                expanded: plugin_api_rpc_1.TreeViewItemCollapsibleState.Expanded === item.collapsibleState,
                children: [],
                command: item.command
            }, update);
        }
        if (TreeViewNode.is(node) && !browser_1.ExpandableTreeNode.is(node)) {
            return Object.assign(node, update, { command: item.command });
        }
        return Object.assign({
            id: item.id,
            parent,
            visible: true,
            selected: false,
            command: item.command,
        }, update);
    }
    markAsChecked(node, checked) {
        var _a;
        function findParentsToChange(child, nodes) {
            var _a;
            if ((((_a = child.parent) === null || _a === void 0 ? void 0 : _a.checkboxInfo) !== undefined && child.parent.checkboxInfo.checked !== checked) &&
                (!checked || !child.parent.children.some(candidate => { var _a; return candidate !== child && ((_a = candidate.checkboxInfo) === null || _a === void 0 ? void 0 : _a.checked) === false; }))) {
                nodes.push(child.parent);
                findParentsToChange(child.parent, nodes);
            }
        }
        function findChildrenToChange(parent, nodes) {
            if (browser_1.CompositeTreeNode.is(parent)) {
                parent.children.forEach(child => {
                    if (child.checkboxInfo !== undefined && child.checkboxInfo.checked !== checked) {
                        nodes.push(child);
                    }
                    findChildrenToChange(child, nodes);
                });
            }
        }
        const nodesToChange = [node];
        if (!this.options.manageCheckboxStateManually) {
            findParentsToChange(node, nodesToChange);
            findChildrenToChange(node, nodesToChange);
        }
        nodesToChange.forEach(n => n.checkboxInfo.checked = checked);
        this.onDidUpdateEmitter.fire(nodesToChange);
        (_a = this.proxy) === null || _a === void 0 ? void 0 : _a.$checkStateChanged(this.options.id, [{ id: node.id, checked: checked }]);
    }
    /** Creates a resolvable tree node. If a node already exists, reset it because the underlying TreeViewItem might have been disposed in the backend. */
    createResolvableTreeNode(item, parent) {
        const update = this.createTreeNodeUpdate(item);
        const node = this.getNode(item.id);
        // Node is a composite node that might contain children
        if (item.collapsibleState !== undefined && item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None) {
            // Reuse existing composite node and reset it
            if (node instanceof ResolvableCompositeTreeViewNode) {
                node.reset();
                return Object.assign(node, update);
            }
            // Create new composite node
            const compositeNode = Object.assign({
                id: item.id,
                parent,
                visible: true,
                selected: false,
                expanded: plugin_api_rpc_1.TreeViewItemCollapsibleState.Expanded === item.collapsibleState,
                children: [],
                command: item.command
            }, update);
            return new ResolvableCompositeTreeViewNode(compositeNode, async (token) => { var _a; return (_a = this._proxy) === null || _a === void 0 ? void 0 : _a.$resolveTreeItem(this.options.id, item.id, token); });
        }
        // Node is a leaf
        // Reuse existing node and reset it.
        if (node instanceof ResolvableTreeViewNode && !browser_1.ExpandableTreeNode.is(node)) {
            node.reset();
            return Object.assign(node, update);
        }
        const treeNode = Object.assign({
            id: item.id,
            parent,
            visible: true,
            selected: false,
            command: item.command,
        }, update);
        return new ResolvableTreeViewNode(treeNode, async (token) => { var _a; return (_a = this._proxy) === null || _a === void 0 ? void 0 : _a.$resolveTreeItem(this.options.id, item.id, token); });
    }
    createTreeNodeUpdate(item) {
        const decorationData = this.toDecorationData(item);
        const icon = this.toIconClass(item);
        const resourceUri = item.resourceUri && uri_1.URI.fromComponents(item.resourceUri).toString();
        const themeIcon = item.themeIcon ? item.themeIcon : item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None ? { id: 'folder' } : undefined;
        return {
            name: item.label,
            decorationData,
            icon,
            description: item.description,
            themeIcon,
            resourceUri,
            tooltip: item.tooltip,
            contextValue: item.contextValue,
            command: item.command,
            checkboxInfo: item.checkboxInfo,
            accessibilityInformation: item.accessibilityInformation,
        };
    }
    toDecorationData(item) {
        let decoration = {};
        if (item.highlights) {
            const highlight = {
                ranges: item.highlights.map(h => ({ offset: h[0], length: h[1] - h[0] }))
            };
            decoration = { highlight };
        }
        return decoration;
    }
    toIconClass(item) {
        if (item.icon) {
            return 'fa ' + item.icon;
        }
        if (item.iconUrl) {
            const reference = this.sharedStyle.toIconClass(item.iconUrl);
            this.toDispose.push(reference);
            return reference.object.iconClass;
        }
        return undefined;
    }
};
exports.PluginTree = PluginTree;
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginTree.prototype, "sharedStyle", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(TreeViewWidgetOptions),
    tslib_1.__metadata("design:type", TreeViewWidgetOptions)
], PluginTree.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(message_service_1.MessageService),
    tslib_1.__metadata("design:type", message_service_1.MessageService)
], PluginTree.prototype, "notification", void 0);
exports.PluginTree = PluginTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTree);
let PluginTreeModel = class PluginTreeModel extends browser_1.TreeModelImpl {
    set proxy(proxy) {
        this.tree.proxy = proxy;
    }
    get proxy() {
        return this.tree.proxy;
    }
    get hasTreeItemResolve() {
        return this.tree.hasTreeItemResolve;
    }
    set viewInfo(viewInfo) {
        this.tree.viewInfo = viewInfo;
    }
    get isTreeEmpty() {
        return this.tree.isEmpty;
    }
    get onDidChangeWelcomeState() {
        return this.tree.onDidChangeWelcomeState;
    }
    doOpenNode(node) {
        super.doOpenNode(node);
        if (node instanceof ResolvableTreeViewNode) {
            node.resolve(common_1.CancellationToken.None);
        }
    }
};
exports.PluginTreeModel = PluginTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginTree),
    tslib_1.__metadata("design:type", PluginTree)
], PluginTreeModel.prototype, "tree", void 0);
exports.PluginTreeModel = PluginTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTreeModel);
let TreeViewWidget = class TreeViewWidget extends browser_1.TreeViewWelcomeWidget {
    constructor() {
        super(...arguments);
        this._contextSelection = false;
        this.expansionTimeouts = new Map();
    }
    async refresh(items) {
        if (items) {
            for (const id of items) {
                const node = this.model.getNode(id);
                if (browser_1.CompositeTreeNode.is(node)) {
                    await this.model.refresh(node);
                }
            }
            ;
        }
        else {
            this.model.refresh();
        }
    }
    init() {
        super.init();
        this.id = this.options.id;
        this.addClass('theia-tree-view');
        this.node.style.height = '100%';
        this.model.onDidChangeWelcomeState(this.update, this);
        this.toDispose.push(this.model.onDidChangeWelcomeState(this.update, this));
        this.toDispose.push(this.onDidChangeVisibilityEmitter);
        this.toDispose.push(this.contextKeyService.onDidChange(() => this.update()));
        this.toDispose.push(this.keybindings.onKeybindingsChanged(() => this.update()));
        this.treeDragType = `application/vnd.code.tree.${this.id.toLowerCase()}`;
    }
    get showCollapseAll() {
        return this.options.showCollapseAll || false;
    }
    renderIcon(node, props) {
        var _a;
        const icon = this.toNodeIcon(node);
        if (icon) {
            let style;
            if (TreeViewNode.is(node) && ((_a = node.themeIcon) === null || _a === void 0 ? void 0 : _a.color)) {
                const color = this.colorRegistry.getCurrentColor(node.themeIcon.color.id);
                if (color) {
                    style = { color };
                }
            }
            return React.createElement("div", { className: icon + ' theia-tree-view-icon', style: style });
        }
        return undefined;
    }
    renderCaption(node, props) {
        const classes = [browser_1.TREE_NODE_SEGMENT_CLASS];
        if (!this.hasTrailingSuffixes(node)) {
            classes.push(browser_1.TREE_NODE_SEGMENT_GROW_CLASS);
        }
        const className = classes.join(' ');
        let attrs = {
            ...this.decorateCaption(node, {}),
            className,
            id: node.id
        };
        if (node.accessibilityInformation) {
            attrs = {
                ...attrs,
                'aria-label': node.accessibilityInformation.label,
                'role': node.accessibilityInformation.role
            };
        }
        if (!node.tooltip && node instanceof ResolvableTreeViewNode) {
            let configuredTip = false;
            let source;
            attrs = {
                ...attrs,
                onMouseLeave: () => source === null || source === void 0 ? void 0 : source.cancel(),
                onMouseEnter: async (event) => {
                    const target = event.currentTarget; // event.currentTarget will be null after awaiting node resolve()
                    if (configuredTip) {
                        if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
                            this.hoverService.requestHover({
                                content: node.tooltip,
                                target: event.target,
                                position: 'right'
                            });
                        }
                        return;
                    }
                    if (!node.resolved) {
                        source = new common_1.CancellationTokenSource();
                        const token = source.token;
                        await node.resolve(token);
                        if (token.isCancellationRequested) {
                            return;
                        }
                    }
                    if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
                        this.hoverService.requestHover({
                            content: node.tooltip,
                            target: event.target,
                            position: 'right'
                        });
                    }
                    else {
                        const title = node.tooltip ||
                            (node.resourceUri && this.labelProvider.getLongName(new uri_1.URI(node.resourceUri)))
                            || this.toNodeName(node);
                        target.title = title;
                    }
                    configuredTip = true;
                }
            };
        }
        else if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
            attrs = {
                ...attrs,
                onMouseEnter: event => {
                    this.hoverService.requestHover({
                        content: node.tooltip,
                        target: event.target,
                        position: 'right'
                    });
                }
            };
        }
        else {
            const title = node.tooltip ||
                (node.resourceUri && this.labelProvider.getLongName(new uri_1.URI(node.resourceUri)))
                || this.toNodeName(node);
            attrs = {
                ...attrs,
                title
            };
        }
        const children = [];
        const caption = this.toNodeName(node);
        const highlight = this.getDecorationData(node, 'highlight')[0];
        if (highlight) {
            children.push(this.toReactNode(caption, highlight));
        }
        const searchHighlight = this.searchHighlights && this.searchHighlights.get(node.id);
        if (searchHighlight) {
            children.push(...this.toReactNode(caption, searchHighlight));
        }
        else if (!highlight) {
            children.push(caption);
        }
        const description = this.toNodeDescription(node);
        if (description) {
            children.push(React.createElement("span", { className: 'theia-tree-view-description' }, description));
        }
        return React.createElement("div", { ...attrs }, ...children);
    }
    createNodeAttributes(node, props) {
        const attrs = super.createNodeAttributes(node, props);
        if (this.options.dragMimeTypes) {
            attrs.onDragStart = event => this.handleDragStartEvent(node, event);
            attrs.onDragEnd = event => this.handleDragEnd(node, event);
            attrs.draggable = true;
        }
        if (this.options.dropMimeTypes) {
            attrs.onDrop = event => this.handleDropEvent(node, event);
            attrs.onDragEnter = event => this.handleDragEnter(node, event);
            attrs.onDragLeave = event => this.handleDragLeave(node, event);
            attrs.onDragOver = event => this.handleDragOver(event);
        }
        return attrs;
    }
    handleDragLeave(node, event) {
        const timeout = this.expansionTimeouts.get(node.id);
        if (typeof timeout !== 'undefined') {
            console.debug(`dragleave ${node.id} canceling timeout`);
            clearTimeout(timeout);
            this.expansionTimeouts.delete(node.id);
        }
    }
    handleDragEnter(node, event) {
        console.debug(`dragenter ${node.id}`);
        if (browser_1.ExpandableTreeNode.is(node)) {
            console.debug(`dragenter ${node.id} starting timeout`);
            this.expansionTimeouts.set(node.id, window.setTimeout(() => {
                console.debug(`dragenter ${node.id} timeout reached`);
                this.model.expandNode(node);
            }, 500));
        }
    }
    createContainerAttributes() {
        const attrs = super.createContainerAttributes();
        if (this.options.dropMimeTypes) {
            attrs.onDrop = event => this.handleDropEvent(undefined, event);
            attrs.onDragOver = event => this.handleDragOver(event);
        }
        return attrs;
    }
    handleDragStartEvent(node, event) {
        event.dataTransfer.setData(this.treeDragType, '');
        let selectedNodes = [];
        if (this.model.selectedNodes.find(selected => browser_1.TreeNode.equals(selected, node))) {
            selectedNodes = this.model.selectedNodes.filter(TreeViewNode.is);
        }
        else {
            selectedNodes = [node];
        }
        this.options.dragMimeTypes.forEach(type => {
            if (type === 'text/uri-list') {
                browser_1.ApplicationShell.setDraggedEditorUris(event.dataTransfer, selectedNodes.filter(n => n.resourceUri).map(n => new uri_1.URI(n.resourceUri)));
            }
            else {
                event.dataTransfer.setData(type, '');
            }
        });
        this.model.proxy.$dragStarted(this.options.id, selectedNodes.map(selected => selected.id), common_1.CancellationToken.None).then(maybeUris => {
            if (maybeUris) {
                this.applicationShell.addAdditionalDraggedEditorUris(maybeUris.map(uri => uri_1.URI.fromComponents(uri)));
            }
        });
    }
    handleDragEnd(node, event) {
        this.applicationShell.clearAdditionalDraggedEditorUris();
        this.model.proxy.$dragEnd(this.id);
    }
    handleDragOver(event) {
        const hasFiles = (items) => {
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file') {
                    return true;
                }
            }
            return false;
        };
        if (event.dataTransfer) {
            const canDrop = event.dataTransfer.types.some(type => this.options.dropMimeTypes.includes(type)) ||
                event.dataTransfer.types.includes(this.treeDragType) ||
                this.options.dropMimeTypes.includes('files') && hasFiles(event.dataTransfer.items);
            if (canDrop) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
            event.stopPropagation();
        }
    }
    handleDropEvent(node, event) {
        var _a;
        if (event.dataTransfer) {
            const items = [];
            let files = [];
            try {
                for (let i = 0; i < event.dataTransfer.items.length; i++) {
                    const transferItem = event.dataTransfer.items[i];
                    if (transferItem.type !== this.treeDragType) {
                        // do not pass the artificial drag data to the extension
                        const f = event.dataTransfer.items[i].getAsFile();
                        if (f) {
                            const fileId = this.dndFileContentStore.addFile(f);
                            files.push(fileId);
                            const uri = f.path ? {
                                scheme: 'file',
                                path: f.path,
                                authority: '',
                                query: '',
                                fragment: ''
                            } : undefined;
                            items.push([transferItem.type, new plugin_api_rpc_1.DataTransferFileDTO(f.name, fileId, uri)]);
                        }
                        else {
                            const textData = event.dataTransfer.getData(transferItem.type);
                            if (textData) {
                                items.push([transferItem.type, textData]);
                            }
                        }
                    }
                }
                if (items.length > 0 || event.dataTransfer.types.includes(this.treeDragType)) {
                    event.preventDefault();
                    event.stopPropagation();
                    (_a = this.model.proxy) === null || _a === void 0 ? void 0 : _a.$drop(this.id, node === null || node === void 0 ? void 0 : node.id, items, common_1.CancellationToken.None).finally(() => {
                        for (const file of files) {
                            this.dndFileContentStore.removeFile(file);
                        }
                    });
                    files = [];
                }
            }
            catch (e) {
                for (const file of files) {
                    this.dndFileContentStore.removeFile(file);
                }
                throw e;
            }
        }
    }
    renderTailDecorations(treeViewNode, props) {
        return this.contextKeys.with({ view: this.id, viewItem: treeViewNode.contextValue }, () => {
            const menu = this.menus.getMenu(exports.VIEW_ITEM_INLINE_MENU);
            const args = this.toContextMenuArgs(treeViewNode);
            const inlineCommands = menu.children.filter((item) => item instanceof menu_1.ActionMenuNode);
            const tailDecorations = super.renderTailDecorations(treeViewNode, props);
            return React.createElement(React.Fragment, null,
                inlineCommands.length > 0 && React.createElement("div", { className: browser_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, inlineCommands.map((item, index) => this.renderInlineCommand(item, index, this.focusService.hasFocus(treeViewNode), args))),
                tailDecorations !== undefined && React.createElement("div", { className: browser_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, tailDecorations));
        });
    }
    toTreeViewItemReference(treeNode) {
        return { viewId: this.id, itemId: treeNode.id };
    }
    resolveKeybindingForCommand(command) {
        let result = '';
        if (command) {
            const bindings = this.keybindings.getKeybindingsForCommand(command);
            let found = false;
            if (bindings && bindings.length > 0) {
                bindings.forEach(binding => {
                    if (!found && this.keybindings.isEnabledInScope(binding, this.node)) {
                        found = true;
                        result = ` (${this.keybindings.acceleratorFor(binding, '+')})`;
                    }
                });
            }
        }
        return result;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    renderInlineCommand(actionMenuNode, index, tabbable, args) {
        if (!actionMenuNode.icon || !this.commands.isVisible(actionMenuNode.command, ...args) || !actionMenuNode.when || !this.contextKeys.match(actionMenuNode.when)) {
            return false;
        }
        const className = [browser_1.TREE_NODE_SEGMENT_CLASS, browser_1.TREE_NODE_TAIL_CLASS, actionMenuNode.icon, widget_1.ACTION_ITEM, 'theia-tree-view-inline-action'].join(' ');
        const tabIndex = tabbable ? 0 : undefined;
        const titleString = actionMenuNode.label + this.resolveKeybindingForCommand(actionMenuNode.command);
        return React.createElement("div", { key: index, className: className, title: titleString, tabIndex: tabIndex, onClick: e => {
                e.stopPropagation();
                this.commands.executeCommand(actionMenuNode.command, ...args);
            } });
    }
    toContextMenuArgs(target) {
        if (this.options.multiSelect) {
            return [this.toTreeViewItemReference(target), this.model.selectedNodes.map(node => this.toTreeViewItemReference(node))];
        }
        else {
            return [this.toTreeViewItemReference(target)];
        }
    }
    setFlag(flag) {
        super.setFlag(flag);
        if (flag === widget_1.Widget.Flag.IsVisible) {
            this.onDidChangeVisibilityEmitter.fire(this.isVisible);
        }
    }
    clearFlag(flag) {
        super.clearFlag(flag);
        if (flag === widget_1.Widget.Flag.IsVisible) {
            this.onDidChangeVisibilityEmitter.fire(this.isVisible);
        }
    }
    handleEnter(event) {
        super.handleEnter(event);
        this.tryExecuteCommand();
    }
    tapNode(node) {
        super.tapNode(node);
        this.findCommands(node).then(commandMap => {
            if (commandMap.size > 0) {
                this.tryExecuteCommandMap(commandMap);
            }
            else if (node && this.isExpandable(node)) {
                this.model.toggleNodeExpansion(node);
            }
        });
    }
    // execute TreeItem.command if present
    async tryExecuteCommand(node) {
        this.tryExecuteCommandMap(await this.findCommands(node));
    }
    tryExecuteCommandMap(commandMap) {
        commandMap.forEach((args, commandId) => {
            this.commands.executeCommand(commandId, ...args);
        });
    }
    async findCommands(node) {
        const commandMap = new Map();
        const treeNodes = (node ? [node] : this.model.selectedNodes);
        if (await this.model.hasTreeItemResolve) {
            const cancellationToken = new common_1.CancellationTokenSource().token;
            // Resolve all resolvable nodes that don't have a command and haven't been resolved.
            const allResolved = Promise.all(treeNodes.map(maybeNeedsResolve => {
                if (!maybeNeedsResolve.command && maybeNeedsResolve instanceof ResolvableTreeViewNode && !maybeNeedsResolve.resolved) {
                    return maybeNeedsResolve.resolve(cancellationToken).catch(err => {
                        console.error(`Failed to resolve tree item '${maybeNeedsResolve.id}'`, err);
                    });
                }
                return Promise.resolve(maybeNeedsResolve);
            }));
            // Only need to wait but don't need the values because tree items are resolved in place.
            await allResolved;
        }
        for (const treeNode of treeNodes) {
            if (treeNode && treeNode.command) {
                commandMap.set(treeNode.command.id, treeNode.command.arguments || []);
            }
        }
        return commandMap;
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.update();
    }
    render() {
        return React.createElement('div', this.createContainerAttributes(), this.renderSearchInfo(), this.renderTree(this.model));
    }
    renderSearchInfo() {
        if (this._message) {
            return React.createElement("div", { className: 'theia-TreeViewInfo' }, this._message);
        }
        return undefined;
    }
    shouldShowWelcomeView() {
        return (this.model.proxy === undefined || this.model.isTreeEmpty) && this.message === undefined;
    }
    handleContextMenuEvent(node, event) {
        if (browser_1.SelectableTreeNode.is(node)) {
            // Keep the selection for the context menu, if the widget support multi-selection and the right click happens on an already selected node.
            if (!this.props.multiSelect || !node.selected) {
                const type = !!this.props.multiSelect && this.hasCtrlCmdMask(event) ? browser_1.TreeSelection.SelectionType.TOGGLE : browser_1.TreeSelection.SelectionType.DEFAULT;
                this.model.addSelection({ node, type });
            }
            this.focusService.setFocus(node);
            const contextMenuPath = this.props.contextMenuPath;
            if (contextMenuPath) {
                const { x, y } = event.nativeEvent;
                const args = this.toContextMenuArgs(node);
                const contextKeyService = this.contextKeyService.createOverlay([
                    ['viewItem', (TreeViewNode.is(node) && node.contextValue) || undefined],
                    ['view', this.options.id]
                ]);
                setTimeout(() => this.contextMenuRenderer.render({
                    menuPath: contextMenuPath,
                    anchor: { x, y },
                    args,
                    contextKeyService,
                    context: event.currentTarget
                }), 10);
            }
        }
        event.stopPropagation();
        event.preventDefault();
    }
};
exports.TreeViewWidget = TreeViewWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], TreeViewWidget.prototype, "applicationShell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], TreeViewWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], TreeViewWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TreeViewWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(TreeViewWidgetOptions),
    tslib_1.__metadata("design:type", TreeViewWidgetOptions)
], TreeViewWidget.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginTreeModel),
    tslib_1.__metadata("design:type", PluginTreeModel)
], TreeViewWidget.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TreeViewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.HoverService),
    tslib_1.__metadata("design:type", browser_1.HoverService)
], TreeViewWidget.prototype, "hoverService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], TreeViewWidget.prototype, "colorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dnd_file_content_store_1.DnDFileContentStore),
    tslib_1.__metadata("design:type", dnd_file_content_store_1.DnDFileContentStore)
], TreeViewWidget.prototype, "dndFileContentStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TreeViewWidget.prototype, "init", null);
exports.TreeViewWidget = TreeViewWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TreeViewWidget);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeViewsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const plugin_view_registry_1 = __webpack_require__(/*! ./plugin-view-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const tree_view_widget_1 = __webpack_require__(/*! ./tree-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./plugin-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const dnd_file_content_store_1 = __webpack_require__(/*! ./dnd-file-content-store */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js");
class TreeViewsMainImpl {
    constructor(rpc, container) {
        this.container = container;
        this.treeViewProviders = new Map();
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TREE_VIEWS_EXT);
        this.viewRegistry = container.get(plugin_view_registry_1.PluginViewRegistry);
        this.widgetManager = this.container.get(browser_1.WidgetManager);
        this.fileContentStore = this.container.get(dnd_file_content_store_1.DnDFileContentStore);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $registerTreeDataProvider(treeViewId, $options) {
        this.treeViewProviders.set(treeViewId, this.viewRegistry.registerViewDataProvider(treeViewId, async ({ state, viewInfo }) => {
            const options = {
                id: treeViewId,
                manageCheckboxStateManually: $options.manageCheckboxStateManually,
                showCollapseAll: $options.showCollapseAll,
                multiSelect: $options.canSelectMany,
                dragMimeTypes: $options.dragMimeTypes,
                dropMimeTypes: $options.dropMimeTypes
            };
            const widget = await this.widgetManager.getOrCreateWidget(plugin_view_registry_1.PLUGIN_VIEW_DATA_FACTORY_ID, options);
            widget.model.viewInfo = viewInfo;
            if (state) {
                widget.restoreState(state);
                // ensure that state is completely restored
                await widget.model.refresh();
            }
            else if (!widget.model.root) {
                const root = {
                    id: '',
                    parent: undefined,
                    name: '',
                    visible: false,
                    expanded: true,
                    children: []
                };
                widget.model.root = root;
            }
            if (this.toDispose.disposed) {
                widget.model.proxy = undefined;
            }
            else {
                widget.model.proxy = this.proxy;
                this.toDispose.push(core_1.Disposable.create(() => widget.model.proxy = undefined));
                this.handleTreeEvents(widget.id, widget);
            }
            await widget.model.refresh();
            return widget;
        }));
        this.toDispose.push(core_1.Disposable.create(() => this.$unregisterTreeDataProvider(treeViewId)));
    }
    async $unregisterTreeDataProvider(treeViewId) {
        const treeDataProvider = this.treeViewProviders.get(treeViewId);
        if (treeDataProvider) {
            this.treeViewProviders.delete(treeViewId);
            treeDataProvider.dispose();
        }
    }
    async $readDroppedFile(contentId) {
        const file = this.fileContentStore.getFile(contentId);
        const buffer = await file.arrayBuffer();
        return buffer_1.BinaryBuffer.wrap(new Uint8Array(buffer));
    }
    async $refresh(treeViewId, items) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        const widget = viewPanel && viewPanel.widgets[0];
        if (widget instanceof tree_view_widget_1.TreeViewWidget) {
            await widget.refresh(items);
        }
    }
    // elementParentChain parameter contain a list of tree ids from root to the revealed node
    // all parents of the revealed node should be fetched and expanded in order for it to reveal
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $reveal(treeViewId, elementParentChain, options) {
        const viewPanel = await this.viewRegistry.openView(treeViewId, { activate: options.focus, reveal: true });
        const widget = viewPanel && viewPanel.widgets[0];
        if (widget instanceof tree_view_widget_1.TreeViewWidget) {
            // pop last element which is the node to reveal
            const elementId = elementParentChain.pop();
            await this.expandParentChain(widget.model, elementParentChain);
            const treeNode = widget.model.getNode(elementId);
            if (treeNode) {
                if (options.expand && browser_1.ExpandableTreeNode.is(treeNode)) {
                    await widget.model.expandNode(treeNode);
                }
                if (options.select && browser_1.SelectableTreeNode.is(treeNode)) {
                    widget.model.selectNode(treeNode);
                }
            }
        }
    }
    /**
     * Expand all parents of the node to reveal from root. This should also fetch missing nodes to the frontend.
     */
    async expandParentChain(model, elementParentChain) {
        for (const elementId of elementParentChain) {
            const treeNode = model.getNode(elementId);
            if (browser_1.ExpandableTreeNode.is(treeNode)) {
                await model.expandNode(treeNode);
            }
        }
    }
    async $setMessage(treeViewId, message) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel instanceof plugin_view_widget_1.PluginViewWidget) {
            viewPanel.message = message;
        }
    }
    async $setTitle(treeViewId, title) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            viewPanel.title.label = title;
        }
    }
    async $setDescription(treeViewId, description) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            viewPanel.description = description;
        }
    }
    async $setBadge(treeViewId, badge) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            viewPanel.badge = badge === null || badge === void 0 ? void 0 : badge.value;
            viewPanel.badgeTooltip = badge === null || badge === void 0 ? void 0 : badge.tooltip;
        }
    }
    async setChecked(treeViewWidget, changedNodes) {
        await this.proxy.$checkStateChanged(treeViewWidget.id, changedNodes.map(node => {
            var _a;
            return ({
                id: node.id,
                checked: !!((_a = node.checkboxInfo) === null || _a === void 0 ? void 0 : _a.checked)
            });
        }));
    }
    handleTreeEvents(treeViewId, treeViewWidget) {
        this.toDispose.push(treeViewWidget.model.onExpansionChanged(event => {
            this.proxy.$setExpanded(treeViewId, event.id, event.expanded);
        }));
        this.toDispose.push(treeViewWidget.model.onSelectionChanged(event => {
            this.proxy.$setSelection(treeViewId, event.map((node) => node.id));
        }));
        const updateVisible = () => this.proxy.$setVisible(treeViewId, treeViewWidget.isVisible);
        updateVisible();
        this.toDispose.push(treeViewWidget.onDidChangeVisibility(() => updateVisible()));
    }
}
exports.TreeViewsMainImpl = TreeViewsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let ViewContextKeyService = class ViewContextKeyService {
    get viewItem() {
        return this._viewItem;
    }
    get activeViewlet() {
        return this._activeViewlet;
    }
    get activePanel() {
        return this._activePanel;
    }
    get activeAuxiliary() {
        return this._activeAuxiliary;
    }
    get focusedView() {
        return this._focusedView;
    }
    init() {
        this._viewItem = this.contextKeyService.createKey('viewItem', '');
        this._activeViewlet = this.contextKeyService.createKey('activeViewlet', '');
        this._activePanel = this.contextKeyService.createKey('activePanel', '');
        this._activeAuxiliary = this.contextKeyService.createKey('activeAuxiliary', '');
        this._focusedView = this.contextKeyService.createKey('focusedView', '');
    }
    match(expression) {
        return !expression || this.contextKeyService.match(expression);
    }
};
exports.ViewContextKeyService = ViewContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ViewContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ViewContextKeyService.prototype, "init", null);
exports.ViewContextKeyService = ViewContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ViewContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/e1f0f8f51390dea5df9096718fb6b647ed5a9534/src/vs/workbench/api/browser/mainThreadWebviewViews.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewViewsMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const plugin_view_registry_1 = __webpack_require__(/*! ../view/plugin-view-registry */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
class WebviewViewsMainImpl {
    constructor(rpc, container, webviewsMain) {
        this.webviewsMain = webviewsMain;
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        this.webviewViews = new Map();
        this.webviewViewProviders = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEW_VIEWS_EXT);
        this.widgetManager = container.get(browser_1.WidgetManager);
        this.pluginViewRegistry = container.get(plugin_view_registry_1.PluginViewRegistry);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $registerWebviewViewProvider(viewType, options) {
        if (this.webviewViewProviders.has(viewType)) {
            throw new Error(`View provider for ${viewType} already registered`);
        }
        const registration = await this.pluginViewRegistry.registerWebviewView(viewType, {
            resolve: async (webviewView, cancellation) => {
                const handle = webviewView.webview.identifier.id;
                this.webviewViews.set(handle, webviewView);
                this.webviewsMain.hookWebview(webviewView.webview);
                let state;
                if (webviewView.webview.state) {
                    try {
                        state = JSON.parse(webviewView.webview.state);
                        console.log(state);
                    }
                    catch (e) {
                        console.error('Could not load webview state', e, webviewView.webview.state);
                    }
                }
                if (options) {
                    webviewView.webview.options = options;
                }
                webviewView.onDidChangeVisibility(async (visible) => {
                    if (visible) {
                        await webviewView.resolve();
                    }
                    this.proxy.$onDidChangeWebviewViewVisibility(handle, visible);
                });
                webviewView.onDidDispose(() => {
                    this.proxy.$disposeWebviewView(handle);
                    this.webviewViews.delete(handle);
                });
                try {
                    await this.proxy.$resolveWebviewView(handle, viewType, webviewView.title, state, cancellation);
                }
                catch (error) {
                    this.logger.error(`Error resolving webview view '${viewType}': ${error}`);
                    webviewView.webview.setHTML('failed to load plugin webview view');
                }
            }
        });
        this.webviewViewProviders.set(viewType, registration);
    }
    getWebview(handle) {
        return this.widgetManager.tryGetWidget(handle);
    }
    $unregisterWebviewViewProvider(viewType) {
        const provider = this.webviewViewProviders.get(viewType);
        if (!provider) {
            throw new Error(`No view provider for ${viewType} registered`);
        }
        provider.dispose();
        this.webviewViewProviders.delete(viewType);
    }
    $setWebviewViewTitle(handle, value) {
        const webviewView = this.getWebviewView(handle);
        webviewView.title = value;
    }
    $setWebviewViewDescription(handle, value) {
        const webviewView = this.getWebviewView(handle);
        webviewView.description = value;
    }
    async $setBadge(handle, badge) {
        const webviewView = this.getWebviewView(handle);
        if (webviewView) {
            webviewView.badge = badge === null || badge === void 0 ? void 0 : badge.value;
            webviewView.badgeTooltip = badge === null || badge === void 0 ? void 0 : badge.tooltip;
        }
    }
    $show(handle, preserveFocus) {
        const webviewView = this.getWebviewView(handle);
        webviewView.show(preserveFocus);
    }
    getWebviewView(handle) {
        const webviewView = this.webviewViews.get(handle);
        if (!webviewView) {
            throw new Error(`No webview view registered for handle '${handle}'`);
        }
        return webviewView;
    }
}
exports.WebviewViewsMainImpl = WebviewViewsMainImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    tslib_1.__metadata("design:type", Object)
], WebviewViewsMainImpl.prototype, "logger", void 0);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewEnvironment = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../node_modules/@theia/core/lib/browser/endpoint.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../node_modules/@theia/core/lib/common/env-variables/index.js");
const webview_protocol_1 = __webpack_require__(/*! ../../common/webview-protocol */ "../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
let WebviewEnvironment = class WebviewEnvironment {
    constructor() {
        this.externalEndpointHost = new promise_util_1.Deferred();
    }
    init() {
        this.doInit();
    }
    async doInit() {
        this._hostPatternPromise = this.getHostPattern();
        try {
            const endpointPattern = await this.hostPatternPromise;
            const { host } = new endpoint_1.Endpoint();
            this.externalEndpointHost.resolve(endpointPattern.replace('{{hostname}}', host));
        }
        catch (e) {
            this.externalEndpointHost.reject(e);
        }
    }
    get hostPatternPromise() {
        return this._hostPatternPromise;
    }
    async externalEndpointUrl() {
        const host = await this.externalEndpointHost.promise;
        return new endpoint_1.Endpoint({
            host,
            path: '/webview'
        }).getRestUrl();
    }
    async externalEndpoint() {
        return (await this.externalEndpointUrl()).toString(true);
    }
    async resourceRoot(host) {
        if (host === 'frontend') {
            return (await this.externalEndpointUrl()).withPath('{{path}}').toString(true);
        }
        // Make sure we preserve the scheme of the resource but convert it into a normal path segment
        // The scheme is important as we need to know if we are requesting a local or a remote resource.
        return (await this.externalEndpointUrl()).resolve('theia-resource/{{scheme}}//{{authority}}/{{path}}').toString(true);
    }
    async cspSource() {
        return (await this.externalEndpointUrl()).withPath('').withQuery('').withFragment('').toString(true).replace('{{uuid}}', '*');
    }
    async getHostPattern() {
        return environment_1.environment.electron.is()
            ? webview_protocol_1.WebviewExternalEndpoint.defaultPattern
            : this.environments.getValue(webview_protocol_1.WebviewExternalEndpoint.pattern)
                .then(variable => (variable === null || variable === void 0 ? void 0 : variable.value) || webview_protocol_1.WebviewExternalEndpoint.defaultPattern);
    }
};
exports.WebviewEnvironment = WebviewEnvironment;
tslib_1.__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    tslib_1.__metadata("design:type", Object)
], WebviewEnvironment.prototype, "environments", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewEnvironment.prototype, "init", null);
exports.WebviewEnvironment = WebviewEnvironment = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewEnvironment);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-preferences.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-preferences.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindWebviewPreferences = exports.createWebviewPreferences = exports.WebviewPreferences = exports.WebviewPreferenceContribution = exports.WebviewConfigSchema = void 0;
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const frontendConfig = frontend_application_config_provider_1.FrontendApplicationConfigProvider.get();
exports.WebviewConfigSchema = {
    type: 'object',
    properties: {
        'webview.trace': {
            type: 'string',
            enum: ['off', 'on', 'verbose'],
            description: nls_1.nls.localize('theia/plugin-ext/webviewTrace', 'Controls communication tracing with webviews.'),
            default: 'off'
        }
    }
};
if (frontendConfig.securityWarnings) {
    exports.WebviewConfigSchema.properties["webview.warnIfUnsecure"] = {
        scope: 'application',
        type: 'boolean',
        description: nls_1.nls.localize('theia/plugin-ext/webviewWarnIfUnsecure', 'Warns users that webviews are currently deployed unsecurely.'),
        default: true,
    };
}
exports.WebviewPreferenceContribution = Symbol('WebviewPreferenceContribution');
exports.WebviewPreferences = Symbol('WebviewPreferences');
function createWebviewPreferences(preferences, schema = exports.WebviewConfigSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createWebviewPreferences = createWebviewPreferences;
function bindWebviewPreferences(bind) {
    bind(exports.WebviewPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.WebviewPreferenceContribution);
        return createWebviewPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.WebviewPreferenceContribution).toConstantValue({ schema: exports.WebviewConfigSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.WebviewPreferenceContribution);
}
exports.bindWebviewPreferences = bindWebviewPreferences;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewResourceCache = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
/**
 * Browser based cache of webview resources across all instances.
 */
let WebviewResourceCache = class WebviewResourceCache {
    constructor() {
        this.cache = new promise_util_1.Deferred();
        this.resolveCache();
    }
    async resolveCache() {
        try {
            this.cache.resolve(await caches.open('webview:v1'));
        }
        catch (e) {
            console.error('Failed to enable webview caching: ', e);
            this.cache.resolve(undefined);
        }
    }
    async match(url) {
        const cache = await this.cache.promise;
        if (!cache) {
            return undefined;
        }
        const response = await cache.match(url);
        if (!response) {
            return undefined;
        }
        return {
            eTag: response.headers.get('ETag') || undefined,
            body: async () => {
                const buffer = await response.arrayBuffer();
                return new Uint8Array(buffer);
            }
        };
    }
    async delete(url) {
        const cache = await this.cache.promise;
        if (!cache) {
            return false;
        }
        return cache.delete(url);
    }
    async put(url, response) {
        if (!response.eTag) {
            return;
        }
        const cache = await this.cache.promise;
        if (!cache) {
            return;
        }
        const body = await response.body();
        await cache.put(url, new Response(body, {
            status: 200,
            headers: { 'ETag': response.eTag }
        }));
    }
};
exports.WebviewResourceCache = WebviewResourceCache;
exports.WebviewResourceCache = WebviewResourceCache = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], WebviewResourceCache);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/common/themeing.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewThemeDataProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const editor_preferences_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-preferences */ "../node_modules/@theia/editor/lib/browser/editor-preferences.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const color_application_contribution_1 = __webpack_require__(/*! @theia/core/lib/browser/color-application-contribution */ "../node_modules/@theia/core/lib/browser/color-application-contribution.js");
let WebviewThemeDataProvider = class WebviewThemeDataProvider {
    constructor() {
        this.onDidChangeThemeDataEmitter = new event_1.Emitter();
        this.onDidChangeThemeData = this.onDidChangeThemeDataEmitter.event;
        this.editorStyles = new Map([
            ['editor.fontFamily', 'editor-font-family'],
            ['editor.fontWeight', 'editor-font-weight'],
            ['editor.fontSize', 'editor-font-size']
        ]);
    }
    init() {
        this.colorContribution.onDidChange(() => this.reset());
        this.editorPreferences.onPreferenceChanged(e => {
            if (this.editorStyles.has(e.preferenceName)) {
                this.reset();
            }
        });
    }
    reset() {
        if (this.themeData) {
            this.themeData = undefined;
            this.onDidChangeThemeDataEmitter.fire(undefined);
        }
    }
    getThemeData() {
        if (!this.themeData) {
            this.themeData = this.computeThemeData();
        }
        return this.themeData;
    }
    computeThemeData() {
        const styles = {};
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const addStyle = (id, rawValue) => {
            if (rawValue) {
                const value = typeof rawValue === 'number' || typeof rawValue === 'string' ? rawValue : String(rawValue);
                styles[this.colors.toCssVariableName(id).substring(2)] = value;
                styles[this.colors.toCssVariableName(id, 'vscode').substring(2)] = value;
            }
        };
        addStyle('font-family', '-apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif');
        addStyle('font-weight', 'normal');
        addStyle('font-size', '13px');
        this.editorStyles.forEach((value, key) => addStyle(value, this.editorPreferences[key]));
        for (const id of this.colors.getColors()) {
            const color = this.colors.getCurrentColor(id);
            if (color) {
                addStyle(id, color.toString());
            }
        }
        const activeTheme = this.getActiveTheme();
        return {
            styles,
            activeThemeName: activeTheme.label,
            activeThemeType: this.getThemeType(activeTheme)
        };
    }
    getActiveTheme() {
        return this.themeService.getCurrentTheme();
    }
    getThemeType(theme) {
        switch (theme.type) {
            case 'light': return 'vscode-light';
            case 'dark': return 'vscode-dark';
            default: return 'vscode-high-contrast';
        }
    }
};
exports.WebviewThemeDataProvider = WebviewThemeDataProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_preferences_1.EditorPreferences),
    tslib_1.__metadata("design:type", Object)
], WebviewThemeDataProvider.prototype, "editorPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], WebviewThemeDataProvider.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_application_contribution_1.ColorApplicationContribution),
    tslib_1.__metadata("design:type", color_application_contribution_1.ColorApplicationContribution)
], WebviewThemeDataProvider.prototype, "colorContribution", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], WebviewThemeDataProvider.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewThemeDataProvider.prototype, "init", null);
exports.WebviewThemeDataProvider = WebviewThemeDataProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewThemeDataProvider);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/browser/baseWebviewElement.ts
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/browser/webviewElement.ts#
var WebviewWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewWidget = exports.WebviewWidgetExternalEndpoint = exports.WebviewWidgetIdentifier = exports.WEBVIEW_CONTEXT_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const mime = __webpack_require__(/*! mime */ "../node_modules/@theia/plugin-ext/node_modules/mime/index.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const widget_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/widget */ "../node_modules/@theia/core/lib/browser/widgets/widget.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const application_shell_mouse_tracker_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell-mouse-tracker */ "../node_modules/@theia/core/lib/browser/shell/application-shell-mouse-tracker.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const webview_environment_1 = __webpack_require__(/*! ./webview-environment */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../node_modules/@theia/core/lib/browser/opener-service.js");
const keybinding_1 = __webpack_require__(/*! @theia/core/lib/browser/keybinding */ "../node_modules/@theia/core/lib/browser/keybinding.js");
const uri_components_1 = __webpack_require__(/*! ../../../common/uri-components */ "../node_modules/@theia/plugin-ext/lib/common/uri-components.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const webview_theme_data_provider_1 = __webpack_require__(/*! ./webview-theme-data-provider */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js");
const external_uri_service_1 = __webpack_require__(/*! @theia/core/lib/browser/external-uri-service */ "../node_modules/@theia/core/lib/browser/external-uri-service.js");
const output_channel_1 = __webpack_require__(/*! @theia/output/lib/browser/output-channel */ "../node_modules/@theia/output/lib/browser/output-channel.js");
const webview_preferences_1 = __webpack_require__(/*! ./webview-preferences */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-preferences.js");
const webview_resource_cache_1 = __webpack_require__(/*! ./webview-resource-cache */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../node_modules/@theia/core/lib/browser/endpoint.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser/browser */ "../node_modules/@theia/core/lib/browser/browser.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../node_modules/@theia/filesystem/lib/common/files.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const plugin_view_widget_1 = __webpack_require__(/*! ../view/plugin-view-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
// Style from core
const TRANSPARENT_OVERLAY_STYLE = 'theia-transparent-overlay';
exports.WEBVIEW_CONTEXT_MENU = ['webview-context-menu'];
let WebviewWidgetIdentifier = class WebviewWidgetIdentifier {
};
exports.WebviewWidgetIdentifier = WebviewWidgetIdentifier;
exports.WebviewWidgetIdentifier = WebviewWidgetIdentifier = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewWidgetIdentifier);
exports.WebviewWidgetExternalEndpoint = Symbol('WebviewWidgetExternalEndpoint');
let WebviewWidget = WebviewWidget_1 = class WebviewWidget extends widget_1.BaseWidget {
    constructor() {
        super(...arguments);
        this.viewState = {
            visible: false,
            active: false,
            position: 0
        };
        this.html = '';
        this._contentOptions = {};
        this.options = {};
        this.ready = new promise_util_1.Deferred();
        this.onMessageEmitter = new event_1.Emitter();
        this.onMessage = this.onMessageEmitter.event;
        this.pendingMessages = [];
        this.toHide = new disposable_1.DisposableCollection();
        this.isExtractable = true;
        this.secondaryWindow = undefined;
        this.onDidChangeBadgeEmitter = new event_1.Emitter();
        this.onDidChangeBadgeTooltipEmitter = new event_1.Emitter();
        this.toDisposeOnIcon = new disposable_1.DisposableCollection();
    }
    get contentOptions() {
        return this._contentOptions;
    }
    get state() {
        return this._state;
    }
    init() {
        this.node.tabIndex = 0;
        this.id = WebviewWidget_1.FACTORY_ID + ':' + this.identifier.id;
        this.title.closable = true;
        this.addClass(WebviewWidget_1.Styles.WEBVIEW);
        this.toDispose.push(this.onMessageEmitter);
        this.toDispose.push(this.onDidChangeBadgeEmitter);
        this.toDispose.push(this.onDidChangeBadgeTooltipEmitter);
        this.transparentOverlay = document.createElement('div');
        this.transparentOverlay.classList.add(TRANSPARENT_OVERLAY_STYLE);
        this.transparentOverlay.style.display = 'none';
        this.node.appendChild(this.transparentOverlay);
        this.toDispose.push(this.mouseTracker.onMousedown(() => {
            if (this.element && this.element.style.display !== 'none') {
                this.transparentOverlay.style.display = 'block';
            }
        }));
        this.toDispose.push(this.mouseTracker.onMouseup(() => {
            if (this.element && this.element.style.display !== 'none') {
                this.transparentOverlay.style.display = 'none';
            }
        }));
    }
    get onDidChangeBadge() {
        return this.onDidChangeBadgeEmitter.event;
    }
    get onDidChangeBadgeTooltip() {
        return this.onDidChangeBadgeTooltipEmitter.event;
    }
    get badge() {
        return this._badge;
    }
    set badge(badge) {
        this._badge = badge;
        this.onDidChangeBadgeEmitter.fire();
    }
    get badgeTooltip() {
        return this._badgeTooltip;
    }
    set badgeTooltip(badgeTooltip) {
        this._badgeTooltip = badgeTooltip;
        this.onDidChangeBadgeTooltipEmitter.fire();
    }
    onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.doShow();
        // iframe has to be reloaded when moved to another DOM element
        this.toDisposeOnDetach.push(disposable_1.Disposable.create(() => this.forceHide()));
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.addEventListener(this.node, 'focus', () => {
            if (this.element) {
                this.doSend('focus');
            }
        });
    }
    onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.doShow();
    }
    onAfterHide(msg) {
        super.onAfterHide(msg);
        this.doHide();
    }
    doHide() {
        if (this.options.retainContextWhenHidden !== true) {
            if (this.hideTimeout === undefined) {
                // avoid removing iframe if a widget moved quickly
                this.hideTimeout = setTimeout(() => this.forceHide(), 50);
            }
        }
    }
    forceHide() {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = undefined;
        this.toHide.dispose();
    }
    doShow() {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = undefined;
        if (!this.toHide.disposed) {
            return;
        }
        this.toDispose.push(this.toHide);
        const element = document.createElement('iframe');
        element.className = 'webview';
        element.sandbox.add('allow-scripts', 'allow-forms', 'allow-same-origin', 'allow-downloads');
        if (!browser_1.isFirefox) {
            element.setAttribute('allow', 'clipboard-read; clipboard-write; usb; serial; hid;');
        }
        element.setAttribute('src', `${this.externalEndpoint}/index.html?id=${this.identifier.id}`);
        element.style.border = 'none';
        element.style.width = '100%';
        element.style.height = '100%';
        this.element = element;
        this.node.appendChild(this.element);
        this.toHide.push(disposable_1.Disposable.create(() => {
            if (this.element) {
                this.element.remove();
                this.element = undefined;
            }
        }));
        const oldReady = this.ready;
        const ready = new promise_util_1.Deferred();
        ready.promise.then(() => oldReady.resolve());
        this.ready = ready;
        this.toHide.push(disposable_1.Disposable.create(() => this.ready = new promise_util_1.Deferred()));
        const subscription = this.on("webview-ready" /* WebviewMessageChannels.webviewReady */, () => {
            subscription.dispose();
            ready.resolve();
        });
        this.toHide.push(subscription);
        this.toHide.push(this.on("onmessage" /* WebviewMessageChannels.onmessage */, (data) => this.onMessageEmitter.fire(data)));
        this.toHide.push(this.on("onconsole" /* WebviewMessageChannels.onconsole */, (data) => this.forwardConsoleLog(data)));
        this.toHide.push(this.on("did-click-link" /* WebviewMessageChannels.didClickLink */, (uri) => this.openLink(new uri_1.default(uri))));
        this.toHide.push(this.on("do-update-state" /* WebviewMessageChannels.doUpdateState */, (state) => {
            this._state = state;
        }));
        this.toHide.push(this.on("did-focus" /* WebviewMessageChannels.didFocus */, () => 
        // emulate the webview focus without actually changing focus
        this.node.dispatchEvent(new FocusEvent('focus'))));
        this.toHide.push(this.on("did-blur" /* WebviewMessageChannels.didBlur */, () => {
            /* no-op: webview loses focus only if another element gains focus in the main window */
        }));
        this.toHide.push(this.on("do-reload" /* WebviewMessageChannels.doReload */, () => this.reload()));
        this.toHide.push(this.on("load-resource" /* WebviewMessageChannels.loadResource */, (entry) => this.loadResource(entry.path, entry.query)));
        this.toHide.push(this.on("load-localhost" /* WebviewMessageChannels.loadLocalhost */, (entry) => this.loadLocalhost(entry.origin)));
        this.toHide.push(this.on("did-keydown" /* WebviewMessageChannels.didKeydown */, (data) => {
            // Electron: workaround for https://github.com/electron/electron/issues/14258
            // We have to detect keyboard events in the <webview> and dispatch them to our
            // keybinding service because these events do not bubble to the parent window anymore.
            this.keybindings.dispatchKeyDown(data, this.element);
        }));
        this.toHide.push(this.on("did-mousedown" /* WebviewMessageChannels.didMouseDown */, (data) => {
            // We have to dispatch mousedown events so menus will be closed when clicking inside webviews.
            // See: https://github.com/eclipse-theia/theia/issues/7752
            this.dispatchMouseEvent('mousedown', data);
        }));
        this.toHide.push(this.on("did-mouseup" /* WebviewMessageChannels.didMouseUp */, (data) => {
            this.dispatchMouseEvent('mouseup', data);
        }));
        this.toHide.push(this.on("did-context-menu" /* WebviewMessageChannels.didcontextmenu */, (event) => {
            this.handleContextMenu(event);
        }));
        this.style();
        this.toHide.push(this.themeDataProvider.onDidChangeThemeData(() => this.style()));
        this.doUpdateContent();
        while (this.pendingMessages.length) {
            this.sendMessage(this.pendingMessages.shift());
        }
    }
    async loadLocalhost(origin) {
        const redirect = await this.getRedirect(origin);
        return this.doSend('did-load-localhost', { origin, location: redirect });
    }
    dispatchMouseEvent(type, data) {
        const domRect = this.node.getBoundingClientRect();
        document.dispatchEvent(new MouseEvent(type, {
            ...data,
            clientX: domRect.x + data.clientX,
            clientY: domRect.y + data.clientY
        }));
    }
    handleContextMenu(event) {
        const domRect = this.node.getBoundingClientRect();
        this.contextKeyService.with(this.parent instanceof plugin_view_widget_1.PluginViewWidget ?
            { webviewId: this.parent.options.viewId, ...event.context } : {}, () => {
            this.contextMenuRenderer.render({
                menuPath: exports.WEBVIEW_CONTEXT_MENU,
                args: [event.context],
                anchor: {
                    x: domRect.x + event.clientX, y: domRect.y + event.clientY
                },
                context: this.node
            });
        });
    }
    async getRedirect(url) {
        const uri = new uri_1.default(url);
        const localhost = this.externalUriService.parseLocalhost(uri);
        if (!localhost) {
            return undefined;
        }
        if (this._contentOptions.portMapping) {
            for (const mapping of this._contentOptions.portMapping) {
                if (mapping.webviewPort === localhost.port) {
                    if (mapping.webviewPort !== mapping.extensionHostPort) {
                        return this.toRemoteUrl(uri.withAuthority(`${localhost.address}:${mapping.extensionHostPort}`));
                    }
                }
            }
        }
        return this.toRemoteUrl(uri);
    }
    async toRemoteUrl(localUri) {
        const remoteUri = await this.externalUriService.resolve(localUri);
        const remoteUrl = remoteUri.toString();
        if (remoteUrl[remoteUrl.length - 1] === '/') {
            return remoteUrl.slice(0, remoteUrl.length - 1);
        }
        return remoteUrl;
    }
    setContentOptions(contentOptions) {
        if (coreutils_1.JSONExt.deepEqual(this.contentOptions, contentOptions)) {
            return;
        }
        this._contentOptions = contentOptions;
        this.doUpdateContent();
    }
    setIconUrl(iconUrl) {
        if ((this.iconUrl && iconUrl && coreutils_1.JSONExt.deepEqual(this.iconUrl, iconUrl)) || (this.iconUrl === iconUrl)) {
            return;
        }
        this.toDisposeOnIcon.dispose();
        this.toDispose.push(this.toDisposeOnIcon);
        this.iconUrl = iconUrl;
        if (iconUrl) {
            const darkIconUrl = typeof iconUrl === 'object' ? iconUrl.dark : iconUrl;
            const lightIconUrl = typeof iconUrl === 'object' ? iconUrl.light : iconUrl;
            const iconClass = `webview-${this.identifier.id}-file-icon`;
            this.toDisposeOnIcon.push(this.sharedStyle.insertRule(`.theia-webview-icon.${iconClass}::before`, theme => `background-image: url(${this.toEndpoint(theme.type === 'light' ? lightIconUrl : darkIconUrl)});`));
            this.title.iconClass = `theia-webview-icon ${iconClass}`;
        }
        else {
            this.title.iconClass = '';
        }
    }
    toEndpoint(pathname) {
        return new endpoint_1.Endpoint({ path: pathname }).getRestUrl().toString();
    }
    setHTML(value) {
        this.html = this.preprocessHtml(value);
        this.doUpdateContent();
    }
    preprocessHtml(value) {
        return value
            .replace(/(["'])(?:vscode|theia)-resource:(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_, startQuote, _1, scheme, path, endQuote) => {
            if (scheme) {
                return `${startQuote}${this.externalEndpoint}/theia-resource/${scheme}${path}${endQuote}`;
            }
            return `${startQuote}${this.externalEndpoint}/theia-resource/file${path}${endQuote}`;
        });
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.node.focus();
    }
    reload() {
        this.doUpdateContent();
    }
    forwardConsoleLog(log) {
        const message = `[webview: ${this.identifier.id}] ${log.message ? JSON.parse(log.message) : undefined}`;
        if (log.optionalParams !== undefined) {
            console[log.level](message, JSON.parse(log.optionalParams));
        }
        else {
            console[log.level](message);
        }
    }
    style() {
        const { styles, activeThemeType, activeThemeName } = this.themeDataProvider.getThemeData();
        this.doSend('styles', { styles, activeThemeType, activeThemeName });
    }
    openLink(link) {
        const supported = this.toSupportedLink(link);
        if (supported) {
            (0, opener_service_1.open)(this.openerService, supported);
        }
    }
    toSupportedLink(link) {
        if (WebviewWidget_1.standardSupportedLinkSchemes.has(link.scheme)) {
            const linkAsString = link.toString();
            for (const resourceRoot of [this.externalEndpoint + '/theia-resource', this.externalEndpoint + '/vscode-resource']) {
                if (linkAsString.startsWith(resourceRoot + '/')) {
                    return this.normalizeRequestUri(linkAsString.substring(resourceRoot.length));
                }
            }
            return link;
        }
        if (link.scheme === uri_components_1.Schemes.command) {
            if (Array.isArray(this.contentOptions.enableCommandUris) && this.contentOptions.enableCommandUris.some(value => value === link.path.toString())) {
                return link;
            }
            else if (this.contentOptions.enableCommandUris === true) {
                return link;
            }
        }
        return undefined;
    }
    async loadResource(requestPath, requestQuery = '') {
        const normalizedUri = this.normalizeRequestUri(requestPath).withQuery(decodeURIComponent(requestQuery));
        // browser cache does not support file scheme, normalize to current endpoint scheme and host
        // use requestPath rather than normalizedUri.path to preserve the scheme of the requested resource as a path segment
        const cacheUrl = new endpoint_1.Endpoint({ path: requestPath }).getRestUrl().withQuery(decodeURIComponent(requestQuery)).toString();
        try {
            if (this.contentOptions.localResourceRoots) {
                for (const root of this.contentOptions.localResourceRoots) {
                    if (!new uri_1.default(root).path.isEqualOrParent(normalizedUri.path)) {
                        continue;
                    }
                    let cached = await this.resourceCache.match(cacheUrl);
                    try {
                        const result = await this.fileService.readFileStream(normalizedUri, { etag: cached === null || cached === void 0 ? void 0 : cached.eTag });
                        const { buffer } = await buffer_1.BinaryBufferReadableStream.toBuffer(result.value);
                        cached = { body: () => buffer, eTag: result.etag };
                        this.resourceCache.put(cacheUrl, cached);
                    }
                    catch (e) {
                        if (!(e instanceof files_1.FileOperationError && e.fileOperationResult === 2 /* FileOperationResult.FILE_NOT_MODIFIED_SINCE */)) {
                            throw e;
                        }
                    }
                    if (cached) {
                        const data = await cached.body();
                        return this.doSend('did-load-resource', {
                            status: 200,
                            path: requestPath,
                            mime: mime.getType(normalizedUri.path.toString()) || 'application/octet-stream',
                            data
                        });
                    }
                }
            }
        }
        catch {
            // no-op
        }
        this.resourceCache.delete(cacheUrl);
        return this.doSend('did-load-resource', {
            status: 404,
            path: requestPath
        });
    }
    normalizeRequestUri(requestPath) {
        const normalizedPath = decodeURIComponent(requestPath);
        const requestUri = new uri_1.default(normalizedPath.replace(/^\/([a-zA-Z0-9.\-+]+)\/(.+)$/, (_, scheme, path) => scheme + ':/' + path));
        if (requestUri.scheme !== 'theia-resource' && requestUri.scheme !== 'vscode-resource') {
            return requestUri;
        }
        // Modern vscode-resources uris put the scheme of the requested resource as the authority
        if (requestUri.authority) {
            return new uri_1.default(requestUri.authority + ':' + requestUri.path);
        }
        // Old style vscode-resource uris lose the scheme of the resource which means they are unable to
        // load a mix of local and remote content properly.
        return requestUri.withScheme('file');
    }
    sendMessage(data) {
        if (this.element) {
            this.doSend('message', data);
        }
        else {
            this.pendingMessages.push(data);
        }
    }
    doUpdateContent() {
        this.doSend('content', {
            contents: this.html,
            options: this.contentOptions,
            state: this.state
        });
    }
    storeState() {
        return {
            viewType: this.viewType,
            title: this.title.label,
            iconUrl: this.iconUrl,
            options: this.options,
            contentOptions: this.contentOptions,
            state: this.state
        };
    }
    restoreState(oldState) {
        const { viewType, title, iconUrl, options, contentOptions, state } = oldState;
        this.viewType = viewType;
        this.title.label = title;
        this.setIconUrl(iconUrl);
        this.options = options;
        this._contentOptions = contentOptions;
        this._state = state;
    }
    setIframeHeight(height) {
        if (this.element) {
            this.element.style.height = `${height}px`;
        }
    }
    async doSend(channel, data) {
        if (!this.element) {
            return;
        }
        try {
            await this.ready.promise;
            this.postMessage(channel, data);
        }
        catch (e) {
            console.error(e);
        }
    }
    postMessage(channel, data) {
        if (this.element) {
            this.trace('out', channel, data);
            if (this.secondaryWindow) {
                this.secondaryWindow.postMessage({ channel, args: data }, '*');
            }
            else {
                this.element.contentWindow.postMessage({ channel, args: data }, '*');
            }
        }
    }
    on(channel, handler) {
        const listener = (e) => {
            if (!e || !e.data || e.data.target !== this.identifier.id) {
                return;
            }
            if (e.data.channel === channel) {
                this.trace('in', e.data.channel, e.data.data);
                handler(e.data.data);
            }
        };
        window.addEventListener('message', listener);
        return disposable_1.Disposable.create(() => window.removeEventListener('message', listener));
    }
    trace(kind, channel, data) {
        const value = this.preferences['webview.trace'];
        if (value === 'off') {
            return;
        }
        const output = this.outputManager.getChannel('webviews');
        output.append('\n' + this.identifier.id);
        output.append(kind === 'out' ? ' => ' : ' <= ');
        output.append(channel);
        if (value === 'verbose') {
            if (data) {
                output.append('\n' + JSON.stringify(data, undefined, 2));
            }
        }
    }
};
exports.WebviewWidget = WebviewWidget;
WebviewWidget.standardSupportedLinkSchemes = new Set([
    uri_components_1.Schemes.http,
    uri_components_1.Schemes.https,
    uri_components_1.Schemes.mailto,
    uri_components_1.Schemes.vscode
]);
WebviewWidget.FACTORY_ID = 'plugin-webview';
tslib_1.__decorate([
    (0, inversify_1.inject)(WebviewWidgetIdentifier),
    tslib_1.__metadata("design:type", WebviewWidgetIdentifier)
], WebviewWidget.prototype, "identifier", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.WebviewWidgetExternalEndpoint),
    tslib_1.__metadata("design:type", String)
], WebviewWidget.prototype, "externalEndpoint", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_shell_mouse_tracker_1.ApplicationShellMouseTracker),
    tslib_1.__metadata("design:type", application_shell_mouse_tracker_1.ApplicationShellMouseTracker)
], WebviewWidget.prototype, "mouseTracker", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], WebviewWidget.prototype, "environment", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(opener_service_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "openerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(keybinding_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", keybinding_1.KeybindingRegistry)
], WebviewWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], WebviewWidget.prototype, "sharedStyle", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_theme_data_provider_1.WebviewThemeDataProvider),
    tslib_1.__metadata("design:type", webview_theme_data_provider_1.WebviewThemeDataProvider)
], WebviewWidget.prototype, "themeDataProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(external_uri_service_1.ExternalUriService),
    tslib_1.__metadata("design:type", external_uri_service_1.ExternalUriService)
], WebviewWidget.prototype, "externalUriService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(output_channel_1.OutputChannelManager),
    tslib_1.__metadata("design:type", output_channel_1.OutputChannelManager)
], WebviewWidget.prototype, "outputManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_preferences_1.WebviewPreferences),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "preferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], WebviewWidget.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_resource_cache_1.WebviewResourceCache),
    tslib_1.__metadata("design:type", webview_resource_cache_1.WebviewResourceCache)
], WebviewWidget.prototype, "resourceCache", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_2.ContextMenuRenderer)
], WebviewWidget.prototype, "contextMenuRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewWidget.prototype, "init", null);
exports.WebviewWidget = WebviewWidget = WebviewWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewWidget);
(function (WebviewWidget) {
    let Styles;
    (function (Styles) {
        Styles.WEBVIEW = 'theia-webview';
    })(Styles = WebviewWidget.Styles || (WebviewWidget.Styles = {}));
})(WebviewWidget || (exports.WebviewWidget = WebviewWidget = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewsMainImpl = void 0;
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const application_shell_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell */ "../node_modules/@theia/core/lib/browser/shell/application-shell.js");
const webview_1 = __webpack_require__(/*! ./webview/webview */ "../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const view_column_service_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/view-column-service */ "../node_modules/@theia/core/lib/browser/shell/view-column-service.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../node_modules/@theia/core/lib/browser/widget-manager.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editors/custom-editor-widget */ "../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
class WebviewsMainImpl {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.updateViewStates = debounce(() => {
            const widgets = this.widgetManager.getWidgets(webview_1.WebviewWidget.FACTORY_ID);
            const customEditors = this.widgetManager.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID);
            for (const widget of widgets.concat(customEditors)) {
                if (widget instanceof webview_1.WebviewWidget) {
                    this.updateViewState(widget);
                }
            }
        }, 100);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEWS_EXT);
        this.shell = container.get(application_shell_1.ApplicationShell);
        this.viewColumnService = container.get(view_column_service_1.ViewColumnService);
        this.widgetManager = container.get(widget_manager_1.WidgetManager);
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.toDispose.push(this.shell.onDidChangeActiveWidget(() => this.updateViewStates()));
        this.toDispose.push(this.shell.onDidChangeCurrentWidget(() => this.updateViewStates()));
        this.toDispose.push(this.viewColumnService.onViewColumnChanged(() => this.updateViewStates()));
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $createWebviewPanel(panelId, viewType, title, showOptions, options) {
        const view = await this.widgetManager.getOrCreateWidget(webview_1.WebviewWidget.FACTORY_ID, { id: panelId, viewId: viewType });
        this.hookWebview(view);
        view.viewType = viewType;
        view.title.label = title;
        const { enableFindWidget, retainContextWhenHidden, enableScripts, enableForms, localResourceRoots, ...contentOptions } = options;
        view.options = { enableFindWidget, retainContextWhenHidden };
        view.setContentOptions({
            allowScripts: enableScripts,
            allowForms: enableForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => root.toString()),
            ...contentOptions
        });
        this.addOrReattachWidget(view, showOptions);
    }
    hookWebview(view) {
        const handle = view.identifier.id;
        this.toDispose.push(view.onDidChangeVisibility(() => this.updateViewState(view)));
        this.toDispose.push(view.onMessage(data => this.proxy.$onMessage(handle, data)));
        view.disposed.connect(() => {
            if (this.toDispose.disposed) {
                return;
            }
            this.proxy.$onDidDisposeWebviewPanel(handle);
        });
    }
    addOrReattachWidget(widget, showOptions) {
        var _a;
        const area = showOptions.area ? showOptions.area : types_impl_1.WebviewPanelTargetArea.Main;
        const widgetOptions = { area };
        let mode = 'open-to-right';
        const canOpenBeside = showOptions.viewColumn === types_impl_1.ViewColumn.Beside && (area === types_impl_1.WebviewPanelTargetArea.Main || area === types_impl_1.WebviewPanelTargetArea.Bottom);
        if (canOpenBeside) {
            const activeOrRightmostTabbar = this.shell.getTabBarFor(area);
            const ref = (_a = activeOrRightmostTabbar === null || activeOrRightmostTabbar === void 0 ? void 0 : activeOrRightmostTabbar.currentTitle) === null || _a === void 0 ? void 0 : _a.owner;
            if (ref) {
                Object.assign(widgetOptions, { ref, mode });
            }
        }
        else if (widgetOptions.area === 'main' && showOptions.viewColumn !== undefined) {
            this.viewColumnService.updateViewColumns();
            let widgetIds = this.viewColumnService.getViewColumnIds(showOptions.viewColumn);
            if (widgetIds.length > 0) {
                mode = 'tab-after';
            }
            else if (showOptions.viewColumn >= 0) {
                const columnsSize = this.viewColumnService.viewColumnsSize();
                if (columnsSize) {
                    showOptions.viewColumn = columnsSize - 1;
                    widgetIds = this.viewColumnService.getViewColumnIds(showOptions.viewColumn);
                }
            }
            const ref = this.shell.getWidgets(widgetOptions.area).find(w => !w.isHidden && widgetIds.indexOf(w.id) !== -1);
            if (ref) {
                Object.assign(widgetOptions, { ref, mode });
            }
        }
        this.shell.addWidget(widget, widgetOptions);
        if (showOptions.preserveFocus) {
            this.shell.revealWidget(widget.id);
        }
        else {
            this.shell.activateWidget(widget.id);
        }
    }
    async $disposeWebview(handle) {
        const view = await this.tryGetWebview(handle);
        if (view) {
            view.dispose();
        }
    }
    async $reveal(handle, showOptions) {
        const widget = await this.getWebview(handle);
        if (widget.isDisposed) {
            return;
        }
        if ((showOptions.viewColumn !== undefined && showOptions.viewColumn !== widget.viewState.position) || showOptions.area !== undefined) {
            this.viewColumnService.updateViewColumns();
            const columnIds = showOptions.viewColumn ? this.viewColumnService.getViewColumnIds(showOptions.viewColumn) : [];
            const area = this.shell.getAreaFor(widget);
            if (columnIds.indexOf(widget.id) === -1 || area !== showOptions.area) {
                this.addOrReattachWidget(widget, showOptions);
                return;
            }
        }
        if (showOptions.preserveFocus) {
            this.shell.revealWidget(widget.id);
        }
        else {
            this.shell.activateWidget(widget.id);
        }
    }
    async $setTitle(handle, value) {
        const webview = await this.getWebview(handle);
        webview.title.label = value;
    }
    async $setBadge(handle, badge) {
        const webview = await this.getWebview(handle);
        if (webview) {
            webview.badge = badge === null || badge === void 0 ? void 0 : badge.value;
            webview.badgeTooltip = badge === null || badge === void 0 ? void 0 : badge.tooltip;
        }
    }
    async $setIconPath(handle, iconUrl) {
        const webview = await this.getWebview(handle);
        webview.setIconUrl(iconUrl);
    }
    async $setHtml(handle, value) {
        const webview = await this.getWebview(handle);
        webview.setHTML(value);
    }
    async $setOptions(handle, options) {
        const webview = await this.getWebview(handle);
        const { enableScripts, enableForms, localResourceRoots, ...contentOptions } = options;
        webview.setContentOptions({
            allowScripts: enableScripts,
            allowForms: enableForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => root.toString()),
            ...contentOptions
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $postMessage(handle, value) {
        // Due to async nature of $postMessage, the webview may have been disposed in the meantime.
        // Therefore, don't throw an error if the webview is not found, but return false in this case.
        const webview = await this.tryGetWebview(handle);
        if (!webview) {
            return false;
        }
        webview.sendMessage(value);
        return true;
    }
    $registerSerializer(viewType) {
        this.pluginService.registerWebviewReviver(viewType, widget => this.restoreWidget(widget));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterSerializer(viewType)));
    }
    $unregisterSerializer(viewType) {
        this.pluginService.unregisterWebviewReviver(viewType);
    }
    async restoreWidget(widget) {
        this.hookWebview(widget);
        const handle = widget.identifier.id;
        const title = widget.title.label;
        let state = undefined;
        if (widget.state) {
            try {
                state = JSON.parse(widget.state);
            }
            catch {
                // noop
            }
        }
        const options = widget.options;
        const { allowScripts, allowForms, localResourceRoots, ...contentOptions } = widget.contentOptions;
        this.updateViewState(widget);
        await this.proxy.$deserializeWebviewPanel(handle, widget.viewType, title, state, widget.viewState, {
            enableScripts: allowScripts,
            enableForms: allowForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => vscode_uri_1.URI.parse(root)),
            ...contentOptions,
            ...options
        });
    }
    updateViewState(widget, viewColumn) {
        const viewState = {
            active: this.shell.activeWidget === widget,
            visible: !widget.isHidden,
            position: viewColumn || 0
        };
        if (typeof viewColumn !== 'number') {
            this.viewColumnService.updateViewColumns();
            viewState.position = this.viewColumnService.getViewColumn(widget.id) || 0;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (coreutils_1.JSONExt.deepEqual(viewState, widget.viewState)) {
            return;
        }
        widget.viewState = viewState;
        this.proxy.$onDidChangeWebviewPanelViewState(widget.identifier.id, widget.viewState);
    }
    async getWebview(viewId) {
        const webview = await this.tryGetWebview(viewId);
        if (!webview) {
            throw new Error(`Unknown Webview: ${viewId}`);
        }
        return webview;
    }
    async tryGetWebview(id) {
        const webview = await this.widgetManager.findWidget(webview_1.WebviewWidget.FACTORY_ID, options => {
            if (options) {
                return options.id === id;
            }
            return false;
        })
            || await this.widgetManager.getWidget(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID, { id });
        return webview;
    }
}
exports.WebviewsMainImpl = WebviewsMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowActivityTracker = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const CHECK_INACTIVITY_LIMIT = 30;
const CHECK_INACTIVITY_INTERVAL = 1000;
const eventListenerOptions = {
    passive: true,
    capture: true
};
class WindowActivityTracker {
    constructor(win) {
        this.win = win;
        this.inactivityCounter = 0; // number of times inactivity was checked since last reset
        this.inactivityLimit = CHECK_INACTIVITY_LIMIT; // number of inactivity checks done before sending inactive signal
        this.checkInactivityInterval = CHECK_INACTIVITY_INTERVAL; // check interval in milliseconds
        this.onDidChangeActiveStateEmitter = new core_1.Emitter();
        this._activeState = true;
        // Reset inactivity time
        this.resetInactivity = () => {
            this.inactivityCounter = 0;
            if (!this.interval) {
                // it was not active. Set as active and restart tracking inactivity
                this.activeState = true;
                this.startTracking();
            }
        };
        // Check inactivity status
        this.checkInactivity = () => {
            this.inactivityCounter++;
            if (this.inactivityCounter >= this.inactivityLimit) {
                this.activeState = false;
                this.stopTracking();
            }
        };
        this.initializeListeners(this.win);
    }
    get onDidChangeActiveState() {
        return this.onDidChangeActiveStateEmitter.event;
    }
    set activeState(newState) {
        if (this._activeState !== newState) {
            this._activeState = newState;
            this.onDidChangeActiveStateEmitter.fire(this._activeState);
        }
    }
    initializeListeners(win) {
        // currently assumes activity based on key/mouse/touch pressed, not on mouse move or scrolling.
        win.addEventListener('mousedown', this.resetInactivity, eventListenerOptions);
        win.addEventListener('keydown', this.resetInactivity, eventListenerOptions);
        win.addEventListener('touchstart', this.resetInactivity, eventListenerOptions);
    }
    dispose() {
        this.stopTracking();
        this.win.removeEventListener('mousedown', this.resetInactivity);
        this.win.removeEventListener('keydown', this.resetInactivity);
        this.win.removeEventListener('touchstart', this.resetInactivity);
    }
    startTracking() {
        this.stopTracking();
        this.interval = setInterval(this.checkInactivity, this.checkInactivityInterval);
    }
    stopTracking() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = undefined;
        }
    }
}
exports.WindowActivityTracker = WindowActivityTracker;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowStateMain = void 0;
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../node_modules/@theia/core/lib/browser/opener-service.js");
const external_uri_service_1 = __webpack_require__(/*! @theia/core/lib/browser/external-uri-service */ "../node_modules/@theia/core/lib/browser/external-uri-service.js");
const window_activity_tracker_1 = __webpack_require__(/*! ./window-activity-tracker */ "../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js");
class WindowStateMain {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WINDOW_STATE_EXT);
        this.openerService = container.get(opener_service_1.OpenerService);
        this.externalUriService = container.get(external_uri_service_1.ExternalUriService);
        const fireDidFocus = () => this.onFocusChanged(true);
        window.addEventListener('focus', fireDidFocus);
        this.toDispose.push(disposable_1.Disposable.create(() => window.removeEventListener('focus', fireDidFocus)));
        const fireDidBlur = () => this.onFocusChanged(false);
        window.addEventListener('blur', fireDidBlur);
        this.toDispose.push(disposable_1.Disposable.create(() => window.removeEventListener('blur', fireDidBlur)));
        const tracker = new window_activity_tracker_1.WindowActivityTracker(window);
        this.toDispose.push(tracker.onDidChangeActiveState(isActive => this.onActiveStateChanged(isActive)));
        this.toDispose.push(tracker);
    }
    dispose() {
        this.toDispose.dispose();
    }
    onFocusChanged(focused) {
        this.proxy.$onDidChangeWindowFocus(focused);
    }
    onActiveStateChanged(isActive) {
        this.proxy.$onDidChangeWindowActive(isActive);
    }
    async $openUri(uriComponent) {
        const uri = vscode_uri_1.URI.revive(uriComponent);
        const url = new uri_1.default(encodeURI(uri.toString(true)));
        try {
            await (0, opener_service_1.open)(this.openerService, url, { openExternalApp: true });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async $asExternalUri(uriComponents) {
        const uri = vscode_uri_1.URI.revive(uriComponents);
        const resolved = await this.externalUriService.resolve(new uri_1.default(uri));
        return vscode_uri_1.URI.parse(resolved.toString());
    }
}
exports.WindowStateMain = WindowStateMain;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextContentResource = exports.TextContentResourceResolver = exports.WorkspaceMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const file_search_service_1 = __webpack_require__(/*! @theia/file-search/lib/common/file-search-service */ "../node_modules/@theia/file-search/lib/common/file-search-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const browser_2 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../node_modules/@theia/filesystem/lib/browser/index.js");
const search_in_workspace_service_1 = __webpack_require__(/*! @theia/search-in-workspace/lib/browser/search-in-workspace-service */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-service.js");
const monaco_quick_input_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-quick-input-service */ "../node_modules/@theia/monaco/lib/browser/monaco-quick-input-service.js");
const request_1 = __webpack_require__(/*! @theia/core/shared/@theia/request */ "../node_modules/@theia/core/shared/@theia/request/index.js");
class WorkspaceMainImpl {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.workspaceSearch = new Set();
        this.canonicalUriProviders = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WORKSPACE_EXT);
        this.storageProxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.STORAGE_EXT);
        this.monacoQuickInputService = container.get(monaco_quick_input_service_1.MonacoQuickInputService);
        this.fileSearchService = container.get(file_search_service_1.FileSearchService);
        this.searchInWorkspaceService = container.get(search_in_workspace_service_1.SearchInWorkspaceService);
        this.resourceResolver = container.get(TextContentResourceResolver);
        this.pluginServer = container.get(plugin_protocol_1.PluginServer);
        this.requestService = container.get(request_1.RequestService);
        this.workspaceService = container.get(browser_1.WorkspaceService);
        this.canonicalUriService = container.get(browser_1.CanonicalUriService);
        this.workspaceTrustService = container.get(browser_1.WorkspaceTrustService);
        this.fsPreferences = container.get(browser_2.FileSystemPreferences);
        this.processWorkspaceFoldersChanged(this.workspaceService.tryGetRoots().map(root => root.resource.toString()));
        this.toDispose.push(this.workspaceService.onWorkspaceChanged(roots => {
            this.processWorkspaceFoldersChanged(roots.map(root => root.resource.toString()));
        }));
        this.toDispose.push(this.workspaceService.onWorkspaceLocationChanged(stat => {
            this.proxy.$onWorkspaceLocationChanged(stat);
        }));
        this.workspaceTrustService.getWorkspaceTrust().then(trust => this.proxy.$onWorkspaceTrustChanged(trust));
    }
    dispose() {
        this.toDispose.dispose();
    }
    $resolveProxy(url) {
        return this.requestService.resolveProxy(url);
    }
    async processWorkspaceFoldersChanged(roots) {
        var _a;
        if (this.isAnyRootChanged(roots) === false) {
            return;
        }
        this.roots = roots;
        this.proxy.$onWorkspaceFoldersChanged({ roots });
        const keyValueStorageWorkspacesData = await this.pluginServer.getAllStorageValues({
            workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
            roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
        });
        this.storageProxy.$updatePluginsWorkspaceData(keyValueStorageWorkspacesData);
    }
    isAnyRootChanged(roots) {
        if (!this.roots || this.roots.length !== roots.length) {
            return true;
        }
        return this.roots.some((root, index) => root !== roots[index]);
    }
    async $getWorkspace() {
        return this.workspaceService.workspace;
    }
    $pickWorkspaceFolder(options) {
        return new Promise((resolve, reject) => {
            // Return undefined if workspace root is not set
            if (!this.roots || !this.roots.length) {
                resolve(undefined);
                return;
            }
            // Active before appearing the pick menu
            const activeElement = window.document.activeElement;
            // WorkspaceFolder to be returned
            let returnValue;
            const items = this.roots.map(root => {
                const rootUri = vscode_uri_1.URI.parse(root);
                const rootPathName = rootUri.path.substring(rootUri.path.lastIndexOf('/') + 1);
                return {
                    label: rootPathName,
                    detail: rootUri.path,
                    execute: () => {
                        returnValue = {
                            uri: rootUri,
                            name: rootPathName,
                            index: 0
                        };
                    }
                };
            });
            // Show pick menu
            this.monacoQuickInputService.showQuickPick(items, {
                onDidHide: () => {
                    if (activeElement) {
                        activeElement.focus({ preventScroll: true });
                    }
                    resolve(returnValue);
                }
            });
        });
    }
    async $startFileSearch(includePattern, includeFolderUri, options) {
        const roots = {};
        const rootUris = includeFolderUri ? [includeFolderUri] : this.roots;
        for (const rootUri of rootUris) {
            roots[rootUri] = {};
        }
        const opts = {
            rootOptions: roots,
            fuzzyMatch: options.fuzzy,
            useGitIgnore: options.useIgnoreFiles
        };
        if (includePattern) {
            opts.includePatterns = [includePattern];
        }
        if (options.exclude) {
            opts.excludePatterns = [options.exclude];
        }
        if (options.useDefaultExcludes) {
            for (const rootUri of rootUris) {
                const filesExclude = this.fsPreferences.get('files.exclude', undefined, rootUri);
                if (filesExclude) {
                    for (const excludePattern in filesExclude) {
                        if (filesExclude[excludePattern]) {
                            const rootOptions = roots[rootUri];
                            const rootExcludePatterns = rootOptions.excludePatterns || [];
                            rootExcludePatterns.push(excludePattern);
                            rootOptions.excludePatterns = rootExcludePatterns;
                        }
                    }
                }
            }
        }
        if (typeof options.maxResults === 'number') {
            opts.limit = options.maxResults;
        }
        const uriStrs = await this.fileSearchService.find('', opts);
        return uriStrs.map(uriStr => vscode_uri_1.URI.parse(uriStr));
    }
    async $findTextInFiles(query, options, searchRequestId, token = core_1.CancellationToken.None) {
        const maxHits = options.maxResults ? options.maxResults : 150;
        const excludes = options.exclude ? (typeof options.exclude === 'string' ? options.exclude : options.exclude.pattern) : undefined;
        const includes = options.include ? (typeof options.include === 'string' ? options.include : options.include.pattern) : undefined;
        let canceledRequest = false;
        return new Promise(resolve => {
            let matches = 0;
            const what = query.pattern;
            this.searchInWorkspaceService.searchWithCallback(what, this.roots, {
                onResult: (searchId, result) => {
                    if (canceledRequest) {
                        return;
                    }
                    const hasSearch = this.workspaceSearch.has(searchId);
                    if (!hasSearch) {
                        this.workspaceSearch.add(searchId);
                        token.onCancellationRequested(() => {
                            this.searchInWorkspaceService.cancel(searchId);
                            canceledRequest = true;
                        });
                    }
                    if (token.isCancellationRequested) {
                        this.searchInWorkspaceService.cancel(searchId);
                        canceledRequest = true;
                        return;
                    }
                    if (result && result.matches && result.matches.length) {
                        while ((matches + result.matches.length) > maxHits) {
                            result.matches.splice(result.matches.length - 1, 1);
                        }
                        this.proxy.$onTextSearchResult(searchRequestId, false, result);
                        matches += result.matches.length;
                        if (maxHits <= matches) {
                            this.searchInWorkspaceService.cancel(searchId);
                        }
                    }
                },
                onDone: (searchId, _error) => {
                    const hasSearch = this.workspaceSearch.has(searchId);
                    if (hasSearch) {
                        this.searchInWorkspaceService.cancel(searchId);
                        this.workspaceSearch.delete(searchId);
                    }
                    this.proxy.$onTextSearchResult(searchRequestId, true);
                    if (maxHits <= matches) {
                        resolve({ limitHit: true });
                    }
                    else {
                        resolve({ limitHit: false });
                    }
                }
            }, {
                useRegExp: query.isRegExp,
                matchCase: query.isCaseSensitive,
                matchWholeWord: query.isWordMatch,
                exclude: excludes ? [excludes] : undefined,
                include: includes ? [includes] : undefined,
                maxResults: maxHits
            });
        });
    }
    async $registerTextDocumentContentProvider(scheme) {
        this.resourceResolver.registerContentProvider(scheme, this.proxy);
        this.toDispose.push(disposable_1.Disposable.create(() => this.resourceResolver.unregisterContentProvider(scheme)));
    }
    $unregisterTextDocumentContentProvider(scheme) {
        this.resourceResolver.unregisterContentProvider(scheme);
    }
    $onTextDocumentContentChange(uri, content) {
        this.resourceResolver.onContentChange(uri, content);
    }
    async $updateWorkspaceFolders(start, deleteCount, ...rootsToAdd) {
        await this.workspaceService.spliceRoots(start, deleteCount, ...rootsToAdd.map(root => new uri_1.default(root)));
    }
    async $requestWorkspaceTrust(_options) {
        return this.workspaceTrustService.requestWorkspaceTrust();
    }
    async $registerCanonicalUriProvider(scheme) {
        this.canonicalUriProviders.set(scheme, this.canonicalUriService.registerCanonicalUriProvider(scheme, {
            provideCanonicalUri: async (uri, targetScheme, token) => {
                const canonicalUri = await this.proxy.$provideCanonicalUri(uri.toString(), targetScheme, core_1.CancellationToken.None);
                return (0, core_1.isUndefined)(uri) ? undefined : new uri_1.default(canonicalUri);
            },
            dispose: () => {
                this.proxy.$disposeCanonicalUriProvider(scheme);
            },
        }));
    }
    $unregisterCanonicalUriProvider(scheme) {
        const disposable = this.canonicalUriProviders.get(scheme);
        if (disposable) {
            this.canonicalUriProviders.delete(scheme);
            disposable.dispose();
        }
        else {
            console.warn(`No canonical uri provider registered for '${scheme}'`);
        }
    }
    async $getCanonicalUri(uri, targetScheme, token) {
        const canonicalUri = await this.canonicalUriService.provideCanonicalUri(new uri_1.default(uri), targetScheme, token);
        return (0, core_1.isUndefined)(canonicalUri) ? undefined : canonicalUri.toString();
    }
}
exports.WorkspaceMainImpl = WorkspaceMainImpl;
let TextContentResourceResolver = class TextContentResourceResolver {
    constructor() {
        // Resource providers for different schemes
        this.providers = new Map();
        // Opened resources
        this.resources = new Map();
    }
    async resolve(uri) {
        const provider = this.providers.get(uri.scheme);
        if (provider) {
            return provider.provideResource(uri);
        }
        throw new Error(`Unable to find Text Content Resource Provider for scheme '${uri.scheme}'`);
    }
    registerContentProvider(scheme, proxy) {
        if (this.providers.has(scheme)) {
            throw new Error(`Text Content Resource Provider for scheme '${scheme}' is already registered`);
        }
        const instance = this;
        this.providers.set(scheme, {
            provideResource: (uri) => {
                let resource = instance.resources.get(uri.toString());
                if (resource) {
                    return resource;
                }
                resource = new TextContentResource(uri, proxy, {
                    dispose() {
                        instance.resources.delete(uri.toString());
                    }
                });
                instance.resources.set(uri.toString(), resource);
                return resource;
            }
        });
    }
    unregisterContentProvider(scheme) {
        if (!this.providers.delete(scheme)) {
            throw new Error(`Text Content Resource Provider for scheme '${scheme}' has not been registered`);
        }
    }
    onContentChange(uri, content) {
        const resource = this.resources.get(uri);
        if (resource) {
            resource.setContent(content);
        }
    }
};
exports.TextContentResourceResolver = TextContentResourceResolver;
exports.TextContentResourceResolver = TextContentResourceResolver = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TextContentResourceResolver);
class TextContentResource {
    constructor(uri, proxy, disposable) {
        this.uri = uri;
        this.proxy = proxy;
        this.disposable = disposable;
        this.onDidChangeContentsEmitter = new core_1.Emitter();
        this.onDidChangeContents = this.onDidChangeContentsEmitter.event;
    }
    async readContents(options) {
        if (this.cache) {
            const content = this.cache;
            this.cache = undefined;
            return content;
        }
        else {
            const content = await this.proxy.$provideTextDocumentContent(this.uri.toString());
            return content !== null && content !== void 0 ? content : '';
        }
    }
    dispose() {
        this.disposable.dispose();
    }
    setContent(content) {
        this.cache = content;
        this.onDidChangeContentsEmitter.fire(undefined);
    }
}
exports.TextContentResource = TextContentResource;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicMessageRegistryMainImpl = void 0;
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../node_modules/@theia/core/lib/common/message-service.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/**
 * A basic implementation of the message registry that does not support the modal option
 * as that requires an UI.
 */
class BasicMessageRegistryMainImpl {
    constructor(container) {
        this.messageService = container.get(message_service_1.MessageService);
    }
    async $showMessage(type, message, options, actions) {
        const action = await this.doShowMessage(type, message, options, actions);
        const handle = action
            ? actions.map(a => a.title).indexOf(action)
            : undefined;
        return handle === undefined && options.modal ? options.onCloseActionHandle : handle;
    }
    async doShowMessage(type, message, options, actions) {
        // Modal notifications are not supported in this context
        switch (type) {
            case plugin_api_rpc_1.MainMessageType.Info:
                return this.messageService.info(message, ...actions.map(a => a.title));
            case plugin_api_rpc_1.MainMessageType.Warning:
                return this.messageService.warn(message, ...actions.map(a => a.title));
            case plugin_api_rpc_1.MainMessageType.Error:
                return this.messageService.error(message, ...actions.map(a => a.title));
        }
        throw new Error(`Message type '${type}' is not supported yet!`);
    }
}
exports.BasicMessageRegistryMainImpl = BasicMessageRegistryMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicNotificationMainImpl = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
class BasicNotificationMainImpl {
    constructor(rpc, container, extIdentifier) {
        this.progressMap = new Map();
        this.progress2Work = new Map();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        this.progressService = container.get(common_1.ProgressService);
        this.proxy = rpc.getProxy(extIdentifier);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $startProgress(options) {
        const onDidCancel = () => {
            // If the map does not contain current id, it has already stopped and should not be cancelled
            if (this.progressMap.has(id)) {
                this.proxy.$acceptProgressCanceled(id);
            }
        };
        const progressMessage = this.mapOptions(options);
        const progress = await this.progressService.showProgress(progressMessage, onDidCancel);
        const id = progress.id;
        this.progressMap.set(id, progress);
        this.progress2Work.set(id, 0);
        if (this.toDispose.disposed) {
            this.$stopProgress(id);
        }
        else {
            this.toDispose.push(disposable_1.Disposable.create(() => this.$stopProgress(id)));
        }
        return id;
    }
    mapOptions(options) {
        const { title, location, cancellable } = options;
        return { text: title, options: { location, cancelable: cancellable } };
    }
    $stopProgress(id) {
        const progress = this.progressMap.get(id);
        if (progress) {
            this.progressMap.delete(id);
            this.progress2Work.delete(id);
            progress.cancel();
        }
    }
    $updateProgress(id, item) {
        const progress = this.progressMap.get(id);
        if (!progress) {
            return;
        }
        const done = Math.min((this.progress2Work.get(id) || 0) + (item.increment || 0), 100);
        this.progress2Work.set(id, done);
        progress.report({ message: item.message, work: done ? { done, total: 100 } : undefined });
    }
}
exports.BasicNotificationMainImpl = BasicNotificationMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/common/env-main.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/common/env-main.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvMainImpl = void 0;
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../node_modules/@theia/core/lib/common/env-variables/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
class EnvMainImpl {
    constructor(rpc, container) {
        this.envVariableServer = container.get(env_variables_1.EnvVariablesServer);
    }
    $getEnvVariable(envVarName) {
        return this.envVariableServer.getValue(envVarName).then(result => result ? result.value : undefined);
    }
    async $getClientOperatingSystem() {
        if (core_1.isWindows) {
            return types_impl_1.OperatingSystem.Windows;
        }
        if (core_1.isOSX) {
            return types_impl_1.OperatingSystem.OSX;
        }
        return types_impl_1.OperatingSystem.Linux;
    }
}
exports.EnvMainImpl = EnvMainImpl;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginPathsService = exports.pluginPathsServicePath = void 0;
exports.pluginPathsServicePath = '/services/plugin-paths';
// Service to create plugin configuration folders for different purpose.
exports.PluginPathsService = Symbol('PluginPathsService');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewExternalEndpoint = void 0;
/**
 * Each webview should be deployed on a unique origin (https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)
 * to ensure isolation from browser shared state as cookies, local storage and so on.
 *
 * Default hostname pattern of a origin is `{{uuid}}.webview.{{hostname}}`. Where `{{uuid}}` is a placeholder for a webview global id.
 * For electron target the default pattern is always used.
 * For the browser target use `THEIA_WEBVIEW_EXTERNAL_ENDPOINT` env variable to customize it.
 */
var WebviewExternalEndpoint;
(function (WebviewExternalEndpoint) {
    WebviewExternalEndpoint.pattern = 'THEIA_WEBVIEW_EXTERNAL_ENDPOINT';
    WebviewExternalEndpoint.defaultPattern = '{{uuid}}.webview.{{hostname}}';
})(WebviewExternalEndpoint || (exports.WebviewExternalEndpoint = WebviewExternalEndpoint = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Mutex.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Mutex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
var Semaphore_1 = __webpack_require__(/*! ./Semaphore */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Semaphore.js");
var Mutex = /** @class */ (function () {
    function Mutex(cancelError) {
        this._semaphore = new Semaphore_1.default(1, cancelError);
    }
    Mutex.prototype.acquire = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, releaser;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._semaphore.acquire()];
                    case 1:
                        _a = _b.sent(), releaser = _a[1];
                        return [2 /*return*/, releaser];
                }
            });
        });
    };
    Mutex.prototype.runExclusive = function (callback) {
        return this._semaphore.runExclusive(function () { return callback(); });
    };
    Mutex.prototype.isLocked = function () {
        return this._semaphore.isLocked();
    };
    Mutex.prototype.waitForUnlock = function () {
        return this._semaphore.waitForUnlock();
    };
    Mutex.prototype.release = function () {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    };
    Mutex.prototype.cancel = function () {
        return this._semaphore.cancel();
    };
    return Mutex;
}());
exports["default"] = Mutex;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Semaphore.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Semaphore.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
var errors_1 = __webpack_require__(/*! ./errors */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js");
var Semaphore = /** @class */ (function () {
    function Semaphore(_value, _cancelError) {
        if (_cancelError === void 0) { _cancelError = errors_1.E_CANCELED; }
        this._value = _value;
        this._cancelError = _cancelError;
        this._weightedQueues = [];
        this._weightedWaiters = [];
    }
    Semaphore.prototype.acquire = function (weight) {
        var _this = this;
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        return new Promise(function (resolve, reject) {
            if (!_this._weightedQueues[weight - 1])
                _this._weightedQueues[weight - 1] = [];
            _this._weightedQueues[weight - 1].push({ resolve: resolve, reject: reject });
            _this._dispatch();
        });
    };
    Semaphore.prototype.runExclusive = function (callback, weight) {
        if (weight === void 0) { weight = 1; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, value, release;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.acquire(weight)];
                    case 1:
                        _a = _b.sent(), value = _a[0], release = _a[1];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, callback(value)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        release();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Semaphore.prototype.waitForUnlock = function (weight) {
        var _this = this;
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        return new Promise(function (resolve) {
            if (!_this._weightedWaiters[weight - 1])
                _this._weightedWaiters[weight - 1] = [];
            _this._weightedWaiters[weight - 1].push(resolve);
            _this._dispatch();
        });
    };
    Semaphore.prototype.isLocked = function () {
        return this._value <= 0;
    };
    Semaphore.prototype.getValue = function () {
        return this._value;
    };
    Semaphore.prototype.setValue = function (value) {
        this._value = value;
        this._dispatch();
    };
    Semaphore.prototype.release = function (weight) {
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        this._value += weight;
        this._dispatch();
    };
    Semaphore.prototype.cancel = function () {
        var _this = this;
        this._weightedQueues.forEach(function (queue) { return queue.forEach(function (entry) { return entry.reject(_this._cancelError); }); });
        this._weightedQueues = [];
    };
    Semaphore.prototype._dispatch = function () {
        var _a;
        for (var weight = this._value; weight > 0; weight--) {
            var queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
            if (!queueEntry)
                continue;
            var previousValue = this._value;
            var previousWeight = weight;
            this._value -= weight;
            weight = this._value + 1;
            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
        }
        this._drainUnlockWaiters();
    };
    Semaphore.prototype._newReleaser = function (weight) {
        var _this = this;
        var called = false;
        return function () {
            if (called)
                return;
            called = true;
            _this.release(weight);
        };
    };
    Semaphore.prototype._drainUnlockWaiters = function () {
        for (var weight = this._value; weight > 0; weight--) {
            if (!this._weightedWaiters[weight - 1])
                continue;
            this._weightedWaiters[weight - 1].forEach(function (waiter) { return waiter(); });
            this._weightedWaiters[weight - 1] = [];
        }
    };
    return Semaphore;
}());
exports["default"] = Semaphore;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.E_CANCELED = exports.E_ALREADY_LOCKED = exports.E_TIMEOUT = void 0;
exports.E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
exports.E_ALREADY_LOCKED = new Error('mutex already locked');
exports.E_CANCELED = new Error('request for lock canceled');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/index.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryAcquire = exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
var Mutex_1 = __webpack_require__(/*! ./Mutex */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Mutex.js");
Object.defineProperty(exports, "Mutex", ({ enumerable: true, get: function () { return Mutex_1.default; } }));
var Semaphore_1 = __webpack_require__(/*! ./Semaphore */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/Semaphore.js");
Object.defineProperty(exports, "Semaphore", ({ enumerable: true, get: function () { return Semaphore_1.default; } }));
var withTimeout_1 = __webpack_require__(/*! ./withTimeout */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/withTimeout.js");
Object.defineProperty(exports, "withTimeout", ({ enumerable: true, get: function () { return withTimeout_1.withTimeout; } }));
var tryAcquire_1 = __webpack_require__(/*! ./tryAcquire */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/tryAcquire.js");
Object.defineProperty(exports, "tryAcquire", ({ enumerable: true, get: function () { return tryAcquire_1.tryAcquire; } }));
tslib_1.__exportStar(__webpack_require__(/*! ./errors */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/tryAcquire.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/tryAcquire.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryAcquire = void 0;
var errors_1 = __webpack_require__(/*! ./errors */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js");
var withTimeout_1 = __webpack_require__(/*! ./withTimeout */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/withTimeout.js");
// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError) {
    if (alreadyAcquiredError === void 0) { alreadyAcquiredError = errors_1.E_ALREADY_LOCKED; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);
}
exports.tryAcquire = tryAcquire;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/withTimeout.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/withTimeout.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
var errors_1 = __webpack_require__(/*! ./errors */ "../node_modules/@theia/plugin-ext/node_modules/async-mutex/lib/errors.js");
function withTimeout(sync, timeout, timeoutError) {
    var _this = this;
    if (timeoutError === void 0) { timeoutError = errors_1.E_TIMEOUT; }
    return {
        acquire: function (weight) {
            if (weight !== undefined && weight <= 0) {
                throw new Error("invalid weight ".concat(weight, ": must be positive"));
            }
            return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var isTimeout, handle, ticket, release, e_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            isTimeout = false;
                            handle = setTimeout(function () {
                                isTimeout = true;
                                reject(timeoutError);
                            }, timeout);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, sync.acquire(weight)];
                        case 2:
                            ticket = _a.sent();
                            if (isTimeout) {
                                release = Array.isArray(ticket) ? ticket[1] : ticket;
                                release();
                            }
                            else {
                                clearTimeout(handle);
                                resolve(ticket);
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            if (!isTimeout) {
                                clearTimeout(handle);
                                reject(e_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
        },
        runExclusive: function (callback, weight) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var release, ticket;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            release = function () { return undefined; };
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 7, 8]);
                            return [4 /*yield*/, this.acquire(weight)];
                        case 2:
                            ticket = _a.sent();
                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];
                            release = ticket[1];
                            return [4 /*yield*/, callback(ticket[0])];
                        case 3: return [2 /*return*/, _a.sent()];
                        case 4:
                            release = ticket;
                            return [4 /*yield*/, callback()];
                        case 5: return [2 /*return*/, _a.sent()];
                        case 6: return [3 /*break*/, 8];
                        case 7:
                            release();
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        },
        release: function (weight) {
            sync.release(weight);
        },
        cancel: function () {
            return sync.cancel();
        },
        waitForUnlock: function (weight) {
            if (weight !== undefined && weight <= 0) {
                throw new Error("invalid weight ".concat(weight, ": must be positive"));
            }
            return new Promise(function (resolve, reject) {
                var handle = setTimeout(function () { return reject(timeoutError); }, timeout);
                sync.waitForUnlock(weight).then(function () {
                    clearTimeout(handle);
                    resolve();
                });
            });
        },
        isLocked: function () { return sync.isLocked(); },
        getValue: function () { return sync.getValue(); },
        setValue: function (value) { return sync.setValue(value); },
    };
}
exports.withTimeout = withTimeout;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/mime/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/mime/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Mime = __webpack_require__(/*! ./Mime */ "../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js");
module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js"), __webpack_require__(/*! ./types/other */ "../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js"));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mapbox-vector-tile":["mvt"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-iwork-keynote-sffkey":["*key"],"application/x-iwork-numbers-sffnumbers":["*numbers"],"application/x-iwork-pages-sffpages":["*pages"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.sap.vds":["vds"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};

/***/ }),

/***/ "../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ }),

/***/ "../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../../css-loader/dist/cjs.js!./modal-notification.css */ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmDecorationsService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const dirty_diff_decorator_1 = __webpack_require__(/*! ../dirty-diff/dirty-diff-decorator */ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js");
const diff_computer_1 = __webpack_require__(/*! ../dirty-diff/diff-computer */ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const content_lines_1 = __webpack_require__(/*! ../dirty-diff/content-lines */ "../node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ../scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const throttle = __webpack_require__(/*! @theia/core/shared/lodash.throttle */ "../node_modules/@theia/core/shared/lodash.throttle/index.js");
let ScmDecorationsService = class ScmDecorationsService {
    constructor(decorator, scmService, editorManager, resourceProvider) {
        this.decorator = decorator;
        this.scmService = scmService;
        this.editorManager = editorManager;
        this.resourceProvider = resourceProvider;
        this.diffComputer = new diff_computer_1.DiffComputer();
        this.onDirtyDiffUpdateEmitter = new core_1.Emitter();
        this.onDirtyDiffUpdate = this.onDirtyDiffUpdateEmitter.event;
        const updateTasks = new Map();
        this.editorManager.onCreated(editorWidget => {
            const { editor } = editorWidget;
            if (!this.supportsDirtyDiff(editor)) {
                return;
            }
            const toDispose = new core_1.DisposableCollection();
            const updateTask = this.createUpdateTask(editor);
            updateTasks.set(editorWidget, updateTask);
            toDispose.push(editor.onDocumentContentChanged(() => updateTask()));
            editorWidget.disposed.connect(() => {
                updateTask.cancel();
                updateTasks.delete(editorWidget);
                toDispose.dispose();
            });
            updateTask();
        });
        const runUpdateTasks = () => {
            for (const updateTask of updateTasks.values()) {
                updateTask();
            }
        };
        this.scmService.onDidAddRepository(({ provider }) => {
            var _a;
            provider.onDidChange(runUpdateTasks);
            (_a = provider.onDidChangeResources) === null || _a === void 0 ? void 0 : _a.call(provider, runUpdateTasks);
        });
        this.scmService.onDidChangeSelectedRepository(runUpdateTasks);
    }
    async applyEditorDecorations(editor) {
        const currentRepo = this.scmService.selectedRepository;
        if (currentRepo) {
            try {
                // Currently, the uri used here is specific to vscode.git; other SCM providers are thus not supported.
                // See https://github.com/eclipse-theia/theia/pull/13104#discussion_r1494540628 for a detailed discussion.
                const query = { path: editor.uri['codeUri'].fsPath, ref: '~' };
                const uri = editor.uri.withScheme(currentRepo.provider.id).withQuery(JSON.stringify(query));
                const previousResource = await this.resourceProvider(uri);
                try {
                    const previousContent = await previousResource.readContents();
                    const previousLines = content_lines_1.ContentLines.fromString(previousContent);
                    const currentLines = content_lines_1.ContentLines.fromTextEditorDocument(editor.document);
                    const dirtyDiff = this.diffComputer.computeDirtyDiff(content_lines_1.ContentLines.arrayLike(previousLines), content_lines_1.ContentLines.arrayLike(currentLines));
                    const update = { editor, previousRevisionUri: uri, ...dirtyDiff };
                    this.decorator.applyDecorations(update);
                    this.onDirtyDiffUpdateEmitter.fire(update);
                }
                finally {
                    previousResource.dispose();
                }
            }
            catch (e) {
                // Scm resource may not be found, do nothing.
            }
        }
    }
    supportsDirtyDiff(editor) {
        return editor.shouldDisplayDirtyDiff();
    }
    createUpdateTask(editor) {
        return throttle(() => this.applyEditorDecorations(editor), 500);
    }
};
exports.ScmDecorationsService = ScmDecorationsService;
exports.ScmDecorationsService = ScmDecorationsService = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(dirty_diff_decorator_1.DirtyDiffDecorator)),
    tslib_1.__param(1, (0, inversify_1.inject)(scm_service_1.ScmService)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.EditorManager)),
    tslib_1.__param(3, (0, inversify_1.inject)(core_1.ResourceProvider)),
    tslib_1.__metadata("design:paramtypes", [dirty_diff_decorator_1.DirtyDiffDecorator,
        scm_service_1.ScmService,
        browser_1.EditorManager, Function])
], ScmDecorationsService);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContentLines = void 0;
var ContentLines;
(function (ContentLines) {
    const NL = '\n'.charCodeAt(0);
    const CR = '\r'.charCodeAt(0);
    function fromString(content) {
        const computeLineStarts = s => {
            const result = [0];
            for (let i = 0; i < s.length; i++) {
                const chr = s.charCodeAt(i);
                if (chr === CR) {
                    if (i + 1 < s.length && s.charCodeAt(i + 1) === NL) {
                        result[result.length] = i + 2;
                        i++;
                    }
                    else {
                        result[result.length] = i + 1;
                    }
                }
                else if (chr === NL) {
                    result[result.length] = i + 1;
                }
            }
            return result;
        };
        const lineStarts = computeLineStarts(content);
        return {
            length: lineStarts.length,
            getLineContent: line => {
                if (line >= lineStarts.length) {
                    throw new Error('line index out of bounds');
                }
                const start = lineStarts[line];
                let end = (line === lineStarts.length - 1) ? undefined : lineStarts[line + 1] - 1;
                if (!!end && content.charCodeAt(end - 1) === CR) {
                    end--; // ignore CR at the end
                }
                const lineContent = content.substring(start, end);
                return lineContent;
            }
        };
    }
    ContentLines.fromString = fromString;
    function fromTextEditorDocument(document) {
        return {
            length: document.lineCount,
            getLineContent: line => document.getLineContent(line + 1),
        };
    }
    ContentLines.fromTextEditorDocument = fromTextEditorDocument;
    function arrayLike(lines) {
        return new Proxy(lines, getProxyHandler());
    }
    ContentLines.arrayLike = arrayLike;
    function getProxyHandler() {
        return {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get(target, p) {
                switch (p) {
                    case 'prototype':
                        return undefined;
                    case 'length':
                        return target.length;
                    case 'slice':
                        return (start, end) => {
                            if (start !== undefined) {
                                return [start, (end !== undefined ? end - 1 : target.length - 1)];
                            }
                            return [0, target.length - 1];
                        };
                    case Symbol.iterator:
                        return function* () {
                            for (let i = 0; i < target.length; i++) {
                                yield target.getLineContent(i);
                            }
                        };
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const index = Number.parseInt(p);
                if (Number.isInteger(index)) {
                    if (index >= 0 && index < target.length) {
                        const value = target.getLineContent(index);
                        if (value === undefined) {
                            console.log(target);
                        }
                        return value;
                    }
                    else {
                        return undefined;
                    }
                }
                throw new Error(`get ${String(p)} not implemented`);
            }
        };
    }
})(ContentLines || (exports.ContentLines = ContentLines = {}));


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineRange = exports.Change = exports.DiffComputer = void 0;
const jsdiff = __webpack_require__(/*! diff */ "../node_modules/diff/lib/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
class DiffComputer {
    computeDiff(previous, current) {
        const diffResult = diffArrays(previous, current);
        return diffResult;
    }
    computeDirtyDiff(previous, current) {
        const changes = [];
        const diffResult = this.computeDiff(previous, current);
        let currentRevisionLine = -1;
        let previousRevisionLine = -1;
        for (let i = 0; i < diffResult.length; i++) {
            const change = diffResult[i];
            const next = diffResult[i + 1];
            if (change.added) {
                // case: addition
                changes.push({ previousRange: LineRange.createEmptyLineRange(previousRevisionLine + 1), currentRange: toLineRange(change) });
                currentRevisionLine += change.count;
            }
            else if (change.removed && next && next.added) {
                const isFirstChange = i === 0;
                const isLastChange = i === diffResult.length - 2;
                const isNextEmptyLine = next.value.length > 0 && current[next.value[0]].length === 0;
                const isPrevEmptyLine = change.value.length > 0 && previous[change.value[0]].length === 0;
                if (isFirstChange && isNextEmptyLine) {
                    // special case: removing at the beginning
                    changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(0) });
                    previousRevisionLine += change.count;
                }
                else if (isFirstChange && isPrevEmptyLine) {
                    // special case: adding at the beginning
                    changes.push({ previousRange: LineRange.createEmptyLineRange(0), currentRange: toLineRange(next) });
                    currentRevisionLine += next.count;
                }
                else if (isLastChange && isNextEmptyLine) {
                    changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(currentRevisionLine + 2) });
                    previousRevisionLine += change.count;
                }
                else {
                    // default case is a modification
                    changes.push({ previousRange: toLineRange(change), currentRange: toLineRange(next) });
                    currentRevisionLine += next.count;
                    previousRevisionLine += change.count;
                }
                i++; // consume next eagerly
            }
            else if (change.removed && !(next && next.added)) {
                // case: removal
                changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(currentRevisionLine + 1) });
                previousRevisionLine += change.count;
            }
            else {
                // case: unchanged region
                currentRevisionLine += change.count;
                previousRevisionLine += change.count;
            }
        }
        return { changes };
    }
}
exports.DiffComputer = DiffComputer;
class ArrayDiff extends jsdiff.Diff {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    tokenize(value) {
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    join(value) {
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    removeEmpty(value) {
        return value;
    }
}
const arrayDiff = new ArrayDiff();
/**
 * Computes diff without copying data.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function diffArrays(oldArr, newArr) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return arrayDiff.diff(oldArr, newArr);
}
function toLineRange({ value }) {
    const [start, end] = value;
    return LineRange.create(start, end + 1);
}
var Change;
(function (Change) {
    function isAddition(change) {
        return LineRange.isEmpty(change.previousRange);
    }
    Change.isAddition = isAddition;
    function isRemoval(change) {
        return LineRange.isEmpty(change.currentRange);
    }
    Change.isRemoval = isRemoval;
    function isModification(change) {
        return !isAddition(change) && !isRemoval(change);
    }
    Change.isModification = isModification;
})(Change || (exports.Change = Change = {}));
var LineRange;
(function (LineRange) {
    function create(start, end) {
        if (start < 0 || end < 0 || start > end) {
            throw new Error(`Invalid line range: { start: ${start}, end: ${end} }`);
        }
        return { start, end };
    }
    LineRange.create = create;
    function createSingleLineRange(line) {
        return create(line, line + 1);
    }
    LineRange.createSingleLineRange = createSingleLineRange;
    function createEmptyLineRange(line) {
        return create(line, line);
    }
    LineRange.createEmptyLineRange = createEmptyLineRange;
    function isEmpty(range) {
        return range.start === range.end;
    }
    LineRange.isEmpty = isEmpty;
    function getStartPosition(range) {
        if (isEmpty(range)) {
            return getEndPosition(range);
        }
        return vscode_languageserver_protocol_1.Position.create(range.start, 0);
    }
    LineRange.getStartPosition = getStartPosition;
    function getEndPosition(range) {
        if (range.end < 1) {
            return vscode_languageserver_protocol_1.Position.create(0, 0);
        }
        return vscode_languageserver_protocol_1.Position.create(range.end - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE);
    }
    LineRange.getEndPosition = getEndPosition;
    function toRange(range) {
        return vscode_languageserver_protocol_1.Range.create(getStartPosition(range), getEndPosition(range));
    }
    LineRange.toRange = toRange;
    function getLineCount(range) {
        return range.end - range.start;
    }
    LineRange.getLineCount = getLineCount;
})(LineRange || (exports.LineRange = LineRange = {}));


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffDecorator = exports.DirtyDiffDecorationType = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
var DirtyDiffDecorationType;
(function (DirtyDiffDecorationType) {
    DirtyDiffDecorationType["AddedLine"] = "dirty-diff-added-line";
    DirtyDiffDecorationType["RemovedLine"] = "dirty-diff-removed-line";
    DirtyDiffDecorationType["ModifiedLine"] = "dirty-diff-modified-line";
})(DirtyDiffDecorationType || (exports.DirtyDiffDecorationType = DirtyDiffDecorationType = {}));
const AddedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-added-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.addedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.addedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: true
};
const RemovedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-removed-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.deletedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.deletedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: false
};
const ModifiedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-modified-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.modifiedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.modifiedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: true
};
function getEditorDecorationOptions(change) {
    if (diff_computer_1.Change.isAddition(change)) {
        return AddedLineDecoration;
    }
    if (diff_computer_1.Change.isRemoval(change)) {
        return RemovedLineDecoration;
    }
    return ModifiedLineDecoration;
}
let DirtyDiffDecorator = class DirtyDiffDecorator extends browser_1.EditorDecorator {
    applyDecorations(update) {
        const decorations = update.changes.map(change => this.toDeltaDecoration(change));
        this.setDecorations(update.editor, decorations);
    }
    toDeltaDecoration(change) {
        const range = diff_computer_1.LineRange.toRange(change.currentRange);
        const options = getEditorDecorationOptions(change);
        return { range, options };
    }
};
exports.DirtyDiffDecorator = DirtyDiffDecorator;
exports.DirtyDiffDecorator = DirtyDiffDecorator = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DirtyDiffDecorator);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffController = exports.DirtyDiffNavigator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const dirty_diff_widget_1 = __webpack_require__(/*! ./dirty-diff-widget */ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
let DirtyDiffNavigator = class DirtyDiffNavigator {
    constructor() {
        this.controllers = new Map();
    }
    init() {
        const dirtyDiffVisible = this.contextKeyService.createKey('dirtyDiffVisible', false);
        this.editorManager.onActiveEditorChanged(editorWidget => {
            var _a;
            dirtyDiffVisible.set(editorWidget && ((_a = this.controllers.get(editorWidget.editor)) === null || _a === void 0 ? void 0 : _a.isShowingChange()));
        });
        this.editorManager.onCreated(editorWidget => {
            const { editor } = editorWidget;
            if (editor.uri.scheme !== 'file') {
                return;
            }
            const controller = this.createController(editor);
            controller.widgetFactory = props => {
                var _a;
                const widget = this.widgetFactory(props);
                if (widget.editor === ((_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor)) {
                    dirtyDiffVisible.set(true);
                }
                widget.onDidClose(() => {
                    var _a;
                    if (widget.editor === ((_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor)) {
                        dirtyDiffVisible.set(false);
                    }
                });
                return widget;
            };
            this.controllers.set(editor, controller);
            editorWidget.disposed.connect(() => {
                this.controllers.delete(editor);
                controller.dispose();
            });
        });
    }
    handleDirtyDiffUpdate(update) {
        const controller = this.controllers.get(update.editor);
        controller === null || controller === void 0 ? void 0 : controller.handleDirtyDiffUpdate(update);
    }
    canNavigate() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.canNavigate());
    }
    gotoNextChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.gotoNextChange();
    }
    gotoPreviousChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.gotoPreviousChange();
    }
    canShowChange() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.canShowChange());
    }
    showNextChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.showNextChange();
    }
    showPreviousChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.showPreviousChange();
    }
    isShowingChange() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.isShowingChange());
    }
    closeChangePeekView() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.closeWidget();
    }
    get activeController() {
        var _a;
        const editor = (_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor;
        return editor && this.controllers.get(editor);
    }
    createController(editor) {
        return new DirtyDiffController(editor);
    }
};
exports.DirtyDiffNavigator = DirtyDiffNavigator;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], DirtyDiffNavigator.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.EditorManager),
    tslib_1.__metadata("design:type", browser_1.EditorManager)
], DirtyDiffNavigator.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dirty_diff_widget_1.DirtyDiffWidgetFactory),
    tslib_1.__metadata("design:type", Function)
], DirtyDiffNavigator.prototype, "widgetFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DirtyDiffNavigator.prototype, "init", null);
exports.DirtyDiffNavigator = DirtyDiffNavigator = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DirtyDiffNavigator);
class DirtyDiffController {
    constructor(editor) {
        this.editor = editor;
        this.toDispose = new core_1.DisposableCollection();
        editor.onMouseDown(this.handleEditorMouseDown, this, this.toDispose);
    }
    dispose() {
        this.closeWidget();
        this.toDispose.dispose();
    }
    handleDirtyDiffUpdate(dirtyDiff) {
        if (dirtyDiff.editor === this.editor) {
            this.closeWidget();
            this.dirtyDiff = dirtyDiff;
        }
    }
    canNavigate() {
        var _a;
        return !!((_a = this.changes) === null || _a === void 0 ? void 0 : _a.length);
    }
    gotoNextChange() {
        var _a;
        const { editor } = this;
        const index = this.findNextClosestChange(editor.cursor.line, false);
        const change = (_a = this.changes) === null || _a === void 0 ? void 0 : _a[index];
        if (change) {
            const position = diff_computer_1.LineRange.getStartPosition(change.currentRange);
            editor.cursor = position;
            editor.revealPosition(position, { vertical: 'auto' });
        }
    }
    gotoPreviousChange() {
        var _a;
        const { editor } = this;
        const index = this.findPreviousClosestChange(editor.cursor.line, false);
        const change = (_a = this.changes) === null || _a === void 0 ? void 0 : _a[index];
        if (change) {
            const position = diff_computer_1.LineRange.getStartPosition(change.currentRange);
            editor.cursor = position;
            editor.revealPosition(position, { vertical: 'auto' });
        }
    }
    canShowChange() {
        var _a;
        return !!(this.widget || this.widgetFactory && this.editor instanceof monaco_editor_1.MonacoEditor && ((_a = this.changes) === null || _a === void 0 ? void 0 : _a.length) && this.previousRevisionUri);
    }
    showNextChange() {
        var _a;
        if (this.widget) {
            this.widget.showNextChange();
        }
        else {
            (_a = (this.widget = this.createWidget())) === null || _a === void 0 ? void 0 : _a.showChange(this.findNextClosestChange(this.editor.cursor.line, true));
        }
    }
    showPreviousChange() {
        var _a;
        if (this.widget) {
            this.widget.showPreviousChange();
        }
        else {
            (_a = (this.widget = this.createWidget())) === null || _a === void 0 ? void 0 : _a.showChange(this.findPreviousClosestChange(this.editor.cursor.line, true));
        }
    }
    isShowingChange() {
        return !!this.widget;
    }
    closeWidget() {
        if (this.widget) {
            this.widget.dispose();
            this.widget = undefined;
        }
    }
    get changes() {
        var _a;
        return (_a = this.dirtyDiff) === null || _a === void 0 ? void 0 : _a.changes;
    }
    get previousRevisionUri() {
        var _a;
        return (_a = this.dirtyDiff) === null || _a === void 0 ? void 0 : _a.previousRevisionUri;
    }
    createWidget() {
        const { widgetFactory, editor, changes, previousRevisionUri } = this;
        if (widgetFactory && editor instanceof monaco_editor_1.MonacoEditor && (changes === null || changes === void 0 ? void 0 : changes.length) && previousRevisionUri) {
            const widget = widgetFactory({ editor, previousRevisionUri, changes });
            widget.onDidClose(() => {
                this.widget = undefined;
            });
            return widget;
        }
    }
    findNextClosestChange(line, inclusive) {
        var _a;
        const length = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.length;
        if (!length) {
            return -1;
        }
        for (let i = 0; i < length; i++) {
            const { currentRange } = this.changes[i];
            if (inclusive) {
                if (diff_computer_1.LineRange.getEndPosition(currentRange).line >= line) {
                    return i;
                }
            }
            else {
                if (diff_computer_1.LineRange.getStartPosition(currentRange).line > line) {
                    return i;
                }
            }
        }
        return 0;
    }
    findPreviousClosestChange(line, inclusive) {
        var _a;
        const length = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.length;
        if (!length) {
            return -1;
        }
        for (let i = length - 1; i >= 0; i--) {
            const { currentRange } = this.changes[i];
            if (inclusive) {
                if (diff_computer_1.LineRange.getStartPosition(currentRange).line <= line) {
                    return i;
                }
            }
            else {
                if (diff_computer_1.LineRange.getEndPosition(currentRange).line < line) {
                    return i;
                }
            }
        }
        return length - 1;
    }
    handleEditorMouseDown({ event, target }) {
        var _a, _b;
        if (event.button !== 0) {
            return;
        }
        const { range, type, element } = target;
        if (!range || type !== browser_1.MouseTargetType.GUTTER_LINE_DECORATIONS || !element || element.className.indexOf('dirty-diff-glyph') < 0) {
            return;
        }
        const gutterOffsetX = target.detail.offsetX - element.offsetLeft;
        if (gutterOffsetX < -3 || gutterOffsetX > 3) { // dirty diff decoration on hover is 6px wide
            return; // to avoid colliding with folding
        }
        const index = this.findNextClosestChange(range.start.line, true);
        if (index < 0) {
            return;
        }
        if (index === ((_a = this.widget) === null || _a === void 0 ? void 0 : _a.currentChangeIndex)) {
            this.closeWidget();
            return;
        }
        if (!this.widget) {
            this.widget = this.createWidget();
        }
        (_b = this.widget) === null || _b === void 0 ? void 0 : _b.showChange(index);
    }
}
exports.DirtyDiffController = DirtyDiffController;


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffWidget = exports.DirtyDiffWidgetFactory = exports.DirtyDiffWidgetProps = exports.PLUGIN_SCM_CHANGE_TITLE_MENU = exports.SCM_CHANGE_TITLE_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const monaco_editor_peek_view_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-peek-view-widget */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const scm_colors_1 = __webpack_require__(/*! ../scm-colors */ "../node_modules/@theia/scm/lib/browser/scm-colors.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
exports.SCM_CHANGE_TITLE_MENU = ['scm-change-title-menu'];
/** Reserved for plugin contributions, corresponds to contribution point 'scm/change/title'. */
exports.PLUGIN_SCM_CHANGE_TITLE_MENU = ['plugin-scm-change-title-menu'];
exports.DirtyDiffWidgetProps = Symbol('DirtyDiffWidgetProps');
exports.DirtyDiffWidgetFactory = Symbol('DirtyDiffWidgetFactory');
let DirtyDiffWidget = class DirtyDiffWidget {
    constructor(props, editorProvider, contextKeyService, menuModelRegistry, menuCommandExecutor) {
        this.props = props;
        this.editorProvider = editorProvider;
        this.contextKeyService = contextKeyService;
        this.menuModelRegistry = menuModelRegistry;
        this.menuCommandExecutor = menuCommandExecutor;
        this.onDidCloseEmitter = new core_1.Emitter();
        this.onDidClose = this.onDidCloseEmitter.event;
        this.index = -1;
    }
    create() {
        this.peekView = new DirtyDiffPeekView(this);
        this.peekView.onDidClose(e => this.onDidCloseEmitter.fire(e));
        this.diffEditorPromise = this.peekView.create();
    }
    get editor() {
        return this.props.editor;
    }
    get uri() {
        return this.editor.uri;
    }
    get previousRevisionUri() {
        return this.props.previousRevisionUri;
    }
    get changes() {
        return this.props.changes;
    }
    get currentChange() {
        return this.changes[this.index];
    }
    get currentChangeIndex() {
        return this.index;
    }
    showChange(index) {
        this.checkCreated();
        if (index >= 0 && index < this.changes.length) {
            this.index = index;
            this.showCurrentChange();
        }
    }
    showNextChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? 0 : cycle(index, 1, length);
            this.showCurrentChange();
        }
    }
    showPreviousChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? length - 1 : cycle(index, -1, length);
            this.showCurrentChange();
        }
    }
    async getContentWithSelectedChanges(predicate) {
        this.checkCreated();
        const changes = this.changes.filter(predicate);
        const { diffEditor } = await this.diffEditorPromise;
        const diffEditorModel = diffEditor.getModel();
        return applyChanges(changes, diffEditorModel.original, diffEditorModel.modified);
    }
    dispose() {
        var _a;
        (_a = this.peekView) === null || _a === void 0 ? void 0 : _a.dispose();
        this.onDidCloseEmitter.dispose();
    }
    showCurrentChange() {
        this.peekView.setTitle(this.computePrimaryHeading(), this.computeSecondaryHeading());
        const { previousRange, currentRange } = this.changes[this.index];
        this.peekView.show(vscode_languageserver_protocol_1.Position.create(diff_computer_1.LineRange.getEndPosition(currentRange).line, 0), this.computeHeightInLines());
        this.diffEditorPromise.then(({ diffEditor }) => {
            let startLine = diff_computer_1.LineRange.getStartPosition(currentRange).line;
            let endLine = diff_computer_1.LineRange.getEndPosition(currentRange).line;
            if (diff_computer_1.LineRange.isEmpty(currentRange)) { // the change is a removal
                ++endLine;
            }
            else if (!diff_computer_1.LineRange.isEmpty(previousRange)) { // the change is a modification
                --startLine;
                ++endLine;
            }
            diffEditor.revealLinesInCenter(startLine + 1, endLine + 1, // monaco line numbers are 1-based
            monaco.editor.ScrollType.Immediate);
        });
        this.editor.focus();
    }
    computePrimaryHeading() {
        return this.uri.path.base;
    }
    computeSecondaryHeading() {
        const index = this.index + 1;
        const length = this.changes.length;
        return length > 1 ? core_1.nls.localizeByDefault('{0} of {1} changes', index, length) :
            core_1.nls.localizeByDefault('{0} of {1} change', index, length);
    }
    computeHeightInLines() {
        const editor = this.editor.getControl();
        const lineHeight = editor.getOption(monaco.editor.EditorOption.lineHeight);
        const editorHeight = editor.getLayoutInfo().height;
        const editorHeightInLines = Math.floor(editorHeight / lineHeight);
        const { previousRange, currentRange } = this.changes[this.index];
        const changeHeightInLines = diff_computer_1.LineRange.getLineCount(currentRange) + diff_computer_1.LineRange.getLineCount(previousRange);
        return Math.min(changeHeightInLines + /* padding */ 8, Math.floor(editorHeightInLines / 3));
    }
    checkCreated() {
        if (!this.peekView) {
            throw new Error('create() method needs to be called first.');
        }
    }
};
exports.DirtyDiffWidget = DirtyDiffWidget;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DirtyDiffWidget.prototype, "create", null);
exports.DirtyDiffWidget = DirtyDiffWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(exports.DirtyDiffWidgetProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider)),
    tslib_1.__param(2, (0, inversify_1.inject)(context_key_service_1.ContextKeyService)),
    tslib_1.__param(3, (0, inversify_1.inject)(core_1.MenuModelRegistry)),
    tslib_1.__param(4, (0, inversify_1.inject)(core_1.MenuCommandExecutor)),
    tslib_1.__metadata("design:paramtypes", [Object, monaco_editor_provider_1.MonacoEditorProvider, Object, core_1.MenuModelRegistry, Object])
], DirtyDiffWidget);
function cycle(index, offset, length) {
    return (index + offset + length) % length;
}
// adapted from https://github.com/microsoft/vscode/blob/823d54f86ee13eb357bc6e8e562e89d793f3c43b/extensions/git/src/staging.ts
function applyChanges(changes, original, modified) {
    const result = [];
    let currentLine = 1;
    for (const change of changes) {
        const { previousRange, currentRange } = change;
        const isInsertion = diff_computer_1.LineRange.isEmpty(previousRange);
        const isDeletion = diff_computer_1.LineRange.isEmpty(currentRange);
        const convert = (range) => {
            let startLineNumber;
            let endLineNumber;
            if (!diff_computer_1.LineRange.isEmpty(range)) {
                startLineNumber = range.start + 1;
                endLineNumber = range.end;
            }
            else {
                startLineNumber = range.start;
                endLineNumber = 0;
            }
            return [startLineNumber, endLineNumber];
        };
        const [originalStartLineNumber, originalEndLineNumber] = convert(previousRange);
        const [modifiedStartLineNumber, modifiedEndLineNumber] = convert(currentRange);
        let toLine = isInsertion ? originalStartLineNumber + 1 : originalStartLineNumber;
        let toCharacter = 1;
        // if this is a deletion at the very end of the document,
        // we need to account for a newline at the end of the last line,
        // which may have been deleted
        if (isDeletion && originalEndLineNumber === original.getLineCount()) {
            toLine--;
            toCharacter = original.getLineMaxColumn(toLine);
        }
        result.push(original.getValueInRange(new monaco.Range(currentLine, 1, toLine, toCharacter)));
        if (!isDeletion) {
            let fromLine = modifiedStartLineNumber;
            let fromCharacter = 1;
            // if this is an insertion at the very end of the document,
            // we must start the next range after the last character of the previous line,
            // in order to take the correct eol
            if (isInsertion && originalStartLineNumber === original.getLineCount()) {
                fromLine--;
                fromCharacter = modified.getLineMaxColumn(fromLine);
            }
            result.push(modified.getValueInRange(new monaco.Range(fromLine, fromCharacter, modifiedEndLineNumber + 1, 1)));
        }
        currentLine = isInsertion ? originalStartLineNumber + 1 : originalEndLineNumber + 1;
    }
    result.push(original.getValueInRange(new monaco.Range(currentLine, 1, original.getLineCount() + 1, 1)));
    return result.join('');
}
class DirtyDiffPeekView extends monaco_editor_peek_view_widget_1.MonacoEditorPeekViewWidget {
    constructor(widget) {
        super(widget.editor, { isResizeable: true, showArrow: true, frameWidth: 1, keepEditorSelection: true, className: 'dirty-diff' });
        this.widget = widget;
    }
    async create() {
        try {
            super.create();
            const diffEditor = await this.diffEditorPromise;
            return new Promise(resolve => {
                // setTimeout is needed here because the non-side-by-side diff editor might still not have created the view zones;
                // otherwise, the first change shown might not be properly revealed in the diff editor.
                // see also https://github.com/microsoft/vscode/blob/b30900b56c4b3ca6c65d7ab92032651f4cb23f15/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.ts#L248
                const disposable = diffEditor.diffEditor.onDidUpdateDiff(() => setTimeout(() => {
                    resolve(diffEditor);
                    disposable.dispose();
                }));
            });
        }
        catch (e) {
            this.dispose();
            throw e;
        }
    }
    show(rangeOrPos, heightInLines) {
        const borderColor = this.getBorderColor();
        this.style({
            arrowColor: borderColor,
            frameColor: borderColor,
            headerBackgroundColor: monaco_editor_peek_view_widget_1.peekViewTitleBackground,
            primaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleForeground,
            secondaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleInfoForeground
        });
        this.updateActions();
        super.show(rangeOrPos, heightInLines);
    }
    getBorderColor() {
        const { currentChange } = this.widget;
        if (!currentChange) {
            return monaco_editor_peek_view_widget_1.peekViewBorder;
        }
        if (diff_computer_1.Change.isAddition(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterAddedBackground;
        }
        else if (diff_computer_1.Change.isRemoval(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterDeletedBackground;
        }
        else {
            return scm_colors_1.ScmColors.editorGutterModifiedBackground;
        }
    }
    updateActions() {
        this.clearActions();
        const { contextKeyService, menuModelRegistry, menuCommandExecutor } = this.widget;
        contextKeyService.with({ originalResourceScheme: this.widget.previousRevisionUri.scheme }, () => {
            for (const menuPath of [exports.SCM_CHANGE_TITLE_MENU, exports.PLUGIN_SCM_CHANGE_TITLE_MENU]) {
                const menu = menuModelRegistry.getMenu(menuPath);
                for (const item of menu.children) {
                    if (item instanceof core_1.ActionMenuNode) {
                        const { command, id, label, icon, when } = item;
                        if (icon && menuCommandExecutor.isVisible(menuPath, command, this.widget) && (!when || contextKeyService.match(when))) {
                            this.addAction(id, label, icon, menuCommandExecutor.isEnabled(menuPath, command, this.widget), () => {
                                menuCommandExecutor.executeCommand(menuPath, command, this.widget);
                            });
                        }
                    }
                }
            }
        });
        this.addAction('dirtydiff.next', core_1.nls.localizeByDefault('Show Next Change'), (0, browser_1.codicon)('arrow-down'), true, () => this.widget.showNextChange());
        this.addAction('dirtydiff.previous', core_1.nls.localizeByDefault('Show Previous Change'), (0, browser_1.codicon)('arrow-up'), true, () => this.widget.showPreviousChange());
        this.addAction('peekview.close', core_1.nls.localizeByDefault('Close'), (0, browser_1.codicon)('close'), true, () => this.dispose());
    }
    fillHead(container) {
        super.fillHead(container, true);
    }
    fillBody(container) {
        this.diffEditorPromise = this.widget.editorProvider.createEmbeddedDiffEditor(this.editor, container, this.widget.previousRevisionUri).then(diffEditor => {
            this.toDispose.push(diffEditor);
            return diffEditor;
        });
    }
    doLayoutBody(height, width) {
        super.doLayoutBody(height, width);
        this.layout(height, width);
        this.height = height;
    }
    onWidth(width) {
        super.onWidth(width);
        const { height } = this;
        if (height !== undefined) {
            this.layout(height, width);
        }
    }
    layout(height, width) {
        var _a;
        (_a = this.diffEditorPromise) === null || _a === void 0 ? void 0 : _a.then(({ diffEditor }) => diffEditor.layout({ height, width }));
    }
    doRevealRange(range) {
        this.editor.revealPosition(vscode_languageserver_protocol_1.Position.create(range.end.line, 0), { vertical: 'centerIfOutsideViewport' });
    }
}


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-amend-component.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-amend-component.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAmendComponent = void 0;
__webpack_require__(/*! ../../src/browser/style/scm-amend-component.css */ "../node_modules/@theia/scm/src/browser/style/scm-amend-component.css");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const TRANSITION_TIME_MS = 300;
const REPOSITORY_STORAGE_KEY = 'scmRepository';
class ScmAmendComponent extends React.Component {
    constructor(props) {
        super(props);
        /**
         * a hint on how to animate an update, set by certain user action handlers
         * and used when updating the view based on a repository change
         */
        this.transitionHint = 'none';
        this.lastCommitHeight = 0;
        this.lastCommitScrollRef = (instance) => {
            if (instance && this.lastCommitHeight === 0) {
                this.lastCommitHeight = instance.getBoundingClientRect().height;
            }
        };
        this.toDisposeOnUnmount = new core_1.DisposableCollection();
        /**
         * This function will update the 'model' (lastCommit, amendingCommits) only
         * when the repository sees the last commit change.
         * 'render' can be called at any time, so be sure we don't update any 'model'
         * fields until we actually start the transition.
         */
        this.amend = async () => {
            if (this.state.transition.state !== 'none' && this.transitionHint !== 'none') {
                return;
            }
            this.transitionHint = 'amend';
            await this.resetAndSetMessage('HEAD~', 'HEAD');
        };
        this.unamend = async () => {
            if (this.state.transition.state !== 'none' && this.transitionHint !== 'none') {
                return;
            }
            const commitToRestore = (this.state.amendingCommits.length >= 1)
                ? this.state.amendingCommits[this.state.amendingCommits.length - 1]
                : undefined;
            const oldestAmendCommit = (this.state.amendingCommits.length >= 2)
                ? this.state.amendingCommits[this.state.amendingCommits.length - 2]
                : undefined;
            if (commitToRestore) {
                const commitToUseForMessage = oldestAmendCommit
                    ? oldestAmendCommit.commit.id
                    : undefined;
                this.transitionHint = 'unamend';
                await this.resetAndSetMessage(commitToRestore.commit.id, commitToUseForMessage);
            }
        };
        this.unamendAll = () => this.doUnamendAll();
        this.clearAmending = () => this.doClearAmending();
        this.state = {
            transition: { state: 'none' },
            amendingCommits: [],
            lastCommit: undefined
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            if (!this.toDisposeOnUnmount.disposed) {
                setState(newState);
            }
        };
    }
    async componentDidMount() {
        this.toDisposeOnUnmount.push(core_1.Disposable.create(() => { }));
        const lastCommit = await this.getLastCommit();
        this.setState({ amendingCommits: await this.buildAmendingList(lastCommit ? lastCommit.commit : undefined), lastCommit });
        if (this.toDisposeOnUnmount.disposed) {
            return;
        }
        this.toDisposeOnUnmount.push(this.props.repository.provider.onDidChange(() => this.fetchStatusAndSetState()));
    }
    componentWillUnmount() {
        this.toDisposeOnUnmount.dispose();
    }
    async fetchStatusAndSetState() {
        const storageKey = this.getStorageKey();
        const nextCommit = await this.getLastCommit();
        if (nextCommit && this.state.lastCommit && nextCommit.commit.id === this.state.lastCommit.commit.id) {
            // No change here
        }
        else if (nextCommit === undefined && this.state.lastCommit === undefined) {
            // No change here
        }
        else if (this.transitionHint === 'none') {
            // If the 'last' commit changes, but we are not expecting an 'amend'
            // or 'unamend' to occur, then we clear out the list of amended commits.
            // This is because an unexpected change has happened to the repository,
            // perhaps the user committed, merged, or something.  The amended commits
            // will no longer be valid.
            // Note that there may or may not have been a previous lastCommit (if the
            // repository was previously empty with no initial commit then lastCommit
            // will be undefined).  Either way we clear the amending commits.
            await this.clearAmendingCommits();
            // There is a change to the last commit, but no transition hint so
            // the view just updates without transition.
            this.setState({ amendingCommits: [], lastCommit: nextCommit });
        }
        else {
            const amendingCommits = this.state.amendingCommits.concat([]); // copy the array
            const direction = this.transitionHint === 'amend' ? 'up' : 'down';
            switch (this.transitionHint) {
                case 'amend':
                    if (this.state.lastCommit) {
                        amendingCommits.push(this.state.lastCommit);
                        const serializedState = JSON.stringify({
                            amendingHeadCommitSha: amendingCommits[0].commit.id,
                            latestCommitSha: nextCommit ? nextCommit.commit.id : undefined
                        });
                        this.props.storageService.setData(storageKey, serializedState);
                    }
                    break;
                case 'unamend':
                    amendingCommits.pop();
                    if (amendingCommits.length === 0) {
                        this.props.storageService.setData(storageKey, undefined);
                    }
                    else {
                        const serializedState = JSON.stringify({
                            amendingHeadCommitSha: amendingCommits[0].commit.id,
                            latestCommitSha: nextCommit ? nextCommit.commit.id : undefined
                        });
                        this.props.storageService.setData(storageKey, serializedState);
                    }
                    break;
            }
            if (this.state.lastCommit && nextCommit) {
                const transitionData = { direction, previousLastCommit: this.state.lastCommit };
                this.setState({ lastCommit: nextCommit, amendingCommits, transition: { ...transitionData, state: 'start' } });
                this.onNextFrame(() => {
                    this.setState({ transition: { ...transitionData, state: 'transitioning' } });
                });
                setTimeout(() => {
                    this.setState({ transition: { state: 'none' } });
                }, TRANSITION_TIME_MS);
            }
            else {
                // No previous last commit so no transition
                this.setState({ transition: { state: 'none' }, amendingCommits, lastCommit: nextCommit });
            }
        }
        this.transitionHint = 'none';
    }
    async clearAmendingCommits() {
        const storageKey = this.getStorageKey();
        await this.props.storageService.setData(storageKey, undefined);
    }
    async buildAmendingList(lastCommit) {
        const storageKey = this.getStorageKey();
        const storedState = await this.props.storageService.getData(storageKey, undefined);
        // Restore list of commits from saved amending head commit up through parents until the
        // current commit.  (If we don't reach the current commit, the repository has been changed in such
        // a way then unamending commits can no longer be done).
        if (storedState) {
            const { amendingHeadCommitSha, latestCommitSha } = JSON.parse(storedState);
            if (!this.commitsAreEqual(lastCommit, latestCommitSha)) {
                // The head commit in the repository has changed.  It is not the same commit that was the
                // head commit after the last 'amend'.
                return [];
            }
            const commits = await this.props.scmAmendSupport.getInitialAmendingCommits(amendingHeadCommitSha, lastCommit ? lastCommit.id : undefined);
            const amendingCommitPromises = commits.map(async (commit) => {
                const avatar = await this.props.avatarService.getAvatar(commit.authorEmail);
                return { commit, avatar };
            });
            return Promise.all(amendingCommitPromises);
        }
        else {
            return [];
        }
    }
    getStorageKey() {
        return REPOSITORY_STORAGE_KEY + ':' + this.props.repository.provider.rootUri;
    }
    /**
     * Commits are equal if the ids are equal or if both are undefined.
     * (If a commit is undefined, it represents the initial empty state of a repository,
     * before the initial commit).
     */
    commitsAreEqual(lastCommit, savedLastCommitId) {
        return lastCommit
            ? lastCommit.id === savedLastCommitId
            : savedLastCommitId === undefined;
    }
    async resetAndSetMessage(commitToRestore, commitToUseForMessage) {
        const message = commitToUseForMessage
            ? await this.props.scmAmendSupport.getMessage(commitToUseForMessage)
            : '';
        await this.props.scmAmendSupport.reset(commitToRestore);
        this.props.setCommitMessage(message);
    }
    render() {
        const neverShrink = this.state.amendingCommits.length <= 3;
        const style = neverShrink
            ? {
                ...this.props.style,
                flexShrink: 0,
            }
            : {
                ...this.props.style,
                flexShrink: 1,
                minHeight: 240 // height with three commits
            };
        return (React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_CONTAINER + ' no-select', style: style },
            this.state.amendingCommits.length > 0 || (this.state.lastCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'down')
                ? this.renderAmendingCommits()
                : '',
            this.state.lastCommit ?
                React.createElement("div", null,
                    React.createElement("div", { id: 'lastCommit', className: 'theia-scm-amend' },
                        React.createElement("div", { className: 'theia-header scm-theia-header' }, nls_1.nls.localize('theia/scm/amendHeadCommit', 'HEAD Commit')),
                        this.renderLastCommit()))
                : ''));
    }
    async getLastCommit() {
        const commit = await this.props.scmAmendSupport.getLastCommit();
        if (commit) {
            const avatar = await this.props.avatarService.getAvatar(commit.authorEmail);
            return { commit, avatar };
        }
        return undefined;
    }
    renderAmendingCommits() {
        const neverShrink = this.state.amendingCommits.length <= 3;
        const style = neverShrink
            ? {
                flexShrink: 0,
            }
            : {
                flexShrink: 1,
                // parent minHeight controls height, we just need any value smaller than
                // what the height would be when the parent is at its minHeight
                minHeight: 0
            };
        return React.createElement("div", { id: 'amendedCommits', className: 'theia-scm-amend-outer-container', style: style },
            React.createElement("div", { className: 'theia-header scm-theia-header' },
                React.createElement("div", { className: 'noWrapInfo' }, "Commits being Amended"),
                this.renderAmendCommitListButtons(),
                this.renderCommitCount(this.state.amendingCommits.length)),
            React.createElement("div", { style: this.styleAmendedCommits() },
                this.state.amendingCommits.map((commitData, index, array) => this.renderCommitBeingAmended(commitData, index === array.length - 1)),
                this.state.lastCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'down'
                    ? this.renderCommitBeingAmended(this.state.lastCommit, false)
                    : ''));
    }
    renderAmendCommitListButtons() {
        return React.createElement("div", { className: 'theia-scm-inline-actions-container' },
            React.createElement("div", { className: 'theia-scm-inline-actions' },
                React.createElement("div", { className: 'theia-scm-inline-action' },
                    React.createElement("a", { className: (0, browser_1.codicon)('dash'), title: 'Unamend All Commits', onClick: this.unamendAll })),
                React.createElement("div", { className: 'theia-scm-inline-action' },
                    React.createElement("a", { className: (0, browser_1.codicon)('close'), title: 'Clear Amending Commits', onClick: this.clearAmending }))));
    }
    renderLastCommit() {
        if (!this.state.lastCommit) {
            return '';
        }
        const canAmend = true;
        return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AND_BUTTON, style: { flexGrow: 0, flexShrink: 0 }, key: this.state.lastCommit.commit.id },
            this.renderLastCommitNoButton(this.state.lastCommit),
            canAmend
                ? React.createElement("div", { className: ScmAmendComponent.Styles.FLEX_CENTER },
                    React.createElement("button", { className: 'theia-button', title: nls_1.nls.localize('theia/scm/amendLastCommit', 'Amend last commit'), onClick: this.amend }, nls_1.nls.localize('theia/scm/amend', 'Amend')))
                : '');
    }
    renderLastCommitNoButton(lastCommit) {
        switch (this.state.transition.state) {
            case 'none':
                return React.createElement("div", { ref: this.lastCommitScrollRef, className: 'theia-scm-scrolling-container' }, this.renderCommitAvatarAndDetail(lastCommit));
            case 'start':
            case 'transitioning':
                switch (this.state.transition.direction) {
                    case 'up':
                        return React.createElement("div", { style: this.styleLastCommitMovingUp(this.state.transition.state) },
                            this.renderCommitAvatarAndDetail(this.state.transition.previousLastCommit),
                            this.renderCommitAvatarAndDetail(lastCommit));
                    case 'down':
                        return React.createElement("div", { style: this.styleLastCommitMovingDown(this.state.transition.state) },
                            this.renderCommitAvatarAndDetail(lastCommit),
                            this.renderCommitAvatarAndDetail(this.state.transition.previousLastCommit));
                }
        }
    }
    /**
     * See https://stackoverflow.com/questions/26556436/react-after-render-code
     *
     * @param callback
     */
    onNextFrame(callback) {
        setTimeout(() => window.requestAnimationFrame(callback), 0);
    }
    renderCommitAvatarAndDetail(commitData) {
        const { commit, avatar } = commitData;
        return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, key: commit.id },
            React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_MESSAGE_AVATAR },
                React.createElement("img", { src: avatar })),
            React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_DETAILS },
                React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_MESSAGE_SUMMARY }, commit.summary),
                React.createElement("div", { className: ScmAmendComponent.Styles.LAST_COMMIT_MESSAGE_TIME }, `${commit.authorDateRelative} by ${commit.authorName}`)));
    }
    renderCommitCount(commits) {
        return React.createElement("div", { className: 'notification-count-container scm-change-count' },
            React.createElement("span", { className: 'notification-count' }, commits));
    }
    renderCommitBeingAmended(commitData, isOldestAmendCommit) {
        if (isOldestAmendCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'up') {
            return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, style: { flexGrow: 0, flexShrink: 0 }, key: commitData.commit.id },
                React.createElement("div", { className: 'fixed-height-commit-container' }, this.renderCommitAvatarAndDetail(commitData)));
        }
        else {
            return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, style: { flexGrow: 0, flexShrink: 0 }, key: commitData.commit.id },
                this.renderCommitAvatarAndDetail(commitData),
                isOldestAmendCommit
                    ? React.createElement("div", { className: ScmAmendComponent.Styles.FLEX_CENTER },
                        React.createElement("button", { className: 'theia-button', title: nls_1.nls.localize('theia/scm/unamendCommit', 'Unamend commit'), onClick: this.unamend }, nls_1.nls.localize('theia/scm/unamend', 'Unamend')))
                    : '');
        }
    }
    /*
     * The style for the <div> containing the list of commits being amended.
     * This div is scrollable.
     */
    styleAmendedCommits() {
        const base = {
            display: 'flex',
            whitespace: 'nowrap',
            width: '100%',
            minHeight: 0,
            flexShrink: 1,
            paddingTop: '2px',
        };
        switch (this.state.transition.state) {
            case 'none':
                return {
                    ...base,
                    flexDirection: 'column',
                    overflowY: 'auto',
                    marginBottom: '0',
                };
            case 'start':
            case 'transitioning':
                let startingMargin = 0;
                let endingMargin = 0;
                switch (this.state.transition.direction) {
                    case 'down':
                        startingMargin = 0;
                        endingMargin = -32;
                        break;
                    case 'up':
                        startingMargin = -32;
                        endingMargin = 0;
                        break;
                }
                switch (this.state.transition.state) {
                    case 'start':
                        return {
                            ...base,
                            flexDirection: 'column',
                            overflowY: 'hidden',
                            marginBottom: `${startingMargin}px`,
                        };
                    case 'transitioning':
                        return {
                            ...base,
                            flexDirection: 'column',
                            overflowY: 'hidden',
                            marginBottom: `${endingMargin}px`,
                            transitionProperty: 'margin-bottom',
                            transitionDuration: `${TRANSITION_TIME_MS}ms`,
                            transitionTimingFunction: 'linear'
                        };
                }
        }
    }
    styleLastCommitMovingUp(transitionState) {
        return this.styleLastCommit(transitionState, 0, -28);
    }
    styleLastCommitMovingDown(transitionState) {
        return this.styleLastCommit(transitionState, -28, 0);
    }
    styleLastCommit(transitionState, startingMarginTop, startingMarginBottom) {
        const base = {
            display: 'flex',
            width: '100%',
            overflow: 'hidden',
            paddingTop: 0,
            paddingBottom: 0,
            borderTop: 0,
            borderBottom: 0,
            height: this.lastCommitHeight * 2
        };
        // We end with top and bottom margins switched
        const endingMarginTop = startingMarginBottom;
        const endingMarginBottom = startingMarginTop;
        switch (transitionState) {
            case 'start':
                return {
                    ...base,
                    position: 'relative',
                    flexDirection: 'column',
                    marginTop: startingMarginTop,
                    marginBottom: startingMarginBottom,
                };
            case 'transitioning':
                return {
                    ...base,
                    position: 'relative',
                    flexDirection: 'column',
                    marginTop: endingMarginTop,
                    marginBottom: endingMarginBottom,
                    transitionProperty: 'margin-top margin-bottom',
                    transitionDuration: `${TRANSITION_TIME_MS}ms`,
                    transitionTimingFunction: 'linear'
                };
        }
    }
    async doUnamendAll() {
        while (this.state.amendingCommits.length > 0) {
            this.unamend();
            await new Promise(resolve => setTimeout(resolve, TRANSITION_TIME_MS));
        }
    }
    async doClearAmending() {
        await this.clearAmendingCommits();
        this.setState({ amendingCommits: [] });
    }
}
exports.ScmAmendComponent = ScmAmendComponent;
(function (ScmAmendComponent) {
    let Styles;
    (function (Styles) {
        Styles.COMMIT_CONTAINER = 'theia-scm-commit-container';
        Styles.COMMIT_AND_BUTTON = 'theia-scm-commit-and-button';
        Styles.COMMIT_AVATAR_AND_TEXT = 'theia-scm-commit-avatar-and-text';
        Styles.COMMIT_DETAILS = 'theia-scm-commit-details';
        Styles.COMMIT_MESSAGE_AVATAR = 'theia-scm-commit-message-avatar';
        Styles.COMMIT_MESSAGE_SUMMARY = 'theia-scm-commit-message-summary';
        Styles.LAST_COMMIT_MESSAGE_TIME = 'theia-scm-commit-message-time';
        Styles.FLEX_CENTER = 'theia-scm-flex-container-center';
    })(Styles = ScmAmendComponent.Styles || (ScmAmendComponent.Styles = {}));
})(ScmAmendComponent || (exports.ScmAmendComponent = ScmAmendComponent = {}));


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-amend-widget.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-amend-widget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmAmendWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAmendWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_avatar_service_1 = __webpack_require__(/*! ./scm-avatar-service */ "../node_modules/@theia/scm/lib/browser/scm-avatar-service.js");
const scm_amend_component_1 = __webpack_require__(/*! ./scm-amend-component */ "../node_modules/@theia/scm/lib/browser/scm-amend-component.js");
let ScmAmendWidget = ScmAmendWidget_1 = class ScmAmendWidget extends browser_1.ReactWidget {
    constructor(contextMenuRenderer) {
        super();
        this.contextMenuRenderer = contextMenuRenderer;
        this.shouldScrollToRow = true;
        this.setInputValue = (event) => {
            const repository = this.scmService.selectedRepository;
            if (repository) {
                repository.input.value = typeof event === 'string' ? event : event.currentTarget.value;
            }
        };
        this.scrollOptions = {
            suppressScrollX: true,
            minScrollbarLength: 35
        };
        this.id = ScmAmendWidget_1.ID;
    }
    render() {
        const repository = this.scmService.selectedRepository;
        if (repository && repository.provider.amendSupport) {
            return React.createElement(scm_amend_component_1.ScmAmendComponent, {
                key: `amend:${repository.provider.rootUri}`,
                style: { flexGrow: 0 },
                repository: repository,
                scmAmendSupport: repository.provider.amendSupport,
                setCommitMessage: this.setInputValue,
                avatarService: this.avatarService,
                storageService: this.storageService,
            });
        }
    }
};
exports.ScmAmendWidget = ScmAmendWidget;
ScmAmendWidget.ID = 'scm-amend-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmAmendWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_avatar_service_1.ScmAvatarService),
    tslib_1.__metadata("design:type", scm_avatar_service_1.ScmAvatarService)
], ScmAmendWidget.prototype, "avatarService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], ScmAmendWidget.prototype, "storageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.SelectionService),
    tslib_1.__metadata("design:type", common_1.SelectionService)
], ScmAmendWidget.prototype, "selectionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], ScmAmendWidget.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], ScmAmendWidget.prototype, "keybindings", void 0);
exports.ScmAmendWidget = ScmAmendWidget = ScmAmendWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [browser_1.ContextMenuRenderer])
], ScmAmendWidget);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-avatar-service.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-avatar-service.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAvatarService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const ts_md5_1 = __webpack_require__(/*! ts-md5 */ "../node_modules/ts-md5/dist/esm/index.js");
let ScmAvatarService = class ScmAvatarService {
    async getAvatar(email) {
        const hash = ts_md5_1.Md5.hashStr(email);
        return `https://www.gravatar.com/avatar/${hash}?d=robohash`;
    }
};
exports.ScmAvatarService = ScmAvatarService;
exports.ScmAvatarService = ScmAvatarService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmAvatarService);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-colors.js":
/*!************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-colors.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmColors = void 0;
var ScmColors;
(function (ScmColors) {
    ScmColors.editorGutterModifiedBackground = 'editorGutter.modifiedBackground';
    ScmColors.editorGutterAddedBackground = 'editorGutter.addedBackground';
    ScmColors.editorGutterDeletedBackground = 'editorGutter.deletedBackground';
})(ScmColors || (exports.ScmColors = ScmColors = {}));


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-commit-widget.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-commit-widget.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmCommitWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmCommitWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const react_textarea_autosize_1 = __webpack_require__(/*! react-textarea-autosize */ "../node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js");
const scm_input_1 = __webpack_require__(/*! ./scm-input */ "../node_modules/@theia/scm/lib/browser/scm-input.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
let ScmCommitWidget = ScmCommitWidget_1 = class ScmCommitWidget extends browser_1.ReactWidget {
    constructor(contextMenuRenderer) {
        super();
        this.contextMenuRenderer = contextMenuRenderer;
        this.toDisposeOnRepositoryChange = new core_1.DisposableCollection();
        this.shouldScrollToRow = true;
        /**
         * Don't modify DOM use React! only exposed for `focusInput`
         * Use `this.scmService.selectedRepository?.input.value` as a single source of truth!
         */
        this.inputRef = React.createRef();
        this.setInputValue = (event) => {
            const repository = this.scmService.selectedRepository;
            if (repository) {
                repository.input.value = typeof event === 'string' ? event : event.currentTarget.value;
            }
        };
        this.scrollOptions = {
            suppressScrollX: true,
            minScrollbarLength: 35
        };
        this.addClass('theia-scm-commit');
        this.id = ScmCommitWidget_1.ID;
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.refreshOnRepositoryChange();
        this.toDisposeOnDetach.push(this.scmService.onDidChangeSelectedRepository(() => {
            this.refreshOnRepositoryChange();
            this.update();
        }));
    }
    refreshOnRepositoryChange() {
        this.toDisposeOnRepositoryChange.dispose();
        const repository = this.scmService.selectedRepository;
        if (repository) {
            this.toDisposeOnRepositoryChange.push(repository.provider.onDidChange(async () => {
                this.update();
            }));
            this.toDisposeOnRepositoryChange.push(repository.provider.onDidChangeCommitTemplate(e => {
                this.setInputValue(e);
            }));
        }
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.focus();
    }
    focus() {
        (this.inputRef.current || this.node).focus();
    }
    render() {
        const repository = this.scmService.selectedRepository;
        if (repository) {
            return React.createElement('div', this.createContainerAttributes(), this.renderInput(repository.input));
        }
    }
    /**
     * Create the container attributes for the widget.
     */
    createContainerAttributes() {
        return {
            style: { flexGrow: 0 }
        };
    }
    renderInput(input) {
        let validationStatus = 'idle';
        if (input.issue) {
            switch (input.issue.type) {
                case scm_input_1.ScmInputIssueType.Error:
                    validationStatus = 'error';
                    break;
                case scm_input_1.ScmInputIssueType.Information:
                    validationStatus = 'info';
                    break;
                case scm_input_1.ScmInputIssueType.Warning:
                    validationStatus = 'warning';
                    break;
            }
        }
        const validationMessage = input.issue ? input.issue.message : '';
        const format = (value, ...args) => {
            if (args.length !== 0) {
                return value.replace(/{(\d+)}/g, (found, n) => {
                    const i = parseInt(n);
                    return isNaN(i) || i < 0 || i >= args.length ? found : args[i];
                });
            }
            return value;
        };
        const keybinding = this.keybindings.acceleratorFor(this.keybindings.getKeybindingsForCommand('scm.acceptInput')[0]).join('+');
        const message = format(input.placeholder || '', keybinding);
        const textArea = input.visible &&
            React.createElement(react_textarea_autosize_1.default, { className: `${ScmCommitWidget_1.Styles.INPUT_MESSAGE} theia-input theia-scm-input-message-${validationStatus}`, id: ScmCommitWidget_1.Styles.INPUT_MESSAGE, placeholder: message, spellCheck: false, autoFocus: true, value: input.value, disabled: !input.enabled, onChange: this.setInputValue, ref: this.inputRef, rows: 1, maxRows: 6 });
        return React.createElement("div", { className: ScmCommitWidget_1.Styles.INPUT_MESSAGE_CONTAINER },
            textArea,
            React.createElement("div", { className: `${ScmCommitWidget_1.Styles.VALIDATION_MESSAGE} ${ScmCommitWidget_1.Styles.NO_SELECT}
                    theia-scm-validation-message-${validationStatus} theia-scm-input-message-${validationStatus}`, style: {
                    display: !!input.issue ? 'block' : 'none'
                } }, validationMessage));
    }
    /**
     * Store the tree state.
     */
    storeState() {
        var _a;
        const message = (_a = this.scmService.selectedRepository) === null || _a === void 0 ? void 0 : _a.input.value;
        return { message };
    }
    /**
     * Restore the state.
     * @param oldState the old state object.
     */
    restoreState(oldState) {
        const value = oldState.message;
        if (!value) {
            return;
        }
        let repository = this.scmService.selectedRepository;
        if (repository) {
            repository.input.value = value;
        }
        else {
            const listener = this.scmService.onDidChangeSelectedRepository(() => {
                repository = this.scmService.selectedRepository;
                if (repository) {
                    listener.dispose();
                    if (!repository.input.value) {
                        repository.input.value = value;
                    }
                }
            });
            this.toDispose.push(listener);
        }
    }
};
exports.ScmCommitWidget = ScmCommitWidget;
ScmCommitWidget.ID = 'scm-commit-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmCommitWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], ScmCommitWidget.prototype, "keybindings", void 0);
exports.ScmCommitWidget = ScmCommitWidget = ScmCommitWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [browser_1.ContextMenuRenderer])
], ScmCommitWidget);
(function (ScmCommitWidget) {
    let Styles;
    (function (Styles) {
        Styles.INPUT_MESSAGE_CONTAINER = 'theia-scm-input-message-container';
        Styles.INPUT_MESSAGE = 'theia-scm-input-message';
        Styles.VALIDATION_MESSAGE = 'theia-scm-input-validation-message';
        Styles.NO_SELECT = 'no-select';
    })(Styles = ScmCommitWidget.Styles || (ScmCommitWidget.Styles = {}));
})(ScmCommitWidget || (exports.ScmCommitWidget = ScmCommitWidget = {}));


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-context-key-service.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-context-key-service.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let ScmContextKeyService = class ScmContextKeyService {
    get scmProvider() {
        return this._scmProvider;
    }
    get scmResourceGroup() {
        return this._scmResourceGroup;
    }
    init() {
        this._scmProvider = this.contextKeyService.createKey('scmProvider', undefined);
        this._scmResourceGroup = this.contextKeyService.createKey('scmResourceGroup', undefined);
    }
    match(expression) {
        return !expression || this.contextKeyService.match(expression);
    }
};
exports.ScmContextKeyService = ScmContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ScmContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmContextKeyService.prototype, "init", null);
exports.ScmContextKeyService = ScmContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-contribution.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-contribution.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmContribution = exports.ScmColors = exports.SCM_COMMANDS = exports.ScmMenus = exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS = exports.SCM_VIEW_CONTAINER_ID = exports.SCM_WIDGET_FACTORY_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_widget_1 = __webpack_require__(/*! ../browser/scm-widget */ "../node_modules/@theia/scm/lib/browser/scm-widget.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const scm_quick_open_service_1 = __webpack_require__(/*! ./scm-quick-open-service */ "../node_modules/@theia/scm/lib/browser/scm-quick-open-service.js");
const color_1 = __webpack_require__(/*! @theia/core/lib/common/color */ "../node_modules/@theia/core/lib/common/color.js");
const scm_colors_1 = __webpack_require__(/*! ./scm-colors */ "../node_modules/@theia/scm/lib/browser/scm-colors.js");
Object.defineProperty(exports, "ScmColors", ({ enumerable: true, get: function () { return scm_colors_1.ScmColors; } }));
const scm_decorations_service_1 = __webpack_require__(/*! ../browser/decorations/scm-decorations-service */ "../node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const theme_1 = __webpack_require__(/*! @theia/core/lib/common/theme */ "../node_modules/@theia/core/lib/common/theme.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const dirty_diff_navigator_1 = __webpack_require__(/*! ./dirty-diff/dirty-diff-navigator */ "../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
exports.SCM_WIDGET_FACTORY_ID = scm_widget_1.ScmWidget.ID;
exports.SCM_VIEW_CONTAINER_ID = 'scm-view-container';
exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS = {
    label: nls_1.nls.localizeByDefault('Source Control'),
    iconClass: (0, browser_1.codicon)('source-control'),
    closeable: true
};
var ScmMenus;
(function (ScmMenus) {
    ScmMenus.CHANGES_GROUP = [...browser_2.EditorMainMenu.GO, '6_changes_group'];
})(ScmMenus || (exports.ScmMenus = ScmMenus = {}));
var SCM_COMMANDS;
(function (SCM_COMMANDS) {
    SCM_COMMANDS.CHANGE_REPOSITORY = {
        id: 'scm.change.repository',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        label: nls_1.nls.localize('theia/scm/changeRepository', 'Change Repository...'),
        originalLabel: 'Change Repository...'
    };
    SCM_COMMANDS.ACCEPT_INPUT = {
        id: 'scm.acceptInput'
    };
    SCM_COMMANDS.TREE_VIEW_MODE = {
        id: 'scm.viewmode.tree',
        tooltip: nls_1.nls.localizeByDefault('View as Tree'),
        iconClass: (0, browser_1.codicon)('list-tree'),
        originalLabel: 'View as Tree',
        label: nls_1.nls.localizeByDefault('View as Tree')
    };
    SCM_COMMANDS.LIST_VIEW_MODE = {
        id: 'scm.viewmode.list',
        tooltip: nls_1.nls.localizeByDefault('View as List'),
        iconClass: (0, browser_1.codicon)('list-flat'),
        originalLabel: 'View as List',
        label: nls_1.nls.localizeByDefault('View as List')
    };
    SCM_COMMANDS.COLLAPSE_ALL = {
        id: 'scm.collapseAll',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        tooltip: nls_1.nls.localizeByDefault('Collapse All'),
        iconClass: (0, browser_1.codicon)('collapse-all'),
        label: nls_1.nls.localizeByDefault('Collapse All'),
        originalLabel: 'Collapse All'
    };
    SCM_COMMANDS.GOTO_NEXT_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.editor.nextChange',
        category: 'Source Control',
        label: 'Go to Next Change',
        iconClass: (0, browser_1.codicon)('arrow-down')
    });
    SCM_COMMANDS.GOTO_PREVIOUS_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.editor.previousChange',
        category: 'Source Control',
        label: 'Go to Previous Change',
        iconClass: (0, browser_1.codicon)('arrow-up')
    });
    SCM_COMMANDS.SHOW_NEXT_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.action.dirtydiff.next',
        category: 'Source Control',
        label: 'Show Next Change'
    });
    SCM_COMMANDS.SHOW_PREVIOUS_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.action.dirtydiff.previous',
        category: 'Source Control',
        label: 'Show Previous Change'
    });
    SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW = {
        id: 'editor.action.dirtydiff.close',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        label: nls_1.nls.localize('theia/scm/dirtyDiff/close', 'Close Change Peek View'),
        originalLabel: 'Close Change Peek View'
    };
})(SCM_COMMANDS || (exports.SCM_COMMANDS = SCM_COMMANDS = {}));
let ScmContribution = class ScmContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            viewContainerId: exports.SCM_VIEW_CONTAINER_ID,
            widgetId: exports.SCM_WIDGET_FACTORY_ID,
            widgetName: exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS.label,
            defaultWidgetOptions: {
                area: 'left',
                rank: 300
            },
            toggleCommandId: 'scmView:toggle',
            toggleKeybinding: 'ctrlcmd+shift+g'
        });
        this.statusBarDisposable = new common_1.DisposableCollection();
    }
    init() {
        this.scmFocus = this.contextKeys.createKey('scmFocus', false);
    }
    async initializeLayout() {
        await this.openView();
    }
    onStart() {
        this.updateStatusBar();
        this.scmService.onDidAddRepository(() => this.updateStatusBar());
        this.scmService.onDidRemoveRepository(() => this.updateStatusBar());
        this.scmService.onDidChangeSelectedRepository(() => this.updateStatusBar());
        this.scmService.onDidChangeStatusBarCommands(() => this.updateStatusBar());
        this.labelProvider.onDidChange(() => this.updateStatusBar());
        this.updateContextKeys();
        this.shell.onDidChangeCurrentWidget(() => this.updateContextKeys());
        this.scmDecorationsService.onDirtyDiffUpdate(update => this.dirtyDiffNavigator.handleDirtyDiffUpdate(update));
    }
    updateContextKeys() {
        this.scmFocus.set(this.shell.currentWidget instanceof scm_widget_1.ScmWidget);
    }
    registerCommands(commandRegistry) {
        super.registerCommands(commandRegistry);
        commandRegistry.registerCommand(SCM_COMMANDS.CHANGE_REPOSITORY, {
            execute: () => this.scmQuickOpenService.changeRepository(),
            isEnabled: () => this.scmService.repositories.length > 1
        });
        commandRegistry.registerCommand(SCM_COMMANDS.ACCEPT_INPUT, {
            execute: () => this.acceptInput(),
            isEnabled: () => !!this.scmFocus.get() && !!this.acceptInputCommand()
        });
        // Note that commands for dirty diff navigation need to be always available.
        // This is consistent with behavior in VS Code, and also with other similar commands (such as `Next Problem/Previous Problem`) in Theia.
        // See https://github.com/eclipse-theia/theia/pull/13104#discussion_r1497316614 for a detailed discussion.
        commandRegistry.registerCommand(SCM_COMMANDS.GOTO_NEXT_CHANGE, {
            execute: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    widget.editor.diffNavigator.next();
                }
                else {
                    this.dirtyDiffNavigator.gotoNextChange();
                }
            },
            isEnabled: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    return widget.editor.diffNavigator.hasNext();
                }
                return true;
            }
        });
        commandRegistry.registerCommand(SCM_COMMANDS.GOTO_PREVIOUS_CHANGE, {
            execute: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    widget.editor.diffNavigator.previous();
                }
                else {
                    this.dirtyDiffNavigator.gotoPreviousChange();
                }
            },
            isEnabled: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    return widget.editor.diffNavigator.hasPrevious();
                }
                return true;
            }
        });
        commandRegistry.registerCommand(SCM_COMMANDS.SHOW_NEXT_CHANGE, {
            execute: () => this.dirtyDiffNavigator.showNextChange()
        });
        commandRegistry.registerCommand(SCM_COMMANDS.SHOW_PREVIOUS_CHANGE, {
            execute: () => this.dirtyDiffNavigator.showPreviousChange()
        });
        commandRegistry.registerCommand(SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW, {
            execute: () => this.dirtyDiffNavigator.closeChangePeekView()
        });
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        menus.registerMenuAction(ScmMenus.CHANGES_GROUP, {
            commandId: SCM_COMMANDS.SHOW_NEXT_CHANGE.id,
            label: nls_1.nls.localizeByDefault('Next Change'),
            order: '1'
        });
        menus.registerMenuAction(ScmMenus.CHANGES_GROUP, {
            commandId: SCM_COMMANDS.SHOW_PREVIOUS_CHANGE.id,
            label: nls_1.nls.localizeByDefault('Previous Change'),
            order: '2'
        });
    }
    registerToolbarItems(registry) {
        const viewModeEmitter = new event_1.Emitter();
        const registerToggleViewItem = (command, mode) => {
            const id = command.id;
            const item = {
                id,
                command: id,
                tooltip: command.label,
                onDidChange: viewModeEmitter.event
            };
            this.commandRegistry.registerCommand({ id, iconClass: command && command.iconClass }, {
                execute: widget => {
                    if (widget instanceof scm_widget_1.ScmWidget) {
                        widget.viewMode = mode;
                        viewModeEmitter.fire();
                    }
                },
                isVisible: widget => {
                    if (widget instanceof scm_widget_1.ScmWidget) {
                        return !!this.scmService.selectedRepository
                            && widget.viewMode !== mode;
                    }
                    return false;
                },
            });
            registry.registerItem(item);
        };
        registerToggleViewItem(SCM_COMMANDS.TREE_VIEW_MODE, 'tree');
        registerToggleViewItem(SCM_COMMANDS.LIST_VIEW_MODE, 'list');
        this.commandRegistry.registerCommand(SCM_COMMANDS.COLLAPSE_ALL, {
            execute: widget => {
                if (widget instanceof scm_widget_1.ScmWidget && widget.viewMode === 'tree') {
                    widget.collapseScmTree();
                }
            },
            isVisible: widget => {
                if (widget instanceof scm_widget_1.ScmWidget) {
                    return !!this.scmService.selectedRepository && widget.viewMode === 'tree';
                }
                return false;
            }
        });
        registry.registerItem({
            id: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            command: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            isVisible: widget => widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor,
        });
        registry.registerItem({
            id: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            command: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            isVisible: widget => widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor,
        });
        registry.registerItem({
            ...SCM_COMMANDS.COLLAPSE_ALL,
            command: SCM_COMMANDS.COLLAPSE_ALL.id
        });
    }
    registerKeybindings(keybindings) {
        super.registerKeybindings(keybindings);
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.ACCEPT_INPUT.id,
            keybinding: 'ctrlcmd+enter',
            when: 'scmFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            keybinding: 'alt+f5',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            keybinding: 'shift+alt+f5',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.SHOW_NEXT_CHANGE.id,
            keybinding: 'alt+f3',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.SHOW_PREVIOUS_CHANGE.id,
            keybinding: 'shift+alt+f3',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW.id,
            keybinding: 'esc',
            when: 'dirtyDiffVisible'
        });
    }
    async acceptInput() {
        const command = this.acceptInputCommand();
        if (command && command.command) {
            await this.commands.executeCommand(command.command, ...command.arguments ? command.arguments : []);
        }
    }
    acceptInputCommand() {
        const repository = this.scmService.selectedRepository;
        if (!repository) {
            return undefined;
        }
        return repository.provider.acceptInputCommand;
    }
    updateStatusBar() {
        this.statusBarDisposable.dispose();
        const repository = this.scmService.selectedRepository;
        if (!repository) {
            return;
        }
        const name = this.labelProvider.getName(new uri_1.default(repository.provider.rootUri));
        if (this.scmService.repositories.length > 1) {
            this.setStatusBarEntry(SCM_COMMANDS.CHANGE_REPOSITORY.id, {
                text: `$(database) ${name}`,
                tooltip: name.toString(),
                command: SCM_COMMANDS.CHANGE_REPOSITORY.id,
                alignment: browser_1.StatusBarAlignment.LEFT,
                priority: 100
            });
        }
        const label = repository.provider.rootUri ? `${name} (${repository.provider.label})` : repository.provider.label;
        this.scmService.statusBarCommands.forEach((value, index) => this.setStatusBarEntry(`scm.status.${index}`, {
            text: value.title,
            tooltip: label + (value.tooltip ? ` - ${value.tooltip}` : ''),
            command: value.command,
            arguments: value.arguments,
            alignment: browser_1.StatusBarAlignment.LEFT,
            priority: 100
        }));
    }
    setStatusBarEntry(id, entry) {
        this.statusBar.setElement(id, entry);
        this.statusBarDisposable.push(common_1.Disposable.create(() => this.statusBar.removeElement(id)));
    }
    /**
     * It should be aligned with https://github.com/microsoft/vscode/blob/0dfa355b3ad185a6289ba28a99c141ab9e72d2be/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.ts#L808
     */
    registerColors(colors) {
        colors.register({
            id: scm_colors_1.ScmColors.editorGutterModifiedBackground, defaults: {
                dark: '#1B81A8',
                light: '#2090D3',
                hcDark: '#1B81A8',
                hcLight: '#2090D3'
            }, description: 'Editor gutter background color for lines that are modified.'
        }, {
            id: scm_colors_1.ScmColors.editorGutterAddedBackground, defaults: {
                dark: '#487E02',
                light: '#48985D',
                hcDark: '#487E02',
                hcLight: '#48985D'
            }, description: 'Editor gutter background color for lines that are added.'
        }, {
            id: scm_colors_1.ScmColors.editorGutterDeletedBackground, defaults: {
                dark: 'editorError.foreground',
                light: 'editorError.foreground',
                hcDark: 'editorError.foreground',
                hcLight: 'editorError.foreground'
            }, description: 'Editor gutter background color for lines that are deleted.'
        }, {
            id: 'minimapGutter.modifiedBackground', defaults: {
                dark: 'editorGutter.modifiedBackground',
                light: 'editorGutter.modifiedBackground',
                hcDark: 'editorGutter.modifiedBackground',
                hcLight: 'editorGutter.modifiedBackground'
            }, description: 'Minimap gutter background color for lines that are modified.'
        }, {
            id: 'minimapGutter.addedBackground', defaults: {
                dark: 'editorGutter.addedBackground',
                light: 'editorGutter.addedBackground',
                hcDark: 'editorGutter.modifiedBackground',
                hcLight: 'editorGutter.modifiedBackground'
            }, description: 'Minimap gutter background color for lines that are added.'
        }, {
            id: 'minimapGutter.deletedBackground', defaults: {
                dark: 'editorGutter.deletedBackground',
                light: 'editorGutter.deletedBackground',
                hcDark: 'editorGutter.deletedBackground',
                hcLight: 'editorGutter.deletedBackground'
            }, description: 'Minimap gutter background color for lines that are deleted.'
        }, {
            id: 'editorOverviewRuler.modifiedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6)
            }, description: 'Overview ruler marker color for modified content.'
        }, {
            id: 'editorOverviewRuler.addedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6)
            }, description: 'Overview ruler marker color for added content.'
        }, {
            id: 'editorOverviewRuler.deletedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6)
            }, description: 'Overview ruler marker color for deleted content.'
        });
    }
    registerThemeStyle(theme, collector) {
        const contrastBorder = theme.getColor('contrastBorder');
        if (contrastBorder && (0, theme_1.isHighContrast)(theme.type)) {
            collector.addRule(`
                .theia-scm-input-message-container textarea {
                    outline: var(--theia-border-width) solid ${contrastBorder};
                    outline-offset: -1px;
                }
            `);
        }
    }
};
exports.ScmContribution = ScmContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StatusBar),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "statusBar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmContribution.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_quick_open_service_1.ScmQuickOpenService),
    tslib_1.__metadata("design:type", scm_quick_open_service_1.ScmQuickOpenService)
], ScmContribution.prototype, "scmQuickOpenService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], ScmContribution.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], ScmContribution.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_decorations_service_1.ScmDecorationsService),
    tslib_1.__metadata("design:type", scm_decorations_service_1.ScmDecorationsService)
], ScmContribution.prototype, "scmDecorationsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dirty_diff_navigator_1.DirtyDiffNavigator),
    tslib_1.__metadata("design:type", dirty_diff_navigator_1.DirtyDiffNavigator)
], ScmContribution.prototype, "dirtyDiffNavigator", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmContribution.prototype, "init", null);
exports.ScmContribution = ScmContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmContribution);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-input.js":
/*!***********************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-input.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmInput = exports.ScmInputIssueType = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
var ScmInputIssueType;
(function (ScmInputIssueType) {
    ScmInputIssueType[ScmInputIssueType["Error"] = 0] = "Error";
    ScmInputIssueType[ScmInputIssueType["Warning"] = 1] = "Warning";
    ScmInputIssueType[ScmInputIssueType["Information"] = 2] = "Information";
})(ScmInputIssueType || (exports.ScmInputIssueType = ScmInputIssueType = {}));
class ScmInput {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    constructor(options = {}) {
        var _a;
        this.options = options;
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.onDidFocusEmitter = new common_1.Emitter();
        this.onDidFocus = this.onDidFocusEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter, this.onDidFocusEmitter);
        this._placeholder = this.options.placeholder;
        this._visible = this.options.visible;
        this._enabled = (_a = this.options.enabled) !== null && _a !== void 0 ? _a : true;
        this.validate = debounce(async () => {
            if (this.options.validator) {
                this.issue = await this.options.validator(this.value);
            }
        }, 200);
    }
    dispose() {
        this.toDispose.dispose();
    }
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(placeholder) {
        if (this._placeholder === placeholder) {
            return;
        }
        this._placeholder = placeholder;
        this.fireDidChange();
    }
    get value() {
        return this._value || '';
    }
    set value(value) {
        if (this.value === value) {
            return;
        }
        this._value = value;
        this.fireDidChange();
        this.validate();
    }
    get visible() {
        var _a;
        return (_a = this._visible) !== null && _a !== void 0 ? _a : true;
    }
    set visible(visible) {
        if (this.visible === visible) {
            return;
        }
        this._visible = visible;
        this.fireDidChange();
        this.validate();
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(enabled) {
        if (this._enabled === enabled) {
            return;
        }
        this._enabled = enabled;
        this.fireDidChange();
        this.validate();
    }
    get issue() {
        return this._issue;
    }
    set issue(issue) {
        if (coreutils_1.JSONExt.deepEqual((this._issue || {}), (issue || {}))) {
            return;
        }
        this._issue = issue;
        this.fireDidChange();
    }
    focus() {
        this.onDidFocusEmitter.fire(undefined);
    }
    toJSON() {
        return {
            value: this._value,
            issue: this._issue
        };
    }
    fromJSON(data) {
        if (this._value !== undefined) {
            return;
        }
        if ('value' in data) {
            this._value = data.value;
            this._issue = data.issue;
            this.fireDidChange();
        }
    }
}
exports.ScmInput = ScmInput;


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmNoRepositoryWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmNoRepositoryWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const alert_message_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/alert-message */ "../node_modules/@theia/core/lib/browser/widgets/alert-message.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let ScmNoRepositoryWidget = ScmNoRepositoryWidget_1 = class ScmNoRepositoryWidget extends browser_1.ReactWidget {
    constructor() {
        super();
        this.addClass('theia-scm-no-repository');
        this.id = ScmNoRepositoryWidget_1.ID;
    }
    render() {
        return React.createElement(alert_message_1.AlertMessage, { type: 'WARNING', header: nls_1.nls.localize('theia/scm/noRepositoryFound', 'No repository found') });
    }
};
exports.ScmNoRepositoryWidget = ScmNoRepositoryWidget;
ScmNoRepositoryWidget.ID = 'scm-no-repository-widget';
exports.ScmNoRepositoryWidget = ScmNoRepositoryWidget = ScmNoRepositoryWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmNoRepositoryWidget);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-preferences.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-preferences.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindScmPreferences = exports.createScmPreferences = exports.ScmPreferences = exports.ScmPreferenceContribution = exports.scmPreferenceSchema = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
exports.scmPreferenceSchema = {
    type: 'object',
    properties: {
        'scm.defaultViewMode': {
            type: 'string',
            enum: ['tree', 'list'],
            enumDescriptions: [
                nls_1.nls.localizeByDefault('Show the repository changes as a tree.'),
                nls_1.nls.localizeByDefault('Show the repository changes as a list.')
            ],
            description: nls_1.nls.localizeByDefault('Controls the default Source Control repository view mode.'),
            default: 'list'
        }
    }
};
exports.ScmPreferenceContribution = Symbol('ScmPreferenceContribution');
exports.ScmPreferences = Symbol('ScmPreferences');
function createScmPreferences(preferences, schema = exports.scmPreferenceSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createScmPreferences = createScmPreferences;
function bindScmPreferences(bind) {
    bind(exports.ScmPreferences).toDynamicValue((ctx) => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.ScmPreferenceContribution);
        return createScmPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.ScmPreferenceContribution).toConstantValue({ schema: exports.scmPreferenceSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.ScmPreferenceContribution);
}
exports.bindScmPreferences = bindScmPreferences;


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-quick-open-service.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-quick-open-service.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmQuickOpenService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../node_modules/@theia/core/lib/common/message-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../node_modules/@theia/core/lib/browser/label-provider.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
let ScmQuickOpenService = class ScmQuickOpenService {
    async changeRepository() {
        var _a;
        const repositories = this.scmService.repositories;
        if (repositories.length > 1) {
            const items = await Promise.all(repositories.map(async (repository) => {
                const uri = new uri_1.default(repository.provider.rootUri);
                return {
                    label: this.labelProvider.getName(uri),
                    description: this.labelProvider.getLongName(uri),
                    execute: () => {
                        this.scmService.selectedRepository = repository;
                    }
                };
            }));
            (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(items, { placeholder: 'Select repository to work with:' });
        }
    }
};
exports.ScmQuickOpenService = ScmQuickOpenService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], ScmQuickOpenService.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(message_service_1.MessageService),
    tslib_1.__metadata("design:type", message_service_1.MessageService)
], ScmQuickOpenService.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], ScmQuickOpenService.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmQuickOpenService.prototype, "scmService", void 0);
exports.ScmQuickOpenService = ScmQuickOpenService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmQuickOpenService);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-repository.js":
/*!****************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-repository.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmRepository = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const scm_input_1 = __webpack_require__(/*! ./scm-input */ "../node_modules/@theia/scm/lib/browser/scm-input.js");
class ScmRepository {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    constructor(provider, options = {}) {
        this.provider = provider;
        this.options = options;
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter);
        this.toDispose.pushAll([
            this.provider,
            this.input = new scm_input_1.ScmInput(options.input),
            this.input.onDidChange(() => this.fireDidChange())
        ]);
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.ScmRepository = ScmRepository;


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-service.js":
/*!*************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-service.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "../node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
const scm_repository_1 = __webpack_require__(/*! ./scm-repository */ "../node_modules/@theia/scm/lib/browser/scm-repository.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
let ScmService = class ScmService {
    constructor() {
        this._repositories = new Map();
        this.onDidChangeSelectedRepositoryEmitter = new common_1.Emitter();
        this.onDidChangeSelectedRepository = this.onDidChangeSelectedRepositoryEmitter.event;
        this.onDidAddRepositoryEmitter = new common_1.Emitter();
        this.onDidAddRepository = this.onDidAddRepositoryEmitter.event;
        this.onDidRemoveRepositoryEmitter = new common_1.Emitter();
        this.onDidRemoveRepository = this.onDidAddRepositoryEmitter.event;
        this.onDidChangeStatusBarCommandsEmitter = new common_1.Emitter();
        this.onDidChangeStatusBarCommands = this.onDidChangeStatusBarCommandsEmitter.event;
        this.toDisposeOnSelected = new common_1.DisposableCollection();
    }
    fireDidChangeStatusBarCommands() {
        this.onDidChangeStatusBarCommandsEmitter.fire(this.statusBarCommands);
    }
    get statusBarCommands() {
        const repository = this.selectedRepository;
        return repository && repository.provider.statusBarCommands || [];
    }
    get repositories() {
        return [...this._repositories.values()];
    }
    get selectedRepository() {
        return this._selectedRepository;
    }
    set selectedRepository(repository) {
        if (this._selectedRepository === repository) {
            return;
        }
        this.toDisposeOnSelected.dispose();
        this._selectedRepository = repository;
        if (this._selectedRepository) {
            if (this._selectedRepository.provider.onDidChangeStatusBarCommands) {
                this.toDisposeOnSelected.push(this._selectedRepository.provider.onDidChangeStatusBarCommands(() => this.fireDidChangeStatusBarCommands()));
            }
        }
        this.onDidChangeSelectedRepositoryEmitter.fire(this._selectedRepository);
        this.fireDidChangeStatusBarCommands();
    }
    findRepository(uri) {
        const reposSorted = this.repositories.sort((ra, rb) => rb.provider.rootUri.length - ra.provider.rootUri.length);
        return reposSorted.find(repo => new uri_1.default(repo.provider.rootUri).isEqualOrParent(uri));
    }
    registerScmProvider(provider, options = {}) {
        const key = provider.id + ':' + provider.rootUri;
        if (this._repositories.has(key)) {
            throw new Error(`${provider.label} provider for '${provider.rootUri}' already exists.`);
        }
        const repository = new scm_repository_1.ScmRepository(provider, options);
        const dispose = repository.dispose;
        repository.dispose = () => {
            this._repositories.delete(key);
            dispose.bind(repository)();
            this.onDidRemoveRepositoryEmitter.fire(repository);
            if (this._selectedRepository === repository) {
                this.selectedRepository = this._repositories.values().next().value;
            }
        };
        this._repositories.set(key, repository);
        this.onDidAddRepositoryEmitter.fire(repository);
        if (this._repositories.size === 1) {
            this.selectedRepository = repository;
        }
        return repository;
    }
};
exports.ScmService = ScmService;
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmService.prototype, "contextKeys", void 0);
exports.ScmService = ScmService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmService);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-tree-model.js":
/*!****************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-tree-model.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmTreeModel = exports.ScmFileChangeNode = exports.ScmFileChangeFolderNode = exports.ScmFileChangeGroupNode = exports.ScmTreeModelProps = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "../node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
exports.ScmTreeModelProps = Symbol('ScmTreeModelProps');
var ScmFileChangeGroupNode;
(function (ScmFileChangeGroupNode) {
    function is(node) {
        return 'groupId' in node && 'children' in node
            && !ScmFileChangeFolderNode.is(node);
    }
    ScmFileChangeGroupNode.is = is;
})(ScmFileChangeGroupNode || (exports.ScmFileChangeGroupNode = ScmFileChangeGroupNode = {}));
var ScmFileChangeFolderNode;
(function (ScmFileChangeFolderNode) {
    function is(node) {
        return 'groupId' in node && 'sourceUri' in node && 'path' in node && 'children' in node;
    }
    ScmFileChangeFolderNode.is = is;
})(ScmFileChangeFolderNode || (exports.ScmFileChangeFolderNode = ScmFileChangeFolderNode = {}));
var ScmFileChangeNode;
(function (ScmFileChangeNode) {
    function is(node) {
        return 'sourceUri' in node
            && !ScmFileChangeFolderNode.is(node);
    }
    ScmFileChangeNode.is = is;
    function getGroupId(node) {
        const parentNode = node.parent;
        if (!(parentNode && (ScmFileChangeFolderNode.is(parentNode) || ScmFileChangeGroupNode.is(parentNode)))) {
            throw new Error('bad node');
        }
        return parentNode.groupId;
    }
    ScmFileChangeNode.getGroupId = getGroupId;
})(ScmFileChangeNode || (exports.ScmFileChangeNode = ScmFileChangeNode = {}));
let ScmTreeModel = class ScmTreeModel extends tree_1.TreeModelImpl {
    constructor() {
        super(...arguments);
        this._viewMode = 'list';
        this.compareNodes = (a, b) => this.doCompareNodes(a, b);
    }
    get languageId() {
        return this._languageId;
    }
    set viewMode(id) {
        const oldSelection = this.selectedNodes;
        this._viewMode = id;
        if (this.root) {
            this.root = this.createTree();
            for (const oldSelectedNode of oldSelection) {
                const newNode = this.getNode(oldSelectedNode.id);
                if (tree_1.SelectableTreeNode.is(newNode)) {
                    this.revealNode(newNode); // this call can run asynchronously
                }
            }
        }
    }
    get viewMode() {
        return this._viewMode;
    }
    createTree() {
        const root = {
            id: 'file-change-tree-root',
            parent: undefined,
            visible: false,
            rootUri: this.rootUri,
            children: []
        };
        const groupNodes = this.groups
            .filter(group => !!group.resources.length || !group.hideWhenEmpty)
            .map(group => this.toGroupNode(group, root));
        root.children = groupNodes;
        return root;
    }
    toGroupNode(group, parent) {
        const groupNode = {
            id: `${group.id}`,
            groupId: group.id,
            groupLabel: group.label,
            parent,
            children: [],
            expanded: true,
        };
        const sortedResources = group.resources.sort((r1, r2) => r1.sourceUri.toString().localeCompare(r2.sourceUri.toString()));
        switch (this._viewMode) {
            case 'list':
                groupNode.children = sortedResources.map(resource => this.toFileChangeNode(resource, groupNode));
                break;
            case 'tree':
                const rootUri = group.provider.rootUri;
                if (rootUri) {
                    const resourcePaths = sortedResources.map(resource => {
                        const relativePath = new uri_1.default(rootUri).relative(resource.sourceUri);
                        const pathParts = relativePath ? relativePath.toString().split('/') : [];
                        return { resource, pathParts };
                    });
                    groupNode.children = this.buildFileChangeTree(resourcePaths, 0, sortedResources.length, 0, groupNode);
                }
                break;
        }
        return groupNode;
    }
    buildFileChangeTree(sortedResources, start, end, level, parent) {
        const result = [];
        let folderStart = start;
        while (folderStart < end) {
            const firstFileChange = sortedResources[folderStart];
            if (level === firstFileChange.pathParts.length - 1) {
                result.push(this.toFileChangeNode(firstFileChange.resource, parent));
                folderStart++;
            }
            else {
                let index = folderStart + 1;
                while (index < end) {
                    if (sortedResources[index].pathParts[level] !== firstFileChange.pathParts[level]) {
                        break;
                    }
                    index++;
                }
                const folderEnd = index;
                const nestingThreshold = this.props.nestingThreshold || 1;
                if (folderEnd - folderStart < nestingThreshold) {
                    // Inline these (i.e. do not create another level in the tree)
                    for (let i = folderStart; i < folderEnd; i++) {
                        result.push(this.toFileChangeNode(sortedResources[i].resource, parent));
                    }
                }
                else {
                    const firstFileParts = firstFileChange.pathParts;
                    const lastFileParts = sortedResources[folderEnd - 1].pathParts;
                    // Multiple files with first folder.
                    // See if more folder levels match and include those if so.
                    let thisLevel = level + 1;
                    while (thisLevel < firstFileParts.length - 1 && thisLevel < lastFileParts.length - 1 && firstFileParts[thisLevel] === lastFileParts[thisLevel]) {
                        thisLevel++;
                    }
                    const nodeRelativePath = firstFileParts.slice(level, thisLevel).join('/');
                    result.push(this.toFileChangeFolderNode(sortedResources, folderStart, folderEnd, thisLevel, nodeRelativePath, parent));
                }
                folderStart = folderEnd;
            }
        }
        ;
        return result.sort(this.compareNodes);
    }
    doCompareNodes(a, b) {
        const isFolderA = ScmFileChangeFolderNode.is(a);
        const isFolderB = ScmFileChangeFolderNode.is(b);
        if (isFolderA && !isFolderB) {
            return -1;
        }
        if (isFolderB && !isFolderA) {
            return 1;
        }
        return a.sourceUri.localeCompare(b.sourceUri);
    }
    toFileChangeFolderNode(resources, start, end, level, nodeRelativePath, parent) {
        const rootUri = this.getRoot(parent).rootUri;
        let parentPath = rootUri;
        if (ScmFileChangeFolderNode.is(parent)) {
            parentPath = parent.sourceUri;
        }
        const sourceUri = new uri_1.default(parentPath).resolve(nodeRelativePath);
        const defaultExpansion = this.props.defaultExpansion ? (this.props.defaultExpansion === 'expanded') : true;
        const id = `${parent.groupId}:${String(sourceUri)}`;
        const oldNode = this.getNode(id);
        const folderNode = {
            id,
            groupId: parent.groupId,
            path: nodeRelativePath,
            sourceUri: String(sourceUri),
            children: [],
            parent,
            expanded: tree_1.ExpandableTreeNode.is(oldNode) ? oldNode.expanded : defaultExpansion,
            selected: tree_1.SelectableTreeNode.is(oldNode) && oldNode.selected,
        };
        folderNode.children = this.buildFileChangeTree(resources, start, end, level, folderNode);
        return folderNode;
    }
    getRoot(node) {
        let parent = node.parent;
        while (ScmFileChangeGroupNode.is(parent) && ScmFileChangeFolderNode.is(parent)) {
            parent = parent.parent;
        }
        return parent;
    }
    toFileChangeNode(resource, parent) {
        const id = `${resource.group.id}:${String(resource.sourceUri)}`;
        const oldNode = this.getNode(id);
        const node = {
            id,
            sourceUri: String(resource.sourceUri),
            decorations: resource.decorations,
            parent,
            selected: tree_1.SelectableTreeNode.is(oldNode) && oldNode.selected,
        };
        if (node.selected) {
            this.selectionService.addSelection(node);
        }
        return node;
    }
    async revealNode(node) {
        if (ScmFileChangeFolderNode.is(node) || ScmFileChangeNode.is(node)) {
            const parentNode = node.parent;
            if (tree_1.ExpandableTreeNode.is(parentNode)) {
                await this.revealNode(parentNode);
                if (!parentNode.expanded) {
                    await this.expandNode(parentNode);
                }
            }
        }
    }
    getResourceFromNode(node) {
        const groupId = ScmFileChangeNode.getGroupId(node);
        const group = this.findGroup(groupId);
        if (group) {
            return group.resources.find(r => String(r.sourceUri) === node.sourceUri);
        }
    }
    getResourceGroupFromNode(node) {
        return this.findGroup(node.groupId);
    }
    getResourcesFromFolderNode(node) {
        const resources = [];
        const group = this.findGroup(node.groupId);
        if (group) {
            this.collectResources(resources, node, group);
        }
        return resources;
    }
    getSelectionArgs(selectedNodes) {
        const resources = [];
        for (const node of selectedNodes) {
            if (ScmFileChangeNode.is(node)) {
                const groupId = ScmFileChangeNode.getGroupId(node);
                const group = this.findGroup(groupId);
                if (group) {
                    const selectedResource = group.resources.find(r => String(r.sourceUri) === node.sourceUri);
                    if (selectedResource) {
                        resources.push(selectedResource);
                    }
                }
            }
            if (ScmFileChangeFolderNode.is(node)) {
                const group = this.findGroup(node.groupId);
                if (group) {
                    this.collectResources(resources, node, group);
                }
            }
        }
        // Remove duplicates which may occur if user selected folder and nested folder
        return resources.filter((item1, index) => resources.findIndex(item2 => item1.sourceUri === item2.sourceUri) === index);
    }
    collectResources(resources, node, group) {
        if (ScmFileChangeFolderNode.is(node)) {
            for (const child of node.children) {
                this.collectResources(resources, child, group);
            }
        }
        else if (ScmFileChangeNode.is(node)) {
            const resource = group.resources.find(r => String(r.sourceUri) === node.sourceUri);
            resources.push(resource);
        }
    }
    execInNodeContext(node, callback) {
        if (!this.provider) {
            return;
        }
        let groupId;
        if (ScmFileChangeGroupNode.is(node) || ScmFileChangeFolderNode.is(node)) {
            groupId = node.groupId;
        }
        else if (ScmFileChangeNode.is(node)) {
            groupId = ScmFileChangeNode.getGroupId(node);
        }
        else {
            return;
        }
        this.contextKeys.scmProvider.set(this.provider.id);
        this.contextKeys.scmResourceGroup.set(groupId);
        try {
            callback();
        }
        finally {
        }
    }
    /*
     * Normally the group would always be expected to be found.  However if the tree is restored
     * in restoreState then the tree may be rendered before the groups have been created
     * in the provider.  The provider's groups property will be empty in such a situation.
     * We want to render the tree (as that is the point of restoreState, we can render
     * the tree in the saved state before the provider has provided status).  We therefore must
     * be prepared to render the tree without having the ScmResourceGroup or ScmResource
     * objects.
     */
    findGroup(groupId) {
        return this.groups.find(g => g.id === groupId);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    storeState() {
        return {
            ...super.storeState(),
            mode: this.viewMode,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    restoreState(oldState) {
        super.restoreState(oldState);
        this.viewMode = oldState.mode === 'tree' ? 'tree' : 'list';
    }
};
exports.ScmTreeModel = ScmTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(tree_1.TreeProps),
    tslib_1.__metadata("design:type", Object)
], ScmTreeModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmTreeModel.prototype, "contextKeys", void 0);
exports.ScmTreeModel = ScmTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmTreeModel);


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-tree-widget.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-tree-widget.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmInlineAction = exports.ScmInlineActions = exports.ScmResourceFolderElement = exports.ScmResourceGroupElement = exports.ScmResourceComponent = exports.ScmElement = exports.ScmTreeWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable no-null/no-null, @typescript-eslint/no-explicit-any */
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "../node_modules/@theia/core/lib/common/os.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const scm_tree_model_1 = __webpack_require__(/*! ./scm-tree-model */ "../node_modules/@theia/scm/lib/browser/scm-tree-model.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../node_modules/@theia/core/lib/common/menu/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "../node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "../node_modules/@theia/core/lib/browser/icon-theme-service.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const decorations_service_1 = __webpack_require__(/*! @theia/core/lib/browser/decorations-service */ "../node_modules/@theia/core/lib/browser/decorations-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../node_modules/@theia/filesystem/lib/common/files.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
let ScmTreeWidget = ScmTreeWidget_1 = class ScmTreeWidget extends tree_1.TreeWidget {
    constructor(props, treeModel, contextMenuRenderer) {
        super(props, treeModel, contextMenuRenderer);
        this.id = ScmTreeWidget_1.ID;
        this.addClass('groups-outer-container');
    }
    init() {
        super.init();
        this.toDispose.push(this.themeService.onDidColorThemeChange(() => this.update()));
    }
    set viewMode(id) {
        // Close the search box because the structure of the tree will change dramatically
        // and the search results will be out of date.
        this.searchBox.hide();
        this.model.viewMode = id;
    }
    get viewMode() {
        return this.model.viewMode;
    }
    /**
     * Render the node given the tree node and node properties.
     * @param node the tree node.
     * @param props the node properties.
     */
    renderNode(node, props) {
        var _a;
        if (!tree_1.TreeNode.isVisible(node)) {
            return undefined;
        }
        const attributes = this.createNodeAttributes(node, props);
        const label = this.labelProvider.getName(node);
        const searchHighlights = (_a = this.searchHighlights) === null || _a === void 0 ? void 0 : _a.get(node.id);
        // The group nodes should not be subject to highlighting.
        const caption = (searchHighlights && !scm_tree_model_1.ScmFileChangeGroupNode.is(node)) ? this.toReactNode(label, searchHighlights) : label;
        if (scm_tree_model_1.ScmFileChangeGroupNode.is(node)) {
            const content = React.createElement(ScmResourceGroupElement, { key: `${node.groupId}`, model: this.model, treeNode: node, renderExpansionToggle: () => this.renderExpansionToggle(node, props), commandExecutor: this.menuCommandExecutor, contextMenuRenderer: this.contextMenuRenderer, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption });
            return React.createElement('div', attributes, content);
        }
        if (scm_tree_model_1.ScmFileChangeFolderNode.is(node)) {
            const content = React.createElement(ScmResourceFolderElement, { key: String(node.sourceUri), model: this.model, treeNode: node, sourceUri: node.sourceUri, renderExpansionToggle: () => this.renderExpansionToggle(node, props), commandExecutor: this.menuCommandExecutor, contextMenuRenderer: this.contextMenuRenderer, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption });
            return React.createElement('div', attributes, content);
        }
        if (scm_tree_model_1.ScmFileChangeNode.is(node)) {
            const parentPath = (node.parent && scm_tree_model_1.ScmFileChangeFolderNode.is(node.parent))
                ? new uri_1.default(node.parent.sourceUri) : new uri_1.default(this.model.rootUri);
            const content = React.createElement(ScmResourceComponent, { key: node.sourceUri, model: this.model, treeNode: node, contextMenuRenderer: this.contextMenuRenderer, commandExecutor: this.menuCommandExecutor, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption, ...this.props,
                parentPath,
                sourceUri: node.sourceUri,
                decoration: this.decorationsService.getDecoration(new uri_1.default(node.sourceUri), true)[0],
                colors: this.colors,
                isLightTheme: this.isCurrentThemeLight(),
                renderExpansionToggle: () => this.renderExpansionToggle(node, props) });
            return React.createElement('div', attributes, content);
        }
        return super.renderNode(node, props);
    }
    createContainerAttributes() {
        if (this.model.canTabToWidget()) {
            return {
                ...super.createContainerAttributes(),
                tabIndex: 0
            };
        }
        return super.createContainerAttributes();
    }
    /**
     * The ARROW_LEFT key controls both the movement around the file tree and also
     * the movement through the change chunks within a file.
     *
     * If the selected tree node is a folder then the ARROW_LEFT key behaves exactly
     * as it does in explorer.  It collapses the tree node if the folder is expanded and
     * it moves the selection up to the parent folder if the folder is collapsed (no-op if no parent folder, as
     * group headers are not selectable).  This behavior is the default behavior implemented
     * in the TreeWidget super class.
     *
     * If the selected tree node is a file then the ARROW_LEFT key moves up through the
     * change chunks within each file.  If the selected chunk is the first chunk in the file
     * then the file selection is moved to the previous file (no-op if no previous file).
     *
     * Note that when cursoring through change chunks, the ARROW_LEFT key cannot be used to
     * move up through the parent folders of the file tree.  If users want to do this, using
     * keys only, then they must press ARROW_UP repeatedly until the selected node is the folder
     * node and then press ARROW_LEFT.
     */
    async handleLeft(event) {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return super.handleLeft(event);
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasPrevious()) {
                        diffNavigator.previous();
                    }
                    else {
                        const previousNode = this.moveToPreviousFileNode();
                        if (previousNode) {
                            const previousResource = this.model.getResourceFromNode(previousNode);
                            if (previousResource) {
                                this.openResource(previousResource);
                            }
                        }
                    }
                    return;
                }
            }
        }
        return super.handleLeft(event);
    }
    /**
     * The ARROW_RIGHT key controls both the movement around the file tree and also
     * the movement through the change chunks within a file.
     *
     * If the selected tree node is a folder then the ARROW_RIGHT key behaves exactly
     * as it does in explorer.  It expands the tree node if the folder is collapsed and
     * it moves the selection to the first child node if the folder is expanded.
     * This behavior is the default behavior implemented
     * in the TreeWidget super class.
     *
     * If the selected tree node is a file then the ARROW_RIGHT key moves down through the
     * change chunks within each file.  If the selected chunk is the last chunk in the file
     * then the file selection is moved to the next file (no-op if no next file).
     */
    async handleRight(event) {
        if (this.model.selectedNodes.length === 0) {
            const firstNode = this.getFirstSelectableNode();
            // Selects the first visible resource as none are selected.
            if (!firstNode) {
                return;
            }
            this.model.selectNode(firstNode);
            return;
        }
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return super.handleRight(event);
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasNext()) {
                        diffNavigator.next();
                    }
                    else {
                        const nextNode = this.moveToNextFileNode();
                        if (nextNode) {
                            const nextResource = this.model.getResourceFromNode(nextNode);
                            if (nextResource) {
                                this.openResource(nextResource);
                            }
                        }
                    }
                }
                return;
            }
        }
        return super.handleRight(event);
    }
    handleEnter(event) {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (selectedResource) {
                    this.openResource(selectedResource);
                }
                return;
            }
        }
        super.handleEnter(event);
    }
    async goToPreviousChange() {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                    const selectedResource = this.model.getResourceFromNode(selectedNode);
                    if (!selectedResource) {
                        return;
                    }
                    const widget = await this.openResource(selectedResource);
                    if (widget) {
                        const diffNavigator = this.diffNavigatorProvider(widget.editor);
                        if (diffNavigator.hasPrevious()) {
                            diffNavigator.previous();
                        }
                        else {
                            const previousNode = this.moveToPreviousFileNode();
                            if (previousNode) {
                                const previousResource = this.model.getResourceFromNode(previousNode);
                                if (previousResource) {
                                    this.openResource(previousResource);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    async goToNextChange() {
        if (this.model.selectedNodes.length === 0) {
            const firstNode = this.getFirstSelectableNode();
            // Selects the first visible resource as none are selected.
            if (!firstNode) {
                return;
            }
            this.model.selectNode(firstNode);
            return;
        }
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return;
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasNext()) {
                        diffNavigator.next();
                    }
                    else {
                        const nextNode = this.moveToNextFileNode();
                        if (nextNode) {
                            const nextResource = this.model.getResourceFromNode(nextNode);
                            if (nextResource) {
                                this.openResource(nextResource);
                            }
                        }
                    }
                }
            }
        }
    }
    selectNodeByUri(uri) {
        for (const group of this.model.groups) {
            const sourceUri = new uri_1.default(uri.path.toString());
            const id = `${group.id}:${sourceUri.toString()}`;
            const node = this.model.getNode(id);
            if (tree_1.SelectableTreeNode.is(node)) {
                this.model.selectNode(node);
                return;
            }
        }
    }
    getFirstSelectableNode() {
        if (this.model.root) {
            const root = this.model.root;
            const groupNode = root.children[0];
            return groupNode.children[0];
        }
    }
    moveToPreviousFileNode() {
        let previousNode = this.model.getPrevSelectableNode();
        while (previousNode) {
            if (scm_tree_model_1.ScmFileChangeNode.is(previousNode)) {
                this.model.selectNode(previousNode);
                return previousNode;
            }
            previousNode = this.model.getPrevSelectableNode(previousNode);
        }
        ;
    }
    moveToNextFileNode() {
        let nextNode = this.model.getNextSelectableNode();
        while (nextNode) {
            if (scm_tree_model_1.ScmFileChangeNode.is(nextNode)) {
                this.model.selectNode(nextNode);
                return nextNode;
            }
            nextNode = this.model.getNextSelectableNode(nextNode);
        }
        ;
    }
    async openResource(resource) {
        try {
            await resource.open();
        }
        catch (e) {
            console.error('Failed to open a SCM resource', e);
            return undefined;
        }
        let standaloneEditor;
        const resourcePath = resource.sourceUri.path.toString();
        for (const widget of this.editorManager.all) {
            const resourceUri = widget.editor.document.uri;
            const editorResourcePath = new uri_1.default(resourceUri).path.toString();
            if (resourcePath === editorResourcePath) {
                if (widget.editor.uri.scheme === browser_1.DiffUris.DIFF_SCHEME) {
                    // prefer diff editor
                    return widget;
                }
                else {
                    standaloneEditor = widget;
                }
            }
            if (widget.editor.uri.scheme === browser_1.DiffUris.DIFF_SCHEME
                && resourceUri === resource.sourceUri.toString()) {
                return widget;
            }
        }
        // fallback to standalone editor
        return standaloneEditor;
    }
    getPaddingLeft(node, props) {
        if (this.viewMode === 'list') {
            if (props.depth === 1) {
                return this.props.expansionTogglePadding;
            }
        }
        return super.getPaddingLeft(node, props);
    }
    getDepthPadding(depth) {
        return super.getDepthPadding(depth) + 5;
    }
    isCurrentThemeLight() {
        const type = this.themeService.getCurrentTheme().type;
        return type.toLocaleLowerCase().includes('light');
    }
    needsExpansionTogglePadding(node) {
        const theme = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (theme && (theme.hidesExplorerArrows || (theme.hasFileIcons && !theme.hasFolderIcons))) {
            return false;
        }
        return super.needsExpansionTogglePadding(node);
    }
};
exports.ScmTreeWidget = ScmTreeWidget;
ScmTreeWidget.ID = 'scm-resource-widget';
ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU = ['RESOURCE_GROUP_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU = ['RESOURCE_GROUP_CONTEXT_MENU', 'inline'];
ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU = ['RESOURCE_FOLDER_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU = ['RESOURCE_FOLDER_CONTEXT_MENU', 'inline'];
ScmTreeWidget.RESOURCE_CONTEXT_MENU = ['RESOURCE_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_INLINE_MENU = ['RESOURCE_CONTEXT_MENU', 'inline'];
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuCommandExecutor),
    tslib_1.__metadata("design:type", Object)
], ScmTreeWidget.prototype, "menuCommandExecutor", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], ScmTreeWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], ScmTreeWidget.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.DiffNavigatorProvider),
    tslib_1.__metadata("design:type", Function)
], ScmTreeWidget.prototype, "diffNavigatorProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], ScmTreeWidget.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(decorations_service_1.DecorationsService),
    tslib_1.__metadata("design:type", Object)
], ScmTreeWidget.prototype, "decorationsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], ScmTreeWidget.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], ScmTreeWidget.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmTreeWidget.prototype, "init", null);
exports.ScmTreeWidget = ScmTreeWidget = ScmTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(tree_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, scm_tree_model_1.ScmTreeModel,
        browser_1.ContextMenuRenderer])
], ScmTreeWidget);
(function (ScmTreeWidget) {
    let Styles;
    (function (Styles) {
        Styles.NO_SELECT = 'no-select';
    })(Styles = ScmTreeWidget.Styles || (ScmTreeWidget.Styles = {}));
})(ScmTreeWidget || (exports.ScmTreeWidget = ScmTreeWidget = {}));
class ScmElement extends React.Component {
    constructor(props) {
        super(props);
        this.toDisposeOnUnmount = new disposable_1.DisposableCollection();
        this.detectHover = (element) => {
            if (element) {
                window.requestAnimationFrame(() => {
                    const hover = element.matches(':hover');
                    this.setState({ hover });
                });
            }
        };
        this.showHover = () => this.setState({ hover: true });
        this.hideHover = () => this.setState({ hover: false });
        this.renderContextMenu = (event) => {
            event.preventDefault();
            const { treeNode: node, contextMenuRenderer } = this.props;
            this.props.model.execInNodeContext(node, () => {
                contextMenuRenderer.render({
                    menuPath: this.contextMenuPath,
                    anchor: event.nativeEvent,
                    args: this.contextMenuArgs,
                    context: event.currentTarget
                });
            });
        };
        this.state = {
            hover: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            if (!this.toDisposeOnUnmount.disposed) {
                setState(newState);
            }
        };
    }
    componentDidMount() {
        this.toDisposeOnUnmount.push(disposable_1.Disposable.create(() => { }));
    }
    componentWillUnmount() {
        this.toDisposeOnUnmount.dispose();
    }
}
exports.ScmElement = ScmElement;
class ScmResourceComponent extends ScmElement {
    constructor() {
        super(...arguments);
        this.open = () => {
            const resource = this.props.model.getResourceFromNode(this.props.treeNode);
            if (resource) {
                resource.open();
            }
        };
        this.contextMenuPath = ScmTreeWidget.RESOURCE_CONTEXT_MENU;
        /**
         * Handle the single clicking of nodes present in the widget.
         */
        this.handleClick = (event) => {
            if (!this.hasCtrlCmdOrShiftMask(event)) {
                // Determine the behavior based on the preference value.
                const isSingle = this.props.corePreferences && this.props.corePreferences['workbench.list.openMode'] === 'singleClick';
                if (isSingle) {
                    this.open();
                }
            }
        };
        /**
         * Handle the double clicking of nodes present in the widget.
         */
        this.handleDoubleClick = () => {
            // Determine the behavior based on the preference value.
            const isDouble = this.props.corePreferences && this.props.corePreferences['workbench.list.openMode'] === 'doubleClick';
            // Nodes should only be opened through double clicking if the correct preference is set.
            if (isDouble) {
                this.open();
            }
        };
    }
    render() {
        var _a;
        const { hover } = this.state;
        const { model, treeNode, colors, parentPath, sourceUri, decoration, labelProvider, commandExecutor, menus, contextKeys, caption, isLightTheme } = this.props;
        const resourceUri = new uri_1.default(sourceUri);
        const decorationIcon = treeNode.decorations;
        const themedIcon = isLightTheme ? decorationIcon === null || decorationIcon === void 0 ? void 0 : decorationIcon.icon : decorationIcon === null || decorationIcon === void 0 ? void 0 : decorationIcon.iconDark;
        const classNames = themedIcon ? ['decoration-icon', themedIcon] : ['decoration-icon', 'status'];
        const icon = labelProvider.getIcon(resourceUri);
        const color = decoration && decoration.colorId && !themedIcon ? `var(${colors.toCssVariableName(decoration.colorId)})` : '';
        const letter = decoration && decoration.letter && !themedIcon ? decoration.letter : '';
        const tooltip = decoration && decoration.tooltip || '';
        const textDecoration = ((_a = treeNode.decorations) === null || _a === void 0 ? void 0 : _a.strikeThrough) === true ? 'line-through' : 'normal';
        const relativePath = parentPath.relative(resourceUri.parent);
        const path = relativePath ? relativePath.fsPath() : labelProvider.getLongName(resourceUri.parent);
        const title = tooltip.length !== 0
            ? `${resourceUri.path.fsPath()} • ${tooltip}`
            : resourceUri.path.fsPath();
        return React.createElement("div", { key: sourceUri, className: `scmItem ${tree_1.TREE_NODE_SEGMENT_CLASS} ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}`, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover, title: title, onClick: this.handleClick, onDoubleClick: this.handleDoubleClick },
            React.createElement("span", { className: icon + ' file-icon' }),
            this.props.renderExpansionToggle(),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` },
                React.createElement("span", { className: 'name', style: { textDecoration } }, caption),
                React.createElement("span", { className: 'path', style: { textDecoration } }, path)),
            React.createElement(ScmInlineActions, { hover,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_INLINE_MENU,
                commandExecutor,
                args: this.contextMenuArgs,
                contextKeys,
                model,
                treeNode },
                React.createElement("div", { title: tooltip, className: classNames.join(' '), style: { color } }, letter)));
    }
    get contextMenuArgs() {
        if (!this.props.model.selectedNodes.some(node => scm_tree_model_1.ScmFileChangeNode.is(node) && node === this.props.treeNode)) {
            // Clicked node is not in selection, so ignore selection and action on just clicked node
            return this.singleNodeArgs;
        }
        else {
            return this.props.model.getSelectionArgs(this.props.model.selectedNodes);
        }
    }
    get singleNodeArgs() {
        const selectedResource = this.props.model.getResourceFromNode(this.props.treeNode);
        if (selectedResource) {
            return [selectedResource];
        }
        else {
            // Repository status not yet available. Empty args disables the action.
            return [];
        }
    }
    hasCtrlCmdOrShiftMask(event) {
        const { metaKey, ctrlKey, shiftKey } = event;
        return (os_1.isOSX && metaKey) || ctrlKey || shiftKey;
    }
}
exports.ScmResourceComponent = ScmResourceComponent;
class ScmResourceGroupElement extends ScmElement {
    constructor() {
        super(...arguments);
        this.contextMenuPath = ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU;
    }
    render() {
        const { hover } = this.state;
        const { model, treeNode, menus, commandExecutor, contextKeys, caption } = this.props;
        return React.createElement("div", { className: `theia-header scm-theia-header ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}`, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover },
            this.props.renderExpansionToggle(),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` }, caption),
            React.createElement(ScmInlineActions, { hover,
                args: this.contextMenuArgs,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU,
                commandExecutor,
                contextKeys,
                model,
                treeNode }, this.renderChangeCount()));
    }
    renderChangeCount() {
        const group = this.props.model.getResourceGroupFromNode(this.props.treeNode);
        return React.createElement("div", { className: 'notification-count-container scm-change-count' },
            React.createElement("span", { className: 'notification-count' }, group ? group.resources.length : 0));
    }
    get contextMenuArgs() {
        const group = this.props.model.getResourceGroupFromNode(this.props.treeNode);
        if (group) {
            return [group];
        }
        else {
            // Repository status not yet available. Empty args disables the action.
            return [];
        }
    }
}
exports.ScmResourceGroupElement = ScmResourceGroupElement;
class ScmResourceFolderElement extends ScmElement {
    constructor() {
        super(...arguments);
        this.contextMenuPath = ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU;
    }
    render() {
        const { hover } = this.state;
        const { model, treeNode, sourceUri, labelProvider, commandExecutor, menus, contextKeys, caption } = this.props;
        const sourceFileStat = files_1.FileStat.dir(sourceUri);
        const icon = labelProvider.getIcon(sourceFileStat);
        const title = new uri_1.default(sourceUri).path.fsPath();
        return React.createElement("div", { key: sourceUri, className: `scmItem  ${tree_1.TREE_NODE_SEGMENT_CLASS} ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS} ${ScmTreeWidget.Styles.NO_SELECT}`, title: title, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover },
            this.props.renderExpansionToggle(),
            React.createElement("span", { className: icon + ' file-icon' }),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` },
                React.createElement("span", { className: 'name' }, caption)),
            React.createElement(ScmInlineActions, { hover,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU,
                commandExecutor,
                args: this.contextMenuArgs,
                contextKeys,
                model,
                treeNode }));
    }
    get contextMenuArgs() {
        if (!this.props.model.selectedNodes.some(node => scm_tree_model_1.ScmFileChangeFolderNode.is(node) && node.sourceUri === this.props.sourceUri)) {
            // Clicked node is not in selection, so ignore selection and action on just clicked node
            return this.singleNodeArgs;
        }
        else {
            return this.props.model.getSelectionArgs(this.props.model.selectedNodes);
        }
    }
    get singleNodeArgs() {
        return this.props.model.getResourcesFromFolderNode(this.props.treeNode);
    }
}
exports.ScmResourceFolderElement = ScmResourceFolderElement;
class ScmInlineActions extends React.Component {
    render() {
        const { hover, menu, menuPath, args, commandExecutor, model, treeNode, contextKeys, children } = this.props;
        return React.createElement("div", { className: 'theia-scm-inline-actions-container' },
            React.createElement("div", { className: 'theia-scm-inline-actions' }, hover && menu.children
                .map((node, index) => node instanceof menu_1.ActionMenuNode &&
                React.createElement(ScmInlineAction, { key: index, node, menuPath, args, commandExecutor, model, treeNode, contextKeys }))),
            children);
    }
}
exports.ScmInlineActions = ScmInlineActions;
class ScmInlineAction extends React.Component {
    constructor() {
        super(...arguments);
        this.execute = (event) => {
            event.stopPropagation();
            const { commandExecutor, menuPath, node, args } = this.props;
            commandExecutor.executeCommand([menuPath[0]], node.command, ...args);
        };
    }
    render() {
        const { node, model, treeNode, args, commandExecutor, menuPath, contextKeys } = this.props;
        let isActive = false;
        model.execInNodeContext(treeNode, () => {
            isActive = contextKeys.match(node.when);
        });
        if (!commandExecutor.isVisible(menuPath, node.command, ...args) || !isActive) {
            return false;
        }
        return React.createElement("div", { className: 'theia-scm-inline-action' },
            React.createElement("a", { className: `${node.icon} ${browser_1.ACTION_ITEM}`, title: node.label, onClick: this.execute }));
    }
}
exports.ScmInlineAction = ScmInlineAction;


/***/ }),

/***/ "../node_modules/@theia/scm/lib/browser/scm-widget.js":
/*!************************************************************!*\
  !*** ../node_modules/@theia/scm/lib/browser/scm-widget.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const scm_commit_widget_1 = __webpack_require__(/*! ./scm-commit-widget */ "../node_modules/@theia/scm/lib/browser/scm-commit-widget.js");
const scm_amend_widget_1 = __webpack_require__(/*! ./scm-amend-widget */ "../node_modules/@theia/scm/lib/browser/scm-amend-widget.js");
const scm_no_repository_widget_1 = __webpack_require__(/*! ./scm-no-repository-widget */ "../node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "../node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_tree_widget_1 = __webpack_require__(/*! ./scm-tree-widget */ "../node_modules/@theia/scm/lib/browser/scm-tree-widget.js");
const scm_preferences_1 = __webpack_require__(/*! ./scm-preferences */ "../node_modules/@theia/scm/lib/browser/scm-preferences.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let ScmWidget = ScmWidget_1 = class ScmWidget extends browser_1.BaseWidget {
    set viewMode(mode) {
        this.resourceWidget.viewMode = mode;
    }
    get viewMode() {
        return this.resourceWidget.viewMode;
    }
    constructor() {
        super();
        this.toDisposeOnRefresh = new disposable_1.DisposableCollection();
        this.node.tabIndex = 0;
        this.id = ScmWidget_1.ID;
        this.addClass('theia-scm');
        this.addClass('theia-scm-main-container');
    }
    init() {
        const layout = new browser_1.PanelLayout();
        this.layout = layout;
        this.panel = new browser_1.Panel({
            layout: new browser_1.PanelLayout({})
        });
        this.panel.node.tabIndex = -1;
        this.panel.node.setAttribute('class', 'theia-scm-panel');
        layout.addWidget(this.panel);
        this.containerLayout.addWidget(this.commitWidget);
        this.containerLayout.addWidget(this.resourceWidget);
        this.containerLayout.addWidget(this.amendWidget);
        this.containerLayout.addWidget(this.noRepositoryWidget);
        this.refresh();
        this.toDispose.push(this.scmService.onDidChangeSelectedRepository(() => this.refresh()));
        this.updateViewMode(this.scmPreferences.get('scm.defaultViewMode'));
        this.toDispose.push(this.scmPreferences.onPreferenceChanged(e => {
            if (e.preferenceName === 'scm.defaultViewMode') {
                this.updateViewMode(e.newValue);
            }
        }));
        this.toDispose.push(this.shell.onDidChangeCurrentWidget(({ newValue }) => {
            const uri = browser_1.NavigatableWidget.getUri(newValue || undefined);
            if (uri) {
                this.resourceWidget.selectNodeByUri(uri);
            }
        }));
    }
    get containerLayout() {
        return this.panel.layout;
    }
    /**
     * Updates the view mode based on the preference value.
     * @param preference the view mode preference.
     */
    updateViewMode(preference) {
        this.viewMode = preference;
    }
    refresh() {
        this.toDisposeOnRefresh.dispose();
        this.toDispose.push(this.toDisposeOnRefresh);
        const repository = this.scmService.selectedRepository;
        this.title.label = repository ? repository.provider.label : nls_1.nls.localize('theia/scm/noRepositoryFound', 'No repository found');
        this.title.caption = this.title.label;
        this.update();
        if (repository) {
            this.toDisposeOnRefresh.push(repository.onDidChange(() => this.update()));
            // render synchronously to avoid cursor jumping
            // see https://stackoverflow.com/questions/28922275/in-reactjs-why-does-setstate-behave-differently-when-called-synchronously/28922465#28922465
            this.toDisposeOnRefresh.push(repository.input.onDidChange(() => this.updateImmediately()));
            this.toDisposeOnRefresh.push(repository.input.onDidFocus(() => this.focusInput()));
            this.commitWidget.show();
            this.resourceWidget.show();
            this.amendWidget.show();
            this.noRepositoryWidget.hide();
        }
        else {
            this.commitWidget.hide();
            this.resourceWidget.hide();
            this.amendWidget.hide();
            this.noRepositoryWidget.show();
        }
    }
    updateImmediately() {
        this.onUpdateRequest(browser_1.Widget.Msg.UpdateRequest);
    }
    onUpdateRequest(msg) {
        browser_1.MessageLoop.sendMessage(this.commitWidget, msg);
        browser_1.MessageLoop.sendMessage(this.resourceWidget, msg);
        browser_1.MessageLoop.sendMessage(this.amendWidget, msg);
        browser_1.MessageLoop.sendMessage(this.noRepositoryWidget, msg);
        super.onUpdateRequest(msg);
    }
    onAfterAttach(msg) {
        this.node.appendChild(this.commitWidget.node);
        this.node.appendChild(this.resourceWidget.node);
        this.node.appendChild(this.amendWidget.node);
        this.node.appendChild(this.noRepositoryWidget.node);
        super.onAfterAttach(msg);
        this.update();
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.refresh();
        if (this.commitWidget.isVisible) {
            this.commitWidget.focus();
        }
        else {
            this.node.focus();
        }
    }
    focusInput() {
        this.commitWidget.focus();
    }
    storeState() {
        const state = {
            commitState: this.commitWidget.storeState(),
            changesTreeState: this.resourceWidget.storeState(),
        };
        return state;
    }
    restoreState(oldState) {
        const { commitState, changesTreeState } = oldState;
        this.commitWidget.restoreState(commitState);
        this.resourceWidget.restoreState(changesTreeState);
    }
    collapseScmTree() {
        const { model } = this.resourceWidget;
        const root = model.root;
        if (browser_1.CompositeTreeNode.is(root)) {
            root.children.map(group => {
                if (browser_1.CompositeTreeNode.is(group)) {
                    group.children.map(folderNode => {
                        if (browser_1.CompositeTreeNode.is(folderNode)) {
                            model.collapseAll(folderNode);
                        }
                        if (browser_1.SelectableTreeNode.isSelected(folderNode)) {
                            model.toggleNode(folderNode);
                        }
                    });
                }
            });
        }
    }
};
exports.ScmWidget = ScmWidget;
ScmWidget.ID = 'scm-view';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], ScmWidget.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_commit_widget_1.ScmCommitWidget),
    tslib_1.__metadata("design:type", scm_commit_widget_1.ScmCommitWidget)
], ScmWidget.prototype, "commitWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_tree_widget_1.ScmTreeWidget),
    tslib_1.__metadata("design:type", scm_tree_widget_1.ScmTreeWidget)
], ScmWidget.prototype, "resourceWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_amend_widget_1.ScmAmendWidget),
    tslib_1.__metadata("design:type", scm_amend_widget_1.ScmAmendWidget)
], ScmWidget.prototype, "amendWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_no_repository_widget_1.ScmNoRepositoryWidget),
    tslib_1.__metadata("design:type", scm_no_repository_widget_1.ScmNoRepositoryWidget)
], ScmWidget.prototype, "noRepositoryWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_preferences_1.ScmPreferences),
    tslib_1.__metadata("design:type", Object)
], ScmWidget.prototype, "scmPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmWidget.prototype, "init", null);
exports.ScmWidget = ScmWidget = ScmWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmWidget);


/***/ }),

/***/ "../node_modules/@theia/scm/src/browser/style/scm-amend-component.css":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/scm/src/browser/style/scm-amend-component.css ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./scm-amend-component.css */ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/scm/src/browser/style/scm-amend-component.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-input.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-input.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceInput = void 0;
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
;
class SearchInWorkspaceInput extends React.Component {
    constructor(props) {
        super(props);
        this.input = React.createRef();
        /**
         * Handle history navigation without overriding the parent's onKeyDown handler, if any.
         */
        this.onKeyDown = (e) => {
            var _a, _b, _c, _d;
            if (browser_1.Key.ARROW_UP.keyCode === ((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode)) {
                e.preventDefault();
                this.previousValue();
            }
            else if (browser_1.Key.ARROW_DOWN.keyCode === ((_b = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _b === void 0 ? void 0 : _b.keyCode)) {
                e.preventDefault();
                this.nextValue();
            }
            (_d = (_c = this.props).onKeyDown) === null || _d === void 0 ? void 0 : _d.call(_c, e);
        };
        /**
         * Handle history collection without overriding the parent's onChange handler, if any.
         */
        this.onChange = (e) => {
            var _a, _b;
            this.addToHistory();
            (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        /**
         * Add a nonempty current value to the history, if not already present. (Debounced, 1 second delay.)
         */
        this.addToHistory = debounce(this.doAddToHistory, 1000);
        this.state = {
            history: [],
            index: 0,
        };
    }
    updateState(index, history) {
        this.value = history ? history[index] : this.state.history[index];
        this.setState(prevState => {
            const newState = {
                ...prevState,
                index,
            };
            if (history) {
                newState.history = history;
            }
            return newState;
        });
    }
    get value() {
        var _a, _b;
        return (_b = (_a = this.input.current) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '';
    }
    set value(value) {
        if (this.input.current) {
            this.input.current.value = value;
        }
    }
    /**
     * Switch the input's text to the previous value, if any.
     */
    previousValue() {
        const { history, index } = this.state;
        if (!this.value) {
            this.value = history[index];
        }
        else if (index > 0 && index < history.length) {
            this.updateState(index - 1);
        }
    }
    /**
     * Switch the input's text to the next value, if any.
     */
    nextValue() {
        const { history, index } = this.state;
        if (index === history.length - 1) {
            this.value = '';
        }
        else if (!this.value) {
            this.value = history[index];
        }
        else if (index >= 0 && index < history.length - 1) {
            this.updateState(index + 1);
        }
    }
    doAddToHistory() {
        if (!this.value) {
            return;
        }
        const history = this.state.history
            .filter(term => term !== this.value)
            .concat(this.value)
            .slice(-SearchInWorkspaceInput.LIMIT);
        this.updateState(history.length - 1, history);
    }
    render() {
        return (React.createElement("input", { ...this.props, onKeyDown: this.onKeyDown, onChange: this.onChange, spellCheck: false, ref: this.input }));
    }
}
exports.SearchInWorkspaceInput = SearchInWorkspaceInput;
SearchInWorkspaceInput.LIMIT = 100;


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-textarea.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-textarea.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceTextArea = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const react_textarea_autosize_1 = __webpack_require__(/*! react-textarea-autosize */ "../node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
;
class SearchInWorkspaceTextArea extends React.Component {
    constructor(props) {
        super(props);
        this.textarea = React.createRef();
        /**
         * Handle history navigation without overriding the parent's onKeyDown handler, if any.
         */
        this.onKeyDown = (e) => {
            var _a, _b, _c, _d, _e;
            // Navigate history only when cursor is at first or last position of the textarea
            if (browser_1.Key.ARROW_UP.keyCode === ((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode) && e.currentTarget.selectionStart === 0) {
                e.preventDefault();
                this.previousValue();
            }
            else if (browser_1.Key.ARROW_DOWN.keyCode === ((_b = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _b === void 0 ? void 0 : _b.keyCode) && e.currentTarget.selectionEnd === e.currentTarget.value.length) {
                e.preventDefault();
                this.nextValue();
            }
            // Prevent newline on enter
            if (browser_1.Key.ENTER.keyCode === ((_c = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _c === void 0 ? void 0 : _c.keyCode) && !e.nativeEvent.shiftKey) {
                e.preventDefault();
            }
            (_e = (_d = this.props).onKeyDown) === null || _e === void 0 ? void 0 : _e.call(_d, e);
        };
        /**
         * Handle history collection and textarea resizing without overriding the parent's onChange handler, if any.
         */
        this.onChange = (e) => {
            var _a, _b;
            this.addToHistory();
            (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        };
        /**
         * Add a nonempty current value to the history, if not already present. (Debounced, 1 second delay.)
         */
        this.addToHistory = debounce(this.doAddToHistory, 1000);
        this.state = {
            history: [],
            index: 0,
        };
    }
    updateState(index, history) {
        this.value = history ? history[index] : this.state.history[index];
        this.setState(prevState => {
            const newState = {
                ...prevState,
                index,
            };
            if (history) {
                newState.history = history;
            }
            return newState;
        });
    }
    get value() {
        var _a, _b;
        return (_b = (_a = this.textarea.current) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '';
    }
    set value(value) {
        if (this.textarea.current) {
            this.textarea.current.value = value;
        }
    }
    /**
     * Switch the textarea's text to the previous value, if any.
     */
    previousValue() {
        const { history, index } = this.state;
        if (!this.value) {
            this.value = history[index];
        }
        else if (index > 0 && index < history.length) {
            this.updateState(index - 1);
        }
    }
    /**
     * Switch the textarea's text to the next value, if any.
     */
    nextValue() {
        const { history, index } = this.state;
        if (index === history.length - 1) {
            this.value = '';
        }
        else if (!this.value) {
            this.value = history[index];
        }
        else if (index >= 0 && index < history.length - 1) {
            this.updateState(index + 1);
        }
    }
    doAddToHistory() {
        if (!this.value) {
            return;
        }
        const history = this.state.history
            .filter(term => term !== this.value)
            .concat(this.value)
            .slice(-SearchInWorkspaceTextArea.LIMIT);
        this.updateState(history.length - 1, history);
    }
    render() {
        const { onResize, ...filteredProps } = this.props;
        return (React.createElement(react_textarea_autosize_1.default, { ...filteredProps, autoCapitalize: "off", autoCorrect: "off", maxRows: 7, onChange: this.onChange, onKeyDown: this.onKeyDown, ref: this.textarea, rows: 1, spellCheck: false }));
    }
}
exports.SearchInWorkspaceTextArea = SearchInWorkspaceTextArea;
SearchInWorkspaceTextArea.LIMIT = 100;


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-context-key-service.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-context-key-service.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let SearchInWorkspaceContextKeyService = class SearchInWorkspaceContextKeyService {
    get searchViewletVisible() {
        return this._searchViewletVisible;
    }
    get searchViewletFocus() {
        return this._searchViewletFocus;
    }
    setSearchInputBoxFocus(searchInputBoxFocus) {
        this.searchInputBoxFocus.set(searchInputBoxFocus);
        this.updateInputBoxFocus();
    }
    setReplaceInputBoxFocus(replaceInputBoxFocus) {
        this.replaceInputBoxFocus.set(replaceInputBoxFocus);
        this.updateInputBoxFocus();
    }
    setPatternIncludesInputBoxFocus(patternIncludesInputBoxFocus) {
        this.patternIncludesInputBoxFocus.set(patternIncludesInputBoxFocus);
        this.updateInputBoxFocus();
    }
    setPatternExcludesInputBoxFocus(patternExcludesInputBoxFocus) {
        this.patternExcludesInputBoxFocus.set(patternExcludesInputBoxFocus);
        this.updateInputBoxFocus();
    }
    updateInputBoxFocus() {
        this.inputBoxFocus.set(this.searchInputBoxFocus.get() ||
            this.replaceInputBoxFocus.get() ||
            this.patternIncludesInputBoxFocus.get() ||
            this.patternExcludesInputBoxFocus.get());
    }
    get replaceActive() {
        return this._replaceActive;
    }
    get hasSearchResult() {
        return this._hasSearchResult;
    }
    init() {
        this._searchViewletVisible = this.contextKeyService.createKey('searchViewletVisible', false);
        this._searchViewletFocus = this.contextKeyService.createKey('searchViewletFocus', false);
        this.inputBoxFocus = this.contextKeyService.createKey('inputBoxFocus', false);
        this.searchInputBoxFocus = this.contextKeyService.createKey('searchInputBoxFocus', false);
        this.replaceInputBoxFocus = this.contextKeyService.createKey('replaceInputBoxFocus', false);
        this.patternIncludesInputBoxFocus = this.contextKeyService.createKey('patternIncludesInputBoxFocus', false);
        this.patternExcludesInputBoxFocus = this.contextKeyService.createKey('patternExcludesInputBoxFocus', false);
        this._replaceActive = this.contextKeyService.createKey('replaceActive', false);
        this._hasSearchResult = this.contextKeyService.createKey('hasSearchResult', false);
    }
};
exports.SearchInWorkspaceContextKeyService = SearchInWorkspaceContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchInWorkspaceContextKeyService.prototype, "init", null);
exports.SearchInWorkspaceContextKeyService = SearchInWorkspaceContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SearchInWorkspaceContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-factory.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-factory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceFactory = exports.SEARCH_VIEW_CONTAINER_TITLE_OPTIONS = exports.SEARCH_VIEW_CONTAINER_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const search_in_workspace_widget_1 = __webpack_require__(/*! ./search-in-workspace-widget */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-widget.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
exports.SEARCH_VIEW_CONTAINER_ID = 'search-view-container';
exports.SEARCH_VIEW_CONTAINER_TITLE_OPTIONS = {
    label: nls_1.nls.localizeByDefault('Search'),
    iconClass: (0, browser_1.codicon)('search'),
    closeable: true
};
let SearchInWorkspaceFactory = class SearchInWorkspaceFactory {
    constructor() {
        this.id = exports.SEARCH_VIEW_CONTAINER_ID;
        this.searchWidgetOptions = {
            canHide: false,
            initiallyCollapsed: false
        };
    }
    async createWidget() {
        const viewContainer = this.viewContainerFactory({
            id: exports.SEARCH_VIEW_CONTAINER_ID,
            progressLocationId: 'search'
        });
        viewContainer.setTitleOptions(exports.SEARCH_VIEW_CONTAINER_TITLE_OPTIONS);
        const widget = await this.widgetManager.getOrCreateWidget(search_in_workspace_widget_1.SearchInWorkspaceWidget.ID);
        viewContainer.addWidget(widget, this.searchWidgetOptions);
        return viewContainer;
    }
};
exports.SearchInWorkspaceFactory = SearchInWorkspaceFactory;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ViewContainer.Factory),
    tslib_1.__metadata("design:type", Function)
], SearchInWorkspaceFactory.prototype, "viewContainerFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], SearchInWorkspaceFactory.prototype, "widgetManager", void 0);
exports.SearchInWorkspaceFactory = SearchInWorkspaceFactory = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SearchInWorkspaceFactory);


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-preferences.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-preferences.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindSearchInWorkspacePreferences = exports.createSearchInWorkspacePreferences = exports.SearchInWorkspacePreferences = exports.SearchInWorkspacePreferenceContribution = exports.SearchInWorkspaceConfiguration = exports.searchInWorkspacePreferencesSchema = void 0;
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "../node_modules/@theia/core/lib/browser/preferences/index.js");
exports.searchInWorkspacePreferencesSchema = {
    type: 'object',
    properties: {
        'search.lineNumbers': {
            description: nls_1.nls.localizeByDefault('Controls whether to show line numbers for search results.'),
            default: false,
            type: 'boolean',
        },
        'search.collapseResults': {
            description: nls_1.nls.localizeByDefault('Controls whether the search results will be collapsed or expanded.'),
            default: 'auto',
            type: 'string',
            enum: ['auto', 'alwaysCollapse', 'alwaysExpand'],
        },
        'search.quickOpen.includeHistory': {
            description: nls_1.nls.localizeByDefault('Whether to include results from recently opened files in the file results for Quick Open.'),
            default: true,
            type: 'boolean',
        },
        'search.searchOnType': {
            description: nls_1.nls.localizeByDefault('Search all files as you type.'),
            default: true,
            type: 'boolean',
        },
        'search.searchOnTypeDebouncePeriod': {
            // eslint-disable-next-line max-len
            markdownDescription: nls_1.nls.localizeByDefault('When {0} is enabled, controls the timeout in milliseconds between a character being typed and the search starting. Has no effect when {0} is disabled.', '`#search.searchOnType#`'),
            default: 300,
            type: 'number',
        },
        'search.searchOnEditorModification': {
            description: nls_1.nls.localize('theia/search-in-workspace/searchOnEditorModification', 'Search the active editor when modified.'),
            default: true,
            type: 'boolean',
        },
        'search.smartCase': {
            // eslint-disable-next-line max-len
            description: nls_1.nls.localizeByDefault('Search case-insensitively if the pattern is all lowercase, otherwise, search case-sensitively.'),
            default: false,
            type: 'boolean',
        },
        'search.followSymlinks': {
            description: nls_1.nls.localizeByDefault('Controls whether to follow symlinks while searching.'),
            default: true,
            type: 'boolean',
        }
    }
};
class SearchInWorkspaceConfiguration {
}
exports.SearchInWorkspaceConfiguration = SearchInWorkspaceConfiguration;
exports.SearchInWorkspacePreferenceContribution = Symbol('SearchInWorkspacePreferenceContribution');
exports.SearchInWorkspacePreferences = Symbol('SearchInWorkspacePreferences');
function createSearchInWorkspacePreferences(preferences, schema = exports.searchInWorkspacePreferencesSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createSearchInWorkspacePreferences = createSearchInWorkspacePreferences;
function bindSearchInWorkspacePreferences(bind) {
    bind(exports.SearchInWorkspacePreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.SearchInWorkspacePreferenceContribution);
        return createSearchInWorkspacePreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.SearchInWorkspacePreferenceContribution).toConstantValue({ schema: exports.searchInWorkspacePreferencesSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.SearchInWorkspacePreferenceContribution);
}
exports.bindSearchInWorkspacePreferences = bindSearchInWorkspacePreferences;


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-result-tree-widget.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-result-tree-widget.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceResultTreeWidget = exports.SearchInWorkspaceResultLineNode = exports.SearchInWorkspaceFileNode = exports.SearchInWorkspaceRootFolderNode = exports.SearchInWorkspaceRoot = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const browser_3 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const browser_4 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../node_modules/@theia/filesystem/lib/browser/index.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const search_in_workspace_service_1 = __webpack_require__(/*! ./search-in-workspace-service */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const search_in_workspace_preferences_1 = __webpack_require__(/*! ./search-in-workspace-preferences */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-preferences.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../node_modules/@theia/core/lib/browser/color-registry.js");
const minimatch = __webpack_require__(/*! minimatch */ "../node_modules/minimatch/minimatch.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../node_modules/@theia/core/shared/lodash.debounce/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const ROOT_ID = 'ResultTree';
var SearchInWorkspaceRoot;
(function (SearchInWorkspaceRoot) {
    function is(node) {
        return browser_1.CompositeTreeNode.is(node) && node.id === ROOT_ID;
    }
    SearchInWorkspaceRoot.is = is;
})(SearchInWorkspaceRoot || (exports.SearchInWorkspaceRoot = SearchInWorkspaceRoot = {}));
var SearchInWorkspaceRootFolderNode;
(function (SearchInWorkspaceRootFolderNode) {
    function is(node) {
        return browser_1.ExpandableTreeNode.is(node) && browser_1.SelectableTreeNode.is(node) && 'path' in node && 'folderUri' in node && !('fileUri' in node);
    }
    SearchInWorkspaceRootFolderNode.is = is;
})(SearchInWorkspaceRootFolderNode || (exports.SearchInWorkspaceRootFolderNode = SearchInWorkspaceRootFolderNode = {}));
var SearchInWorkspaceFileNode;
(function (SearchInWorkspaceFileNode) {
    function is(node) {
        return browser_1.ExpandableTreeNode.is(node) && browser_1.SelectableTreeNode.is(node) && 'path' in node && 'fileUri' in node && !('folderUri' in node);
    }
    SearchInWorkspaceFileNode.is = is;
})(SearchInWorkspaceFileNode || (exports.SearchInWorkspaceFileNode = SearchInWorkspaceFileNode = {}));
var SearchInWorkspaceResultLineNode;
(function (SearchInWorkspaceResultLineNode) {
    function is(node) {
        return browser_1.SelectableTreeNode.is(node) && 'line' in node && 'character' in node && 'lineText' in node;
    }
    SearchInWorkspaceResultLineNode.is = is;
})(SearchInWorkspaceResultLineNode || (exports.SearchInWorkspaceResultLineNode = SearchInWorkspaceResultLineNode = {}));
let SearchInWorkspaceResultTreeWidget = class SearchInWorkspaceResultTreeWidget extends browser_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this._showReplaceButtons = false;
        this._replaceTerm = '';
        this.searchTerm = '';
        this.startSearchOnModification = (activeEditor) => debounce(() => this.searchActiveEditor(activeEditor, this.searchTerm, this.searchOptions), this.searchOnEditorModificationDelay);
        this.searchOnEditorModificationDelay = 300;
        this.toDisposeOnActiveEditorChanged = new disposable_1.DisposableCollection();
        // The default root name to add external search results in the case that a workspace is opened.
        this.defaultRootName = nls_1.nls.localizeByDefault('Other files');
        this.forceVisibleRootNode = false;
        this.appliedDecorations = new Map();
        this.changeEmitter = new core_1.Emitter();
        this.onExpansionChangedEmitter = new core_1.Emitter();
        this.onExpansionChanged = this.onExpansionChangedEmitter.event;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.focusInputEmitter = new core_1.Emitter();
        this.remove = (node, e) => this.doRemove(node, e);
        model.root = {
            id: ROOT_ID,
            parent: undefined,
            visible: false,
            children: []
        };
        this.toDispose.push(model.onSelectionChanged(nodes => {
            const node = nodes[0];
            if (SearchInWorkspaceResultLineNode.is(node)) {
                this.doOpen(node, true, true);
            }
        }));
        this.toDispose.push(model.onOpenNode(node => {
            if (SearchInWorkspaceResultLineNode.is(node)) {
                this.doOpen(node, true, false);
            }
        }));
        this.resultTree = new Map();
        this.toDispose.push(model.onNodeRefreshed(() => this.changeEmitter.fire(this.resultTree)));
    }
    init() {
        super.init();
        this.addClass('resultContainer');
        this.toDispose.push(this.changeEmitter);
        this.toDispose.push(this.focusInputEmitter);
        this.toDispose.push(this.editorManager.onActiveEditorChanged(activeEditor => {
            this.updateCurrentEditorDecorations();
            this.toDisposeOnActiveEditorChanged.dispose();
            this.toDispose.push(this.toDisposeOnActiveEditorChanged);
            if (activeEditor) {
                this.toDisposeOnActiveEditorChanged.push(activeEditor.editor.onDocumentContentChanged(() => {
                    if (this.searchTerm !== '' && this.searchInWorkspacePreferences['search.searchOnEditorModification']) {
                        this.startSearchOnModification(activeEditor)();
                    }
                }));
            }
        }));
        this.toDispose.push(this.searchInWorkspacePreferences.onPreferenceChanged(() => {
            this.update();
        }));
        this.toDispose.push(this.fileService.onDidFilesChange(event => {
            if (event.gotDeleted()) {
                event.getDeleted().forEach(deletedFile => {
                    const fileNodes = this.getFileNodesByUri(deletedFile.resource);
                    fileNodes.forEach(node => this.removeFileNode(node));
                });
                this.model.refresh();
            }
        }));
        this.toDispose.push(this.model.onExpansionChanged(() => {
            this.onExpansionChangedEmitter.fire(undefined);
        }));
    }
    get fileNumber() {
        let num = 0;
        for (const rootFolderNode of this.resultTree.values()) {
            num += rootFolderNode.children.length;
        }
        return num;
    }
    set showReplaceButtons(srb) {
        this._showReplaceButtons = srb;
        this.update();
    }
    set replaceTerm(rt) {
        this._replaceTerm = rt;
        this.update();
    }
    get isReplacing() {
        return this._replaceTerm !== '' && this._showReplaceButtons;
    }
    get onChange() {
        return this.changeEmitter.event;
    }
    get onFocusInput() {
        return this.focusInputEmitter.event;
    }
    collapseAll() {
        for (const rootFolderNode of this.resultTree.values()) {
            for (const fileNode of rootFolderNode.children) {
                this.expansionService.collapseNode(fileNode);
            }
            if (rootFolderNode.visible) {
                this.expansionService.collapseNode(rootFolderNode);
            }
        }
    }
    expandAll() {
        for (const rootFolderNode of this.resultTree.values()) {
            for (const fileNode of rootFolderNode.children) {
                this.expansionService.expandNode(fileNode);
            }
            if (rootFolderNode.visible) {
                this.expansionService.expandNode(rootFolderNode);
            }
        }
    }
    areResultsCollapsed() {
        for (const rootFolderNode of this.resultTree.values()) {
            for (const fileNode of rootFolderNode.children) {
                if (!browser_1.ExpandableTreeNode.isCollapsed(fileNode)) {
                    return false;
                }
            }
        }
        return true;
    }
    selectNextResult() {
        if (!this.model.getFocusedNode()) {
            return this.selectFirstResult();
        }
        let foundNextResult = false;
        while (!foundNextResult) {
            const nextNode = this.model.getNextNode();
            if (!nextNode) {
                return this.selectFirstResult();
            }
            else if (SearchInWorkspaceResultLineNode.is(nextNode)) {
                foundNextResult = true;
                this.selectExpandOpenResultNode(nextNode);
            }
            else {
                this.model.selectNext();
            }
        }
    }
    selectPreviousResult() {
        if (!this.model.getFocusedNode()) {
            return this.selectLastResult();
        }
        let foundSelectedNode = false;
        while (!foundSelectedNode) {
            const prevNode = this.model.getPrevNode();
            if (!prevNode) {
                return this.selectLastResult();
            }
            else if (SearchInWorkspaceResultLineNode.is(prevNode)) {
                foundSelectedNode = true;
                this.selectExpandOpenResultNode(prevNode);
            }
            else if (prevNode.id === 'ResultTree') {
                return this.selectLastResult();
            }
            else {
                this.model.selectPrev();
            }
        }
    }
    selectExpandOpenResultNode(node) {
        this.model.expandNode(node.parent.parent);
        this.model.expandNode(node.parent);
        this.model.selectNode(node);
        this.model.openNode(node);
    }
    selectFirstResult() {
        for (const rootFolder of this.resultTree.values()) {
            for (const file of rootFolder.children) {
                for (const result of file.children) {
                    if (browser_1.SelectableTreeNode.is(result)) {
                        return this.selectExpandOpenResultNode(result);
                    }
                }
            }
        }
    }
    selectLastResult() {
        const rootFolders = Array.from(this.resultTree.values());
        for (let i = rootFolders.length - 1; i >= 0; i--) {
            const rootFolder = rootFolders[i];
            for (let j = rootFolder.children.length - 1; j >= 0; j--) {
                const file = rootFolder.children[j];
                for (let k = file.children.length - 1; k >= 0; k--) {
                    const result = file.children[k];
                    if (browser_1.SelectableTreeNode.is(result)) {
                        return this.selectExpandOpenResultNode(result);
                    }
                }
            }
        }
    }
    /**
     * Find matches for the given editor.
     * @param searchTerm the search term.
     * @param widget the editor widget.
     * @param searchOptions the search options to apply.
     *
     * @returns the list of matches.
     */
    findMatches(searchTerm, widget, searchOptions) {
        if (!widget.editor.document.findMatches) {
            return [];
        }
        const results = widget.editor.document.findMatches({
            searchString: searchTerm,
            isRegex: !!searchOptions.useRegExp,
            matchCase: !!searchOptions.matchCase,
            matchWholeWord: !!searchOptions.matchWholeWord,
            limitResultCount: searchOptions.maxResults
        });
        const matches = [];
        results.forEach(r => {
            const numberOfLines = searchTerm.split('\n').length;
            const lineTexts = [];
            for (let i = 0; i < numberOfLines; i++) {
                lineTexts.push(widget.editor.document.getLineContent(r.range.start.line + i));
            }
            matches.push({
                line: r.range.start.line,
                character: r.range.start.character,
                length: searchTerm.length,
                lineText: lineTexts.join('\n')
            });
        });
        return matches;
    }
    /**
     * Convert a pattern to match all directories.
     * @param workspaceRootUri the uri of the current workspace root.
     * @param pattern the pattern to be converted.
     */
    convertPatternToGlob(workspaceRootUri, pattern) {
        if (pattern.startsWith('**/')) {
            return pattern;
        }
        if (pattern.startsWith('./')) {
            if (workspaceRootUri === undefined) {
                return pattern;
            }
            return workspaceRootUri.toString() + pattern.replace('./', '/');
        }
        return pattern.startsWith('/')
            ? '**' + pattern
            : '**/' + pattern;
    }
    /**
     * Determine if the URI matches any of the patterns.
     * @param uri the editor URI.
     * @param patterns the glob patterns to verify.
     */
    inPatternList(uri, patterns) {
        const opts = { dot: true, matchBase: true };
        return patterns.some(pattern => minimatch(uri.toString(), this.convertPatternToGlob(this.workspaceService.getWorkspaceRootUri(uri), pattern), opts));
    }
    /**
     * Determine if the given editor satisfies the filtering criteria.
     * An editor should be searched only if:
     * - it is not excluded through the `excludes` list.
     * - it is not explicitly present in a non-empty `includes` list.
     */
    shouldApplySearch(editorWidget, searchOptions) {
        const excludePatterns = this.getExcludeGlobs(searchOptions.exclude);
        if (this.inPatternList(editorWidget.editor.uri, excludePatterns)) {
            return false;
        }
        const includePatterns = searchOptions.include;
        if (!!(includePatterns === null || includePatterns === void 0 ? void 0 : includePatterns.length) && !this.inPatternList(editorWidget.editor.uri, includePatterns)) {
            return false;
        }
        return true;
    }
    /**
     * Search the active editor only and update the tree with those results.
     */
    searchActiveEditor(activeEditor, searchTerm, searchOptions) {
        const includesExternalResults = () => !!this.resultTree.get(this.defaultRootName);
        // Check if outside workspace results are present before searching.
        const hasExternalResultsBefore = includesExternalResults();
        // Collect search results for the given editor.
        const results = this.searchInEditor(activeEditor, searchTerm, searchOptions);
        // Update the tree by removing the result node, and add new results if applicable.
        this.getFileNodesByUri(activeEditor.editor.uri).forEach(fileNode => this.removeFileNode(fileNode));
        if (results) {
            this.appendToResultTree(results);
        }
        // Check if outside workspace results are present after searching.
        const hasExternalResultsAfter = includesExternalResults();
        // Redo a search to update the tree node visibility if:
        // + `Other files` node was present, now it is not.
        // + `Other files` node was not present, now it is.
        if (hasExternalResultsBefore ? !hasExternalResultsAfter : hasExternalResultsAfter) {
            this.search(this.searchTerm, this.searchOptions);
            return;
        }
        this.handleSearchCompleted();
    }
    /**
     * Perform a search in all open editors.
     * @param searchTerm the search term.
     * @param searchOptions the search options to apply.
     *
     * @returns the tuple of result count, and the list of search results.
     */
    searchInOpenEditors(searchTerm, searchOptions) {
        // Track the number of results found.
        let numberOfResults = 0;
        const searchResults = [];
        this.editorManager.all.forEach(e => {
            const editorResults = this.searchInEditor(e, searchTerm, searchOptions);
            if (editorResults) {
                numberOfResults += editorResults.matches.length;
                searchResults.push(editorResults);
            }
        });
        return {
            numberOfResults,
            matches: searchResults
        };
    }
    /**
     * Perform a search in the target editor.
     * @param editorWidget the editor widget.
     * @param searchTerm the search term.
     * @param searchOptions the search options to apply.
     *
     * @returns the search results from the given editor, undefined if the editor is either filtered or has no matches found.
     */
    searchInEditor(editorWidget, searchTerm, searchOptions) {
        var _a;
        if (!this.shouldApplySearch(editorWidget, searchOptions)) {
            return undefined;
        }
        const matches = this.findMatches(searchTerm, editorWidget, searchOptions);
        if (matches.length <= 0) {
            return undefined;
        }
        const fileUri = editorWidget.editor.uri.toString();
        const root = (_a = this.workspaceService.getWorkspaceRootUri(editorWidget.editor.uri)) === null || _a === void 0 ? void 0 : _a.toString();
        return {
            root: root !== null && root !== void 0 ? root : this.defaultRootName,
            fileUri,
            matches
        };
    }
    /**
     * Append search results to the result tree.
     * @param result Search result.
     */
    appendToResultTree(result) {
        const collapseValue = this.searchInWorkspacePreferences['search.collapseResults'];
        let path;
        if (result.root === this.defaultRootName) {
            path = new uri_1.default(result.fileUri).path.dir.fsPath();
        }
        else {
            path = this.filenameAndPath(result.root, result.fileUri).path;
        }
        const tree = this.resultTree;
        let rootFolderNode = tree.get(result.root);
        if (!rootFolderNode) {
            rootFolderNode = this.createRootFolderNode(result.root);
            tree.set(result.root, rootFolderNode);
        }
        let fileNode = rootFolderNode.children.find(f => f.fileUri === result.fileUri);
        if (!fileNode) {
            fileNode = this.createFileNode(result.root, path, result.fileUri, rootFolderNode);
            rootFolderNode.children.push(fileNode);
        }
        for (const match of result.matches) {
            const line = this.createResultLineNode(result, match, fileNode);
            if (fileNode.children.findIndex(lineNode => lineNode.id === line.id) < 0) {
                fileNode.children.push(line);
            }
        }
        this.collapseFileNode(fileNode, collapseValue);
    }
    /**
     * Handle when searching completed.
     */
    handleSearchCompleted(cancelIndicator) {
        if (cancelIndicator) {
            cancelIndicator.cancel();
        }
        this.sortResultTree();
        this.refreshModelChildren();
    }
    /**
     * Sort the result tree by URIs.
     */
    sortResultTree() {
        // Sort the result map by folder URI.
        const entries = [...this.resultTree.entries()];
        entries.sort(([, a], [, b]) => this.compare(a.folderUri, b.folderUri));
        this.resultTree = new Map(entries);
        // Update the list of children nodes, sorting them by their file URI.
        entries.forEach(([, folder]) => {
            folder.children.sort((a, b) => this.compare(a.fileUri, b.fileUri));
        });
    }
    /**
     * Search and populate the result tree with matches.
     * @param searchTerm the search term.
     * @param searchOptions the search options to apply.
     */
    async search(searchTerm, searchOptions) {
        this.searchTerm = searchTerm;
        this.searchOptions = searchOptions;
        searchOptions = {
            ...searchOptions,
            exclude: this.getExcludeGlobs(searchOptions.exclude)
        };
        this.resultTree.clear();
        this.forceVisibleRootNode = false;
        if (this.cancelIndicator) {
            this.cancelIndicator.cancel();
        }
        if (searchTerm === '') {
            this.refreshModelChildren();
            return;
        }
        this.cancelIndicator = new core_1.CancellationTokenSource();
        const cancelIndicator = this.cancelIndicator;
        const token = this.cancelIndicator.token;
        const progress = await this.progressService.showProgress({ text: `search: ${searchTerm}`, options: { location: 'search' } });
        token.onCancellationRequested(() => {
            progress.cancel();
            if (searchId) {
                this.searchService.cancel(searchId);
            }
            this.cancelIndicator = undefined;
            this.changeEmitter.fire(this.resultTree);
        });
        // Collect search results for opened editors which otherwise may not be found by ripgrep (ex: dirty editors).
        const { numberOfResults, matches } = this.searchInOpenEditors(searchTerm, searchOptions);
        // The root node is visible if outside workspace results are found and workspace root(s) are present.
        this.forceVisibleRootNode = matches.some(m => m.root === this.defaultRootName) && this.workspaceService.opened;
        matches.forEach(m => this.appendToResultTree(m));
        // Exclude files already covered by searching open editors.
        this.editorManager.all.forEach(e => {
            const excludePath = e.editor.uri.path.toString();
            searchOptions.exclude = searchOptions.exclude ? searchOptions.exclude.concat(excludePath) : [excludePath];
        });
        // Reduce `maxResults` due to editor results.
        if (searchOptions.maxResults) {
            searchOptions.maxResults -= numberOfResults;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let pendingRefreshTimeout;
        const searchId = await this.searchService.search(searchTerm, {
            onResult: (aSearchId, result) => {
                if (token.isCancellationRequested || aSearchId !== searchId) {
                    return;
                }
                this.appendToResultTree(result);
                if (pendingRefreshTimeout) {
                    clearTimeout(pendingRefreshTimeout);
                }
                pendingRefreshTimeout = setTimeout(() => this.refreshModelChildren(), 100);
            },
            onDone: () => {
                this.handleSearchCompleted(cancelIndicator);
            }
        }, searchOptions).catch(() => {
            this.handleSearchCompleted(cancelIndicator);
        });
    }
    focusFirstResult() {
        if (SearchInWorkspaceRoot.is(this.model.root) && this.model.root.children.length > 0) {
            const node = this.model.root.children[0];
            if (browser_1.SelectableTreeNode.is(node)) {
                this.node.focus();
                this.model.selectNode(node);
            }
        }
    }
    /**
     * Collapse the search-in-workspace file node
     * based on the preference value.
     */
    collapseFileNode(node, preferenceValue) {
        if (preferenceValue === 'auto' && node.children.length >= 10) {
            node.expanded = false;
        }
        else if (preferenceValue === 'alwaysCollapse') {
            node.expanded = false;
        }
        else if (preferenceValue === 'alwaysExpand') {
            node.expanded = true;
        }
    }
    handleUp(event) {
        if (!this.model.getPrevSelectableNode(this.model.getFocusedNode())) {
            this.focusInputEmitter.fire(true);
        }
        else {
            super.handleUp(event);
        }
    }
    async refreshModelChildren() {
        if (SearchInWorkspaceRoot.is(this.model.root)) {
            this.model.root.children = Array.from(this.resultTree.values());
            this.model.refresh();
            this.updateCurrentEditorDecorations();
        }
    }
    updateCurrentEditorDecorations() {
        this.shell.allTabBars.forEach(tb => {
            const currentTitle = tb.currentTitle;
            if (currentTitle && currentTitle.owner instanceof browser_2.EditorWidget) {
                const widget = currentTitle.owner;
                const fileNodes = this.getFileNodesByUri(widget.editor.uri);
                if (fileNodes.length > 0) {
                    fileNodes.forEach(node => {
                        this.decorateEditor(node, widget);
                    });
                }
                else {
                    this.decorateEditor(undefined, widget);
                }
            }
        });
        const currentWidget = this.editorManager.currentEditor;
        if (currentWidget) {
            const fileNodes = this.getFileNodesByUri(currentWidget.editor.uri);
            fileNodes.forEach(node => {
                this.decorateEditor(node, currentWidget);
            });
        }
    }
    createRootFolderNode(rootUri) {
        const uri = new uri_1.default(rootUri);
        return {
            selected: false,
            path: uri.path.fsPath(),
            folderUri: rootUri,
            uri: new uri_1.default(rootUri),
            children: [],
            expanded: true,
            id: rootUri,
            parent: this.model.root,
            visible: this.forceVisibleRootNode || this.workspaceService.isMultiRootWorkspaceOpened
        };
    }
    createFileNode(rootUri, path, fileUri, parent) {
        return {
            selected: false,
            path,
            children: [],
            expanded: true,
            id: `${rootUri}::${fileUri}`,
            parent,
            fileUri,
            uri: new uri_1.default(fileUri),
        };
    }
    createResultLineNode(result, match, fileNode) {
        return {
            ...result,
            ...match,
            selected: false,
            id: result.fileUri + '-' + match.line + '-' + match.character + '-' + match.length,
            name: typeof match.lineText === 'string' ? match.lineText : match.lineText.text,
            parent: fileNode
        };
    }
    getFileNodesByUri(uri) {
        const nodes = [];
        const fileUri = uri.withScheme('file').toString();
        for (const rootFolderNode of this.resultTree.values()) {
            const rootUri = new uri_1.default(rootFolderNode.path).withScheme('file');
            if (rootUri.isEqualOrParent(uri) || rootFolderNode.id === this.defaultRootName) {
                for (const fileNode of rootFolderNode.children) {
                    if (fileNode.fileUri === fileUri) {
                        nodes.push(fileNode);
                    }
                }
            }
        }
        return nodes;
    }
    filenameAndPath(rootUriStr, uriStr) {
        const uri = new uri_1.default(uriStr);
        const relativePath = new uri_1.default(rootUriStr).relative(uri.parent);
        return {
            name: this.labelProvider.getName(uri),
            path: relativePath ? relativePath.fsPath() : ''
        };
    }
    getDepthPadding(depth) {
        return super.getDepthPadding(depth) + 5;
    }
    renderCaption(node, props) {
        if (SearchInWorkspaceRootFolderNode.is(node)) {
            return this.renderRootFolderNode(node);
        }
        else if (SearchInWorkspaceFileNode.is(node)) {
            return this.renderFileNode(node);
        }
        else if (SearchInWorkspaceResultLineNode.is(node)) {
            return this.renderResultLineNode(node);
        }
        return '';
    }
    renderTailDecorations(node, props) {
        return React.createElement("div", { className: 'result-node-buttons' },
            this._showReplaceButtons && this.renderReplaceButton(node),
            this.renderRemoveButton(node));
    }
    doReplace(node, e) {
        const selection = browser_1.SelectableTreeNode.isSelected(node) ? this.selectionService.selection : [node];
        selection.forEach(n => this.replace(n));
        e.stopPropagation();
    }
    renderReplaceButton(node) {
        const isResultLineNode = SearchInWorkspaceResultLineNode.is(node);
        return React.createElement("span", { className: isResultLineNode ? (0, browser_1.codicon)('replace') : (0, browser_1.codicon)('replace-all'), onClick: e => this.doReplace(node, e), title: isResultLineNode
                ? nls_1.nls.localizeByDefault('Replace')
                : nls_1.nls.localizeByDefault('Replace All') });
    }
    getFileCount(node) {
        if (SearchInWorkspaceRoot.is(node)) {
            return node.children.reduce((acc, current) => acc + this.getFileCount(current), 0);
        }
        else if (SearchInWorkspaceRootFolderNode.is(node)) {
            return node.children.length;
        }
        else if (SearchInWorkspaceFileNode.is(node)) {
            return 1;
        }
        return 0;
    }
    getResultCount(node) {
        if (SearchInWorkspaceRoot.is(node)) {
            return node.children.reduce((acc, current) => acc + this.getResultCount(current), 0);
        }
        else if (SearchInWorkspaceRootFolderNode.is(node)) {
            return node.children.reduce((acc, current) => acc + this.getResultCount(current), 0);
        }
        else if (SearchInWorkspaceFileNode.is(node)) {
            return node.children.length;
        }
        else if (SearchInWorkspaceResultLineNode.is(node)) {
            return 1;
        }
        return 0;
    }
    /**
     * Replace results under the node passed into the function. If node is undefined, replace all results.
     * @param node Node in the tree widget where the "replace all" operation is performed
     */
    async replace(node) {
        const replaceForNode = node || this.model.root;
        const needConfirm = !SearchInWorkspaceFileNode.is(node) && !SearchInWorkspaceResultLineNode.is(node);
        const replacementText = this._replaceTerm;
        if (!needConfirm || await this.confirmReplaceAll(this.getResultCount(replaceForNode), this.getFileCount(replaceForNode), replacementText)) {
            (node ? [node] : Array.from(this.resultTree.values())).forEach(n => {
                this.replaceResult(n, !!node, replacementText);
                this.removeNode(n);
            });
        }
    }
    confirmReplaceAll(resultNumber, fileNumber, replacementText) {
        return new browser_1.ConfirmDialog({
            title: nls_1.nls.localizeByDefault('Replace All'),
            msg: this.buildReplaceAllConfirmationMessage(resultNumber, fileNumber, replacementText)
        }).open();
    }
    buildReplaceAllConfirmationMessage(occurrences, fileCount, replaceValue) {
        if (occurrences === 1) {
            if (fileCount === 1) {
                if (replaceValue) {
                    return nls_1.nls.localizeByDefault("Replace {0} occurrence across {1} file with '{2}'?", occurrences, fileCount, replaceValue);
                }
                return nls_1.nls.localizeByDefault('Replace {0} occurrence across {1} file?', occurrences, fileCount);
            }
            if (replaceValue) {
                return nls_1.nls.localizeByDefault("Replace {0} occurrence across {1} files with '{2}'?", occurrences, fileCount, replaceValue);
            }
            return nls_1.nls.localizeByDefault('Replace {0} occurrence across {1} files?', occurrences, fileCount);
        }
        if (fileCount === 1) {
            if (replaceValue) {
                return nls_1.nls.localizeByDefault("Replace {0} occurrences across {1} file with '{2}'?", occurrences, fileCount, replaceValue);
            }
            return nls_1.nls.localizeByDefault('Replace {0} occurrences across {1} file?', occurrences, fileCount);
        }
        if (replaceValue) {
            return nls_1.nls.localizeByDefault("Replace {0} occurrences across {1} files with '{2}'?", occurrences, fileCount, replaceValue);
        }
        return nls_1.nls.localizeByDefault('Replace {0} occurrences across {1} files?', occurrences, fileCount);
    }
    updateRightResults(node) {
        const fileNode = node.parent;
        const rightPositionedNodes = fileNode.children.filter(rl => rl.line === node.line && rl.character > node.character);
        const diff = this._replaceTerm.length - this.searchTerm.length;
        rightPositionedNodes.forEach(r => r.character += diff);
    }
    /**
     * Replace text either in all search matches under a node or in all search matches, and save the changes.
     * @param node - node in the tree widget in which the "replace all" is performed.
     * @param {boolean} replaceOne - whether the function is to replace all matches under a node. If it is false, replace all.
     * @param replacementText - text to be used for all replacements in the current replacement cycle.
     */
    async replaceResult(node, replaceOne, replacementText) {
        const toReplace = [];
        if (SearchInWorkspaceRootFolderNode.is(node)) {
            node.children.forEach(fileNode => this.replaceResult(fileNode, replaceOne, replacementText));
        }
        else if (SearchInWorkspaceFileNode.is(node)) {
            toReplace.push(...node.children);
        }
        else if (SearchInWorkspaceResultLineNode.is(node)) {
            toReplace.push(node);
            this.updateRightResults(node);
        }
        if (toReplace.length > 0) {
            // Store the state of all tracked editors before another editor widget might be created for text replacing.
            const trackedEditors = this.editorManager.all;
            // Open the file only if the function is called to replace all matches under a specific node.
            const widget = replaceOne ? await this.doOpen(toReplace[0]) : await this.doGetWidget(toReplace[0]);
            const source = widget.editor.document.getText();
            const replaceOperations = toReplace.map(resultLineNode => ({
                text: replacementText,
                range: {
                    start: {
                        line: resultLineNode.line - 1,
                        character: resultLineNode.character - 1
                    },
                    end: this.findEndCharacterPosition(resultLineNode),
                }
            }));
            // Replace the text.
            await widget.editor.replaceText({
                source,
                replaceOperations
            });
            // Save the text replacement changes in the editor.
            await widget.saveable.save();
            // Dispose the widget if it is not opened but created for `replaceAll`.
            if (!replaceOne) {
                if (trackedEditors.indexOf(widget) === -1) {
                    widget.dispose();
                }
            }
        }
    }
    doRemove(node, e) {
        const selection = browser_1.SelectableTreeNode.isSelected(node) ? this.selectionService.selection : [node];
        selection.forEach(n => this.removeNode(n));
        e.stopPropagation();
    }
    renderRemoveButton(node) {
        return React.createElement("span", { className: (0, browser_1.codicon)('close'), onClick: e => this.remove(node, e), title: 'Dismiss' });
    }
    removeNode(node) {
        if (SearchInWorkspaceRootFolderNode.is(node)) {
            this.removeRootFolderNode(node);
        }
        else if (SearchInWorkspaceFileNode.is(node)) {
            this.removeFileNode(node);
        }
        else if (SearchInWorkspaceResultLineNode.is(node)) {
            this.removeResultLineNode(node);
        }
        this.refreshModelChildren();
    }
    removeRootFolderNode(node) {
        for (const rootUri of this.resultTree.keys()) {
            if (rootUri === node.folderUri) {
                this.resultTree.delete(rootUri);
                break;
            }
        }
    }
    removeFileNode(node) {
        const rootFolderNode = node.parent;
        const index = rootFolderNode.children.findIndex(fileNode => fileNode.id === node.id);
        if (index > -1) {
            rootFolderNode.children.splice(index, 1);
        }
        if (this.getFileCount(rootFolderNode) === 0) {
            this.removeRootFolderNode(rootFolderNode);
        }
    }
    removeResultLineNode(node) {
        const fileNode = node.parent;
        const index = fileNode.children.findIndex(n => n.fileUri === node.fileUri && n.line === node.line && n.character === node.character);
        if (index > -1) {
            fileNode.children.splice(index, 1);
            if (this.getResultCount(fileNode) === 0) {
                this.removeFileNode(fileNode);
            }
        }
    }
    findEndCharacterPosition(node) {
        const lineText = typeof node.lineText === 'string' ? node.lineText : node.lineText.text;
        const lines = lineText.split('\n');
        const line = node.line + lines.length - 2;
        let character = node.character - 1 + node.length;
        if (lines.length > 1) {
            character = node.length - lines[0].length + node.character - lines.length;
            if (lines.length > 2) {
                for (const lineNum of Array(lines.length - 2).keys()) {
                    character -= lines[lineNum + 1].length;
                }
            }
        }
        return { line, character };
    }
    renderRootFolderNode(node) {
        return React.createElement("div", { className: 'result' },
            React.createElement("div", { className: 'result-head' },
                React.createElement("div", { className: `result-head-info noWrapInfo noselect ${node.selected ? 'selected' : ''}` },
                    React.createElement("span", { className: `file-icon ${this.toNodeIcon(node) || ''}` }),
                    React.createElement("div", { className: 'noWrapInfo' },
                        React.createElement("span", { className: 'file-name' }, this.toNodeName(node)),
                        node.path !== '/' + this.defaultRootName &&
                            React.createElement("span", { className: 'file-path ' + browser_1.TREE_NODE_INFO_CLASS }, node.path))),
                React.createElement("span", { className: 'notification-count-container highlighted-count-container' },
                    React.createElement("span", { className: 'notification-count' }, this.getFileCount(node)))));
    }
    renderFileNode(node) {
        return React.createElement("div", { className: 'result' },
            React.createElement("div", { className: 'result-head' },
                React.createElement("div", { className: `result-head-info noWrapInfo noselect ${node.selected ? 'selected' : ''}`, title: new uri_1.default(node.fileUri).path.fsPath() },
                    React.createElement("span", { className: `file-icon ${this.toNodeIcon(node)}` }),
                    React.createElement("div", { className: 'noWrapInfo' },
                        React.createElement("span", { className: 'file-name' }, this.toNodeName(node)),
                        React.createElement("span", { className: 'file-path ' + browser_1.TREE_NODE_INFO_CLASS }, node.path))),
                React.createElement("span", { className: 'notification-count-container' },
                    React.createElement("span", { className: 'notification-count' }, this.getResultCount(node)))));
    }
    renderResultLineNode(node) {
        const character = typeof node.lineText === 'string' ? node.character : node.lineText.character;
        const lineText = typeof node.lineText === 'string' ? node.lineText : node.lineText.text;
        let start = Math.max(0, character - 26);
        const wordBreak = /\b/g;
        while (start > 0 && wordBreak.test(lineText) && wordBreak.lastIndex < character) {
            if (character - wordBreak.lastIndex < 26) {
                break;
            }
            start = wordBreak.lastIndex;
            wordBreak.lastIndex++;
        }
        const before = lineText.slice(start, character - 1).trimStart();
        const lineCount = lineText.split('\n').length;
        return React.createElement(React.Fragment, null,
            React.createElement("div", { className: `resultLine noWrapInfo noselect ${node.selected ? 'selected' : ''}`, title: lineText.trim() },
                this.searchInWorkspacePreferences['search.lineNumbers'] && React.createElement("span", { className: 'theia-siw-lineNumber' }, node.line),
                React.createElement("span", null, before),
                this.renderMatchLinePart(node),
                lineCount > 1 || React.createElement("span", null, lineText.slice(node.character + node.length - 1, 250 - before.length + node.length))),
            lineCount > 1 && React.createElement("div", { className: 'match-line-num' },
                "+",
                lineCount - 1));
    }
    renderMatchLinePart(node) {
        const replaceTermLines = this._replaceTerm.split('\n');
        const replaceTerm = this.isReplacing ? React.createElement("span", { className: 'replace-term' }, replaceTermLines[0]) : '';
        const className = `match${this.isReplacing ? ' strike-through' : ''}`;
        const text = typeof node.lineText === 'string' ? node.lineText : node.lineText.text;
        const match = text.substring(node.character - 1, node.character + node.length - 1);
        const matchLines = match.split('\n');
        return React.createElement(React.Fragment, null,
            React.createElement("span", { className: className }, matchLines[0]),
            replaceTerm);
    }
    /**
     * Get the editor widget by the node.
     * @param {SearchInWorkspaceResultLineNode} node - the node representing a match in the search results.
     * @returns The editor widget to which the text replace will be done.
     */
    async doGetWidget(node) {
        const fileUri = new uri_1.default(node.fileUri);
        const editorWidget = await this.editorManager.getOrCreateByUri(fileUri);
        return editorWidget;
    }
    async doOpen(node, asDiffWidget = false, preview = false) {
        let fileUri;
        const resultNode = node.parent;
        if (resultNode && this.isReplacing && asDiffWidget) {
            const leftUri = new uri_1.default(node.fileUri);
            const rightUri = await this.createReplacePreview(resultNode);
            fileUri = browser_1.DiffUris.encode(leftUri, rightUri);
        }
        else {
            fileUri = new uri_1.default(node.fileUri);
        }
        const opts = {
            selection: {
                start: {
                    line: node.line - 1,
                    character: node.character - 1
                },
                end: this.findEndCharacterPosition(node),
            },
            mode: preview ? 'reveal' : 'activate',
            preview,
        };
        const editorWidget = await this.editorManager.open(fileUri, opts);
        if (!browser_1.DiffUris.isDiffUri(fileUri)) {
            this.decorateEditor(resultNode, editorWidget);
        }
        return editorWidget;
    }
    async createReplacePreview(node) {
        const fileUri = new uri_1.default(node.fileUri).withScheme('file');
        const openedEditor = this.editorManager.all.find(({ editor }) => editor.uri.toString() === fileUri.toString());
        let content;
        if (openedEditor) {
            content = openedEditor.editor.document.getText();
        }
        else {
            const resource = await this.fileResourceResolver.resolve(fileUri);
            content = await resource.readContents();
        }
        const searchTermRegExp = new RegExp(this.searchTerm, 'g');
        return fileUri.withScheme(common_1.MEMORY_TEXT).withQuery(content.replace(searchTermRegExp, this._replaceTerm));
    }
    decorateEditor(node, editorWidget) {
        if (!browser_1.DiffUris.isDiffUri(editorWidget.editor.uri)) {
            const key = `${editorWidget.editor.uri.toString()}#search-in-workspace-matches`;
            const oldDecorations = this.appliedDecorations.get(key) || [];
            const newDecorations = this.createEditorDecorations(node);
            const appliedDecorations = editorWidget.editor.deltaDecorations({
                newDecorations,
                oldDecorations,
            });
            this.appliedDecorations.set(key, appliedDecorations);
        }
    }
    createEditorDecorations(resultNode) {
        const decorations = [];
        if (resultNode) {
            resultNode.children.forEach(res => {
                decorations.push({
                    range: {
                        start: {
                            line: res.line - 1,
                            character: res.character - 1
                        },
                        end: {
                            line: res.line - 1,
                            character: res.character - 1 + res.length
                        }
                    },
                    options: {
                        overviewRuler: {
                            color: {
                                id: 'editor.findMatchHighlightBackground'
                            },
                            position: browser_2.OverviewRulerLane.Center
                        },
                        className: res.selected ? 'current-search-in-workspace-editor-match' : 'search-in-workspace-editor-match',
                        stickiness: browser_2.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
                    }
                });
            });
        }
        return decorations;
    }
    /**
     * Get the list of exclude globs.
     * @param excludeOptions the exclude search option.
     *
     * @returns the list of exclude globs.
     */
    getExcludeGlobs(excludeOptions) {
        const excludePreferences = this.filesystemPreferences['files.exclude'];
        const excludePreferencesGlobs = Object.keys(excludePreferences).filter(key => !!excludePreferences[key]);
        return [...new Set([...excludePreferencesGlobs, ...excludeOptions || []])];
    }
    /**
     * Compare two normalized strings.
     *
     * @param a {string} the first string.
     * @param b {string} the second string.
     */
    compare(a, b) {
        const itemA = a.toLowerCase().trim();
        const itemB = b.toLowerCase().trim();
        return itemA.localeCompare(itemB);
    }
    /**
     * @param recursive if true, all child nodes will be included in the stringified result.
     */
    nodeToString(node, recursive) {
        if (SearchInWorkspaceFileNode.is(node) || SearchInWorkspaceRootFolderNode.is(node)) {
            if (recursive) {
                return this.nodeIteratorToString(new browser_1.TopDownTreeIterator(node, { pruneSiblings: true }));
            }
            return this.labelProvider.getLongName(node.uri);
        }
        if (SearchInWorkspaceResultLineNode.is(node)) {
            return `  ${node.line}:${node.character}: ${node.lineText}`;
        }
        return '';
    }
    treeToString() {
        return this.nodeIteratorToString(this.getVisibleNodes());
    }
    *getVisibleNodes() {
        for (const { node } of this.rows.values()) {
            yield node;
        }
    }
    nodeIteratorToString(nodes) {
        const strings = [];
        for (const node of nodes) {
            const string = this.nodeToString(node, false);
            if (string.length !== 0) {
                strings.push(string);
            }
        }
        return strings.join(core_1.EOL);
    }
};
exports.SearchInWorkspaceResultTreeWidget = SearchInWorkspaceResultTreeWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_service_1.SearchInWorkspaceService),
    tslib_1.__metadata("design:type", search_in_workspace_service_1.SearchInWorkspaceService)
], SearchInWorkspaceResultTreeWidget.prototype, "searchService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], SearchInWorkspaceResultTreeWidget.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_4.FileResourceResolver),
    tslib_1.__metadata("design:type", browser_4.FileResourceResolver)
], SearchInWorkspaceResultTreeWidget.prototype, "fileResourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], SearchInWorkspaceResultTreeWidget.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.WorkspaceService),
    tslib_1.__metadata("design:type", browser_3.WorkspaceService)
], SearchInWorkspaceResultTreeWidget.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.TreeExpansionService),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceResultTreeWidget.prototype, "expansionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_preferences_1.SearchInWorkspacePreferences),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceResultTreeWidget.prototype, "searchInWorkspacePreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ProgressService),
    tslib_1.__metadata("design:type", core_1.ProgressService)
], SearchInWorkspaceResultTreeWidget.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], SearchInWorkspaceResultTreeWidget.prototype, "colorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_4.FileSystemPreferences),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceResultTreeWidget.prototype, "filesystemPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], SearchInWorkspaceResultTreeWidget.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchInWorkspaceResultTreeWidget.prototype, "init", null);
exports.SearchInWorkspaceResultTreeWidget = SearchInWorkspaceResultTreeWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(browser_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, browser_1.ContextMenuRenderer])
], SearchInWorkspaceResultTreeWidget);
(function (SearchInWorkspaceResultTreeWidget) {
    let Menus;
    (function (Menus) {
        Menus.BASE = ['siw-tree-context-menu'];
        /** Dismiss command, or others that only affect the widget itself */
        Menus.INTERNAL = [...Menus.BASE, '1_internal'];
        /** Copy a stringified representation of content */
        Menus.COPY = [...Menus.BASE, '2_copy'];
        /** Commands that lead out of the widget, like revealing a file in the navigator */
        Menus.EXTERNAL = [...Menus.BASE, '3_external'];
    })(Menus = SearchInWorkspaceResultTreeWidget.Menus || (SearchInWorkspaceResultTreeWidget.Menus = {}));
})(SearchInWorkspaceResultTreeWidget || (exports.SearchInWorkspaceResultTreeWidget = SearchInWorkspaceResultTreeWidget = {}));


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-service.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-service.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017-2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceService = exports.SearchInWorkspaceClientImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const search_in_workspace_interface_1 = __webpack_require__(/*! ../common/search-in-workspace-interface */ "../node_modules/@theia/search-in-workspace/lib/common/search-in-workspace-interface.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
/**
 * Class that will receive the search results from the server.  This is separate
 * from the SearchInWorkspaceService class only to avoid a cycle in the
 * dependency injection.
 */
let SearchInWorkspaceClientImpl = class SearchInWorkspaceClientImpl {
    onResult(searchId, result) {
        this.service.onResult(searchId, result);
    }
    onDone(searchId, error) {
        this.service.onDone(searchId, error);
    }
    setService(service) {
        this.service = service;
    }
};
exports.SearchInWorkspaceClientImpl = SearchInWorkspaceClientImpl;
exports.SearchInWorkspaceClientImpl = SearchInWorkspaceClientImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SearchInWorkspaceClientImpl);
/**
 * Service to search text in the workspace files.
 */
let SearchInWorkspaceService = class SearchInWorkspaceService {
    constructor() {
        // All the searches that we have started, that are not done yet (onDone
        // with that searchId has not been called).
        this.pendingSearches = new Map();
        // Due to the asynchronicity of the node backend, it's possible that we
        // start a search, receive an event for that search, and then receive
        // the search id for that search.We therefore need to keep those
        // events until we get the search id and return it to the caller.
        // Otherwise the caller would discard the event because it doesn't know
        // the search id yet.
        this.pendingOnDones = new Map();
        this.lastKnownSearchId = -1;
    }
    init() {
        this.client.setService(this);
    }
    isEnabled() {
        return this.workspaceService.opened;
    }
    onResult(searchId, result) {
        const callbacks = this.pendingSearches.get(searchId);
        if (callbacks) {
            callbacks.onResult(searchId, result);
        }
    }
    onDone(searchId, error) {
        const callbacks = this.pendingSearches.get(searchId);
        if (callbacks) {
            this.pendingSearches.delete(searchId);
            callbacks.onDone(searchId, error);
        }
        else {
            if (searchId > this.lastKnownSearchId) {
                this.logger.debug(`Got an onDone for a searchId we don't know about (${searchId}), stashing it for later with error = `, error);
                this.pendingOnDones.set(searchId, error);
            }
            else {
                // It's possible to receive an onDone for a search we have cancelled.  Just ignore it.
                this.logger.debug(`Got an onDone for a searchId we don't know about (${searchId}), but it's probably an old one, error = `, error);
            }
        }
    }
    // Start a search of the string "what" in the workspace.
    async search(what, callbacks, opts) {
        if (!this.workspaceService.opened) {
            throw new Error('Search failed: no workspace root.');
        }
        const roots = await this.workspaceService.roots;
        return this.doSearch(what, roots.map(r => r.resource.toString()), callbacks, opts);
    }
    async doSearch(what, rootsUris, callbacks, opts) {
        const searchId = await this.searchServer.search(what, rootsUris, opts);
        this.pendingSearches.set(searchId, callbacks);
        this.lastKnownSearchId = searchId;
        this.logger.debug('Service launched search ' + searchId);
        // Check if we received an onDone before search() returned.
        if (this.pendingOnDones.has(searchId)) {
            this.logger.debug('Ohh, we have a stashed onDone for that searchId');
            const error = this.pendingOnDones.get(searchId);
            this.pendingOnDones.delete(searchId);
            // Call the client's searchId, but first give it a
            // chance to record the returned searchId.
            setTimeout(() => {
                this.onDone(searchId, error);
            }, 0);
        }
        return searchId;
    }
    async searchWithCallback(what, rootsUris, callbacks, opts) {
        return this.doSearch(what, rootsUris, callbacks, opts);
    }
    // Cancel an ongoing search.
    cancel(searchId) {
        this.pendingSearches.delete(searchId);
        this.searchServer.cancel(searchId);
    }
};
exports.SearchInWorkspaceService = SearchInWorkspaceService;
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_interface_1.SearchInWorkspaceServer),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceService.prototype, "searchServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(SearchInWorkspaceClientImpl),
    tslib_1.__metadata("design:type", SearchInWorkspaceClientImpl)
], SearchInWorkspaceService.prototype, "client", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], SearchInWorkspaceService.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceService.prototype, "logger", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchInWorkspaceService.prototype, "init", null);
exports.SearchInWorkspaceService = SearchInWorkspaceService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SearchInWorkspaceService);


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-widget.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-widget.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var SearchInWorkspaceWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const search_in_workspace_result_tree_widget_1 = __webpack_require__(/*! ./search-in-workspace-result-tree-widget */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-result-tree-widget.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const client_1 = __webpack_require__(/*! @theia/core/shared/react-dom/client */ "../node_modules/@theia/core/shared/react-dom/client/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const search_in_workspace_context_key_service_1 = __webpack_require__(/*! ./search-in-workspace-context-key-service */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-context-key-service.js");
const progress_bar_factory_1 = __webpack_require__(/*! @theia/core/lib/browser/progress-bar-factory */ "../node_modules/@theia/core/lib/browser/progress-bar-factory.js");
const browser_3 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const search_in_workspace_preferences_1 = __webpack_require__(/*! ./search-in-workspace-preferences */ "../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-preferences.js");
const search_in_workspace_input_1 = __webpack_require__(/*! ./components/search-in-workspace-input */ "../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-input.js");
const search_in_workspace_textarea_1 = __webpack_require__(/*! ./components/search-in-workspace-textarea */ "../node_modules/@theia/search-in-workspace/lib/browser/components/search-in-workspace-textarea.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let SearchInWorkspaceWidget = SearchInWorkspaceWidget_1 = class SearchInWorkspaceWidget extends browser_1.BaseWidget {
    constructor() {
        super(...arguments);
        this.showSearchDetails = false;
        this._hasResults = false;
        this.resultNumber = 0;
        this.searchFieldContainerIsFocused = false;
        this.searchTerm = '';
        this.replaceTerm = '';
        this.searchRef = React.createRef();
        this.replaceRef = React.createRef();
        this.includeRef = React.createRef();
        this.excludeRef = React.createRef();
        this._showReplaceField = false;
        this.onDidUpdateEmitter = new common_1.Emitter();
        this.onDidUpdate = this.onDidUpdateEmitter.event;
        this.focusSearchFieldContainer = () => this.doFocusSearchFieldContainer();
        this.blurSearchFieldContainer = () => this.doBlurSearchFieldContainer();
        this.search = (e) => {
            e.persist();
            const searchOnType = this.searchInWorkspacePreferences['search.searchOnType'];
            if (searchOnType) {
                const delay = this.searchInWorkspacePreferences['search.searchOnTypeDebouncePeriod'] || 0;
                window.clearTimeout(this._searchTimeout);
                this._searchTimeout = window.setTimeout(() => this.doSearch(e), delay);
            }
        };
        this.onKeyDownSearch = (e) => {
            var _a;
            if (browser_1.Key.ENTER.keyCode === ((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode)) {
                this.searchTerm = e.target.value;
                this.performSearch();
            }
        };
        this.handleFocusSearchInputBox = (event) => {
            event.target.placeholder = SearchInWorkspaceWidget_1.LABEL + nls_1.nls.localizeByDefault(' ({0} for history)', '⇅');
            this.contextKeyService.setSearchInputBoxFocus(true);
        };
        this.handleBlurSearchInputBox = (event) => {
            event.target.placeholder = SearchInWorkspaceWidget_1.LABEL;
            this.contextKeyService.setSearchInputBoxFocus(false);
        };
        this.updateReplaceTerm = (e) => this.doUpdateReplaceTerm(e);
        this.handleFocusReplaceInputBox = (event) => {
            event.target.placeholder = nls_1.nls.localizeByDefault('Replace') + nls_1.nls.localizeByDefault(' ({0} for history)', '⇅');
            this.contextKeyService.setReplaceInputBoxFocus(true);
        };
        this.handleBlurReplaceInputBox = (event) => {
            event.target.placeholder = nls_1.nls.localizeByDefault('Replace');
            this.contextKeyService.setReplaceInputBoxFocus(false);
        };
        this.handleFocusIncludesInputBox = () => this.contextKeyService.setPatternIncludesInputBoxFocus(true);
        this.handleBlurIncludesInputBox = () => this.contextKeyService.setPatternIncludesInputBoxFocus(false);
        this.handleFocusExcludesInputBox = () => this.contextKeyService.setPatternExcludesInputBoxFocus(true);
        this.handleBlurExcludesInputBox = () => this.contextKeyService.setPatternExcludesInputBoxFocus(false);
    }
    get hasResults() {
        return this._hasResults;
    }
    set hasResults(hasResults) {
        this.contextKeyService.hasSearchResult.set(hasResults);
        this._hasResults = hasResults;
    }
    get showReplaceField() {
        return this._showReplaceField;
    }
    set showReplaceField(showReplaceField) {
        this.contextKeyService.replaceActive.set(showReplaceField);
        this._showReplaceField = showReplaceField;
    }
    init() {
        this.id = SearchInWorkspaceWidget_1.ID;
        this.title.label = SearchInWorkspaceWidget_1.LABEL;
        this.title.caption = SearchInWorkspaceWidget_1.LABEL;
        this.title.iconClass = (0, browser_1.codicon)('search');
        this.title.closable = true;
        this.contentNode = document.createElement('div');
        this.contentNode.classList.add('t-siw-search-container');
        this.searchFormContainer = document.createElement('div');
        this.searchFormContainer.classList.add('searchHeader');
        this.contentNode.appendChild(this.searchFormContainer);
        this.searchFormContainerRoot = (0, client_1.createRoot)(this.searchFormContainer);
        this.node.tabIndex = 0;
        this.node.appendChild(this.contentNode);
        this.matchCaseState = {
            className: (0, browser_1.codicon)('case-sensitive'),
            enabled: false,
            title: nls_1.nls.localizeByDefault('Match Case')
        };
        this.wholeWordState = {
            className: (0, browser_1.codicon)('whole-word'),
            enabled: false,
            title: nls_1.nls.localizeByDefault('Match Whole Word')
        };
        this.regExpState = {
            className: (0, browser_1.codicon)('regex'),
            enabled: false,
            title: nls_1.nls.localizeByDefault('Use Regular Expression')
        };
        this.includeIgnoredState = {
            className: (0, browser_1.codicon)('eye'),
            enabled: false,
            title: nls_1.nls.localize('theia/search-in-workspace/includeIgnoredFiles', 'Include Ignored Files')
        };
        this.searchInWorkspaceOptions = {
            matchCase: false,
            matchWholeWord: false,
            useRegExp: false,
            multiline: false,
            includeIgnored: false,
            include: [],
            exclude: [],
            maxResults: 2000
        };
        this.toDispose.push(this.resultTreeWidget.onChange(r => {
            this.hasResults = r.size > 0;
            this.resultNumber = 0;
            const results = Array.from(r.values());
            results.forEach(rootFolder => rootFolder.children.forEach(file => this.resultNumber += file.children.length));
            this.update();
        }));
        this.toDispose.push(this.resultTreeWidget.onFocusInput(b => {
            this.focusInputField();
        }));
        this.toDispose.push(this.searchInWorkspacePreferences.onPreferenceChanged(e => {
            if (e.preferenceName === 'search.smartCase') {
                this.performSearch();
            }
        }));
        this.toDispose.push(this.resultTreeWidget);
        this.toDispose.push(this.resultTreeWidget.onExpansionChanged(() => {
            this.onDidUpdateEmitter.fire();
        }));
        this.toDispose.push(this.progressBarFactory({ container: this.node, insertMode: 'prepend', locationId: 'search' }));
    }
    storeState() {
        var _a, _b, _c, _d;
        return {
            matchCaseState: this.matchCaseState,
            wholeWordState: this.wholeWordState,
            regExpState: this.regExpState,
            includeIgnoredState: this.includeIgnoredState,
            showSearchDetails: this.showSearchDetails,
            searchInWorkspaceOptions: this.searchInWorkspaceOptions,
            searchTerm: this.searchTerm,
            replaceTerm: this.replaceTerm,
            showReplaceField: this.showReplaceField,
            searchHistoryState: (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.state,
            replaceHistoryState: (_b = this.replaceRef.current) === null || _b === void 0 ? void 0 : _b.state,
            includeHistoryState: (_c = this.includeRef.current) === null || _c === void 0 ? void 0 : _c.state,
            excludeHistoryState: (_d = this.excludeRef.current) === null || _d === void 0 ? void 0 : _d.state,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    restoreState(oldState) {
        var _a, _b, _c, _d;
        this.matchCaseState = oldState.matchCaseState;
        this.wholeWordState = oldState.wholeWordState;
        this.regExpState = oldState.regExpState;
        this.includeIgnoredState = oldState.includeIgnoredState;
        // Override the title of the restored state, as we could have changed languages in between
        this.matchCaseState.title = nls_1.nls.localizeByDefault('Match Case');
        this.wholeWordState.title = nls_1.nls.localizeByDefault('Match Whole Word');
        this.regExpState.title = nls_1.nls.localizeByDefault('Use Regular Expression');
        this.includeIgnoredState.title = nls_1.nls.localize('theia/search-in-workspace/includeIgnoredFiles', 'Include Ignored Files');
        this.showSearchDetails = oldState.showSearchDetails;
        this.searchInWorkspaceOptions = oldState.searchInWorkspaceOptions;
        this.searchTerm = oldState.searchTerm;
        this.replaceTerm = oldState.replaceTerm;
        this.showReplaceField = oldState.showReplaceField;
        this.resultTreeWidget.replaceTerm = this.replaceTerm;
        this.resultTreeWidget.showReplaceButtons = this.showReplaceField;
        (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.setState(oldState.searchHistoryState);
        (_b = this.replaceRef.current) === null || _b === void 0 ? void 0 : _b.setState(oldState.replaceHistoryState);
        (_c = this.includeRef.current) === null || _c === void 0 ? void 0 : _c.setState(oldState.includeHistoryState);
        (_d = this.excludeRef.current) === null || _d === void 0 ? void 0 : _d.setState(oldState.excludeHistoryState);
        this.refresh();
    }
    findInFolder(uris) {
        this.showSearchDetails = true;
        const values = Array.from(new Set(uris.map(uri => `${uri}/**`)));
        const value = values.join(', ');
        this.searchInWorkspaceOptions.include = values;
        if (this.includeRef.current) {
            this.includeRef.current.value = value;
            this.includeRef.current.addToHistory();
        }
        this.update();
    }
    /**
     * Update the search term and input field.
     * @param term the search term.
     * @param showReplaceField controls if the replace field should be displayed.
     */
    updateSearchTerm(term, showReplaceField) {
        this.searchTerm = term;
        if (this.searchRef.current) {
            this.searchRef.current.value = term;
            this.searchRef.current.addToHistory();
        }
        if (showReplaceField) {
            this.showReplaceField = true;
        }
        this.refresh();
    }
    hasResultList() {
        return this.hasResults;
    }
    hasSearchTerm() {
        return this.searchTerm !== '';
    }
    refresh() {
        this.performSearch();
        this.update();
    }
    getCancelIndicator() {
        return this.resultTreeWidget.cancelIndicator;
    }
    collapseAll() {
        this.resultTreeWidget.collapseAll();
        this.update();
    }
    expandAll() {
        this.resultTreeWidget.expandAll();
        this.update();
    }
    areResultsCollapsed() {
        return this.resultTreeWidget.areResultsCollapsed();
    }
    clear() {
        this.searchTerm = '';
        this.replaceTerm = '';
        this.searchInWorkspaceOptions.include = [];
        this.searchInWorkspaceOptions.exclude = [];
        this.includeIgnoredState.enabled = false;
        this.matchCaseState.enabled = false;
        this.wholeWordState.enabled = false;
        this.regExpState.enabled = false;
        if (this.searchRef.current) {
            this.searchRef.current.value = '';
        }
        if (this.replaceRef.current) {
            this.replaceRef.current.value = '';
        }
        if (this.includeRef.current) {
            this.includeRef.current.value = '';
        }
        if (this.excludeRef.current) {
            this.excludeRef.current.value = '';
        }
        this.performSearch();
        this.update();
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.searchFormContainerRoot.render(React.createElement(React.Fragment, null,
            this.renderSearchHeader(),
            this.renderSearchInfo()));
        browser_1.Widget.attach(this.resultTreeWidget, this.contentNode);
        this.toDisposeOnDetach.push(common_1.Disposable.create(() => {
            browser_1.Widget.detach(this.resultTreeWidget);
        }));
    }
    onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        const searchInfo = this.renderSearchInfo();
        if (searchInfo) {
            this.searchFormContainerRoot.render(React.createElement(React.Fragment, null,
                this.renderSearchHeader(),
                searchInfo));
            this.onDidUpdateEmitter.fire(undefined);
        }
    }
    onResize(msg) {
        var _a, _b;
        super.onResize(msg);
        (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.forceUpdate();
        (_b = this.replaceRef.current) === null || _b === void 0 ? void 0 : _b.forceUpdate();
        browser_1.MessageLoop.sendMessage(this.resultTreeWidget, browser_1.Widget.ResizeMessage.UnknownSize);
    }
    onAfterShow(msg) {
        super.onAfterShow(msg);
        this.focusInputField();
        this.contextKeyService.searchViewletVisible.set(true);
    }
    onAfterHide(msg) {
        super.onAfterHide(msg);
        this.contextKeyService.searchViewletVisible.set(false);
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.focusInputField();
    }
    focusInputField() {
        const f = document.getElementById('search-input-field');
        if (f) {
            f.focus();
            f.select();
        }
    }
    renderSearchHeader() {
        const searchAndReplaceContainer = this.renderSearchAndReplace();
        const searchDetails = this.renderSearchDetails();
        return React.createElement("div", null,
            searchAndReplaceContainer,
            searchDetails);
    }
    renderSearchAndReplace() {
        const toggleContainer = this.renderReplaceFieldToggle();
        const searchField = this.renderSearchField();
        const replaceField = this.renderReplaceField();
        return React.createElement("div", { className: 'search-and-replace-container' },
            toggleContainer,
            React.createElement("div", { className: 'search-and-replace-fields' },
                searchField,
                replaceField));
    }
    renderReplaceFieldToggle() {
        const toggle = React.createElement("span", { className: (0, browser_1.codicon)(this.showReplaceField ? 'chevron-down' : 'chevron-right') });
        return React.createElement("div", { title: nls_1.nls.localizeByDefault('Toggle Replace'), className: 'replace-toggle', tabIndex: 0, onClick: e => {
                const elArr = document.getElementsByClassName('replace-toggle');
                if (elArr && elArr.length > 0) {
                    elArr[0].focus();
                }
                this.showReplaceField = !this.showReplaceField;
                this.resultTreeWidget.showReplaceButtons = this.showReplaceField;
                this.update();
            } }, toggle);
    }
    renderNotification() {
        if (this.workspaceService.tryGetRoots().length <= 0 && this.editorManager.all.length <= 0) {
            return React.createElement("div", { className: 'search-notification show' },
                React.createElement("div", null, nls_1.nls.localize('theia/search-in-workspace/noFolderSpecified', 'You have not opened or specified a folder. Only open files are currently searched.')));
        }
        return React.createElement("div", { className: `search-notification ${this.searchInWorkspaceOptions.maxResults && this.resultNumber >= this.searchInWorkspaceOptions.maxResults ? 'show' : ''}` },
            React.createElement("div", null, nls_1.nls.localize('theia/search-in-workspace/resultSubset', 'This is only a subset of all results. Use a more specific search term to narrow down the result list.')));
    }
    doFocusSearchFieldContainer() {
        this.searchFieldContainerIsFocused = true;
        this.update();
    }
    doBlurSearchFieldContainer() {
        this.searchFieldContainerIsFocused = false;
        this.update();
    }
    doSearch(e) {
        var _a;
        if (e.target) {
            const searchValue = e.target.value;
            if (this.searchTerm === searchValue && browser_1.Key.ENTER.keyCode !== ((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode)) {
                return;
            }
            else {
                this.searchTerm = searchValue;
                this.performSearch();
            }
        }
    }
    performSearch() {
        const searchOptions = {
            ...this.searchInWorkspaceOptions,
            followSymlinks: this.shouldFollowSymlinks(),
            matchCase: this.shouldMatchCase(),
            multiline: this.searchTerm.includes('\n')
        };
        this.resultTreeWidget.search(this.searchTerm, searchOptions);
    }
    shouldFollowSymlinks() {
        return this.searchInWorkspacePreferences['search.followSymlinks'];
    }
    /**
     * Determine if search should be case sensitive.
     */
    shouldMatchCase() {
        if (this.matchCaseState.enabled) {
            return this.matchCaseState.enabled;
        }
        // search.smartCase makes siw search case-sensitive if the search term contains uppercase letter(s).
        return (!!this.searchInWorkspacePreferences['search.smartCase']
            && this.searchTerm !== this.searchTerm.toLowerCase());
    }
    renderSearchField() {
        const input = React.createElement(search_in_workspace_textarea_1.SearchInWorkspaceTextArea, { id: 'search-input-field', className: 'theia-input', title: SearchInWorkspaceWidget_1.LABEL, placeholder: SearchInWorkspaceWidget_1.LABEL, defaultValue: this.searchTerm, autoComplete: 'off', onKeyUp: this.search, onKeyDown: this.onKeyDownSearch, onFocus: this.handleFocusSearchInputBox, onBlur: this.handleBlurSearchInputBox, ref: this.searchRef });
        const notification = this.renderNotification();
        const optionContainer = this.renderOptionContainer();
        const tooMany = this.searchInWorkspaceOptions.maxResults && this.resultNumber >= this.searchInWorkspaceOptions.maxResults ? 'tooManyResults' : '';
        const className = `search-field-container ${tooMany} ${this.searchFieldContainerIsFocused ? 'focused' : ''}`;
        return React.createElement("div", { className: className },
            React.createElement("div", { className: 'search-field', tabIndex: -1, onFocus: this.focusSearchFieldContainer, onBlur: this.blurSearchFieldContainer },
                input,
                optionContainer),
            notification);
    }
    doUpdateReplaceTerm(e) {
        var _a;
        if (e.target) {
            this.replaceTerm = e.target.value;
            this.resultTreeWidget.replaceTerm = this.replaceTerm;
            if (((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode) === browser_1.Key.ENTER.keyCode) {
                this.performSearch();
            }
            this.update();
        }
    }
    renderReplaceField() {
        const replaceAllButtonContainer = this.renderReplaceAllButtonContainer();
        const replace = nls_1.nls.localizeByDefault('Replace');
        return React.createElement("div", { className: `replace-field${this.showReplaceField ? '' : ' hidden'}` },
            React.createElement(search_in_workspace_textarea_1.SearchInWorkspaceTextArea, { id: 'replace-input-field', className: 'theia-input', title: replace, placeholder: replace, defaultValue: this.replaceTerm, autoComplete: 'off', onKeyUp: this.updateReplaceTerm, onFocus: this.handleFocusReplaceInputBox, onBlur: this.handleBlurReplaceInputBox, ref: this.replaceRef }),
            replaceAllButtonContainer);
    }
    renderReplaceAllButtonContainer() {
        // The `Replace All` button is enabled if there is a search term present with results.
        const enabled = this.searchTerm !== '' && this.resultNumber > 0;
        return React.createElement("div", { className: 'replace-all-button-container' },
            React.createElement("span", { title: nls_1.nls.localizeByDefault('Replace All'), className: `${(0, browser_1.codicon)('replace-all', true)} ${enabled ? ' ' : ' disabled'}`, onClick: () => {
                    if (enabled) {
                        this.resultTreeWidget.replace(undefined);
                    }
                } }));
    }
    renderOptionContainer() {
        const matchCaseOption = this.renderOptionElement(this.matchCaseState);
        const wholeWordOption = this.renderOptionElement(this.wholeWordState);
        const regexOption = this.renderOptionElement(this.regExpState);
        const includeIgnoredOption = this.renderOptionElement(this.includeIgnoredState);
        return React.createElement("div", { className: 'option-buttons' },
            matchCaseOption,
            wholeWordOption,
            regexOption,
            includeIgnoredOption);
    }
    renderOptionElement(opt) {
        return React.createElement("span", { className: `${opt.className} option action-label ${opt.enabled ? 'enabled' : ''}`, title: opt.title, onClick: () => this.handleOptionClick(opt) });
    }
    handleOptionClick(option) {
        option.enabled = !option.enabled;
        this.updateSearchOptions();
        this.searchFieldContainerIsFocused = true;
        this.performSearch();
        this.update();
    }
    updateSearchOptions() {
        this.searchInWorkspaceOptions.matchCase = this.matchCaseState.enabled;
        this.searchInWorkspaceOptions.matchWholeWord = this.wholeWordState.enabled;
        this.searchInWorkspaceOptions.useRegExp = this.regExpState.enabled;
        this.searchInWorkspaceOptions.includeIgnored = this.includeIgnoredState.enabled;
    }
    renderSearchDetails() {
        const expandButton = this.renderExpandGlobFieldsButton();
        const globFieldContainer = this.renderGlobFieldContainer();
        return React.createElement("div", { className: 'search-details' },
            expandButton,
            globFieldContainer);
    }
    renderGlobFieldContainer() {
        const includeField = this.renderGlobField('include');
        const excludeField = this.renderGlobField('exclude');
        return React.createElement("div", { className: `glob-field-container${!this.showSearchDetails ? ' hidden' : ''}` },
            includeField,
            excludeField);
    }
    renderExpandGlobFieldsButton() {
        return React.createElement("div", { className: 'button-container' },
            React.createElement("span", { title: nls_1.nls.localizeByDefault('Toggle Search Details'), className: (0, browser_1.codicon)('ellipsis'), onClick: () => {
                    this.showSearchDetails = !this.showSearchDetails;
                    this.update();
                } }));
    }
    renderGlobField(kind) {
        const currentValue = this.searchInWorkspaceOptions[kind];
        const value = currentValue && currentValue.join(', ') || '';
        return React.createElement("div", { className: 'glob-field' },
            React.createElement("div", { className: 'label' }, nls_1.nls.localizeByDefault('files to ' + kind)),
            React.createElement(search_in_workspace_input_1.SearchInWorkspaceInput, { className: 'theia-input', type: 'text', size: 1, defaultValue: value, autoComplete: 'off', id: kind + '-glob-field', placeholder: kind === 'include'
                    ? nls_1.nls.localizeByDefault('e.g. *.ts, src/**/include')
                    : nls_1.nls.localizeByDefault('e.g. *.ts, src/**/exclude'), onKeyUp: e => {
                    var _a;
                    if (e.target) {
                        const targetValue = e.target.value || '';
                        let shouldSearch = browser_1.Key.ENTER.keyCode === ((_a = browser_1.KeyCode.createKeyCode(e.nativeEvent).key) === null || _a === void 0 ? void 0 : _a.keyCode);
                        const currentOptions = (this.searchInWorkspaceOptions[kind] || []).slice().map(s => s.trim()).sort();
                        const candidateOptions = this.splitOnComma(targetValue).map(s => s.trim()).sort();
                        const sameAs = (left, right) => {
                            if (left.length !== right.length) {
                                return false;
                            }
                            for (let i = 0; i < left.length; i++) {
                                if (left[i] !== right[i]) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        if (!sameAs(currentOptions, candidateOptions)) {
                            this.searchInWorkspaceOptions[kind] = this.splitOnComma(targetValue);
                            shouldSearch = true;
                        }
                        if (shouldSearch) {
                            this.performSearch();
                        }
                    }
                }, onFocus: kind === 'include' ? this.handleFocusIncludesInputBox : this.handleFocusExcludesInputBox, onBlur: kind === 'include' ? this.handleBlurIncludesInputBox : this.handleBlurExcludesInputBox, ref: kind === 'include' ? this.includeRef : this.excludeRef }));
    }
    splitOnComma(patterns) {
        return patterns.length > 0 ? patterns.split(',').map(s => s.trim()) : [];
    }
    renderSearchInfo() {
        const message = this.getSearchResultMessage() || '';
        return React.createElement("div", { className: 'search-info' }, message);
    }
    getSearchResultMessage() {
        if (!this.searchTerm) {
            return undefined;
        }
        if (this.resultNumber === 0) {
            const isIncludesPresent = this.searchInWorkspaceOptions.include && this.searchInWorkspaceOptions.include.length > 0;
            const isExcludesPresent = this.searchInWorkspaceOptions.exclude && this.searchInWorkspaceOptions.exclude.length > 0;
            let message;
            if (isIncludesPresent && isExcludesPresent) {
                message = nls_1.nls.localizeByDefault("No results found in '{0}' excluding '{1}' - ", this.searchInWorkspaceOptions.include.toString(), this.searchInWorkspaceOptions.exclude.toString());
            }
            else if (isIncludesPresent) {
                message = nls_1.nls.localizeByDefault("No results found in '{0}' - ", this.searchInWorkspaceOptions.include.toString());
            }
            else if (isExcludesPresent) {
                message = nls_1.nls.localizeByDefault("No results found excluding '{0}' - ", this.searchInWorkspaceOptions.exclude.toString());
            }
            else {
                message = nls_1.nls.localizeByDefault('No results found') + ' - ';
            }
            // We have to trim here as vscode will always add a trailing " - " string
            return message.substring(0, message.length - 2).trim();
        }
        else {
            if (this.resultNumber === 1 && this.resultTreeWidget.fileNumber === 1) {
                return nls_1.nls.localizeByDefault('{0} result in {1} file', this.resultNumber.toString(), this.resultTreeWidget.fileNumber.toString());
            }
            else if (this.resultTreeWidget.fileNumber === 1) {
                return nls_1.nls.localizeByDefault('{0} results in {1} file', this.resultNumber.toString(), this.resultTreeWidget.fileNumber.toString());
            }
            else if (this.resultTreeWidget.fileNumber > 0) {
                return nls_1.nls.localizeByDefault('{0} results in {1} files', this.resultNumber.toString(), this.resultTreeWidget.fileNumber.toString());
            }
            else {
                // if fileNumber === 0, return undefined so that `onUpdateRequest()` would not re-render component
                return undefined;
            }
        }
    }
};
exports.SearchInWorkspaceWidget = SearchInWorkspaceWidget;
SearchInWorkspaceWidget.ID = 'search-in-workspace';
SearchInWorkspaceWidget.LABEL = nls_1.nls.localizeByDefault('Search');
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_result_tree_widget_1.SearchInWorkspaceResultTreeWidget),
    tslib_1.__metadata("design:type", search_in_workspace_result_tree_widget_1.SearchInWorkspaceResultTreeWidget)
], SearchInWorkspaceWidget.prototype, "resultTreeWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], SearchInWorkspaceWidget.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_context_key_service_1.SearchInWorkspaceContextKeyService),
    tslib_1.__metadata("design:type", search_in_workspace_context_key_service_1.SearchInWorkspaceContextKeyService)
], SearchInWorkspaceWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(progress_bar_factory_1.ProgressBarFactory),
    tslib_1.__metadata("design:type", Function)
], SearchInWorkspaceWidget.prototype, "progressBarFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.EditorManager),
    tslib_1.__metadata("design:type", browser_3.EditorManager)
], SearchInWorkspaceWidget.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(search_in_workspace_preferences_1.SearchInWorkspacePreferences),
    tslib_1.__metadata("design:type", Object)
], SearchInWorkspaceWidget.prototype, "searchInWorkspacePreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], SearchInWorkspaceWidget.prototype, "init", null);
exports.SearchInWorkspaceWidget = SearchInWorkspaceWidget = SearchInWorkspaceWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SearchInWorkspaceWidget);


/***/ }),

/***/ "../node_modules/@theia/search-in-workspace/lib/common/search-in-workspace-interface.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@theia/search-in-workspace/lib/common/search-in-workspace-interface.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017-2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchInWorkspaceServer = exports.SIW_WS_PATH = exports.SearchInWorkspaceClient = exports.SearchInWorkspaceResult = void 0;
var SearchInWorkspaceResult;
(function (SearchInWorkspaceResult) {
    /**
     * Sort search in workspace results according to file, line, character position
     * and then length.
     */
    function compare(a, b) {
        if (a.fileUri !== b.fileUri) {
            return a.fileUri < b.fileUri ? -1 : 1;
        }
        return 0;
    }
    SearchInWorkspaceResult.compare = compare;
})(SearchInWorkspaceResult || (exports.SearchInWorkspaceResult = SearchInWorkspaceResult = {}));
exports.SearchInWorkspaceClient = Symbol('SearchInWorkspaceClient');
exports.SIW_WS_PATH = '/services/search-in-workspace';
exports.SearchInWorkspaceServer = Symbol('SearchInWorkspaceServer');


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/index.js":
/*!********************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./task-service */ "../node_modules/@theia/task/lib/browser/task-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-contribution */ "../node_modules/@theia/task/lib/browser/task-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-problem-matcher-registry */ "../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-problem-pattern-registry */ "../node_modules/@theia/task/lib/browser/task-problem-pattern-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-schema-updater */ "../node_modules/@theia/task/lib/browser/task-schema-updater.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/provided-task-configurations.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/provided-task-configurations.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProvidedTaskConfigurations = exports.ALL_TASK_TYPES = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const task_contribution_1 = __webpack_require__(/*! ./task-contribution */ "../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
exports.ALL_TASK_TYPES = '*';
let ProvidedTaskConfigurations = class ProvidedTaskConfigurations {
    constructor() {
        /**
         * Map of source (name of extension, or path of root folder that the task config comes from) and `task config map`.
         * For the second level of inner map, the key is task label.
         * For the third level of inner map, the key is the task scope and value TaskConfiguration.
         */
        this.tasksMap = new Map();
        this.currentToken = 0;
        this.activatedProvidersTypes = [];
        this.nextToken = 1;
    }
    startUserAction() {
        return this.nextToken++;
    }
    updateUserAction(token) {
        if (this.currentToken !== token) {
            this.currentToken = token;
            this.activatedProvidersTypes.length = 0;
        }
    }
    pushActivatedProvidersType(taskType) {
        if (!this.activatedProvidersTypes.includes(taskType)) {
            this.activatedProvidersTypes.push(taskType);
        }
    }
    isTaskProviderActivationNeeded(taskType) {
        if (!taskType || this.activatedProvidersTypes.includes(taskType) || this.activatedProvidersTypes.includes(exports.ALL_TASK_TYPES)) {
            return false;
        }
        return true;
    }
    /**
     * Activate providers for the given taskType
     * @param taskType A specific task type or '*' to indicate all task providers
     */
    async activateProviders(taskType) {
        if (!!taskType) {
            await this.taskProviderRegistry.activateProvider(taskType);
            this.pushActivatedProvidersType(taskType);
        }
    }
    /** returns a list of provided tasks matching an optional given type, or all if '*' is used */
    async getTasks(token, type) {
        await this.refreshTasks(token, type);
        const tasks = [];
        for (const taskLabelMap of this.tasksMap.values()) {
            for (const taskScopeMap of taskLabelMap.values()) {
                for (const task of taskScopeMap.values()) {
                    if (!type || task.type === type || type === exports.ALL_TASK_TYPES) {
                        tasks.push(task);
                    }
                }
            }
        }
        return tasks;
    }
    async refreshTasks(token, taskType) {
        const newProviderActivationNeeded = this.isTaskProviderActivationNeeded(taskType);
        if (token !== this.currentToken || newProviderActivationNeeded) {
            this.updateUserAction(token);
            await this.activateProviders(taskType);
            const providers = await this.taskProviderRegistry.getProviders();
            const providedTasks = (await Promise.all(providers.map(p => this.resolveTaskConfigurations(p))))
                .reduce((acc, taskArray) => acc.concat(taskArray), []);
            this.cacheTasks(providedTasks);
        }
    }
    async resolveTaskConfigurations(taskProvider) {
        return (await taskProvider.provideTasks())
            // Global/User tasks from providers are not supported.
            .filter(task => task.scope !== common_1.TaskScope.Global)
            .map(providedTask => {
            const originalPresentation = providedTask.presentation || {};
            return {
                ...providedTask,
                presentation: {
                    ...common_1.TaskOutputPresentation.getDefault(),
                    ...originalPresentation
                }
            };
        });
    }
    /** returns the task configuration for a given source and label or undefined if none */
    async getTask(token, source, taskLabel, scope) {
        await this.refreshTasks(token);
        return this.getCachedTask(source, taskLabel, scope);
    }
    /**
     * Finds the detected task for the given task customization.
     * The detected task is considered as a "match" to the task customization if it has all the `required` properties.
     * In case that more than one customization is found, return the one that has the biggest number of matched properties.
     *
     * @param customization the task customization
     * @return the detected task for the given task customization. If the task customization is not found, `undefined` is returned.
     */
    async getTaskToCustomize(token, customization, scope) {
        const definition = this.taskDefinitionRegistry.getDefinition(customization);
        if (!definition) {
            return undefined;
        }
        const matchedTasks = [];
        let highest = -1;
        const tasks = await this.getTasks(token, customization.type);
        for (const task of tasks) { // find detected tasks that match the `definition`
            const required = definition.properties.required || [];
            if (!required.every(requiredProp => customization[requiredProp] !== undefined)) {
                continue;
            }
            let score = required.length; // number of required properties
            const requiredProps = new Set(required);
            // number of optional properties
            score += definition.properties.all.filter(p => !requiredProps.has(p) && customization[p] !== undefined).length;
            if (score >= highest) {
                if (score > highest) {
                    highest = score;
                    matchedTasks.length = 0;
                }
                matchedTasks.push(task);
            }
        }
        // Tasks with scope set to 'Workspace' can be customized in a workspace root, and will not match
        // providers scope 'TaskScope.Workspace' unless specifically included as below.
        const scopes = [scope, common_1.TaskScope.Workspace];
        // find the task that matches the `customization`.
        // The scenario where more than one match is found should not happen unless users manually enter multiple customizations for one type of task
        // If this does happen, return the first match
        const matchedTask = matchedTasks.find(t => scopes.some(scp => scp === t._scope) && definition.properties.all.every(p => t[p] === customization[p]));
        return matchedTask;
    }
    getCachedTask(source, taskLabel, scope) {
        const labelConfigMap = this.tasksMap.get(source);
        if (labelConfigMap) {
            const scopeConfigMap = labelConfigMap.get(taskLabel);
            if (scopeConfigMap) {
                if (scope) {
                    return scopeConfigMap.get(scope.toString());
                }
                return Array.from(scopeConfigMap.values())[0];
            }
        }
    }
    cacheTasks(tasks) {
        this.tasksMap.clear();
        for (const task of tasks) {
            const label = task.label;
            const source = task._source;
            const scope = task._scope;
            if (this.tasksMap.has(source)) {
                const labelConfigMap = this.tasksMap.get(source);
                if (labelConfigMap.has(label)) {
                    labelConfigMap.get(label).set(scope.toString(), task);
                }
                else {
                    const newScopeConfigMap = new Map();
                    newScopeConfigMap.set(scope.toString(), task);
                    labelConfigMap.set(label, newScopeConfigMap);
                }
            }
            else {
                const newLabelConfigMap = new Map();
                const newScopeConfigMap = new Map();
                newScopeConfigMap.set(scope.toString(), task);
                newLabelConfigMap.set(label, newScopeConfigMap);
                this.tasksMap.set(source, newLabelConfigMap);
            }
        }
    }
};
exports.ProvidedTaskConfigurations = ProvidedTaskConfigurations;
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskProviderRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskProviderRegistry)
], ProvidedTaskConfigurations.prototype, "taskProviderRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], ProvidedTaskConfigurations.prototype, "taskDefinitionRegistry", void 0);
exports.ProvidedTaskConfigurations = ProvidedTaskConfigurations = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ProvidedTaskConfigurations);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/quick-open-task.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/quick-open-task.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var QuickOpenTask_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskRestartRunningQuickOpen = exports.RunningTaskQuickOpenItem = exports.TaskRunningQuickOpen = exports.TaskTerminateQuickOpen = exports.TaskConfigureQuickOpenItem = exports.ConfigureBuildOrTestTaskQuickOpenItem = exports.TaskRunQuickOpenItem = exports.QuickOpenTask = exports.SHOW_ALL = exports.NO_TASK_TO_RUN = exports.CONFIGURE_A_TASK = exports.CHOOSE_TASK = exports.TaskEntry = exports.ConfigureTaskAction = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const task_service_1 = __webpack_require__(/*! ./task-service */ "../node_modules/@theia/task/lib/browser/task-service.js");
const task_protocol_1 = __webpack_require__(/*! ../common/task-protocol */ "../node_modules/@theia/task/lib/common/task-protocol.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const provided_task_configurations_1 = __webpack_require__(/*! ./provided-task-configurations */ "../node_modules/@theia/task/lib/browser/provided-task-configurations.js");
const task_name_resolver_1 = __webpack_require__(/*! ./task-name-resolver */ "../node_modules/@theia/task/lib/browser/task-name-resolver.js");
const task_source_resolver_1 = __webpack_require__(/*! ./task-source-resolver */ "../node_modules/@theia/task/lib/browser/task-source-resolver.js");
const task_configuration_manager_1 = __webpack_require__(/*! ./task-configuration-manager */ "../node_modules/@theia/task/lib/browser/task-configuration-manager.js");
const quick_input_service_1 = __webpack_require__(/*! @theia/core/lib/browser/quick-input/quick-input-service */ "../node_modules/@theia/core/lib/browser/quick-input/quick-input-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
const pickerQuickAccess_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/quickinput/browser/pickerQuickAccess */ "../node_modules/@theia/monaco-editor-core/esm/vs/platform/quickinput/browser/pickerQuickAccess.js");
var ConfigureTaskAction;
(function (ConfigureTaskAction) {
    ConfigureTaskAction.ID = 'workbench.action.tasks.configureTaskRunner';
    ConfigureTaskAction.TEXT = 'Configure Task';
})(ConfigureTaskAction || (exports.ConfigureTaskAction = ConfigureTaskAction = {}));
var TaskEntry;
(function (TaskEntry) {
    function isQuickPickValue(item) {
        return 'value' in item && typeof item.value === 'string';
    }
    TaskEntry.isQuickPickValue = isQuickPickValue;
})(TaskEntry || (exports.TaskEntry = TaskEntry = {}));
exports.CHOOSE_TASK = nls_1.nls.localizeByDefault('Select the task to run');
exports.CONFIGURE_A_TASK = nls_1.nls.localizeByDefault('Configure a Task');
exports.NO_TASK_TO_RUN = nls_1.nls.localize('theia/task/noTaskToRun', 'No task to run found. Configure Tasks...');
exports.SHOW_ALL = nls_1.nls.localizeByDefault('Show All Tasks...');
let QuickOpenTask = QuickOpenTask_1 = class QuickOpenTask {
    constructor() {
        this.description = 'Run Task';
        this.items = [];
    }
    init() {
        return this.doInit(this.taskService.startUserAction());
    }
    async doInit(token) {
        const recentTasks = this.taskService.recentTasks;
        const configuredTasks = await this.taskService.getConfiguredTasks(token);
        const providedTypes = this.taskDefinitionRegistry.getAll();
        const { filteredRecentTasks, filteredConfiguredTasks } = this.getFilteredTasks(recentTasks, configuredTasks, []);
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        this.items = [];
        const filteredRecentTasksItems = this.getItems(filteredRecentTasks, 'recently used tasks', token, isMulti);
        const filteredConfiguredTasksItems = this.getItems(filteredConfiguredTasks, 'configured tasks', token, isMulti, {
            label: `$(plus) ${exports.CONFIGURE_A_TASK}`,
            execute: () => this.configure()
        });
        const providedTypeItems = this.createProvidedTypeItems(providedTypes);
        this.items.push(...filteredRecentTasksItems, ...filteredConfiguredTasksItems, ...providedTypeItems);
        if (!this.items.length) {
            this.items.push(({
                label: exports.NO_TASK_TO_RUN,
                execute: () => this.configure()
            }));
        }
    }
    createProvidedTypeItems(providedTypes) {
        const result = [];
        result.push({ type: 'separator', label: nls_1.nls.localizeByDefault('contributed') });
        providedTypes.sort((t1, t2) => t1.taskType.localeCompare(t2.taskType));
        for (const definition of providedTypes) {
            const type = definition.taskType;
            result.push(this.toProvidedTaskTypeEntry(type, `$(folder) ${type}`));
        }
        result.push(this.toProvidedTaskTypeEntry(exports.SHOW_ALL, exports.SHOW_ALL));
        return result;
    }
    toProvidedTaskTypeEntry(type, label) {
        return {
            label,
            value: type,
            /**
             * This function is used in the context of a QuickAccessProvider (triggered from the command palette: '?task').
             * It triggers a call to QuickOpenTask#getPicks,
             * the 'execute' function below is called when the user selects an entry for a task type which triggers the display of
             * the second level quick pick.
             *
             * Due to the asynchronous resolution of second-level tasks, there may be a delay in showing the quick input widget.
             *
             * NOTE: The widget is not delayed in other contexts e.g. by commands (Run Tasks), see the implementation at QuickOpenTask#open
             *
             * To improve the performance, we may consider using a `PickerQuickAccessProvider` instead of a `QuickAccessProvider`,
             * and support providing 'FastAndSlowPicks'.
             *
             * TODO: Consider the introduction and exposure of monaco `PickerQuickAccessProvider` and the corresponding refactoring for this and other
             * users of QuickAccessProvider.
             */
            execute: () => {
                this.doSecondLevel(type);
            }
        };
    }
    onDidTriggerGearIcon(item) {
        if (item instanceof TaskRunQuickOpenItem) {
            this.taskService.configure(item.token, item.task);
            this.quickInputService.hide();
        }
    }
    async open() {
        this.showMultiLevelQuickPick();
    }
    async showMultiLevelQuickPick(skipInit) {
        if (!skipInit) {
            await this.init();
        }
        const picker = this.quickInputService.createQuickPick();
        picker.placeholder = exports.CHOOSE_TASK;
        picker.matchOnDescription = true;
        picker.ignoreFocusOut = false;
        picker.items = this.items;
        picker.onDidTriggerItemButton(({ item }) => this.onDidTriggerGearIcon(item));
        const firstLevelTask = await this.doPickerFirstLevel(picker);
        if (!!firstLevelTask && TaskEntry.isQuickPickValue(firstLevelTask)) {
            // A taskType was selected
            picker.busy = true;
            await this.doSecondLevel(firstLevelTask.value);
        }
        else if (!!firstLevelTask && 'execute' in firstLevelTask && typeof firstLevelTask.execute === 'function') {
            firstLevelTask.execute();
        }
        picker.dispose();
    }
    async doPickerFirstLevel(picker) {
        picker.show();
        const firstLevelPickerResult = await new Promise(resolve => {
            picker.onDidAccept(async () => {
                resolve(picker.selectedItems ? picker.selectedItems[0] : undefined);
            });
        });
        return firstLevelPickerResult !== null && firstLevelPickerResult !== void 0 ? firstLevelPickerResult : undefined;
    }
    async doSecondLevel(taskType) {
        var _a;
        // Resolve Second level tasks based on selected TaskType
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        const token = this.taskService.startUserAction();
        const providedTasks = taskType === exports.SHOW_ALL ?
            await this.taskService.getProvidedTasks(token, provided_task_configurations_1.ALL_TASK_TYPES) :
            await this.taskService.getProvidedTasks(token, taskType);
        const providedTasksItems = this.getItems(providedTasks, taskType + ' tasks', token, isMulti);
        const label = providedTasksItems.length ?
            nls_1.nls.localizeByDefault('Go back ↩') :
            nls_1.nls.localizeByDefault('No {0} tasks found. Go back ↩', taskType);
        providedTasksItems.push(({
            label,
            execute: () => this.showMultiLevelQuickPick(true)
        }));
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(providedTasksItems, {
            placeholder: exports.CHOOSE_TASK,
            onDidTriggerItemButton: ({ item }) => this.onDidTriggerGearIcon(item)
        });
    }
    attach() {
        this.items = [];
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        this.taskService.getRunningTasks().then(tasks => {
            var _a;
            if (!tasks.length) {
                this.items.push({
                    label: 'No tasks found',
                });
            }
            else {
                tasks.forEach((task) => {
                    // can only attach to terminal processes, so only list those
                    if (task.terminalId) {
                        this.items.push(new RunningTaskQuickOpenItem(task, this.taskService, this.taskNameResolver, this.taskSourceResolver, this.taskDefinitionRegistry, this.labelProvider, isMulti, () => this.taskService.attach(task.terminalId, task)));
                    }
                });
            }
            if (this.items.length === 0) {
                this.items.push(({
                    label: 'No tasks found'
                }));
            }
            (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(this.items, { placeholder: exports.CHOOSE_TASK });
        });
    }
    async configure() {
        var _a;
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.pick(this.resolveItemsToConfigure(), { placeHolder: nls_1.nls.localizeByDefault('Select a task to configure') }).then(async (item) => {
            if (item && 'execute' in item && typeof item.execute === 'function') {
                item.execute();
            }
        });
    }
    async resolveItemsToConfigure() {
        const items = [];
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        const token = this.taskService.startUserAction();
        const configuredTasks = await this.taskService.getConfiguredTasks(token);
        const providedTasks = await this.taskService.getProvidedTasks(token, provided_task_configurations_1.ALL_TASK_TYPES);
        // check if tasks.json exists. If not, display "Create tasks.json file from template"
        // If tasks.json exists and empty, display 'Open tasks.json file'
        const { filteredConfiguredTasks, filteredProvidedTasks } = this.getFilteredTasks([], configuredTasks, providedTasks);
        const groupedTasks = this.getGroupedTasksByWorkspaceFolder([...filteredConfiguredTasks, ...filteredProvidedTasks]);
        if (groupedTasks.has(task_protocol_1.TaskScope.Global.toString())) {
            const configs = groupedTasks.get(task_protocol_1.TaskScope.Global.toString());
            this.addConfigurationItems(items, configs, token, isMulti);
        }
        if (groupedTasks.has(task_protocol_1.TaskScope.Workspace.toString())) {
            const configs = groupedTasks.get(task_protocol_1.TaskScope.Workspace.toString());
            this.addConfigurationItems(items, configs, token, isMulti);
        }
        const rootUris = (await this.workspaceService.roots).map(rootStat => rootStat.resource.toString());
        for (const rootFolder of rootUris) {
            const folderName = new uri_1.default(rootFolder).displayName;
            if (groupedTasks.has(rootFolder)) {
                const configs = groupedTasks.get(rootFolder.toString());
                this.addConfigurationItems(items, configs, token, isMulti);
            }
            else {
                const { configUri } = this.preferences.resolve('tasks', [], rootFolder);
                const existTaskConfigFile = !!configUri;
                items.push(({
                    label: existTaskConfigFile ? 'Open tasks.json file' : 'Create tasks.json file from template',
                    execute: () => {
                        setTimeout(() => this.taskConfigurationManager.openConfiguration(rootFolder));
                    }
                }));
            }
            if (items.length > 0) {
                items.unshift({
                    type: 'separator',
                    label: isMulti ? folderName : ''
                });
            }
        }
        if (items.length === 0) {
            items.push(({
                label: 'No tasks found'
            }));
        }
        return items;
    }
    addConfigurationItems(items, configs, token, isMulti) {
        items.push(...configs.map(taskConfig => {
            const item = new TaskConfigureQuickOpenItem(token, taskConfig, this.taskService, this.taskNameResolver, this.workspaceService, isMulti);
            item['taskDefinitionRegistry'] = this.taskDefinitionRegistry;
            return item;
        }).sort((t1, t2) => t1.label.localeCompare(t2.label)));
    }
    getTaskItems() {
        return this.items.filter((item) => item.type !== 'separator' && item.task !== undefined);
    }
    async runBuildOrTestTask(buildOrTestType) {
        var _a;
        const shouldRunBuildTask = buildOrTestType === 'build';
        const token = this.taskService.startUserAction();
        await this.doInit(token);
        const taskItems = this.getTaskItems();
        if (taskItems.length > 0) { // the item in `this.items` is not 'No tasks found'
            const buildOrTestTasks = taskItems.filter((t) => shouldRunBuildTask ? task_protocol_1.TaskCustomization.isBuildTask(t.task) : task_protocol_1.TaskCustomization.isTestTask(t.task));
            if (buildOrTestTasks.length > 0) { // build / test tasks are defined in the workspace
                const defaultBuildOrTestTasks = buildOrTestTasks.filter((t) => shouldRunBuildTask ? task_protocol_1.TaskCustomization.isDefaultBuildTask(t.task) : task_protocol_1.TaskCustomization.isDefaultTestTask(t.task));
                if (defaultBuildOrTestTasks.length === 1) { // run the default build / test task
                    const defaultBuildOrTestTask = defaultBuildOrTestTasks[0];
                    const taskToRun = defaultBuildOrTestTask.task;
                    const scope = taskToRun._scope;
                    if (this.taskDefinitionRegistry && !!this.taskDefinitionRegistry.getDefinition(taskToRun)) {
                        this.taskService.run(token, taskToRun.source, taskToRun.label, scope);
                    }
                    else {
                        this.taskService.run(token, taskToRun._source, taskToRun.label, scope);
                    }
                    return;
                }
                // if default build / test task is not found, or there are more than one default,
                // display the list of build /test tasks to let the user decide which to run
                this.items = buildOrTestTasks;
            }
            else { // no build / test tasks, display an action item to configure the build / test task
                this.items = [({
                        label: `No ${buildOrTestType} task to run found. Configure ${buildOrTestType.charAt(0).toUpperCase() + buildOrTestType.slice(1)} Task...`,
                        execute: () => {
                            this.doInit(token).then(() => {
                                var _a;
                                // update the `tasks.json` file, instead of running the task itself
                                this.items = this.getTaskItems().map((item) => new ConfigureBuildOrTestTaskQuickOpenItem(token, item.task, this.taskService, this.workspaceService.isMultiRootWorkspaceOpened, this.taskNameResolver, shouldRunBuildTask, this.taskConfigurationManager, this.taskDefinitionRegistry, this.taskSourceResolver));
                                (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(this.items, { placeholder: `Select the task to be used as the default ${buildOrTestType} task` });
                            });
                        }
                    })];
            }
        }
        else { // no tasks are currently present, prompt users if they'd like to configure a task.
            this.items = [{
                    label: `No ${buildOrTestType} task to run found. Configure ${buildOrTestType.charAt(0).toUpperCase() + buildOrTestType.slice(1)} Task...`,
                    execute: () => this.configure()
                }];
        }
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(this.items, {
            placeholder: `Select the ${buildOrTestType} task to run`,
            onDidTriggerItemButton: ({ item }) => this.onDidTriggerGearIcon(item)
        });
    }
    async getPicks(filter, token) {
        await this.init();
        return (0, quick_input_service_1.filterItems)(this.items, filter);
    }
    registerQuickAccessProvider() {
        this.quickAccessRegistry.registerQuickAccessProvider({
            getInstance: () => this,
            prefix: QuickOpenTask_1.PREFIX,
            placeholder: 'Select the task to run',
            helpEntries: [{ description: 'Run Task', needsEditor: false }]
        });
    }
    getRunningTaskLabel(task) {
        return `Task id: ${task.taskId}, label: ${task.config.label}`;
    }
    getItems(tasks, groupLabel, token, isMulti, defaultTask) {
        const items = tasks.map(task => new TaskRunQuickOpenItem(token, task, this.taskService, isMulti, this.taskDefinitionRegistry, this.taskNameResolver, this.taskSourceResolver, this.taskConfigurationManager, [{
                iconClass: 'codicon-gear',
                tooltip: 'Configure Task',
            }])).sort((t1, t2) => {
            var _a, _b;
            let result = ((_a = t1.description) !== null && _a !== void 0 ? _a : '').localeCompare((_b = t2.description) !== null && _b !== void 0 ? _b : '');
            if (result === 0) {
                result = t1.label.localeCompare(t2.label);
            }
            return result;
        });
        if (items.length === 0 && defaultTask) {
            items.push(defaultTask);
        }
        if (items.length > 0) {
            items.unshift({ type: 'separator', label: groupLabel });
        }
        return items;
    }
    getFilteredTasks(recentTasks, configuredTasks, providedTasks) {
        const filteredRecentTasks = [];
        recentTasks.forEach(recent => {
            const originalTaskConfig = [...configuredTasks, ...providedTasks].find(t => this.taskDefinitionRegistry.compareTasks(recent, t));
            if (originalTaskConfig) {
                filteredRecentTasks.push(originalTaskConfig);
            }
        });
        const filteredProvidedTasks = [];
        providedTasks.forEach(provided => {
            const exist = [...filteredRecentTasks, ...configuredTasks].some(t => this.taskDefinitionRegistry.compareTasks(provided, t));
            if (!exist) {
                filteredProvidedTasks.push(provided);
            }
        });
        const filteredConfiguredTasks = [];
        configuredTasks.forEach(configured => {
            const exist = filteredRecentTasks.some(t => this.taskDefinitionRegistry.compareTasks(configured, t));
            if (!exist) {
                filteredConfiguredTasks.push(configured);
            }
        });
        return {
            filteredRecentTasks, filteredConfiguredTasks, filteredProvidedTasks
        };
    }
    getGroupedTasksByWorkspaceFolder(tasks) {
        const grouped = new Map();
        for (const task of tasks) {
            const scope = task._scope;
            if (grouped.has(scope.toString())) {
                grouped.get(scope.toString()).push(task);
            }
            else {
                grouped.set(scope.toString(), [task]);
            }
        }
        for (const taskConfigs of grouped.values()) {
            taskConfigs.sort((t1, t2) => t1.label.localeCompare(t2.label));
        }
        return grouped;
    }
};
exports.QuickOpenTask = QuickOpenTask;
QuickOpenTask.PREFIX = 'task ';
tslib_1.__decorate([
    (0, inversify_1.inject)(task_service_1.TaskService),
    tslib_1.__metadata("design:type", task_service_1.TaskService)
], QuickOpenTask.prototype, "taskService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], QuickOpenTask.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickAccessRegistry),
    tslib_1.__metadata("design:type", Object)
], QuickOpenTask.prototype, "quickAccessRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], QuickOpenTask.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], QuickOpenTask.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_name_resolver_1.TaskNameResolver),
    tslib_1.__metadata("design:type", task_name_resolver_1.TaskNameResolver)
], QuickOpenTask.prototype, "taskNameResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], QuickOpenTask.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_configuration_manager_1.TaskConfigurationManager),
    tslib_1.__metadata("design:type", task_configuration_manager_1.TaskConfigurationManager)
], QuickOpenTask.prototype, "taskConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], QuickOpenTask.prototype, "preferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], QuickOpenTask.prototype, "labelProvider", void 0);
exports.QuickOpenTask = QuickOpenTask = QuickOpenTask_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], QuickOpenTask);
class TaskRunQuickOpenItem {
    constructor(token, task, taskService, isMulti, taskDefinitionRegistry, taskNameResolver, taskSourceResolver, taskConfigurationManager, buttons) {
        this.token = token;
        this.task = task;
        this.taskService = taskService;
        this.isMulti = isMulti;
        this.taskDefinitionRegistry = taskDefinitionRegistry;
        this.taskNameResolver = taskNameResolver;
        this.taskSourceResolver = taskSourceResolver;
        this.taskConfigurationManager = taskConfigurationManager;
        this.buttons = buttons;
    }
    get label() {
        return this.taskNameResolver.resolve(this.task);
    }
    get description() {
        return renderScope(this.task._scope, this.isMulti);
    }
    get detail() {
        return this.task.detail;
    }
    execute() {
        const scope = this.task._scope;
        if (this.taskDefinitionRegistry && !!this.taskDefinitionRegistry.getDefinition(this.task)) {
            this.taskService.run(this.token, this.task.source || this.task._source, this.task.label, scope);
        }
        else {
            this.taskService.run(this.token, this.task._source, this.task.label, scope);
        }
    }
    trigger() {
        this.taskService.configure(this.token, this.task);
        return pickerQuickAccess_1.TriggerAction.CLOSE_PICKER;
    }
}
exports.TaskRunQuickOpenItem = TaskRunQuickOpenItem;
class ConfigureBuildOrTestTaskQuickOpenItem extends TaskRunQuickOpenItem {
    constructor(token, task, taskService, isMulti, taskNameResolver, isBuildTask, taskConfigurationManager, taskDefinitionRegistry, taskSourceResolver) {
        super(token, task, taskService, isMulti, taskDefinitionRegistry, taskNameResolver, taskSourceResolver, taskConfigurationManager);
        this.isBuildTask = isBuildTask;
    }
    execute() {
        this.taskService.updateTaskConfiguration(this.token, this.task, { group: { kind: this.isBuildTask ? 'build' : 'test', isDefault: true } })
            .then(() => {
            if (this.task._scope) {
                this.taskConfigurationManager.openConfiguration(this.task._scope);
            }
        });
    }
}
exports.ConfigureBuildOrTestTaskQuickOpenItem = ConfigureBuildOrTestTaskQuickOpenItem;
function renderScope(scope, isMulti) {
    if (typeof scope === 'string') {
        if (isMulti) {
            return new uri_1.default(scope).displayName;
        }
        else {
            return '';
        }
    }
    else {
        return task_protocol_1.TaskScope[scope];
    }
}
class TaskConfigureQuickOpenItem {
    constructor(token, task, taskService, taskNameResolver, workspaceService, isMulti) {
        this.token = token;
        this.task = task;
        this.taskService = taskService;
        this.taskNameResolver = taskNameResolver;
        this.workspaceService = workspaceService;
        this.isMulti = isMulti;
        const stat = this.workspaceService.workspace;
        this.isMulti = stat ? !stat.isDirectory : false;
    }
    get label() {
        return this.taskNameResolver.resolve(this.task);
    }
    get description() {
        return renderScope(this.task._scope, this.isMulti);
    }
    accept() {
        this.execute();
    }
    execute() {
        this.taskService.configure(this.token, this.task);
    }
}
exports.TaskConfigureQuickOpenItem = TaskConfigureQuickOpenItem;
let TaskTerminateQuickOpen = class TaskTerminateQuickOpen {
    async getItems() {
        const items = [];
        const runningTasks = await this.taskService.getRunningTasks();
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        if (runningTasks.length <= 0) {
            items.push(({
                label: 'No task is currently running',
            }));
        }
        else {
            runningTasks.forEach((task) => {
                items.push(new RunningTaskQuickOpenItem(task, this.taskService, this.taskNameResolver, this.taskSourceResolver, this.taskDefinitionRegistry, this.labelProvider, isMulti, () => this.taskService.kill(task.taskId)));
            });
            if (runningTasks.length > 1) {
                items.push(({
                    label: 'All running tasks',
                    execute: () => {
                        runningTasks.forEach((t) => {
                            this.taskService.kill(t.taskId);
                        });
                    }
                }));
            }
        }
        return items;
    }
    async open() {
        var _a;
        const items = await this.getItems();
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(items, { placeholder: 'Select task to terminate' });
    }
};
exports.TaskTerminateQuickOpen = TaskTerminateQuickOpen;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], TaskTerminateQuickOpen.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], TaskTerminateQuickOpen.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskTerminateQuickOpen.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_name_resolver_1.TaskNameResolver),
    tslib_1.__metadata("design:type", task_name_resolver_1.TaskNameResolver)
], TaskTerminateQuickOpen.prototype, "taskNameResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], TaskTerminateQuickOpen.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_service_1.TaskService),
    tslib_1.__metadata("design:type", task_service_1.TaskService)
], TaskTerminateQuickOpen.prototype, "taskService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], TaskTerminateQuickOpen.prototype, "workspaceService", void 0);
exports.TaskTerminateQuickOpen = TaskTerminateQuickOpen = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskTerminateQuickOpen);
let TaskRunningQuickOpen = class TaskRunningQuickOpen {
    async getItems() {
        const items = [];
        const runningTasks = await this.taskService.getRunningTasks();
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        if (runningTasks.length <= 0) {
            items.push(({
                label: 'No task is currently running',
            }));
        }
        else {
            runningTasks.forEach((task) => {
                items.push(new RunningTaskQuickOpenItem(task, this.taskService, this.taskNameResolver, this.taskSourceResolver, this.taskDefinitionRegistry, this.labelProvider, isMulti, () => {
                    if (task.terminalId) {
                        const terminal = this.terminalService.getByTerminalId(task.terminalId);
                        if (terminal) {
                            this.terminalService.open(terminal);
                        }
                    }
                }));
            });
        }
        return items;
    }
    async open() {
        var _a;
        const items = await this.getItems();
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(items, { placeholder: 'Select the task to show its output' });
    }
};
exports.TaskRunningQuickOpen = TaskRunningQuickOpen;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], TaskRunningQuickOpen.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], TaskRunningQuickOpen.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskRunningQuickOpen.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_name_resolver_1.TaskNameResolver),
    tslib_1.__metadata("design:type", task_name_resolver_1.TaskNameResolver)
], TaskRunningQuickOpen.prototype, "taskNameResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], TaskRunningQuickOpen.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_service_1.TaskService),
    tslib_1.__metadata("design:type", task_service_1.TaskService)
], TaskRunningQuickOpen.prototype, "taskService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], TaskRunningQuickOpen.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], TaskRunningQuickOpen.prototype, "terminalService", void 0);
exports.TaskRunningQuickOpen = TaskRunningQuickOpen = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskRunningQuickOpen);
class RunningTaskQuickOpenItem {
    constructor(taskInfo, taskService, taskNameResolver, taskSourceResolver, taskDefinitionRegistry, labelProvider, isMulti, execute) {
        this.taskInfo = taskInfo;
        this.taskService = taskService;
        this.taskNameResolver = taskNameResolver;
        this.taskSourceResolver = taskSourceResolver;
        this.taskDefinitionRegistry = taskDefinitionRegistry;
        this.labelProvider = labelProvider;
        this.isMulti = isMulti;
        this.execute = execute;
    }
    get label() {
        return this.taskNameResolver.resolve(this.taskInfo.config);
    }
    get description() {
        return renderScope(this.taskInfo.config._scope, this.isMulti);
    }
    get detail() {
        return this.taskInfo.config.detail;
    }
}
exports.RunningTaskQuickOpenItem = RunningTaskQuickOpenItem;
let TaskRestartRunningQuickOpen = class TaskRestartRunningQuickOpen {
    async getItems() {
        const items = [];
        const runningTasks = await this.taskService.getRunningTasks();
        const isMulti = this.workspaceService.isMultiRootWorkspaceOpened;
        if (runningTasks.length <= 0) {
            items.push({
                label: 'No task to restart'
            });
        }
        else {
            runningTasks.forEach((task) => {
                items.push(new RunningTaskQuickOpenItem(task, this.taskService, this.taskNameResolver, this.taskSourceResolver, this.taskDefinitionRegistry, this.labelProvider, isMulti, () => this.taskService.restartTask(task)));
            });
        }
        return items;
    }
    async open() {
        var _a;
        const items = await this.getItems();
        (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(items, { placeholder: 'Select task to restart' });
    }
};
exports.TaskRestartRunningQuickOpen = TaskRestartRunningQuickOpen;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], TaskRestartRunningQuickOpen.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], TaskRestartRunningQuickOpen.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskRestartRunningQuickOpen.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_name_resolver_1.TaskNameResolver),
    tslib_1.__metadata("design:type", task_name_resolver_1.TaskNameResolver)
], TaskRestartRunningQuickOpen.prototype, "taskNameResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], TaskRestartRunningQuickOpen.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_service_1.TaskService),
    tslib_1.__metadata("design:type", task_service_1.TaskService)
], TaskRestartRunningQuickOpen.prototype, "taskService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], TaskRestartRunningQuickOpen.prototype, "workspaceService", void 0);
exports.TaskRestartRunningQuickOpen = TaskRestartRunningQuickOpen = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskRestartRunningQuickOpen);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-configuration-manager.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-configuration-manager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskConfigurationManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const jsoncparser = __webpack_require__(/*! jsonc-parser */ "../node_modules/jsonc-parser/lib/esm/main.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const quick_pick_service_1 = __webpack_require__(/*! @theia/core/lib/common/quick-pick-service */ "../node_modules/@theia/core/lib/common/quick-pick-service.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../node_modules/@theia/workspace/lib/browser/workspace-service.js");
const task_configuration_model_1 = __webpack_require__(/*! ./task-configuration-model */ "../node_modules/@theia/task/lib/browser/task-configuration-model.js");
const task_templates_1 = __webpack_require__(/*! ./task-templates */ "../node_modules/@theia/task/lib/browser/task-templates.js");
const task_protocol_1 = __webpack_require__(/*! ../common/task-protocol */ "../node_modules/@theia/task/lib/common/task-protocol.js");
const workspace_variable_contribution_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-variable-contribution */ "../node_modules/@theia/workspace/lib/browser/workspace-variable-contribution.js");
const preference_configurations_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences/preference-configurations */ "../node_modules/@theia/core/lib/browser/preferences/preference-configurations.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const task_schema_updater_1 = __webpack_require__(/*! ./task-schema-updater */ "../node_modules/@theia/task/lib/browser/task-schema-updater.js");
/**
 * This class connects the the "tasks" preferences sections to task system: it collects tasks preference values and
 * provides them to the task system as raw, parsed JSON.
 */
let TaskConfigurationManager = class TaskConfigurationManager {
    constructor() {
        this.onDidChangeTaskConfigEmitter = new event_1.Emitter();
        this.onDidChangeTaskConfig = this.onDidChangeTaskConfigEmitter.event;
        this.models = new Map();
        this.updateModels = debounce(async () => {
            const roots = await this.workspaceService.roots;
            const toDelete = new Set([...this.models.keys()]
                .filter(key => key !== task_protocol_1.TaskScope.Global && key !== task_protocol_1.TaskScope.Workspace));
            this.updateWorkspaceModel();
            for (const rootStat of roots) {
                const key = rootStat.resource.toString();
                toDelete.delete(key);
                if (!this.models.has(key)) {
                    const model = new task_configuration_model_1.TaskConfigurationModel(key, this.folderPreferences);
                    model.onDidChange(() => this.onDidChangeTaskConfigEmitter.fire({ scope: key, type: 0 /* FileChangeType.UPDATED */ }));
                    model.onDispose(() => this.models.delete(key));
                    this.models.set(key, model);
                    this.onDidChangeTaskConfigEmitter.fire({ scope: key, type: 0 /* FileChangeType.UPDATED */ });
                }
            }
            for (const uri of toDelete) {
                const model = this.models.get(uri);
                if (model) {
                    model.dispose();
                }
                this.onDidChangeTaskConfigEmitter.fire({ scope: uri, type: 2 /* FileChangeType.DELETED */ });
            }
        }, 500);
        this.toDisposeOnDelegateChange = new common_1.DisposableCollection();
    }
    init() {
        this.createModels();
        this.folderPreferences.onDidPreferencesChanged(e => {
            if (e['tasks']) {
                this.updateModels();
            }
        });
        this.workspaceService.onWorkspaceChanged(() => {
            this.updateModels();
        });
        this.workspaceService.onWorkspaceLocationChanged(() => {
            this.updateModels();
        });
    }
    createModels() {
        const userModel = new task_configuration_model_1.TaskConfigurationModel(task_protocol_1.TaskScope.Global, this.userPreferences);
        userModel.onDidChange(() => this.onDidChangeTaskConfigEmitter.fire({ scope: task_protocol_1.TaskScope.Global, type: 0 /* FileChangeType.UPDATED */ }));
        this.models.set(task_protocol_1.TaskScope.Global, userModel);
        this.updateModels();
    }
    getTasks(scope) {
        var _a, _b;
        return (_b = (_a = this.getModel(scope)) === null || _a === void 0 ? void 0 : _a.configurations) !== null && _b !== void 0 ? _b : [];
    }
    getTask(name, scope) {
        return this.getTasks(scope).find((configuration) => configuration.name === name);
    }
    async openConfiguration(scope) {
        const taskPrefModel = this.getModel(scope);
        const maybeURI = typeof scope === 'string' ? scope : undefined;
        const configURI = this.preferenceService.getConfigUri(this.getMatchingPreferenceScope(scope), maybeURI, 'tasks');
        if (taskPrefModel && configURI) {
            await this.doOpen(taskPrefModel, configURI);
        }
    }
    async addTaskConfiguration(scope, taskConfig) {
        const taskPrefModel = this.getModel(scope);
        if (taskPrefModel) {
            const configurations = taskPrefModel.configurations;
            return this.setTaskConfigurations(scope, [...configurations, taskConfig]);
        }
        return false;
    }
    async setTaskConfigurations(scope, taskConfigs) {
        const taskPrefModel = this.getModel(scope);
        if (taskPrefModel) {
            return taskPrefModel.setConfigurations(taskConfigs);
        }
        return false;
    }
    getModel(scope) {
        return this.models.get(scope);
    }
    async doOpen(model, configURI) {
        if (!model.uri) {
            // The file has not yet been created.
            await this.doCreate(model, configURI);
        }
        return this.editorManager.open(configURI, {
            mode: 'activate'
        });
    }
    async doCreate(model, configURI) {
        var _a;
        const content = await this.getInitialConfigurationContent();
        if (content) {
            // All scopes but workspace.
            if (this.preferenceConfigurations.getName(configURI) === 'tasks') {
                await this.fileService.write(configURI, content);
            }
            else {
                let taskContent;
                try {
                    taskContent = jsoncparser.parse(content);
                }
                catch {
                    taskContent = (_a = this.taskSchemaProvider.getTaskSchema().default) !== null && _a !== void 0 ? _a : {};
                }
                await model.preferences.setPreference('tasks', taskContent);
            }
        }
    }
    getMatchingPreferenceScope(scope) {
        switch (scope) {
            case task_protocol_1.TaskScope.Global:
                return browser_2.PreferenceScope.User;
            case task_protocol_1.TaskScope.Workspace:
                return browser_2.PreferenceScope.Workspace;
            default:
                return browser_2.PreferenceScope.Folder;
        }
    }
    async getInitialConfigurationContent() {
        var _a;
        const selected = await this.quickPickService.show(this.taskTemplateSelector.selectTemplates(), {
            placeholder: 'Select a Task Template'
        });
        if (selected) {
            return (_a = selected.value) === null || _a === void 0 ? void 0 : _a.content;
        }
    }
    updateWorkspaceModel() {
        var _a;
        const isFolderWorkspace = this.workspaceService.opened && !this.workspaceService.saved;
        const newDelegate = isFolderWorkspace ? this.folderPreferences : this.workspacePreferences;
        const effectiveScope = isFolderWorkspace ? (_a = this.workspaceService.tryGetRoots()[0]) === null || _a === void 0 ? void 0 : _a.resource.toString() : task_protocol_1.TaskScope.Workspace;
        if (newDelegate !== this.workspaceDelegate) {
            this.workspaceDelegate = newDelegate;
            this.toDisposeOnDelegateChange.dispose();
            const workspaceModel = new task_configuration_model_1.TaskConfigurationModel(effectiveScope, newDelegate);
            this.toDisposeOnDelegateChange.push(workspaceModel);
            // If the delegate is the folder preference provider, its events will be relayed via the folder scope models.
            if (newDelegate === this.workspacePreferences) {
                this.toDisposeOnDelegateChange.push(workspaceModel.onDidChange(() => {
                    this.onDidChangeTaskConfigEmitter.fire({ scope: task_protocol_1.TaskScope.Workspace, type: 0 /* FileChangeType.UPDATED */ });
                }));
            }
            this.models.set(task_protocol_1.TaskScope.Workspace, workspaceModel);
            this.onDidChangeTaskConfigEmitter.fire({ scope: effectiveScope, type: 0 /* FileChangeType.UPDATED */ });
        }
    }
};
exports.TaskConfigurationManager = TaskConfigurationManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_service_1.WorkspaceService),
    tslib_1.__metadata("design:type", workspace_service_1.WorkspaceService)
], TaskConfigurationManager.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.EditorManager),
    tslib_1.__metadata("design:type", browser_1.EditorManager)
], TaskConfigurationManager.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(quick_pick_service_1.QuickPickService),
    tslib_1.__metadata("design:type", Object)
], TaskConfigurationManager.prototype, "quickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], TaskConfigurationManager.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], TaskConfigurationManager.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_schema_updater_1.TaskSchemaUpdater),
    tslib_1.__metadata("design:type", task_schema_updater_1.TaskSchemaUpdater)
], TaskConfigurationManager.prototype, "taskSchemaProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.PreferenceProvider),
    (0, inversify_1.named)(browser_2.PreferenceScope.Folder),
    tslib_1.__metadata("design:type", browser_2.PreferenceProvider)
], TaskConfigurationManager.prototype, "folderPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.PreferenceProvider),
    (0, inversify_1.named)(browser_2.PreferenceScope.User),
    tslib_1.__metadata("design:type", browser_2.PreferenceProvider)
], TaskConfigurationManager.prototype, "userPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.PreferenceProvider),
    (0, inversify_1.named)(browser_2.PreferenceScope.Workspace),
    tslib_1.__metadata("design:type", browser_2.PreferenceProvider)
], TaskConfigurationManager.prototype, "workspacePreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preference_configurations_1.PreferenceConfigurations),
    tslib_1.__metadata("design:type", preference_configurations_1.PreferenceConfigurations)
], TaskConfigurationManager.prototype, "preferenceConfigurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_variable_contribution_1.WorkspaceVariableContribution),
    tslib_1.__metadata("design:type", workspace_variable_contribution_1.WorkspaceVariableContribution)
], TaskConfigurationManager.prototype, "workspaceVariables", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_templates_1.TaskTemplateSelector),
    tslib_1.__metadata("design:type", task_templates_1.TaskTemplateSelector)
], TaskConfigurationManager.prototype, "taskTemplateSelector", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskConfigurationManager.prototype, "init", null);
exports.TaskConfigurationManager = TaskConfigurationManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskConfigurationManager);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-configuration-model.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-configuration-model.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskConfigurationModel = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
/**
 * Holds the task configurations associated with a particular file. Uses an editor model to facilitate
 * non-destructive editing and coordination with editing the file by hand.
 */
class TaskConfigurationModel {
    constructor(scope, preferences) {
        this.scope = scope;
        this.preferences = preferences;
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDispose = new disposable_1.DisposableCollection(this.onDidChangeEmitter);
        this.reconcile();
        this.toDispose.push(this.preferences.onDidPreferencesChanged((e) => {
            const change = e['tasks'];
            if (change && browser_1.PreferenceProviderDataChange.affects(change, this.getWorkspaceFolder())) {
                this.reconcile();
            }
        }));
    }
    get uri() {
        return this.json.uri;
    }
    getWorkspaceFolder() {
        return typeof this.scope === 'string' ? this.scope : undefined;
    }
    dispose() {
        this.toDispose.dispose();
    }
    get onDispose() {
        return this.toDispose.onDispose;
    }
    get configurations() {
        return this.json.configurations;
    }
    reconcile() {
        this.json = this.parseConfigurations();
        this.onDidChangeEmitter.fire(undefined);
    }
    setConfigurations(value) {
        return this.preferences.setPreference('tasks.tasks', value, this.getWorkspaceFolder());
    }
    parseConfigurations() {
        const configurations = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { configUri, value } = this.preferences.resolve('tasks', this.getWorkspaceFolder());
        if ((0, common_1.isObject)(value) && Array.isArray(value.tasks)) {
            for (const taskConfig of value.tasks) {
                configurations.push(taskConfig);
            }
        }
        return {
            uri: configUri,
            configurations
        };
    }
}
exports.TaskConfigurationModel = TaskConfigurationModel;


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-configurations.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-configurations.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017-2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskConfigurations = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const provided_task_configurations_1 = __webpack_require__(/*! ./provided-task-configurations */ "../node_modules/@theia/task/lib/browser/provided-task-configurations.js");
const task_configuration_manager_1 = __webpack_require__(/*! ./task-configuration-manager */ "../node_modules/@theia/task/lib/browser/task-configuration-manager.js");
const task_schema_updater_1 = __webpack_require__(/*! ./task-schema-updater */ "../node_modules/@theia/task/lib/browser/task-schema-updater.js");
const task_source_resolver_1 = __webpack_require__(/*! ./task-source-resolver */ "../node_modules/@theia/task/lib/browser/task-source-resolver.js");
const common_2 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
/**
 * Watches a tasks.json configuration file and provides a parsed version of the contained task configurations
 */
let TaskConfigurations = class TaskConfigurations {
    constructor() {
        this.toDispose = new common_2.DisposableCollection();
        /**
         * Map of source (path of root folder that the task configs come from) and task config map.
         * For the inner map (i.e., task config map), the key is task label and value TaskConfiguration
         */
        this.tasksMap = new Map();
        /**
         * Map of source (path of root folder that the task configs come from) and task customizations map.
         */
        this.taskCustomizationMap = new Map();
        this.client = undefined;
        /**
         * Map of source (path of root folder that the task configs come from) and raw task configurations / customizations.
         * This map is used to store the data from `tasks.json` files in workspace.
         */
        this.rawTaskConfigurations = new Map();
        this.toDispose.push(common_2.Disposable.create(() => {
            this.tasksMap.clear();
            this.taskCustomizationMap.clear();
            this.rawTaskConfigurations.clear();
            this.client = undefined;
        }));
    }
    init() {
        this.toDispose.push(this.taskConfigurationManager.onDidChangeTaskConfig(async (change) => {
            try {
                await this.onDidTaskFileChange([change]);
                if (this.client) {
                    this.client.taskConfigurationChanged(this.getTaskLabels());
                }
            }
            catch (err) {
                console.error(err);
            }
        }));
        this.reorganizeTasks();
        this.toDispose.push(this.taskSchemaUpdater.onDidChangeTaskSchema(() => this.reorganizeTasks()));
    }
    setClient(client) {
        this.client = client;
    }
    dispose() {
        this.toDispose.dispose();
    }
    /** returns the list of known task labels */
    getTaskLabels() {
        return Array.from(this.tasksMap.values()).reduce((acc, labelConfigMap) => acc.concat(Array.from(labelConfigMap.keys())), []);
    }
    /**
     * returns a collection of known tasks, which includes:
     * - all the configured tasks in `tasks.json`, and
     * - the customized detected tasks.
     *
     * The invalid task configs are not returned.
     */
    async getTasks(token) {
        const configuredTasks = Array.from(this.tasksMap.values()).reduce((acc, labelConfigMap) => acc.concat(Array.from(labelConfigMap.values())), []);
        const detectedTasksAsConfigured = [];
        for (const [rootFolder, customizations] of Array.from(this.taskCustomizationMap.entries())) {
            for (const customization of customizations) {
                // TODO: getTasksToCustomize() will ask all task providers to contribute tasks. Doing this in a loop is bad.
                const detected = await this.providedTaskConfigurations.getTaskToCustomize(token, customization, rootFolder);
                if (detected) {
                    // there might be a provided task that has a different scope from the task we're inspecting
                    detectedTasksAsConfigured.push({ ...detected, ...customization });
                }
            }
        }
        return [...configuredTasks, ...detectedTasksAsConfigured];
    }
    getRawTaskConfigurations(scope) {
        if (scope === undefined) {
            const tasks = [];
            for (const configs of this.rawTaskConfigurations.values()) {
                tasks.push(...configs);
            }
            return tasks;
        }
        const scopeKey = this.getKeyFromScope(scope);
        if (this.rawTaskConfigurations.has(scopeKey)) {
            return Array.from(this.rawTaskConfigurations.get(scopeKey).values());
        }
        return [];
    }
    /**
     * returns a collection of invalid task configs as per the task schema defined in Theia.
     */
    getInvalidTaskConfigurations() {
        const invalidTaskConfigs = [];
        for (const taskConfigs of this.rawTaskConfigurations.values()) {
            for (const taskConfig of taskConfigs) {
                const isValid = this.isTaskConfigValid(taskConfig);
                if (!isValid) {
                    invalidTaskConfigs.push(taskConfig);
                }
            }
        }
        return invalidTaskConfigs;
    }
    /** returns the task configuration for a given label or undefined if none */
    getTask(scope, taskLabel) {
        const labelConfigMap = this.tasksMap.get(this.getKeyFromScope(scope));
        if (labelConfigMap) {
            return labelConfigMap.get(taskLabel);
        }
    }
    /** returns the customized task for a given label or undefined if none */
    async getCustomizedTask(token, scope, taskLabel) {
        const customizations = this.taskCustomizationMap.get(this.getKeyFromScope(scope));
        if (customizations) {
            const customization = customizations.find(cus => cus.label === taskLabel);
            if (customization) {
                const detected = await this.providedTaskConfigurations.getTaskToCustomize(token, customization, scope);
                if (detected) {
                    return {
                        ...detected,
                        ...customization,
                        type: detected.type
                    };
                }
            }
        }
    }
    /** removes tasks configured in the given task config file */
    removeTasks(scope) {
        const source = this.getKeyFromScope(scope);
        this.tasksMap.delete(source);
        this.taskCustomizationMap.delete(source);
    }
    /**
     * Removes task customization objects found in the given task config file from the memory.
     * Please note: this function does not modify the task config file.
     */
    removeTaskCustomizations(scope) {
        const source = this.getKeyFromScope(scope);
        this.taskCustomizationMap.delete(source);
    }
    /**
     * Returns the task customizations by type from a given root folder in the workspace.
     * @param type the type of task customizations
     * @param rootFolder the root folder to find task customizations from. If `undefined`, this function returns an empty array.
     */
    getTaskCustomizations(type, scope) {
        const customizationInRootFolder = this.taskCustomizationMap.get(this.getKeyFromScope(scope));
        if (customizationInRootFolder) {
            return customizationInRootFolder.filter(c => c.type === type);
        }
        else {
            return [];
        }
    }
    /**
     * Returns the customization object in `tasks.json` for the given task. Please note, this function
     * returns `undefined` if the given task is not a detected task, because configured tasks don't need
     * customization objects - users can modify its config directly in `tasks.json`.
     * @param taskConfig The task config, which could either be a configured task or a detected task.
     */
    getCustomizationForTask(taskConfig) {
        if (!this.isDetectedTask(taskConfig)) {
            return undefined;
        }
        const customizationByType = this.getTaskCustomizations(taskConfig.type, taskConfig._scope) || [];
        const hasCustomization = customizationByType.length > 0;
        if (hasCustomization) {
            const taskDefinition = this.taskDefinitionRegistry.getDefinition(taskConfig);
            if (taskDefinition) {
                const required = taskDefinition.properties.required || [];
                // Only support having one customization per task.
                return customizationByType.find(customization => required.every(property => customization[property] === taskConfig[property]));
            }
        }
        return undefined;
    }
    /**
     * Called when a change, to a config file we watch, is detected.
     */
    async onDidTaskFileChange(fileChanges) {
        for (const change of fileChanges) {
            if (change.type === 2 /* FileChangeType.DELETED */) {
                this.removeTasks(change.scope);
            }
            else {
                // re-parse the config file
                await this.refreshTasks(change.scope);
            }
        }
    }
    /**
     * Read the task configs from the task configuration manager, and updates the list of available tasks.
     */
    async refreshTasks(scope) {
        await this.readTasks(scope);
        this.removeTasks(scope);
        this.removeTaskCustomizations(scope);
        this.reorganizeTasks();
    }
    /** parses a config file and extracts the tasks launch configurations */
    async readTasks(scope) {
        const rawConfigArray = this.taskConfigurationManager.getTasks(scope);
        const key = this.getKeyFromScope(scope);
        if (this.rawTaskConfigurations.has(key)) {
            this.rawTaskConfigurations.delete(key);
        }
        this.rawTaskConfigurations.set(key, rawConfigArray);
        return rawConfigArray;
    }
    async openUserTasks() {
        await this.taskConfigurationManager.openConfiguration(common_1.TaskScope.Global);
    }
    /** Adds given task to a config file and opens the file to provide ability to edit task configuration. */
    async configure(token, task) {
        const scope = task._scope;
        if (scope === common_1.TaskScope.Global) {
            return this.openUserTasks();
        }
        const workspace = this.workspaceService.workspace;
        if (!workspace) {
            return;
        }
        const configuredAndCustomizedTasks = await this.getTasks(token);
        if (!configuredAndCustomizedTasks.some(t => this.taskDefinitionRegistry.compareTasks(t, task))) {
            await this.saveTask(scope, task);
        }
        try {
            await this.taskConfigurationManager.openConfiguration(scope);
        }
        catch (e) {
            console.error(`Error occurred while opening 'tasks.json' in ${this.taskSourceResolver.resolve(task)}.`, e);
        }
    }
    getTaskCustomizationTemplate(task) {
        const definition = this.getTaskDefinition(task);
        if (!definition) {
            console.error('Detected / Contributed tasks should have a task definition.');
            return;
        }
        const customization = { type: task.type, runOptions: task.runOptions };
        definition.properties.all.forEach(p => {
            if (task[p] !== undefined) {
                customization[p] = task[p];
            }
        });
        if ('problemMatcher' in task) {
            const problemMatcher = [];
            if (Array.isArray(task.problemMatcher)) {
                problemMatcher.push(...task.problemMatcher.map(t => {
                    if (typeof t === 'string') {
                        return t;
                    }
                    else {
                        return t.name;
                    }
                }));
            }
            else if (typeof task.problemMatcher === 'string') {
                problemMatcher.push(task.problemMatcher);
            }
            else if (task.problemMatcher) {
                problemMatcher.push(task.problemMatcher.name);
            }
            customization.problemMatcher = problemMatcher.map(common_1.asVariableName);
        }
        if (task.group) {
            customization.group = task.group;
        }
        customization.label = task.label;
        return { ...customization };
    }
    /** Writes the task to a config file. Creates a config file if this one does not exist */
    saveTask(scope, task) {
        const { _source, $ident, ...preparedTask } = task;
        const customizedTaskTemplate = this.getTaskCustomizationTemplate(task) || preparedTask;
        return this.taskConfigurationManager.addTaskConfiguration(scope, customizedTaskTemplate);
    }
    /**
     * This function is called after a change in TaskDefinitionRegistry happens.
     * It checks all tasks that have been loaded, and re-organized them in `tasksMap` and `taskCustomizationMap`.
     */
    reorganizeTasks() {
        const newTaskMap = new Map();
        const newTaskCustomizationMap = new Map();
        const addCustomization = (rootFolder, customization) => {
            if (newTaskCustomizationMap.has(rootFolder)) {
                newTaskCustomizationMap.get(rootFolder).push(customization);
            }
            else {
                newTaskCustomizationMap.set(rootFolder, [customization]);
            }
        };
        const addConfiguredTask = (rootFolder, label, configuredTask) => {
            if (newTaskMap.has(rootFolder)) {
                newTaskMap.get(rootFolder).set(label, configuredTask);
            }
            else {
                const newConfigMap = new Map();
                newConfigMap.set(label, configuredTask);
                newTaskMap.set(rootFolder, newConfigMap);
            }
        };
        for (const [scopeKey, taskConfigs] of this.rawTaskConfigurations.entries()) {
            for (const taskConfig of taskConfigs) {
                const scope = this.getScopeFromKey(scopeKey);
                const isValid = this.isTaskConfigValid(taskConfig);
                if (!isValid) {
                    continue;
                }
                const transformedTask = this.getTransformedRawTask(taskConfig, scope);
                if (this.isDetectedTask(transformedTask)) {
                    addCustomization(scopeKey, transformedTask);
                }
                else {
                    addConfiguredTask(scopeKey, transformedTask['label'], transformedTask);
                }
            }
        }
        this.taskCustomizationMap = newTaskCustomizationMap;
        this.tasksMap = newTaskMap;
    }
    getTransformedRawTask(rawTask, scope) {
        let taskConfig;
        if (this.isDetectedTask(rawTask)) {
            const def = this.getTaskDefinition(rawTask);
            taskConfig = {
                ...rawTask,
                _source: def.source,
                _scope: scope
            };
        }
        else {
            taskConfig = {
                ...rawTask,
                _source: scope,
                _scope: scope
            };
        }
        return {
            ...taskConfig,
            presentation: common_1.TaskOutputPresentation.fromJson(rawTask)
        };
    }
    /**
     * Returns `true` if the given task configuration is valid as per the task schema defined in Theia
     * or contributed by Theia extensions and plugins, `false` otherwise.
     */
    isTaskConfigValid(task) {
        return this.taskSchemaUpdater.validate({ tasks: [task] });
    }
    /**
     * Updates the task config in the `tasks.json`.
     * The task config, together with updates, will be written into the `tasks.json` if it is not found in the file.
     *
     * @param task task that the updates will be applied to
     * @param update the updates to be applied
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async updateTaskConfig(token, task, update) {
        const scope = task._scope;
        const configuredAndCustomizedTasks = await this.getTasks(token);
        if (configuredAndCustomizedTasks.some(t => this.taskDefinitionRegistry.compareTasks(t, task))) { // task is already in `tasks.json`
            const jsonTasks = this.taskConfigurationManager.getTasks(scope);
            if (jsonTasks) {
                const ind = jsonTasks.findIndex((t) => {
                    if (t.type !== (task.type)) {
                        return false;
                    }
                    const def = this.taskDefinitionRegistry.getDefinition(t);
                    if (def) {
                        return def.properties.all.every(p => t[p] === task[p]);
                    }
                    return t.label === task.label;
                });
                jsonTasks[ind] = {
                    ...jsonTasks[ind],
                    ...update
                };
            }
            this.taskConfigurationManager.setTaskConfigurations(scope, jsonTasks);
        }
        else { // task is not in `tasks.json`
            Object.keys(update).forEach(taskProperty => {
                task[taskProperty] = update[taskProperty];
            });
            this.saveTask(scope, task);
        }
    }
    getKeyFromScope(scope) {
        // Converting the enums to string will not yield a valid URI, so the keys will be distinct from any URI.
        return scope.toString();
    }
    getScopeFromKey(key) {
        if (common_1.TaskScope.Global.toString() === key) {
            return common_1.TaskScope.Global;
        }
        else if (common_1.TaskScope.Workspace.toString() === key) {
            return common_1.TaskScope.Workspace;
        }
        else {
            return key;
        }
    }
    /** checks if the config is a detected / contributed task */
    isDetectedTask(task) {
        const taskDefinition = this.getTaskDefinition(task);
        // it is considered as a customization if the task definition registry finds a def for the task configuration
        return !!taskDefinition;
    }
    getTaskDefinition(task) {
        return this.taskDefinitionRegistry.getDefinition(task);
    }
};
exports.TaskConfigurations = TaskConfigurations;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], TaskConfigurations.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskConfigurations.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(provided_task_configurations_1.ProvidedTaskConfigurations),
    tslib_1.__metadata("design:type", provided_task_configurations_1.ProvidedTaskConfigurations)
], TaskConfigurations.prototype, "providedTaskConfigurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_configuration_manager_1.TaskConfigurationManager),
    tslib_1.__metadata("design:type", task_configuration_manager_1.TaskConfigurationManager)
], TaskConfigurations.prototype, "taskConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_schema_updater_1.TaskSchemaUpdater),
    tslib_1.__metadata("design:type", task_schema_updater_1.TaskSchemaUpdater)
], TaskConfigurations.prototype, "taskSchemaUpdater", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], TaskConfigurations.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskConfigurations.prototype, "init", null);
exports.TaskConfigurations = TaskConfigurations = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TaskConfigurations);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-context-key-service.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-context-key-service.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const application_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/application-protocol */ "../node_modules/@theia/core/lib/common/application-protocol.js");
let TaskContextKeyService = class TaskContextKeyService {
    init() {
        this.customExecutionSupported = this.contextKeyService.createKey('customExecutionSupported', true);
        this.shellExecutionSupported = this.contextKeyService.createKey('shellExecutionSupported', true);
        this.processExecutionSupported = this.contextKeyService.createKey('processExecutionSupported', true);
        this.serverlessWebContext = this.contextKeyService.createKey('serverlessWebContext', false);
        this.taskCommandsRegistered = this.contextKeyService.createKey('taskCommandsRegistered', true);
        this.applicationServer.getApplicationPlatform().then(platform => {
            if (platform === 'web') {
                this.setShellExecutionSupported(false);
                this.setProcessExecutionSupported(false);
                this.setServerlessWebContext(true);
            }
        });
    }
    setCustomExecutionSupported(customExecutionSupported) {
        this.customExecutionSupported.set(customExecutionSupported);
    }
    setShellExecutionSupported(shellExecutionSupported) {
        this.shellExecutionSupported.set(shellExecutionSupported);
    }
    setProcessExecutionSupported(processExecutionSupported) {
        this.processExecutionSupported.set(processExecutionSupported);
    }
    setServerlessWebContext(serverlessWebContext) {
        this.serverlessWebContext.set(serverlessWebContext);
    }
    setTaskCommandsRegistered(taskCommandsRegistered) {
        this.taskCommandsRegistered.set(taskCommandsRegistered);
    }
};
exports.TaskContextKeyService = TaskContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TaskContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_protocol_1.ApplicationServer),
    tslib_1.__metadata("design:type", Object)
], TaskContextKeyService.prototype, "applicationServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskContextKeyService.prototype, "init", null);
exports.TaskContextKeyService = TaskContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-contribution.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-contribution.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskProviderRegistry = exports.TaskResolverRegistry = exports.TaskContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
exports.TaskContribution = Symbol('TaskContribution');
/**
 * The {@link TaskResolverRegistry} is the common component for registration and provision of
 * {@link TaskResolver}s. Theia will collect all {@link TaskContribution}s and invoke {@link TaskContribution#registerResolvers}
 * for each contribution.
 */
let TaskResolverRegistry = class TaskResolverRegistry {
    constructor() {
        this.onWillProvideTaskResolverEmitter = new event_1.Emitter();
        /**
         * Emit when the registry provides a registered resolver. i.e. when the {@link TaskResolverRegistry#getResolver}
         * function is called.
         */
        this.onWillProvideTaskResolver = this.onWillProvideTaskResolverEmitter.event;
        this.taskResolvers = new Map();
        this.executionResolvers = new Map();
    }
    /**
     * Registers the given {@link TaskResolver} to resolve the `TaskConfiguration` of the specified type.
     * If there is already a `TaskResolver` registered for the specified type the registration will
     * be overwritten with the new value.
     *
     * @deprecated since 1.12.0 use `registerTaskResolver` instead.
     *
     * @param type the task configuration type for which the given resolver should be registered.
     * @param resolver the task resolver that should be registered.
     *
     * @returns a `Disposable` that can be invoked to unregister the given resolver
     */
    register(type, resolver) {
        return this.registerTaskResolver(type, resolver);
    }
    /**
     * Registers the given {@link TaskResolver} to resolve the `TaskConfiguration` of the specified type.
     * If there is already a `TaskResolver` registered for the specified type the registration will
     * be overwritten with the new value.
     *
     * @param type the task configuration type for which the given resolver should be registered.
     * @param resolver the task resolver that should be registered.
     *
     * @returns a `Disposable` that can be invoked to unregister the given resolver
     */
    registerTaskResolver(type, resolver) {
        if (this.taskResolvers.has(type)) {
            console.warn(`Overriding task resolver for ${type}`);
        }
        this.taskResolvers.set(type, resolver);
        return {
            dispose: () => this.taskResolvers.delete(type)
        };
    }
    /**
     * Retrieves the {@link TaskResolver} registered for the given type task configuration type.
     *
     * @deprecated since 1.12.0 use `getTaskResolver()` instead.
     *
     * @param type the task configuration type
     *
     * @returns a promise of the registered `TaskResolver` or `undefined` if no resolver is registered for the given type.
     */
    async getResolver(type) {
        return this.getTaskResolver(type);
    }
    /**
     * Retrieves the {@link TaskResolver} registered for the given type task configuration type.
     * @param type the task configuration type
     *
     * @returns a promise of the registered `TaskResolver` or `undefined` if no resolver is registered for the given type.
     */
    async getTaskResolver(type) {
        await event_1.WaitUntilEvent.fire(this.onWillProvideTaskResolverEmitter, { taskType: type });
        return this.taskResolvers.get(type);
    }
    /**
     * Registers the given {@link TaskResolver} to resolve the `TaskConfiguration` for the
     * specified type of execution ('shell', 'process' or 'customExecution').
     * If there is already a `TaskResolver` registered for the specified type the registration will
     * be overwritten with the new value.
     *
     * @param type the task execution type for which the given resolver should be registered.
     * @param resolver the task resolver that should be registered.
     *
     * @returns a `Disposable` that can be invoked to unregister the given resolver
     */
    registerExecutionResolver(type, resolver) {
        if (this.executionResolvers.has(type)) {
            console.warn(`Overriding execution resolver for ${type}`);
        }
        this.executionResolvers.set(type, resolver);
        return {
            dispose: () => this.executionResolvers.delete(type)
        };
    }
    /**
     * Retrieves the {@link TaskResolver} registered for the given type of execution ('shell', 'process' or 'customExecution')..
     * @param type the task configuration type
     *
     * @returns a promise of the registered `TaskResolver` or `undefined` if no resolver is registered for the given type.
     */
    getExecutionResolver(executionType) {
        return this.executionResolvers.get(executionType);
    }
};
exports.TaskResolverRegistry = TaskResolverRegistry;
exports.TaskResolverRegistry = TaskResolverRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskResolverRegistry);
/**
 * The {@link TaskProviderRegistry} is the common component for registration and provision of
 * {@link TaskProvider}s. Theia will collect all {@link TaskContribution}s and invoke {@link TaskContribution#registerProviders}
 * for each contribution.
 */
let TaskProviderRegistry = class TaskProviderRegistry {
    constructor() {
        this.onWillProvideTaskProviderEmitter = new event_1.Emitter();
        /**
         * Emit when the registry provides a registered task provider. i.e. when the {@link TaskProviderRegistry#getProvider}
         * function is called.
         */
        this.onWillProvideTaskProvider = this.onWillProvideTaskProviderEmitter.event;
    }
    init() {
        this.providers = new Map();
    }
    /**
     * Registers the given {@link TaskProvider} for task configurations of the specified type
     * @param type the task configuration type for which the given provider should be registered.
     * @param provider the `TaskProvider` that should be registered.
     *
     * @returns a `Disposable` that can be invoked to unregister the given resolver.
     */
    register(type, provider, handle) {
        const key = handle === undefined ? type : `${type}::${handle}`;
        this.providers.set(key, provider);
        return {
            dispose: () => this.providers.delete(key)
        };
    }
    /**
     * Initiates activation of a TaskProvider with the given type
     * @param type the task configuration type, '*' indicates, all providers.
     */
    async activateProvider(type) {
        await event_1.WaitUntilEvent.fire(this.onWillProvideTaskProviderEmitter, { taskType: type });
    }
    /**
     * Retrieves the {@link TaskProvider} registered for the given type task configuration type.
     * If there is already a `TaskProvider` registered for the specified type the registration will
     * be overwritten with the new value.
     * @param type the task configuration type.
     *
     * @returns a promise of the registered `TaskProvider`` or `undefined` if no provider is registered for the given type.
     */
    async getProvider(type) {
        await this.activateProvider(type);
        return this.providers.get(type);
    }
    /**
     * Retrieve all registered {@link TaskProvider}s.
     *
     * Use {@link activateProvider} to control registration of providers as needed.
     * @returns a promise of all registered {@link TaskProvider}s.
     */
    async getProviders() {
        return [...this.providers.values()];
    }
};
exports.TaskProviderRegistry = TaskProviderRegistry;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskProviderRegistry.prototype, "init", null);
exports.TaskProviderRegistry = TaskProviderRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskProviderRegistry);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-definition-registry.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-definition-registry.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskDefinitionRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
let TaskDefinitionRegistry = class TaskDefinitionRegistry {
    constructor() {
        // task type - array of task definitions
        this.definitions = new Map();
        this.onDidRegisterTaskDefinitionEmitter = new common_1.Emitter();
        this.onDidUnregisterTaskDefinitionEmitter = new common_1.Emitter();
    }
    get onDidRegisterTaskDefinition() {
        return this.onDidRegisterTaskDefinitionEmitter.event;
    }
    get onDidUnregisterTaskDefinition() {
        return this.onDidUnregisterTaskDefinitionEmitter.event;
    }
    /**
     * Returns all task definitions that are registered
     * @return the task definitions that are registered
     */
    getAll() {
        const all = [];
        for (const definitions of this.definitions.values()) {
            all.push(...definitions);
        }
        return all;
    }
    /**
     * Finds the task definition(s) from the registry with the given `taskType`.
     *
     * @param taskType the type of the task
     * @return an array of the task definitions. If no task definitions are found, an empty array is returned.
     */
    getDefinitions(taskType) {
        return this.definitions.get(taskType) || [];
    }
    /**
     * Finds the task definition from the registry for the task configuration.
     * The task configuration is considered as a "match" to the task definition if it has all the `required` properties.
     * In case that more than one task definition is found, return the one that has the biggest number of matched properties.
     *
     * @param taskConfiguration the task configuration
     * @return the task definition for the task configuration. If the task definition is not found, `undefined` is returned.
     */
    getDefinition(taskConfiguration) {
        const definitions = this.getDefinitions(taskConfiguration.type);
        let matchedDefinition;
        let highest = -1;
        for (const def of definitions) {
            const required = def.properties.required || [];
            if (!required.every(requiredProp => taskConfiguration[requiredProp] !== undefined)) {
                continue;
            }
            let score = required.length; // number of required properties
            const requiredProps = new Set(required);
            // number of optional properties
            score += def.properties.all.filter(p => !requiredProps.has(p) && taskConfiguration[p] !== undefined).length;
            if (score > highest) {
                highest = score;
                matchedDefinition = def;
            }
        }
        return matchedDefinition;
    }
    /**
     * Add a task definition to the registry.
     *
     * @param definition the task definition to be added.
     */
    register(definition) {
        const taskType = definition.taskType;
        const definitions = this.definitions.get(taskType) || [];
        definitions.push(definition);
        this.definitions.set(taskType, definitions);
        this.onDidRegisterTaskDefinitionEmitter.fire(undefined);
        return disposable_1.Disposable.create(() => {
            const index = definitions.indexOf(definition);
            if (index !== -1) {
                definitions.splice(index, 1);
            }
            this.onDidUnregisterTaskDefinitionEmitter.fire(undefined);
        });
    }
    compareTasks(one, other) {
        const oneType = one.type;
        const otherType = other.type;
        if (oneType !== otherType) {
            return false;
        }
        if (one['taskType'] !== other['taskType']) {
            return false;
        }
        const def = this.getDefinition(one);
        if (def) {
            // scope is either a string or an enum value. Anyway...they must exactly match
            // "_scope" may hold the Uri to the associated workspace whereas
            // "scope" reflects the original TaskConfigurationScope as provided by plugins,
            // Matching "_scope" or "scope" are both accepted in order to correlate provided task
            // configurations (e.g. TaskScope.Workspace) against already configured tasks.
            return def.properties.all.every(p => p === 'type' || coreutils_1.JSONExt.deepEqual(one[p], other[p]))
                && (one._scope === other._scope || one.scope === other.scope);
        }
        return one.label === other.label && one._source === other._source;
    }
};
exports.TaskDefinitionRegistry = TaskDefinitionRegistry;
exports.TaskDefinitionRegistry = TaskDefinitionRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskDefinitionRegistry);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-name-resolver.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-name-resolver.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskNameResolver = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const task_configurations_1 = __webpack_require__(/*! ./task-configurations */ "../node_modules/@theia/task/lib/browser/task-configurations.js");
let TaskNameResolver = class TaskNameResolver {
    /**
     * Returns task name to display.
     * It is aligned with VS Code.
     */
    resolve(task) {
        if (this.isDetectedTask(task)) {
            const scope = task._scope;
            const rawConfigs = this.taskConfigurations.getRawTaskConfigurations(scope);
            const jsonConfig = rawConfigs.find(rawConfig => this.taskDefinitionRegistry.compareTasks({
                ...rawConfig, _scope: scope
            }, task));
            // detected task that has a `label` defined in `tasks.json`
            if (jsonConfig && jsonConfig.label) {
                return jsonConfig.label;
            }
            return `${task.source || task._source}: ${task.label}`;
        }
        // it is a hack, when task is customized but extension is absent
        return task.label || `${task.type}: ${task.task}`;
    }
    isDetectedTask(task) {
        return !!this.taskDefinitionRegistry.getDefinition(task);
    }
};
exports.TaskNameResolver = TaskNameResolver;
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskNameResolver.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_configurations_1.TaskConfigurations),
    tslib_1.__metadata("design:type", task_configurations_1.TaskConfigurations)
], TaskNameResolver.prototype, "taskConfigurations", void 0);
exports.TaskNameResolver = TaskNameResolver = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskNameResolver);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-node.js":
/*!************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-node.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskNode = void 0;
class TaskNode {
    constructor(taskId, childTasks, parentsID) {
        this.taskId = taskId;
        this.childTasks = childTasks;
        this.parentsID = parentsID;
    }
    addChildDependency(node) {
        this.childTasks.push(node);
    }
    addParentDependency(parentId) {
        this.parentsID.push(parentId);
    }
}
exports.TaskNode = TaskNode;


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProblemMatcherRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const common_2 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const task_problem_pattern_registry_1 = __webpack_require__(/*! ./task-problem-pattern-registry */ "../node_modules/@theia/task/lib/browser/task-problem-pattern-registry.js");
const severity_1 = __webpack_require__(/*! @theia/core/lib/common/severity */ "../node_modules/@theia/core/lib/common/severity.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
let ProblemMatcherRegistry = class ProblemMatcherRegistry {
    constructor() {
        this.matchers = new Map();
        this.readyPromise = new promise_util_1.Deferred();
        this.onDidChangeProblemMatcherEmitter = new common_1.Emitter();
    }
    get onDidChangeProblemMatcher() {
        return this.onDidChangeProblemMatcherEmitter.event;
    }
    init() {
        this.problemPatternRegistry.onReady().then(() => {
            this.fillDefaults();
            this.readyPromise.resolve();
            this.onDidChangeProblemMatcherEmitter.fire(undefined);
        });
    }
    onReady() {
        return this.readyPromise.promise;
    }
    /**
     * Add a problem matcher to the registry.
     *
     * @param definition the problem matcher to be added.
     */
    register(matcher) {
        if (!matcher.name) {
            console.error('Only named Problem Matchers can be registered.');
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => {
            /* mark as not disposed */
            this.onDidChangeProblemMatcherEmitter.fire(undefined);
        }));
        this.doRegister(matcher, toDispose).then(() => this.onDidChangeProblemMatcherEmitter.fire(undefined));
        return toDispose;
    }
    async doRegister(matcher, toDispose) {
        const problemMatcher = await this.getProblemMatcherFromContribution(matcher);
        if (toDispose.disposed) {
            return;
        }
        toDispose.push(this.add(problemMatcher));
    }
    /**
     * Finds the problem matcher from the registry by its name.
     *
     * @param name the name of the problem matcher
     * @return the problem matcher. If the task definition is not found, `undefined` is returned.
     */
    get(name) {
        return this.matchers.get((0, common_2.fromVariableName)(name));
    }
    /**
     * Returns all registered problem matchers in the registry.
     */
    getAll() {
        const all = [];
        for (const matcherName of this.matchers.keys()) {
            all.push(this.get(matcherName));
        }
        all.sort((one, other) => one.name.localeCompare(other.name));
        return all;
    }
    /**
     * Transforms the `ProblemMatcherContribution` to a `ProblemMatcher`
     *
     * @return the problem matcher
     */
    async getProblemMatcherFromContribution(matcher) {
        let baseMatcher;
        if (matcher.base) {
            baseMatcher = this.get(matcher.base);
        }
        let fileLocation;
        let filePrefix;
        if (matcher.fileLocation === undefined) {
            fileLocation = baseMatcher ? baseMatcher.fileLocation : common_2.FileLocationKind.Relative;
            filePrefix = baseMatcher ? baseMatcher.filePrefix : '${workspaceFolder}';
        }
        else {
            const locationAndPrefix = this.getFileLocationKindAndPrefix(matcher);
            fileLocation = locationAndPrefix.fileLocation;
            filePrefix = locationAndPrefix.filePrefix;
        }
        const patterns = [];
        if (matcher.pattern) {
            if (typeof matcher.pattern === 'string') {
                await this.problemPatternRegistry.onReady();
                const registeredPattern = this.problemPatternRegistry.get((0, common_2.fromVariableName)(matcher.pattern));
                if (Array.isArray(registeredPattern)) {
                    patterns.push(...registeredPattern);
                }
                else if (!!registeredPattern) {
                    patterns.push(registeredPattern);
                }
            }
            else if (Array.isArray(matcher.pattern)) {
                patterns.push(...matcher.pattern.map(p => common_2.ProblemPattern.fromProblemPatternContribution(p)));
            }
            else {
                patterns.push(common_2.ProblemPattern.fromProblemPatternContribution(matcher.pattern));
            }
        }
        else if (baseMatcher) {
            if (Array.isArray(baseMatcher.pattern)) {
                patterns.push(...baseMatcher.pattern);
            }
            else {
                patterns.push(baseMatcher.pattern);
            }
        }
        let deprecated = matcher.deprecated;
        if (deprecated === undefined && baseMatcher) {
            deprecated = baseMatcher.deprecated;
        }
        let applyTo;
        if (matcher.applyTo === undefined) {
            applyTo = baseMatcher ? baseMatcher.applyTo : common_2.ApplyToKind.allDocuments;
        }
        else {
            applyTo = common_2.ApplyToKind.fromString(matcher.applyTo) || common_2.ApplyToKind.allDocuments;
        }
        let severity = severity_1.Severity.fromValue(matcher.severity);
        if (matcher.severity === undefined && baseMatcher && baseMatcher.severity !== undefined) {
            severity = baseMatcher.severity;
        }
        let watching = common_2.WatchingMatcher.fromWatchingMatcherContribution(matcher.background || matcher.watching);
        if (watching === undefined && baseMatcher) {
            watching = baseMatcher.watching;
        }
        const problemMatcher = {
            name: matcher.name || (baseMatcher ? baseMatcher.name : undefined),
            label: matcher.label || (baseMatcher === null || baseMatcher === void 0 ? void 0 : baseMatcher.label) || '',
            deprecated,
            owner: matcher.owner || (baseMatcher ? baseMatcher.owner : ''),
            source: matcher.source || (baseMatcher ? baseMatcher.source : undefined),
            applyTo,
            fileLocation,
            filePrefix,
            pattern: patterns,
            severity,
            watching
        };
        return problemMatcher;
    }
    add(matcher) {
        this.matchers.set(matcher.name, matcher);
        return disposable_1.Disposable.create(() => this.matchers.delete(matcher.name));
    }
    getFileLocationKindAndPrefix(matcher) {
        let fileLocation = common_2.FileLocationKind.Relative;
        let filePrefix = '${workspaceFolder}';
        if (matcher.fileLocation !== undefined) {
            if (Array.isArray(matcher.fileLocation)) {
                if (matcher.fileLocation.length > 0) {
                    const locationKind = common_2.FileLocationKind.fromString(matcher.fileLocation[0]);
                    if (matcher.fileLocation.length === 1 && locationKind === common_2.FileLocationKind.Absolute) {
                        fileLocation = locationKind;
                    }
                    else if (matcher.fileLocation.length === 2 && locationKind === common_2.FileLocationKind.Relative && matcher.fileLocation[1]) {
                        fileLocation = locationKind;
                        filePrefix = matcher.fileLocation[1];
                    }
                }
            }
            else {
                const locationKind = common_2.FileLocationKind.fromString(matcher.fileLocation);
                if (locationKind) {
                    fileLocation = locationKind;
                    if (locationKind === common_2.FileLocationKind.Relative) {
                        filePrefix = '${workspaceFolder}';
                    }
                }
            }
        }
        return { fileLocation, filePrefix };
    }
    // copied from https://github.com/Microsoft/vscode/blob/1.33.1/src/vs/workbench/contrib/tasks/common/problemMatcher.ts
    fillDefaults() {
        this.add({
            name: 'msCompile',
            label: 'Microsoft compiler problems',
            owner: 'msCompile',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            pattern: (this.problemPatternRegistry.get('msCompile'))
        });
        this.add({
            name: 'lessCompile',
            label: 'Less problems',
            deprecated: true,
            owner: 'lessCompile',
            source: 'less',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            pattern: (this.problemPatternRegistry.get('lessCompile')),
            severity: severity_1.Severity.Error
        });
        this.add({
            name: 'gulp-tsc',
            label: 'Gulp TSC Problems',
            owner: 'typescript',
            source: 'ts',
            applyTo: common_2.ApplyToKind.closedDocuments,
            fileLocation: common_2.FileLocationKind.Relative,
            filePrefix: '${workspaceFolder}',
            pattern: (this.problemPatternRegistry.get('gulp-tsc'))
        });
        this.add({
            name: 'jshint',
            label: 'JSHint problems',
            owner: 'jshint',
            source: 'jshint',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            pattern: (this.problemPatternRegistry.get('jshint'))
        });
        this.add({
            name: 'jshint-stylish',
            label: 'JSHint stylish problems',
            owner: 'jshint',
            source: 'jshint',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            pattern: (this.problemPatternRegistry.get('jshint-stylish'))
        });
        this.add({
            name: 'eslint-compact',
            label: 'ESLint compact problems',
            owner: 'eslint',
            source: 'eslint',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            filePrefix: '${workspaceFolder}',
            pattern: (this.problemPatternRegistry.get('eslint-compact'))
        });
        this.add({
            name: 'eslint-stylish',
            label: 'ESLint stylish problems',
            owner: 'eslint',
            source: 'eslint',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Absolute,
            pattern: (this.problemPatternRegistry.get('eslint-stylish'))
        });
        this.add({
            name: 'go',
            label: 'Go problems',
            owner: 'go',
            source: 'go',
            applyTo: common_2.ApplyToKind.allDocuments,
            fileLocation: common_2.FileLocationKind.Relative,
            filePrefix: '${workspaceFolder}',
            pattern: (this.problemPatternRegistry.get('go'))
        });
    }
};
exports.ProblemMatcherRegistry = ProblemMatcherRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(task_problem_pattern_registry_1.ProblemPatternRegistry),
    tslib_1.__metadata("design:type", task_problem_pattern_registry_1.ProblemPatternRegistry)
], ProblemMatcherRegistry.prototype, "problemPatternRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ProblemMatcherRegistry.prototype, "init", null);
exports.ProblemMatcherRegistry = ProblemMatcherRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ProblemMatcherRegistry);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-problem-pattern-registry.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-problem-pattern-registry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProblemPatternRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
let ProblemPatternRegistry = class ProblemPatternRegistry {
    constructor() {
        this.patterns = new Map();
        this.readyPromise = new promise_util_1.Deferred();
    }
    init() {
        this.fillDefaults();
        this.readyPromise.resolve();
    }
    onReady() {
        return this.readyPromise.promise;
    }
    /**
     * Add a problem pattern to the registry.
     *
     * @param definition the problem pattern to be added.
     */
    register(value) {
        if (Array.isArray(value)) {
            const toDispose = new disposable_1.DisposableCollection();
            value.forEach(problemPatternContribution => toDispose.push(this.register(problemPatternContribution)));
            return toDispose;
        }
        if (!value.name) {
            console.error('Only named Problem Patterns can be registered.');
            return disposable_1.Disposable.NULL;
        }
        const problemPattern = common_1.ProblemPattern.fromProblemPatternContribution(value);
        return this.add(problemPattern.name, problemPattern);
    }
    /**
     * Finds the problem pattern(s) from the registry with the given name.
     *
     * @param key the name of the problem patterns
     * @return a problem pattern or an array of the problem patterns associated with the name. If no problem patterns are found, `undefined` is returned.
     */
    get(key) {
        return this.patterns.get(key);
    }
    add(key, value) {
        let toAdd;
        if (Array.isArray(value)) {
            toAdd = value.map(v => Object.assign(v, { name: key }));
        }
        else {
            toAdd = Object.assign(value, { name: key });
        }
        this.patterns.set(key, toAdd);
        return disposable_1.Disposable.create(() => this.patterns.delete(key));
    }
    // copied from https://github.com/Microsoft/vscode/blob/1.33.1/src/vs/workbench/contrib/tasks/common/problemMatcher.ts
    fillDefaults() {
        this.add('msCompile', {
            regexp: /^(?:\s+\d+\>)?([^\s].*)\((\d+|\d+,\d+|\d+,\d+,\d+,\d+)\)\s*:\s+(error|warning|info)\s+(\w{1,2}\d+)\s*:\s*(.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            location: 2,
            severity: 3,
            code: 4,
            message: 5
        });
        this.add('gulp-tsc', {
            regexp: /^([^\s].*)\((\d+|\d+,\d+|\d+,\d+,\d+,\d+)\):\s+(\d+)\s+(.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            location: 2,
            code: 3,
            message: 4
        });
        this.add('cpp', {
            regexp: /^([^\s].*)\((\d+|\d+,\d+|\d+,\d+,\d+,\d+)\):\s+(error|warning|info)\s+(C\d+)\s*:\s*(.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            location: 2,
            severity: 3,
            code: 4,
            message: 5
        });
        this.add('csc', {
            regexp: /^([^\s].*)\((\d+|\d+,\d+|\d+,\d+,\d+,\d+)\):\s+(error|warning|info)\s+(CS\d+)\s*:\s*(.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            location: 2,
            severity: 3,
            code: 4,
            message: 5
        });
        this.add('vb', {
            regexp: /^([^\s].*)\((\d+|\d+,\d+|\d+,\d+,\d+,\d+)\):\s+(error|warning|info)\s+(BC\d+)\s*:\s*(.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            location: 2,
            severity: 3,
            code: 4,
            message: 5
        });
        this.add('lessCompile', {
            regexp: /^\s*(.*) in file (.*) line no. (\d+)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            message: 1,
            file: 2,
            line: 3
        });
        this.add('jshint', {
            regexp: /^(.*):\s+line\s+(\d+),\s+col\s+(\d+),\s(.+?)(?:\s+\((\w)(\d+)\))?$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 1,
            line: 2,
            character: 3,
            message: 4,
            severity: 5,
            code: 6
        });
        this.add('jshint-stylish', [
            {
                regexp: /^(.+)$/.source,
                kind: common_1.ProblemLocationKind.Location,
                file: 1
            },
            {
                regexp: /^\s+line\s+(\d+)\s+col\s+(\d+)\s+(.+?)(?:\s+\((\w)(\d+)\))?$/.source,
                line: 1,
                character: 2,
                message: 3,
                severity: 4,
                code: 5,
                loop: true
            }
        ]);
        this.add('eslint-compact', {
            regexp: /^(.+):\sline\s(\d+),\scol\s(\d+),\s(Error|Warning|Info)\s-\s(.+)\s\((.+)\)$/.source,
            file: 1,
            kind: common_1.ProblemLocationKind.Location,
            line: 2,
            character: 3,
            severity: 4,
            message: 5,
            code: 6
        });
        this.add('eslint-stylish', [
            {
                regexp: /^([^\s].*)$/.source,
                kind: common_1.ProblemLocationKind.Location,
                file: 1
            },
            {
                regexp: /^\s+(\d+):(\d+)\s+(error|warning|info)\s+(.+?)(?:\s\s+(.*))?$/.source,
                line: 1,
                character: 2,
                severity: 3,
                message: 4,
                code: 5,
                loop: true
            }
        ]);
        this.add('go', {
            regexp: /^([^:]*: )?((.:)?[^:]*):(\d+)(:(\d+))?: (.*)$/.source,
            kind: common_1.ProblemLocationKind.Location,
            file: 2,
            line: 4,
            character: 6,
            message: 7
        });
    }
};
exports.ProblemPatternRegistry = ProblemPatternRegistry;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ProblemPatternRegistry.prototype, "init", null);
exports.ProblemPatternRegistry = ProblemPatternRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ProblemPatternRegistry);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-schema-updater.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-schema-updater.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
// This file is inspired by VSCode and partially copied from https://github.com/Microsoft/vscode/blob/1.33.1/src/vs/workbench/contrib/tasks/common/problemMatcher.ts
// 'problemMatcher.ts' copyright:
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskSchemaUpdater = exports.taskSchemaId = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const Ajv = __webpack_require__(/*! @theia/core/shared/ajv */ "../node_modules/@theia/core/shared/ajv/index.js");
const debounce = __webpack_require__(/*! p-debounce */ "../node_modules/p-debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const json_schema_store_1 = __webpack_require__(/*! @theia/core/lib/browser/json-schema-store */ "../node_modules/@theia/core/lib/browser/json-schema-store.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const variable_input_schema_1 = __webpack_require__(/*! @theia/variable-resolver/lib/browser/variable-input-schema */ "../node_modules/@theia/variable-resolver/lib/browser/variable-input-schema.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const task_problem_matcher_registry_1 = __webpack_require__(/*! ./task-problem-matcher-registry */ "../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const common_2 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/userstorage/lib/browser */ "../node_modules/@theia/userstorage/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../node_modules/@theia/workspace/lib/browser/index.js");
exports.taskSchemaId = 'vscode://schemas/tasks';
let TaskSchemaUpdater = class TaskSchemaUpdater {
    constructor() {
        this.onDidChangeTaskSchemaEmitter = new common_1.Emitter();
        this.onDidChangeTaskSchema = this.onDidChangeTaskSchemaEmitter.event;
        this.uri = new uri_1.default(exports.taskSchemaId);
        this.update = debounce(() => this.doUpdate(), 0);
    }
    init() {
        this.jsonSchemaData.setSchema(this.uri, '');
        this.updateProblemMatcherNames();
        this.updateSupportedTaskTypes();
        // update problem matcher names in the task schema every time a problem matcher is added or disposed
        this.problemMatcherRegistry.onDidChangeProblemMatcher(() => this.updateProblemMatcherNames());
        // update supported task types in the task schema every time a task definition is registered or removed
        this.taskDefinitionRegistry.onDidRegisterTaskDefinition(() => this.updateSupportedTaskTypes());
        this.taskDefinitionRegistry.onDidUnregisterTaskDefinition(() => this.updateSupportedTaskTypes());
    }
    registerSchemas(context) {
        context.registerSchema({
            fileMatch: ['tasks.json', browser_1.UserStorageUri.resolve('tasks.json').toString()],
            url: this.uri.toString()
        });
        this.workspaceService.updateSchema('tasks', { $ref: this.uri.toString() });
    }
    doUpdate() {
        taskConfigurationSchema.anyOf = [processTaskConfigurationSchema, ...customizedDetectedTasks, ...customSchemas];
        const schema = this.getTaskSchema();
        this.doValidate = new Ajv().compile(schema);
        this.jsonSchemaData.setSchema(this.uri, schema);
        this.onDidChangeTaskSchemaEmitter.fire(undefined);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validate(data) {
        return !!this.doValidate && !!this.doValidate(data);
    }
    /**
     * Adds given task schema to `taskConfigurationSchema` as `oneOf` subschema.
     * Replaces existed subschema by given schema if the corresponding `$id` properties are equal.
     *
     * Note: please provide `$id` property for subschema to have ability remove/replace it.
     * @param schema subschema for adding to `taskConfigurationSchema`
     */
    addSubschema(schema) {
        const schemaId = schema.$id;
        if (schemaId) {
            this.doRemoveSubschema(schemaId);
        }
        customSchemas.push(schema);
        this.update();
    }
    /**
     * Removes task subschema from `taskConfigurationSchema`.
     *
     * @param arg `$id` property of subschema
     */
    removeSubschema(arg) {
        const isRemoved = this.doRemoveSubschema(arg);
        if (isRemoved) {
            this.update();
        }
    }
    /**
     * Removes task subschema from `customSchemas`, use `update()` to apply the changes for `taskConfigurationSchema`.
     *
     * @param arg `$id` property of subschema
     * @returns `true` if subschema was removed, `false` otherwise
     */
    doRemoveSubschema(arg) {
        const index = customSchemas.findIndex(existed => !!existed.$id && existed.$id === arg);
        if (index > -1) {
            customSchemas.splice(index, 1);
            return true;
        }
        return false;
    }
    /** Returns an array of task types that are registered, including the default types */
    async getRegisteredTaskTypes() {
        const serverSupportedTypes = await this.taskServer.getRegisteredTaskTypes();
        const browserSupportedTypes = this.taskDefinitionRegistry.getAll().map(def => def.taskType);
        const allTypes = new Set([...serverSupportedTypes, ...browserSupportedTypes]);
        return Array.from(allTypes.values()).sort();
    }
    updateSchemasForRegisteredTasks() {
        customizedDetectedTasks.length = 0;
        const definitions = this.taskDefinitionRegistry.getAll();
        definitions.forEach(def => {
            const customizedDetectedTask = {
                type: 'object',
                required: ['type'],
                properties: {}
            };
            const taskType = {
                ...defaultTaskType,
                enum: [def.taskType],
                default: def.taskType,
                description: 'The task type to customize'
            };
            customizedDetectedTask.properties.type = taskType;
            const required = def.properties.required || [];
            def.properties.all.forEach(taskProp => {
                if (required.find(requiredProp => requiredProp === taskProp)) { // property is mandatory
                    customizedDetectedTask.required.push(taskProp);
                }
                customizedDetectedTask.properties[taskProp] = { ...def.properties.schema.properties[taskProp] };
            });
            customizedDetectedTask.properties.label = taskLabel;
            customizedDetectedTask.properties.problemMatcher = problemMatcher;
            customizedDetectedTask.properties.presentation = presentation;
            customizedDetectedTask.properties.options = commandOptionsSchema;
            customizedDetectedTask.properties.group = group;
            customizedDetectedTask.properties.detail = detail;
            customizedDetectedTask.additionalProperties = true;
            customizedDetectedTasks.push(customizedDetectedTask);
        });
    }
    /** Returns the task's JSON schema */
    getTaskSchema() {
        return {
            type: 'object',
            default: { version: '2.0.0', tasks: [] },
            properties: {
                version: {
                    type: 'string',
                    default: '2.0.0'
                },
                tasks: {
                    type: 'array',
                    items: {
                        ...(0, common_1.deepClone)(taskConfigurationSchema)
                    }
                },
                inputs: variable_input_schema_1.inputsSchema.definitions.inputs
            },
            additionalProperties: false,
            allowComments: true,
            allowTrailingCommas: true,
        };
    }
    /** Gets the most up-to-date names of problem matchers from the registry and update the task schema */
    updateProblemMatcherNames() {
        const matcherNames = this.problemMatcherRegistry.getAll().map(m => (0, common_2.asVariableName)(m.name));
        problemMatcherNames.length = 0;
        problemMatcherNames.push(...matcherNames);
        this.update();
    }
    async updateSupportedTaskTypes() {
        this.updateSchemasForRegisteredTasks();
        this.update();
    }
};
exports.TaskSchemaUpdater = TaskSchemaUpdater;
tslib_1.__decorate([
    (0, inversify_1.inject)(json_schema_store_1.JsonSchemaDataStore),
    tslib_1.__metadata("design:type", json_schema_store_1.JsonSchemaDataStore)
], TaskSchemaUpdater.prototype, "jsonSchemaData", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_problem_matcher_registry_1.ProblemMatcherRegistry),
    tslib_1.__metadata("design:type", task_problem_matcher_registry_1.ProblemMatcherRegistry)
], TaskSchemaUpdater.prototype, "problemMatcherRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskSchemaUpdater.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_2.TaskServer),
    tslib_1.__metadata("design:type", Object)
], TaskSchemaUpdater.prototype, "taskServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], TaskSchemaUpdater.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskSchemaUpdater.prototype, "init", null);
exports.TaskSchemaUpdater = TaskSchemaUpdater = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskSchemaUpdater);
const commandSchema = {
    type: 'string',
    description: 'The actual command or script to execute'
};
const commandArgSchema = {
    type: 'array',
    description: 'A list of strings, each one being one argument to pass to the command',
    items: {
        type: 'string'
    }
};
const commandOptionsSchema = {
    type: 'object',
    description: 'The command options used when the command is executed',
    properties: {
        cwd: {
            type: 'string',
            description: 'The directory in which the command will be executed',
            default: '${workspaceFolder}'
        },
        env: {
            type: 'object',
            description: 'The environment of the executed program or shell. If omitted the parent process\' environment is used'
        },
        shell: {
            type: 'object',
            description: 'Configuration of the shell when task type is `shell`',
            properties: {
                executable: {
                    type: 'string',
                    description: 'The shell to use'
                },
                args: {
                    type: 'array',
                    description: `The arguments to be passed to the shell executable to run in command mode
                        (e.g ['-c'] for bash or ['/S', '/C'] for cmd.exe)`,
                    items: {
                        type: 'string'
                    }
                }
            }
        }
    }
};
const problemMatcherNames = [];
const defaultTaskTypes = ['shell', 'process'];
const supportedTaskTypes = [...defaultTaskTypes];
const taskLabel = {
    type: 'string',
    description: 'A unique string that identifies the task that is also used as task\'s user interface label'
};
const defaultTaskType = {
    type: 'string',
    enum: supportedTaskTypes,
    default: defaultTaskTypes[0],
    description: 'Determines what type of process will be used to execute the task. Only shell types will have output shown on the user interface'
};
const commandAndArgs = {
    command: commandSchema,
    args: commandArgSchema,
    options: commandOptionsSchema
};
const group = {
    oneOf: [
        {
            type: 'string',
            enum: ['build', 'test', 'none'],
            enumDescriptions: [
                'Marks the task as a build task accessible through the \'Run Build Task\' command.',
                'Marks the task as a test task accessible through the \'Run Test Task\' command.',
                'Assigns the task to no group'
            ]
        },
        {
            type: 'object',
            properties: {
                kind: {
                    type: 'string',
                    default: 'none',
                    description: 'The task\'s execution group.',
                    enum: ['build', 'test', 'none'],
                    enumDescriptions: [
                        'Marks the task as a build task accessible through the \'Run Build Task\' command.',
                        'Marks the task as a test task accessible through the \'Run Test Task\' command.',
                        'Assigns the task to no group'
                    ]
                },
                isDefault: {
                    type: 'boolean',
                    default: false,
                    description: 'Defines if this task is the default task in the group.'
                }
            }
        }
    ],
    // eslint-disable-next-line max-len
    description: 'Defines to which execution group this task belongs to. It supports "build" to add it to the build group and "test" to add it to the test group.'
};
const problemPattern = {
    default: {
        regexp: '^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$',
        file: 1,
        location: 2,
        message: 3
    },
    type: 'object',
    properties: {
        regexp: {
            type: 'string',
            description: 'The regular expression to find an error, warning or info in the output.'
        },
        kind: {
            type: 'string',
            description: 'whether the pattern matches a location (file and line) or only a file.'
        },
        file: {
            type: 'integer',
            description: 'The match group index of the filename. If omitted 1 is used.'
        },
        location: {
            type: 'integer',
            // eslint-disable-next-line max-len
            description: 'The match group index of the problem\'s location. Valid location patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). If omitted (line,column) is assumed.'
        },
        line: {
            type: 'integer',
            description: 'The match group index of the problem\'s line. Defaults to 2'
        },
        column: {
            type: 'integer',
            description: 'The match group index of the problem\'s line character. Defaults to 3'
        },
        endLine: {
            type: 'integer',
            description: 'The match group index of the problem\'s end line. Defaults to undefined'
        },
        endColumn: {
            type: 'integer',
            description: 'The match group index of the problem\'s end line character. Defaults to undefined'
        },
        severity: {
            type: 'integer',
            description: 'The match group index of the problem\'s severity. Defaults to undefined'
        },
        code: {
            type: 'integer',
            description: 'The match group index of the problem\'s code. Defaults to undefined'
        },
        message: {
            type: 'integer',
            description: 'The match group index of the message. If omitted it defaults to 4 if location is specified. Otherwise it defaults to 5.'
        },
        loop: {
            type: 'boolean',
            // eslint-disable-next-line max-len
            description: 'In a multi line matcher loop indicated whether this pattern is executed in a loop as long as it matches. Can only specified on a last pattern in a multi line pattern.'
        }
    }
};
const multiLineProblemPattern = {
    type: 'array',
    items: problemPattern
};
const watchingPattern = {
    type: 'object',
    additionalProperties: false,
    properties: {
        regexp: {
            type: 'string',
            description: 'The regular expression to detect the begin or end of a background task.'
        },
        file: {
            type: 'integer',
            description: 'The match group index of the filename. Can be omitted.'
        },
    }
};
const patternType = {
    anyOf: [
        {
            type: 'string',
            description: 'The name of a contributed or predefined pattern'
        },
        problemPattern,
        multiLineProblemPattern
    ],
    description: 'A problem pattern or the name of a contributed or predefined problem pattern. Can be omitted if base is specified.'
};
const problemMatcherObject = {
    type: 'object',
    properties: {
        base: {
            type: 'string',
            enum: problemMatcherNames,
            description: 'The name of a base problem matcher to use.'
        },
        owner: {
            type: 'string',
            description: 'The owner of the problem inside Code. Can be omitted if base is specified. Defaults to \'external\' if omitted and base is not specified.'
        },
        source: {
            type: 'string',
            description: 'A human-readable string describing the source of this diagnostic, e.g. \'typescript\' or \'super lint\'.'
        },
        severity: {
            type: 'string',
            enum: ['error', 'warning', 'info'],
            description: 'The default severity for captures problems. Is used if the pattern doesn\'t define a match group for severity.'
        },
        applyTo: {
            type: 'string',
            enum: ['allDocuments', 'openDocuments', 'closedDocuments'],
            description: 'Controls if a problem reported on a text document is applied only to open, closed or all documents.'
        },
        pattern: patternType,
        fileLocation: {
            oneOf: [
                {
                    type: 'string',
                    enum: ['absolute', 'relative', 'autoDetect']
                },
                {
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                }
            ],
            description: 'Defines how file names reported in a problem pattern should be interpreted.'
        },
        background: {
            type: 'object',
            additionalProperties: false,
            description: 'Patterns to track the begin and end of a matcher active on a background task.',
            properties: {
                activeOnStart: {
                    type: 'boolean',
                    description: 'If set to true the background monitor is in active mode when the task starts. This is equals of issuing a line that matches the beginsPattern'
                },
                beginsPattern: {
                    oneOf: [
                        {
                            type: 'string'
                        },
                        watchingPattern
                    ],
                    description: 'If matched in the output the start of a background task is signaled.'
                },
                endsPattern: {
                    oneOf: [
                        {
                            type: 'string'
                        },
                        watchingPattern
                    ],
                    description: 'If matched in the output the end of a background task is signaled.'
                }
            }
        },
        watching: {
            type: 'object',
            additionalProperties: false,
            deprecationMessage: 'The watching property is deprecated. Use background instead.',
            description: 'Patterns to track the begin and end of a watching matcher.',
            properties: {
                activeOnStart: {
                    type: 'boolean',
                    description: 'If set to true the watcher is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern'
                },
                beginsPattern: {
                    oneOf: [
                        {
                            type: 'string'
                        },
                        watchingPattern
                    ],
                    description: 'If matched in the output the start of a watching task is signaled.'
                },
                endsPattern: {
                    oneOf: [
                        {
                            type: 'string'
                        },
                        watchingPattern
                    ],
                    description: 'If matched in the output the end of a watching task is signaled.'
                }
            }
        }
    }
};
const problemMatcher = {
    anyOf: [
        {
            type: 'string',
            description: 'Name of the problem matcher to parse the output of the task',
            enum: problemMatcherNames
        },
        {
            type: 'array',
            description: 'Name(s) of the problem matcher(s) to parse the output of the task',
            items: {
                type: 'string',
                enum: problemMatcherNames
            }
        },
        problemMatcherObject,
        {
            type: 'array',
            description: 'User defined problem matcher(s) to parse the output of the task',
            items: problemMatcherObject
        }
    ]
};
const presentation = {
    type: 'object',
    default: {
        echo: true,
        reveal: 'always',
        focus: false,
        panel: 'shared',
        showReuseMessage: true,
        clear: false
    },
    description: 'Configures the panel that is used to present the task\'s output and reads its input.',
    additionalProperties: true,
    properties: {
        echo: {
            type: 'boolean',
            default: true,
            description: 'Controls whether the executed command is echoed to the panel. Default is true.'
        },
        focus: {
            type: 'boolean',
            default: false,
            description: 'Controls whether the panel takes focus. Default is false. If set to true the panel is revealed as well.'
        },
        reveal: {
            type: 'string',
            enum: ['always', 'silent', 'never'],
            enumDescriptions: [
                'Always reveals the terminal when this task is executed.',
                'Only reveals the terminal if the task exits with an error or the problem matcher finds an error.',
                'Never reveals the terminal when this task is executed.'
            ],
            default: 'always',
            description: 'Controls whether the terminal running the task is revealed or not. May be overridden by option \"revealProblems\". Default is \"always\".'
        },
        panel: {
            type: 'string',
            enum: ['shared', 'dedicated', 'new'],
            enumDescriptions: [
                'The terminal is shared and the output of other task runs are added to the same terminal.',
                // eslint-disable-next-line max-len
                'The terminal is dedicated to a specific task. If that task is executed again, the terminal is reused. However, the output of a different task is presented in a different terminal.',
                'Every execution of that task is using a new clean terminal.'
            ],
            default: 'shared',
            description: 'Controls if the panel is shared between tasks, dedicated to this task or a new one is created on every run.'
        },
        showReuseMessage: {
            type: 'boolean',
            default: true,
            description: 'Controls whether to show the "Terminal will be reused by tasks" message.'
        },
        clear: {
            type: 'boolean',
            default: false,
            description: 'Controls whether the terminal is cleared before this task is run.'
        }
    }
};
const detail = {
    type: 'string',
    description: 'An optional description of a task that shows in the Run Task quick pick as a detail.'
};
const taskIdentifier = {
    type: 'object',
    additionalProperties: true,
    properties: {
        type: {
            type: 'string',
            description: 'The task identifier.'
        }
    }
};
const processTaskConfigurationSchema = {
    type: 'object',
    required: ['type', 'label', 'command'],
    properties: {
        label: taskLabel,
        type: defaultTaskType,
        ...commandAndArgs,
        isBackground: {
            type: 'boolean',
            default: false,
            description: 'Whether the executed task is kept alive and is running in the background.'
        },
        dependsOn: {
            anyOf: [
                {
                    type: 'string',
                    description: 'Another task this task depends on.'
                },
                taskIdentifier,
                {
                    type: 'array',
                    description: 'The other tasks this task depends on.',
                    items: {
                        anyOf: [
                            {
                                type: 'string'
                            },
                            taskIdentifier
                        ]
                    }
                }
            ],
            description: 'Either a string representing another task or an array of other tasks that this task depends on.'
        },
        dependsOrder: {
            type: 'string',
            enum: ['parallel', 'sequence'],
            enumDescriptions: [
                'Run all dependsOn tasks in parallel.',
                'Run all dependsOn tasks in sequence.'
            ],
            default: 'parallel',
            description: 'Determines the order of the dependsOn tasks for this task. Note that this property is not recursive.'
        },
        windows: {
            type: 'object',
            description: 'Windows specific command configuration that overrides the command, args, and options',
            properties: commandAndArgs
        },
        osx: {
            type: 'object',
            description: 'MacOS specific command configuration that overrides the command, args, and options',
            properties: commandAndArgs
        },
        linux: {
            type: 'object',
            description: 'Linux specific command configuration that overrides the default command, args, and options',
            properties: commandAndArgs
        },
        group,
        problemMatcher,
        presentation,
        detail,
    },
    additionalProperties: true
};
const customizedDetectedTasks = [];
const customSchemas = [];
const taskConfigurationSchema = {
    $id: exports.taskSchemaId,
    anyOf: [processTaskConfigurationSchema, ...customizedDetectedTasks, ...customSchemas]
};


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-service.js":
/*!***************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-service.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskService = exports.TaskEndedTypes = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../node_modules/@theia/core/lib/browser/opener-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../node_modules/@theia/core/lib/common/message-service.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
const quick_pick_service_1 = __webpack_require__(/*! @theia/core/lib/common/quick-pick-service */ "../node_modules/@theia/core/lib/common/quick-pick-service.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../node_modules/@theia/core/lib/browser/label-provider.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const problem_manager_1 = __webpack_require__(/*! @theia/markers/lib/browser/problem/problem-manager */ "../node_modules/@theia/markers/lib/browser/problem/problem-manager.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const browser_3 = __webpack_require__(/*! @theia/variable-resolver/lib/browser */ "../node_modules/@theia/variable-resolver/lib/browser/index.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../node_modules/@theia/workspace/lib/browser/workspace-service.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const common_2 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const task_watcher_1 = __webpack_require__(/*! ../common/task-watcher */ "../node_modules/@theia/task/lib/common/task-watcher.js");
const provided_task_configurations_1 = __webpack_require__(/*! ./provided-task-configurations */ "../node_modules/@theia/task/lib/browser/provided-task-configurations.js");
const task_configurations_1 = __webpack_require__(/*! ./task-configurations */ "../node_modules/@theia/task/lib/browser/task-configurations.js");
const task_contribution_1 = __webpack_require__(/*! ./task-contribution */ "../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const task_name_resolver_1 = __webpack_require__(/*! ./task-name-resolver */ "../node_modules/@theia/task/lib/browser/task-name-resolver.js");
const task_source_resolver_1 = __webpack_require__(/*! ./task-source-resolver */ "../node_modules/@theia/task/lib/browser/task-source-resolver.js");
const task_problem_matcher_registry_1 = __webpack_require__(/*! ./task-problem-matcher-registry */ "../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js");
const task_schema_updater_1 = __webpack_require__(/*! ./task-schema-updater */ "../node_modules/@theia/task/lib/browser/task-schema-updater.js");
const task_configuration_manager_1 = __webpack_require__(/*! ./task-configuration-manager */ "../node_modules/@theia/task/lib/browser/task-configuration-manager.js");
const problem_widget_1 = __webpack_require__(/*! @theia/markers/lib/browser/problem/problem-widget */ "../node_modules/@theia/markers/lib/browser/problem/problem-widget.js");
const task_node_1 = __webpack_require__(/*! ./task-node */ "../node_modules/@theia/task/lib/browser/task-node.js");
const monaco_workspace_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-workspace */ "../node_modules/@theia/monaco/lib/browser/monaco-workspace.js");
const task_terminal_widget_manager_1 = __webpack_require__(/*! ./task-terminal-widget-manager */ "../node_modules/@theia/task/lib/browser/task-terminal-widget-manager.js");
const shell_terminal_protocol_1 = __webpack_require__(/*! @theia/terminal/lib/common/shell-terminal-protocol */ "../node_modules/@theia/terminal/lib/common/shell-terminal-protocol.js");
const async_mutex_1 = __webpack_require__(/*! async-mutex */ "../node_modules/async-mutex/lib/index.js");
const task_context_key_service_1 = __webpack_require__(/*! ./task-context-key-service */ "../node_modules/@theia/task/lib/browser/task-context-key-service.js");
var TaskEndedTypes;
(function (TaskEndedTypes) {
    TaskEndedTypes[TaskEndedTypes["TaskExited"] = 0] = "TaskExited";
    TaskEndedTypes[TaskEndedTypes["BackgroundTaskEnded"] = 1] = "BackgroundTaskEnded";
})(TaskEndedTypes || (exports.TaskEndedTypes = TaskEndedTypes = {}));
let TaskService = class TaskService {
    constructor() {
        /**
         * The last executed task.
         */
        this.lastTask = { resolvedTask: undefined, option: undefined };
        this.cachedRecentTasks = [];
        this.runningTasks = new Map();
        this.taskStartingLock = new async_mutex_1.Mutex();
    }
    init() {
        this.getRunningTasks().then(tasks => tasks.forEach(task => {
            if (!this.runningTasks.has(task.taskId)) {
                this.runningTasks.set(task.taskId, {
                    exitCode: new promise_util_1.Deferred(), terminateSignal: new promise_util_1.Deferred(),
                    isBackgroundTaskEnded: new promise_util_1.Deferred()
                });
            }
        }));
        // notify user that task has started
        this.taskWatcher.onTaskCreated((event) => {
            if (!this.isEventForThisClient(event.ctx)) {
                return;
            }
            this.runningTasks.set(event.taskId, {
                exitCode: new promise_util_1.Deferred(),
                terminateSignal: new promise_util_1.Deferred(),
                isBackgroundTaskEnded: new promise_util_1.Deferred()
            });
        });
        this.taskWatcher.onOutputProcessed(async (event) => {
            if (!this.isEventForThisClient(event.ctx)) {
                return;
            }
            if (event.problems) {
                const runningTasksInfo = await this.getRunningTasks();
                // check if the task is active
                const matchedRunningTaskInfo = runningTasksInfo.find(taskInfo => {
                    const taskConfig = taskInfo.config;
                    return this.taskDefinitionRegistry.compareTasks(taskConfig, event.config);
                });
                const isTaskActiveAndOutputSilent = matchedRunningTaskInfo &&
                    matchedRunningTaskInfo.config.presentation && matchedRunningTaskInfo.config.presentation.reveal === common_2.RevealKind.Silent;
                event.problems.forEach(problem => {
                    const existingMarkers = this.problemManager.findMarkers({ owner: problem.description.owner });
                    const uris = new Set();
                    existingMarkers.forEach(marker => uris.add(marker.uri));
                    if (common_2.ProblemMatchData.is(problem) && problem.resource) {
                        // When task.presentation.reveal === RevealKind.Silent, put focus on the terminal only if it is an error
                        if (isTaskActiveAndOutputSilent && problem.marker.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error) {
                            const terminalId = matchedRunningTaskInfo.terminalId;
                            if (terminalId) {
                                const terminal = this.terminalService.getByTerminalId(terminalId);
                                if (terminal) {
                                    const focus = !!matchedRunningTaskInfo.config.presentation.focus;
                                    if (focus) { // assign focus to the terminal if presentation.focus is true
                                        this.terminalService.open(terminal, { mode: 'activate' });
                                    }
                                    else { // show the terminal but not assign focus
                                        this.terminalService.open(terminal, { mode: 'reveal' });
                                    }
                                }
                            }
                        }
                        const uri = problem.resource.withScheme(problem.resource.scheme);
                        const document = this.monacoWorkspace.getTextDocument(uri.toString());
                        if (problem.description.applyTo === common_2.ApplyToKind.openDocuments && !!document ||
                            problem.description.applyTo === common_2.ApplyToKind.closedDocuments && !document ||
                            problem.description.applyTo === common_2.ApplyToKind.allDocuments) {
                            if (uris.has(uri.toString())) {
                                const newData = [
                                    ...existingMarkers
                                        .filter(marker => marker.uri === uri.toString())
                                        .map(markerData => markerData.data),
                                    problem.marker
                                ];
                                this.problemManager.setMarkers(uri, problem.description.owner, newData);
                            }
                            else {
                                this.problemManager.setMarkers(uri, problem.description.owner, [problem.marker]);
                            }
                        }
                    }
                    else { // should have received an event for finding the "background task begins" pattern
                        uris.forEach(uriString => this.problemManager.setMarkers(new uri_1.default(uriString), problem.description.owner, []));
                    }
                });
            }
        });
        this.taskWatcher.onBackgroundTaskEnded((event) => {
            if (!this.isEventForThisClient(event.ctx)) {
                return;
            }
            if (!this.runningTasks.has(event.taskId)) {
                this.runningTasks.set(event.taskId, {
                    exitCode: new promise_util_1.Deferred(),
                    terminateSignal: new promise_util_1.Deferred(),
                    isBackgroundTaskEnded: new promise_util_1.Deferred()
                });
            }
            this.runningTasks.get(event.taskId).isBackgroundTaskEnded.resolve(true);
        });
        // notify user that task has finished
        this.taskWatcher.onTaskExit((event) => {
            if (!this.isEventForThisClient(event.ctx)) {
                return;
            }
            if (!this.runningTasks.has(event.taskId)) {
                this.runningTasks.set(event.taskId, {
                    exitCode: new promise_util_1.Deferred(),
                    terminateSignal: new promise_util_1.Deferred(),
                    isBackgroundTaskEnded: new promise_util_1.Deferred()
                });
            }
            this.runningTasks.get(event.taskId).exitCode.resolve(event.code);
            this.runningTasks.get(event.taskId).terminateSignal.resolve(event.signal);
            setTimeout(() => this.runningTasks.delete(event.taskId), 60 * 1000);
            const taskConfig = event.config;
            const taskIdentifier = taskConfig ? this.getTaskIdentifier(taskConfig) : event.taskId.toString();
            if (event.code !== undefined) {
                if (event.code !== 0) {
                    const eventTaskConfig = event.config;
                    if (eventTaskConfig && eventTaskConfig.presentation && eventTaskConfig.presentation.reveal === common_2.RevealKind.Silent && event.terminalId) {
                        const terminal = this.terminalService.getByTerminalId(event.terminalId);
                        const focus = !!eventTaskConfig.presentation.focus;
                        if (terminal) {
                            if (focus) { // assign focus to the terminal if presentation.focus is true
                                this.terminalService.open(terminal, { mode: 'activate' });
                            }
                            else { // show the terminal but not assign focus
                                this.terminalService.open(terminal, { mode: 'reveal' });
                            }
                        }
                    }
                    this.messageService.error(`Task '${taskIdentifier}' has exited with code ${event.code}.`);
                }
            }
            else if (event.signal !== undefined) {
                this.messageService.info(`Task '${taskIdentifier}' was terminated by signal ${event.signal}.`);
            }
            else {
                console.error('Invalid TaskExitedEvent received, neither code nor signal is set.');
            }
        });
    }
    getTaskIdentifier(taskConfig) {
        const taskName = this.taskNameResolver.resolve(taskConfig);
        const sourceStrUri = this.taskSourceResolver.resolve(taskConfig);
        return `${taskName} (${this.labelProvider.getName(new uri_1.default(sourceStrUri))})`;
    }
    /**
     * Client should call this method to indicate that a new user-level action related to tasks has been started,
     * like invoking "Run Task..."
     * This method returns a token that can be used with various methods in this service.
     * As long as a client uses the same token, task providers will only asked once to contribute
     * tasks and the set of tasks will be cached. Each time the a new token is used, the cache of
     * contributed tasks is cleared.
     * @returns a token to be used for task-related actions
     */
    startUserAction() {
        return this.providedTaskConfigurations.startUserAction();
    }
    /**
     * Returns an array of the task configurations configured in tasks.json and provided by the extensions.
     * @param token  The cache token for the user interaction in progress
     */
    async getTasks(token) {
        const configuredTasks = await this.getConfiguredTasks(token);
        const providedTasks = await this.getProvidedTasks(token);
        const notCustomizedProvidedTasks = providedTasks.filter(provided => !configuredTasks.some(configured => this.taskDefinitionRegistry.compareTasks(configured, provided)));
        return [...configuredTasks, ...notCustomizedProvidedTasks];
    }
    /**
     * Returns an array of the valid task configurations which are configured in tasks.json files
     * @param token  The cache token for the user interaction in progress
     *
     */
    async getConfiguredTasks(token) {
        const invalidTaskConfig = this.taskConfigurations.getInvalidTaskConfigurations()[0];
        if (invalidTaskConfig) {
            const widget = await this.widgetManager.getOrCreateWidget(problem_widget_1.PROBLEMS_WIDGET_ID);
            const isProblemsWidgetVisible = widget && widget.isVisible;
            const currentEditorUri = this.editorManager.currentEditor && this.editorManager.currentEditor.editor.getResourceUri();
            let isInvalidTaskConfigFileOpen = false;
            if (currentEditorUri) {
                const folderUri = this.workspaceService.getWorkspaceRootUri(currentEditorUri);
                if (folderUri && folderUri.toString() === invalidTaskConfig._scope) {
                    isInvalidTaskConfigFileOpen = true;
                }
            }
            const warningMessage = 'Invalid task configurations are found. Open tasks.json and find details in the Problems view.';
            if (!isProblemsWidgetVisible || !isInvalidTaskConfigFileOpen) {
                this.messageService.warn(warningMessage, 'Open').then(actionOpen => {
                    if (actionOpen) {
                        if (invalidTaskConfig && invalidTaskConfig._scope) {
                            this.taskConfigurationManager.openConfiguration(invalidTaskConfig._scope);
                        }
                        if (!isProblemsWidgetVisible) {
                            this.commands.executeCommand('problemsView:toggle');
                        }
                    }
                });
            }
            else {
                this.messageService.warn(warningMessage);
            }
        }
        const validTaskConfigs = await this.taskConfigurations.getTasks(token);
        return validTaskConfigs;
    }
    /**
     * Returns an array that contains the task configurations provided by the task providers for the specified task type.
     * @param token  The cache token for the user interaction in progress
     * @param type The task type (filter) associated to the returning TaskConfigurations
     *
     * '*' indicates all tasks regardless of the type
     */
    getProvidedTasks(token, type) {
        return this.providedTaskConfigurations.getTasks(token, type);
    }
    addRecentTasks(tasks) {
        if (Array.isArray(tasks)) {
            tasks.forEach(task => this.addRecentTasks(task));
        }
        else {
            const ind = this.cachedRecentTasks.findIndex(recent => this.taskDefinitionRegistry.compareTasks(recent, tasks));
            if (ind >= 0) {
                this.cachedRecentTasks.splice(ind, 1);
            }
            this.cachedRecentTasks.unshift(tasks);
        }
    }
    get recentTasks() {
        return this.cachedRecentTasks;
    }
    set recentTasks(recent) {
        this.cachedRecentTasks = recent;
    }
    /**
     * Clears the list of recently used tasks.
     */
    clearRecentTasks() {
        this.cachedRecentTasks = [];
    }
    /**
     * Open user ser
     */
    openUserTasks() {
        return this.taskConfigurations.openUserTasks();
    }
    /**
     * Returns a task configuration provided by an extension by task source, scope and label.
     * If there are no task configuration, returns undefined.
     * @param token  The cache token for the user interaction in progress
     * @param source The source for configured tasks
     * @param label  The label of the task to find
     * @param scope  The task scope to look in
     */
    async getProvidedTask(token, source, label, scope) {
        return this.providedTaskConfigurations.getTask(token, source, label, scope);
    }
    /** Returns an array of running tasks 'TaskInfo' objects */
    getRunningTasks() {
        return this.taskServer.getTasks(this.getContext());
    }
    async customExecutionComplete(id, exitCode) {
        return this.taskServer.customExecutionComplete(id, exitCode);
    }
    /** Returns an array of task types that are registered, including the default types */
    getRegisteredTaskTypes() {
        return this.taskSchemaUpdater.getRegisteredTaskTypes();
    }
    /**
     * Get the last executed task.
     *
     * @returns the last executed task or `undefined`.
     */
    getLastTask() {
        return this.lastTask;
    }
    /**
     * Runs a task, by task configuration label.
     * Note, it looks for a task configured in tasks.json only.
     * @param token  The cache token for the user interaction in progress
     * @param scope The scope where to look for tasks
     * @param taskLabel the label to look for
     */
    async runConfiguredTask(token, scope, taskLabel) {
        const task = this.taskConfigurations.getTask(scope, taskLabel);
        if (!task) {
            this.logger.error(`Can't get task launch configuration for label: ${taskLabel}`);
            return;
        }
        this.run(token, task._source, taskLabel, scope);
    }
    /**
     * Run the last executed task.
     * @param token  The cache token for the user interaction in progress
     */
    async runLastTask(token) {
        var _a, _b;
        if (!((_a = this.lastTask) === null || _a === void 0 ? void 0 : _a.resolvedTask)) {
            return;
        }
        if (!((_b = this.lastTask.resolvedTask.runOptions) === null || _b === void 0 ? void 0 : _b.reevaluateOnRerun)) {
            return this.runResolvedTask(this.lastTask.resolvedTask, this.lastTask.option);
        }
        const { _source, label, _scope } = this.lastTask.resolvedTask;
        return this.run(token, _source, label, _scope);
    }
    /**
     * Runs a task, by the source and label of the task configuration.
     * It looks for configured and detected tasks.
     * @param token  The cache token for the user interaction in progress
     * @param source The source for configured tasks
     * @param taskLabel The label to look for
     * @param scope  The scope where to look for tasks
     */
    async run(token, source, taskLabel, scope) {
        var _a, _b;
        let task;
        task = this.taskConfigurations.getTask(scope, taskLabel);
        if (!task) { // if a configured task cannot be found, search from detected tasks
            task = await this.getProvidedTask(token, source, taskLabel, scope);
            if (!task) { // find from the customized detected tasks
                task = await this.taskConfigurations.getCustomizedTask(token, scope, taskLabel);
            }
            if (!task) {
                this.logger.error(`Can't get task launch configuration for label: ${taskLabel}`);
                return;
            }
        }
        const customizationObject = await this.getTaskCustomization(task);
        if (!customizationObject.problemMatcher) {
            // ask the user what s/he wants to use to parse the task output
            const items = this.getCustomizeProblemMatcherItems();
            const selected = await this.quickPickService.show(items, {
                placeholder: 'Select for which kind of errors and warnings to scan the task output'
            });
            if (selected && ('value' in selected)) {
                if ((_a = selected.value) === null || _a === void 0 ? void 0 : _a.problemMatchers) {
                    let matcherNames = [];
                    if (selected.value.problemMatchers && selected.value.problemMatchers.length === 0) { // never parse output for this task
                        matcherNames = [];
                    }
                    else if (selected.value.problemMatchers && selected.value.problemMatchers.length > 0) { // continue with user-selected parser
                        matcherNames = selected.value.problemMatchers.map(matcher => matcher.name);
                    }
                    customizationObject.problemMatcher = matcherNames;
                    // write the selected matcher (or the decision of "never parse") into the `tasks.json`
                    this.updateTaskConfiguration(token, task, { problemMatcher: matcherNames });
                }
                else if ((_b = selected.value) === null || _b === void 0 ? void 0 : _b.learnMore) { // user wants to learn more about parsing task output
                    (0, opener_service_1.open)(this.openerService, new uri_1.default('https://code.visualstudio.com/docs/editor/tasks#_processing-task-output-with-problem-matchers'));
                }
                // else, continue the task with no parser
            }
            else { // do not start the task in case that the user did not select any item from the list
                return;
            }
        }
        const resolvedMatchers = await this.resolveProblemMatchers(task, customizationObject);
        const runTaskOption = {
            customization: { ...customizationObject, ...{ problemMatcher: resolvedMatchers } }
        };
        if (task.dependsOn) {
            return this.runCompoundTask(token, task, runTaskOption);
        }
        else {
            return this.runTask(task, runTaskOption).catch(error => {
                console.error('Error at launching task', error);
                return undefined;
            });
        }
    }
    /**
     * Runs a compound task
     * @param token  The cache token for the user interaction in progress
     * @param task The task to be executed
     * @param option options for executing the task
     */
    async runCompoundTask(token, task, option) {
        const tasks = await this.getWorkspaceTasks(token, task._scope);
        try {
            const rootNode = new task_node_1.TaskNode(task, [], []);
            this.detectDirectedAcyclicGraph(task, rootNode, tasks);
        }
        catch (error) {
            console.error(`Error at launching task '${task.label}'`, error);
            this.messageService.error(error.message);
            return undefined;
        }
        return this.runTasksGraph(task, tasks, option).catch(error => {
            console.error(`Error at launching task '${task.label}'`, error);
            return undefined;
        });
    }
    /**
     * A recursive function that runs a task and all its sub tasks that it depends on.
     * A task can be executed only when all of its dependencies have been executed, or when it doesn’t have any dependencies at all.
     */
    async runTasksGraph(task, tasks, option) {
        if (task && task.dependsOn) {
            // In case it is an array of task dependencies
            if (Array.isArray(task.dependsOn) && task.dependsOn.length > 0) {
                const dependentTasks = [];
                for (let i = 0; i < task.dependsOn.length; i++) {
                    // It may be a string (a task label) or a JSON object which represents a TaskIdentifier (e.g. {"type":"npm", "script":"script1"})
                    const taskIdentifier = task.dependsOn[i];
                    const dependentTask = this.getDependentTask(taskIdentifier, tasks);
                    const taskCustomization = await this.getTaskCustomization(dependentTask);
                    const resolvedMatchers = await this.resolveProblemMatchers(dependentTask, taskCustomization);
                    dependentTasks.push({ 'task': dependentTask, 'taskCustomization': taskCustomization, 'resolvedMatchers': resolvedMatchers });
                    // In case the 'dependsOrder' is 'sequence'
                    if (task.dependsOrder && task.dependsOrder === common_2.DependsOrder.Sequence) {
                        await this.runTasksGraph(dependentTask, tasks, {
                            customization: { ...taskCustomization, ...{ problemMatcher: resolvedMatchers } }
                        });
                    }
                }
                // In case the 'dependsOrder' is 'parallel'
                if (((!task.dependsOrder) || (task.dependsOrder && task.dependsOrder === common_2.DependsOrder.Parallel))) {
                    const promises = dependentTasks.map(item => this.runTasksGraph(item.task, tasks, {
                        customization: { ...item.taskCustomization, ...{ problemMatcher: item.resolvedMatchers } }
                    }));
                    await Promise.all(promises);
                }
            }
            else if (!Array.isArray(task.dependsOn)) {
                // In case it is a string (a task label) or a JSON object which represents a TaskIdentifier (e.g. {"type":"npm", "script":"script1"})
                const taskIdentifier = task.dependsOn;
                const dependentTask = this.getDependentTask(taskIdentifier, tasks);
                const taskCustomization = await this.getTaskCustomization(dependentTask);
                const resolvedMatchers = await this.resolveProblemMatchers(dependentTask, taskCustomization);
                await this.runTasksGraph(dependentTask, tasks, {
                    customization: { ...taskCustomization, ...{ problemMatcher: resolvedMatchers } }
                });
            }
        }
        const taskInfo = await this.runTask(task, option);
        if (taskInfo) {
            const getExitCodePromise = this.getExitCode(taskInfo.taskId).then(result => ({ taskEndedType: TaskEndedTypes.TaskExited, value: result }));
            const isBackgroundTaskEndedPromise = this.isBackgroundTaskEnded(taskInfo.taskId).then(result => ({ taskEndedType: TaskEndedTypes.BackgroundTaskEnded, value: result }));
            // After start running the task, we wait for the task process to exit and if it is a background task, we also wait for a feedback
            // that a background task is active, as soon as one of the promises fulfills, we can continue and analyze the results.
            const taskEndedInfo = await Promise.race([getExitCodePromise, isBackgroundTaskEndedPromise]);
            if ((taskEndedInfo.taskEndedType === TaskEndedTypes.TaskExited && taskEndedInfo.value !== 0) ||
                (taskEndedInfo.taskEndedType === TaskEndedTypes.BackgroundTaskEnded && !taskEndedInfo.value)) {
                throw new Error('The task: ' + task.label + ' terminated with exit code ' + taskEndedInfo.value + '.');
            }
        }
        return taskInfo;
    }
    /**
     * Creates a graph of dependencies tasks from the root task and verify there is no DAG (Directed Acyclic Graph).
     * In case of detection of a circular dependency, an error is thrown with a message which describes the detected circular reference.
     */
    detectDirectedAcyclicGraph(task, taskNode, tasks) {
        if (task && task.dependsOn) {
            // In case the 'dependsOn' is an array
            if (Array.isArray(task.dependsOn) && task.dependsOn.length > 0) {
                for (let i = 0; i < task.dependsOn.length; i++) {
                    const childNode = this.createChildTaskNode(task, taskNode, task.dependsOn[i], tasks);
                    this.detectDirectedAcyclicGraph(childNode.taskConfiguration, childNode.node, tasks);
                }
            }
            else if (!Array.isArray(task.dependsOn)) {
                const childNode = this.createChildTaskNode(task, taskNode, task.dependsOn, tasks);
                this.detectDirectedAcyclicGraph(childNode.taskConfiguration, childNode.node, tasks);
            }
        }
    }
    // 'childTaskIdentifier' may be a string (a task label) or a JSON object which represents a TaskIdentifier (e.g. {"type":"npm", "script":"script1"})
    createChildTaskNode(task, taskNode, childTaskIdentifier, tasks) {
        const childTaskConfiguration = this.getDependentTask(childTaskIdentifier, tasks);
        // If current task and child task are identical or if
        // one of the child tasks is identical to one of the current task ancestors, then raise an error
        if (this.taskDefinitionRegistry.compareTasks(task, childTaskConfiguration) ||
            taskNode.parentsID.filter(t => this.taskDefinitionRegistry.compareTasks(childTaskConfiguration, t)).length > 0) {
            const fromNode = task.label;
            const toNode = childTaskConfiguration.label;
            throw new Error('Circular reference detected: ' + fromNode + ' -->  ' + toNode);
        }
        const childNode = new task_node_1.TaskNode(childTaskConfiguration, [], Object.assign([], taskNode.parentsID));
        childNode.addParentDependency(taskNode.taskId);
        taskNode.addChildDependency(childNode);
        return { 'taskConfiguration': childTaskConfiguration, 'node': childNode };
    }
    /**
     * Gets task configuration by task label or by a JSON object which represents a task identifier
     *
     * @param taskIdentifier The task label (string) or a JSON object which represents a TaskIdentifier (e.g. {"type":"npm", "script":"script1"})
     * @param tasks an array of the task configurations
     * @returns the correct TaskConfiguration object which matches the taskIdentifier
     */
    getDependentTask(taskIdentifier, tasks) {
        const notEnoughDataError = 'The information provided in the "dependsOn" is not enough for matching the correct task !';
        let currentTaskChildConfiguration;
        if (typeof (taskIdentifier) !== 'string') {
            // TaskIdentifier object does not support tasks of type 'shell' (The same behavior as in VS Code).
            // So if we want the 'dependsOn' property to include tasks of type 'shell',
            // then we must mention their labels (in the 'dependsOn' property) and not to create a task identifier object for them.
            currentTaskChildConfiguration = this.getTaskByTaskIdentifier(taskIdentifier, tasks);
            if (!currentTaskChildConfiguration.type) {
                this.messageService.error(notEnoughDataError);
                throw new Error(notEnoughDataError);
            }
            return currentTaskChildConfiguration;
        }
        else {
            currentTaskChildConfiguration = tasks.filter(t => taskIdentifier === this.taskNameResolver.resolve(t))[0];
            return currentTaskChildConfiguration;
        }
    }
    /**
     * Gets the matched task from an array of task configurations by TaskIdentifier.
     * In case that more than one task configuration matches, we returns the first one.
     *
     * @param taskIdentifier The task label (string) or a JSON object which represents a TaskIdentifier (e.g. {"type":"npm", "script":"script1"})
     * @param tasks An array of task configurations.
     * @returns The correct TaskConfiguration object which matches the taskIdentifier.
     */
    getTaskByTaskIdentifier(taskIdentifier, tasks) {
        const requiredProperties = Object.keys(taskIdentifier);
        const taskWithAllProperties = tasks.find(task => requiredProperties.every(property => task.hasOwnProperty(property) && task[property] === taskIdentifier[property]));
        return taskWithAllProperties !== null && taskWithAllProperties !== void 0 ? taskWithAllProperties : { label: '', _scope: '', type: '' }; // Fall back to empty TaskConfiguration
    }
    async runTask(task, option) {
        console.debug('entering runTask');
        const releaseLock = await this.taskStartingLock.acquire();
        console.debug('got lock');
        try {
            // resolve problemMatchers
            if (!option && task.problemMatcher) {
                const customizationObject = { type: task.taskType, problemMatcher: task.problemMatcher, runOptions: task.runOptions };
                const resolvedMatchers = await this.resolveProblemMatchers(task, customizationObject);
                option = {
                    customization: { ...customizationObject, ...{ problemMatcher: resolvedMatchers } }
                };
            }
            const runningTasksInfo = await this.getRunningTasks();
            // check if the task is active
            const matchedRunningTaskInfo = runningTasksInfo.find(taskInfo => {
                const taskConfig = taskInfo.config;
                return this.taskDefinitionRegistry.compareTasks(taskConfig, task);
            });
            console.debug(`running task ${JSON.stringify(task)}, already running = ${!!matchedRunningTaskInfo}`);
            if (matchedRunningTaskInfo) { // the task is active
                releaseLock();
                console.debug('released lock');
                const taskName = this.taskNameResolver.resolve(task);
                const terminalId = matchedRunningTaskInfo.terminalId;
                if (terminalId) {
                    const terminal = this.terminalService.getByTerminalId(terminalId);
                    if (terminal) {
                        if (common_2.TaskOutputPresentation.shouldSetFocusToTerminal(task)) { // assign focus to the terminal if presentation.focus is true
                            this.terminalService.open(terminal, { mode: 'activate' });
                        }
                        else if (common_2.TaskOutputPresentation.shouldAlwaysRevealTerminal(task)) { // show the terminal but not assign focus
                            this.terminalService.open(terminal, { mode: 'reveal' });
                        }
                    }
                }
                const selectedAction = await this.messageService.info(`The task '${taskName}' is already active`, 'Terminate Task', 'Restart Task');
                if (selectedAction === 'Terminate Task') {
                    await this.terminateTask(matchedRunningTaskInfo);
                }
                else if (selectedAction === 'Restart Task') {
                    return this.restartTask(matchedRunningTaskInfo, option);
                }
            }
            else { // run task as the task is not active
                console.debug('task about to start');
                const taskInfo = await this.doRunTask(task, option);
                releaseLock();
                console.debug('release lock 2');
                return taskInfo;
            }
        }
        catch (e) {
            releaseLock();
            throw e;
        }
    }
    /**
     * Terminates a task that is actively running.
     * @param activeTaskInfo the TaskInfo of the task that is actively running
     */
    async terminateTask(activeTaskInfo) {
        const taskId = activeTaskInfo.taskId;
        return this.kill(taskId);
    }
    /**
     * Terminates a task that is actively running, and restarts it.
     * @param activeTaskInfo the TaskInfo of the task that is actively running
     */
    async restartTask(activeTaskInfo, option) {
        await this.terminateTask(activeTaskInfo);
        return this.doRunTask(activeTaskInfo.config, option);
    }
    async doRunTask(task, option) {
        let overridePropertiesFunction = () => { };
        if (option && option.customization) {
            const taskDefinition = this.taskDefinitionRegistry.getDefinition(task);
            if (taskDefinition) { // use the customization object to override the task config
                overridePropertiesFunction = tsk => {
                    Object.keys(option.customization).forEach(customizedProperty => {
                        // properties used to define the task cannot be customized
                        if (customizedProperty !== 'type' && !taskDefinition.properties.all.some(pDefinition => pDefinition === customizedProperty)) {
                            tsk[customizedProperty] = option.customization[customizedProperty];
                        }
                    });
                };
            }
        }
        overridePropertiesFunction(task);
        this.addRecentTasks(task);
        try {
            const resolver = await this.taskResolverRegistry.getTaskResolver(task.type);
            const resolvedTask = resolver ? await resolver.resolveTask(task) : task;
            const executionResolver = this.taskResolverRegistry.getExecutionResolver(resolvedTask.taskType || resolvedTask.type);
            overridePropertiesFunction(resolvedTask);
            const taskToRun = executionResolver ? await executionResolver.resolveTask(resolvedTask) : resolvedTask;
            await this.removeProblemMarkers(option);
            return this.runResolvedTask(taskToRun, option);
        }
        catch (error) {
            const errMessage = `Error resolving task '${task.label}': ${error}`;
            this.logger.error(errMessage);
        }
        return undefined;
    }
    /**
     * Runs the first task with the given label.
     *
     * @param token  The cache token for the user interaction in progress
     * @param taskLabel The label of the task to be executed
     */
    async runTaskByLabel(token, taskLabel) {
        const tasks = await this.getTasks(token);
        for (const task of tasks) {
            if (task.label === taskLabel) {
                return this.runTask(task);
            }
        }
        return;
    }
    /**
     * Runs a task identified by the given identifier, but only if found in the given workspace folder
     *
     * @param token  The cache token for the user interaction in progress
     * @param workspaceFolderUri  The folder to restrict the search to
     * @param taskIdentifier The identifier to look for
     */
    async runWorkspaceTask(token, workspaceFolderUri, taskIdentifier) {
        const tasks = await this.getWorkspaceTasks(token, workspaceFolderUri);
        const task = this.getDependentTask(taskIdentifier, tasks);
        if (!task) {
            return undefined;
        }
        const taskCustomization = await this.getTaskCustomization(task);
        const resolvedMatchers = await this.resolveProblemMatchers(task, taskCustomization);
        try {
            const rootNode = new task_node_1.TaskNode(task, [], []);
            this.detectDirectedAcyclicGraph(task, rootNode, tasks);
        }
        catch (error) {
            this.logger.error(error.message);
            this.messageService.error(error.message);
            return undefined;
        }
        return this.runTasksGraph(task, tasks, {
            customization: { ...taskCustomization, ...{ problemMatcher: resolvedMatchers } }
        }).catch(error => {
            console.log(error.message);
            return undefined;
        });
    }
    /**
     * Updates the task configuration in the `tasks.json`.
     * The task config, together with updates, will be written into the `tasks.json` if it is not found in the file.
     *
     * @param token  The cache token for the user interaction in progress
     * @param task task that the updates will be applied to
     * @param update the updates to be applied
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async updateTaskConfiguration(token, task, update) {
        if (update.problemMatcher) {
            if (Array.isArray(update.problemMatcher)) {
                update.problemMatcher.forEach((_name, index) => update.problemMatcher[index] = (0, common_2.asVariableName)(update.problemMatcher[index]));
            }
            else {
                update.problemMatcher = (0, common_2.asVariableName)(update.problemMatcher);
            }
        }
        this.taskConfigurations.updateTaskConfig(token, task, update);
    }
    async getWorkspaceTasks(token, restrictToFolder) {
        const tasks = await this.getTasks(token);
        // if we pass undefined, return everything, otherwise only tasks with the same uri or workspace/global scope tasks
        return tasks.filter(t => typeof t._scope !== 'string' || t._scope === restrictToFolder);
    }
    async resolveProblemMatchers(task, customizationObject) {
        const notResolvedMatchers = customizationObject.problemMatcher ?
            (Array.isArray(customizationObject.problemMatcher) ? customizationObject.problemMatcher : [customizationObject.problemMatcher]) : undefined;
        let resolvedMatchers = [];
        if (notResolvedMatchers) {
            // resolve matchers before passing them to the server
            for (const matcher of notResolvedMatchers) {
                let resolvedMatcher;
                await this.problemMatcherRegistry.onReady();
                if (typeof matcher === 'string') {
                    resolvedMatcher = this.problemMatcherRegistry.get(matcher);
                }
                else {
                    resolvedMatcher = await this.problemMatcherRegistry.getProblemMatcherFromContribution(matcher);
                }
                if (resolvedMatcher) {
                    const scope = task._scope || task._source;
                    if (resolvedMatcher.filePrefix && scope) {
                        const options = {
                            context: new uri_1.default(scope).withScheme('file'),
                            configurationSection: 'tasks'
                        };
                        const resolvedPrefix = await this.variableResolverService.resolve(resolvedMatcher.filePrefix, options);
                        Object.assign(resolvedMatcher, { filePrefix: resolvedPrefix });
                    }
                    resolvedMatchers.push(resolvedMatcher);
                }
            }
        }
        else {
            resolvedMatchers = undefined;
        }
        return resolvedMatchers;
    }
    async getTaskCustomization(task) {
        const customizationObject = { type: '', _scope: task._scope, runOptions: task.runOptions };
        const customizationFound = this.taskConfigurations.getCustomizationForTask(task);
        if (customizationFound) {
            Object.assign(customizationObject, customizationFound);
        }
        else {
            Object.assign(customizationObject, {
                type: task.type,
                problemMatcher: task.problemMatcher
            });
        }
        return customizationObject;
    }
    async removeProblemMarkers(option) {
        if (option && option.customization) {
            const matchersFromOption = option.customization.problemMatcher || [];
            for (const matcher of matchersFromOption) {
                if (matcher && matcher.owner) {
                    const existingMarkers = this.problemManager.findMarkers({ owner: matcher.owner });
                    const uris = new Set();
                    existingMarkers.forEach(marker => uris.add(marker.uri));
                    uris.forEach(uriString => this.problemManager.setMarkers(new uri_1.default(uriString), matcher.owner, []));
                }
            }
        }
    }
    /**
     * Runs the resolved task and opens terminal widget if the task is based on a terminal process
     * @param resolvedTask the resolved task
     * @param option options to run the resolved task
     */
    async runResolvedTask(resolvedTask, option) {
        const taskLabel = resolvedTask.label;
        let taskInfo;
        try {
            taskInfo = await this.taskServer.run(resolvedTask, this.getContext(), option);
            this.lastTask = { resolvedTask, option };
            this.logger.debug(`Task created. Task id: ${taskInfo.taskId}`);
            /**
             * open terminal widget if the task is based on a terminal process (type: 'shell' or 'process')
             *
             * @todo Use a different mechanism to determine if the task should be attached?
             *       Reason: Maybe a new task type wants to also be displayed in a terminal.
             */
            if (typeof taskInfo.terminalId === 'number') {
                await this.attach(taskInfo.terminalId, taskInfo);
            }
            return taskInfo;
        }
        catch (error) {
            const errorStr = `Error launching task '${taskLabel}': ${error.message}`;
            this.logger.error(errorStr);
            this.messageService.error(errorStr);
            if (taskInfo && typeof taskInfo.terminalId === 'number') {
                this.shellTerminalServer.onAttachAttempted(taskInfo.terminalId);
            }
        }
    }
    getCustomizeProblemMatcherItems() {
        const items = [];
        items.push({
            label: 'Continue without scanning the task output',
            value: { problemMatchers: undefined }
        });
        items.push({
            label: 'Never scan the task output',
            value: { problemMatchers: [] }
        });
        items.push({
            label: 'Learn more about scanning the task output',
            value: { problemMatchers: undefined, learnMore: true }
        });
        items.push({ type: 'separator', label: 'registered parsers' });
        const registeredProblemMatchers = this.problemMatcherRegistry.getAll();
        items.push(...registeredProblemMatchers.map(matcher => ({
            label: matcher.label,
            value: { problemMatchers: [matcher] },
            description: (0, common_2.asVariableName)(matcher.name)
        })));
        return items;
    }
    /**
     * Run selected text in the last active terminal.
     */
    async runSelectedText() {
        if (!this.editorManager.currentEditor) {
            return;
        }
        const startLine = this.editorManager.currentEditor.editor.selection.start.line;
        const startCharacter = this.editorManager.currentEditor.editor.selection.start.character;
        const endLine = this.editorManager.currentEditor.editor.selection.end.line;
        const endCharacter = this.editorManager.currentEditor.editor.selection.end.character;
        let selectedRange = vscode_languageserver_protocol_1.Range.create(startLine, startCharacter, endLine, endCharacter);
        // if no text is selected, default to selecting entire line
        if (startLine === endLine && startCharacter === endCharacter) {
            selectedRange = vscode_languageserver_protocol_1.Range.create(startLine, 0, endLine + 1, 0);
        }
        const selectedText = this.editorManager.currentEditor.editor.document.getText(selectedRange).trimRight() + '\n';
        let terminal = this.terminalService.lastUsedTerminal;
        if (!terminal || terminal.kind !== 'user' || (await terminal.hasChildProcesses())) {
            terminal = await this.terminalService.newTerminal({ created: new Date().toString() });
            await terminal.start();
            this.terminalService.open(terminal);
        }
        terminal.sendText(selectedText);
    }
    async attach(terminalId, taskInfo) {
        let widgetOpenMode = 'open';
        if (taskInfo) {
            const terminalWidget = this.terminalService.getByTerminalId(terminalId);
            if (terminalWidget) {
                this.messageService.error('Task is already running in terminal');
                return this.terminalService.open(terminalWidget, { mode: 'activate' });
            }
            if (common_2.TaskOutputPresentation.shouldAlwaysRevealTerminal(taskInfo.config)) {
                if (common_2.TaskOutputPresentation.shouldSetFocusToTerminal(taskInfo.config)) { // assign focus to the terminal if presentation.focus is true
                    widgetOpenMode = 'activate';
                }
                else { // show the terminal but not assign focus
                    widgetOpenMode = 'reveal';
                }
            }
        }
        const { taskId } = taskInfo;
        // Create / find a terminal widget to display an execution output of a task that was launched as a command inside a shell.
        const widget = await this.taskTerminalWidgetManager.open({
            created: new Date().toString(),
            id: this.getTerminalWidgetId(terminalId),
            title: taskInfo
                ? `Task: ${taskInfo.config.label}`
                : `Task: #${taskId}`,
            destroyTermOnClose: true,
            useServerTitle: false
        }, {
            widgetOptions: { area: 'bottom' },
            mode: widgetOpenMode,
            taskInfo
        });
        return widget.start(terminalId);
    }
    getTerminalWidgetId(terminalId) {
        const terminalWidget = this.terminalService.getByTerminalId(terminalId);
        if (terminalWidget) {
            return terminalWidget.id;
        }
    }
    /**
     * Opens an editor to configure the given task.
     *
     * @param token  The cache token for the user interaction in progress
     * @param task The task to configure
     */
    async configure(token, task) {
        Object.assign(task, { label: this.taskNameResolver.resolve(task) });
        await this.taskConfigurations.configure(token, task);
    }
    isEventForThisClient(context) {
        if (context === this.getContext()) {
            return true;
        }
        return false;
    }
    taskConfigurationChanged(event) {
        // do nothing for now
    }
    getContext() {
        var _a;
        return (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString();
    }
    /** Kill task for a given id if task is found */
    async kill(id) {
        try {
            await this.taskServer.kill(id);
        }
        catch (error) {
            this.logger.error(`Error killing task '${id}': ${error}`);
            this.messageService.error(`Error killing task '${id}': ${error}`);
            return;
        }
        this.logger.debug(`Task killed. Task id: ${id}`);
    }
    async isBackgroundTaskEnded(id) {
        const completedTask = this.runningTasks.get(id);
        return completedTask && completedTask.isBackgroundTaskEnded.promise;
    }
    async getExitCode(id) {
        const completedTask = this.runningTasks.get(id);
        return completedTask && completedTask.exitCode.promise;
    }
    async getTerminateSignal(id) {
        const completedTask = this.runningTasks.get(id);
        return completedTask && completedTask.terminateSignal.promise;
    }
};
exports.TaskService = TaskService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.FrontendApplication),
    tslib_1.__metadata("design:type", browser_1.FrontendApplication)
], TaskService.prototype, "app", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], TaskService.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_2.TaskServer),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "taskServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.ILogger),
    (0, inversify_1.named)('task'),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "logger", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], TaskService.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_watcher_1.TaskWatcher),
    tslib_1.__metadata("design:type", task_watcher_1.TaskWatcher)
], TaskService.prototype, "taskWatcher", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(message_service_1.MessageService),
    tslib_1.__metadata("design:type", message_service_1.MessageService)
], TaskService.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_service_1.WorkspaceService),
    tslib_1.__metadata("design:type", workspace_service_1.WorkspaceService)
], TaskService.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_configurations_1.TaskConfigurations),
    tslib_1.__metadata("design:type", task_configurations_1.TaskConfigurations)
], TaskService.prototype, "taskConfigurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(provided_task_configurations_1.ProvidedTaskConfigurations),
    tslib_1.__metadata("design:type", provided_task_configurations_1.ProvidedTaskConfigurations)
], TaskService.prototype, "providedTaskConfigurations", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.VariableResolverService),
    tslib_1.__metadata("design:type", browser_3.VariableResolverService)
], TaskService.prototype, "variableResolverService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskResolverRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskResolverRegistry)
], TaskService.prototype, "taskResolverRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], TaskService.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(problem_manager_1.ProblemManager),
    tslib_1.__metadata("design:type", problem_manager_1.ProblemManager)
], TaskService.prototype, "problemManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskService.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_problem_matcher_registry_1.ProblemMatcherRegistry),
    tslib_1.__metadata("design:type", task_problem_matcher_registry_1.ProblemMatcherRegistry)
], TaskService.prototype, "problemMatcherRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(quick_pick_service_1.QuickPickService),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "quickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(opener_service_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "openerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(shell_terminal_protocol_1.ShellTerminalServerProxy),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "shellTerminalServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_name_resolver_1.TaskNameResolver),
    tslib_1.__metadata("design:type", task_name_resolver_1.TaskNameResolver)
], TaskService.prototype, "taskNameResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_source_resolver_1.TaskSourceResolver),
    tslib_1.__metadata("design:type", task_source_resolver_1.TaskSourceResolver)
], TaskService.prototype, "taskSourceResolver", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_schema_updater_1.TaskSchemaUpdater),
    tslib_1.__metadata("design:type", task_schema_updater_1.TaskSchemaUpdater)
], TaskService.prototype, "taskSchemaUpdater", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_configuration_manager_1.TaskConfigurationManager),
    tslib_1.__metadata("design:type", task_configuration_manager_1.TaskConfigurationManager)
], TaskService.prototype, "taskConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], TaskService.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], TaskService.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_workspace_1.MonacoWorkspace),
    tslib_1.__metadata("design:type", monaco_workspace_1.MonacoWorkspace)
], TaskService.prototype, "monacoWorkspace", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_terminal_widget_manager_1.TaskTerminalWidgetManager),
    tslib_1.__metadata("design:type", task_terminal_widget_manager_1.TaskTerminalWidgetManager)
], TaskService.prototype, "taskTerminalWidgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_context_key_service_1.TaskContextKeyService),
    tslib_1.__metadata("design:type", task_context_key_service_1.TaskContextKeyService)
], TaskService.prototype, "taskContextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskService.prototype, "init", null);
exports.TaskService = TaskService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskService);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-source-resolver.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-source-resolver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskSourceResolver = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
let TaskSourceResolver = class TaskSourceResolver {
    /**
     * Returns task source to display.
     */
    resolve(task) {
        if (typeof task._scope === 'string') {
            return task._scope;
        }
        else {
            return common_1.TaskScope[task._scope];
        }
    }
};
exports.TaskSourceResolver = TaskSourceResolver;
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskSourceResolver.prototype, "taskDefinitionRegistry", void 0);
exports.TaskSourceResolver = TaskSourceResolver = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskSourceResolver);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-templates.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-templates.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskTemplateSelector = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const dotnetBuild = {
    id: 'dotnetCore',
    label: '.NET Core',
    sort: 'NET Core',
    autoDetect: false, // not supported in Theia
    description: 'Executes .NET Core build command',
    content: [
        '{',
        '\t// See https://go.microsoft.com/fwlink/?LinkId=733558',
        '\t// for the documentation about the tasks.json format',
        '\t"version": "2.0.0",',
        '\t"tasks": [',
        '\t\t{',
        '\t\t\t"label": "build",',
        '\t\t\t"command": "dotnet",',
        '\t\t\t"type": "shell",',
        '\t\t\t"args": [',
        '\t\t\t\t"build",',
        '\t\t\t\t// Ask dotnet build to generate full paths for file names.',
        '\t\t\t\t"/property:GenerateFullPaths=true",',
        '\t\t\t\t// Do not generate summary otherwise it leads to duplicate errors in Problems panel',
        '\t\t\t\t"/consoleloggerparameters:NoSummary"',
        '\t\t\t],',
        '\t\t\t"group": "build",',
        '\t\t\t"presentation": {',
        '\t\t\t\t"reveal": "silent"',
        '\t\t\t},',
        '\t\t\t"problemMatcher": "$msCompile"',
        '\t\t}',
        '\t]',
        '}'
    ].join('\n')
};
const msbuild = {
    id: 'msbuild',
    label: 'MSBuild',
    autoDetect: false, // not supported in Theia
    description: 'Executes the build target',
    content: [
        '{',
        '\t// See https://go.microsoft.com/fwlink/?LinkId=733558',
        '\t// for the documentation about the tasks.json format',
        '\t"version": "2.0.0",',
        '\t"tasks": [',
        '\t\t{',
        '\t\t\t"label": "build",',
        '\t\t\t"type": "shell",',
        '\t\t\t"command": "msbuild",',
        '\t\t\t"args": [',
        '\t\t\t\t// Ask msbuild to generate full paths for file names.',
        '\t\t\t\t"/property:GenerateFullPaths=true",',
        '\t\t\t\t"/t:build",',
        '\t\t\t\t// Do not generate summary otherwise it leads to duplicate errors in Problems panel',
        '\t\t\t\t"/consoleloggerparameters:NoSummary"',
        '\t\t\t],',
        '\t\t\t"group": "build",',
        '\t\t\t"presentation": {',
        '\t\t\t\t// Reveal the output only if unrecognized errors occur.',
        '\t\t\t\t"reveal": "silent"',
        '\t\t\t},',
        '\t\t\t// Use the standard MS compiler pattern to detect errors, warnings and infos',
        '\t\t\t"problemMatcher": "$msCompile"',
        '\t\t}',
        '\t]',
        '}'
    ].join('\n')
};
const maven = {
    id: 'maven',
    label: 'maven',
    sort: 'MVN',
    autoDetect: false, // not supported in Theia
    description: 'Executes common maven commands',
    content: [
        '{',
        '\t// See https://go.microsoft.com/fwlink/?LinkId=733558',
        '\t// for the documentation about the tasks.json format',
        '\t"version": "2.0.0",',
        '\t"tasks": [',
        '\t\t{',
        '\t\t\t"label": "verify",',
        '\t\t\t"type": "shell",',
        '\t\t\t"command": "mvn -B verify",',
        '\t\t\t"group": "build"',
        '\t\t},',
        '\t\t{',
        '\t\t\t"label": "test",',
        '\t\t\t"type": "shell",',
        '\t\t\t"command": "mvn -B test",',
        '\t\t\t"group": "test"',
        '\t\t}',
        '\t]',
        '}'
    ].join('\n')
};
const command = {
    id: 'externalCommand',
    label: 'Others',
    autoDetect: false, // not supported in Theia
    description: 'Example to run an arbitrary external command',
    content: [
        '{',
        '\t// See https://go.microsoft.com/fwlink/?LinkId=733558',
        '\t// for the documentation about the tasks.json format',
        '\t"version": "2.0.0",',
        '\t"tasks": [',
        '\t\t{',
        '\t\t\t"label": "echo",',
        '\t\t\t"type": "shell",',
        '\t\t\t"command": "echo Hello"',
        '\t\t}',
        '\t]',
        '}'
    ].join('\n')
};
let TaskTemplateSelector = class TaskTemplateSelector {
    selectTemplates() {
        const templates = [
            dotnetBuild, msbuild, maven
        ].sort((a, b) => (a.sort || a.label).localeCompare(b.sort || b.label));
        templates.push(command);
        return templates.map(t => ({
            label: t.label,
            description: t.description,
            value: t
        }));
    }
};
exports.TaskTemplateSelector = TaskTemplateSelector;
exports.TaskTemplateSelector = TaskTemplateSelector = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskTemplateSelector);


/***/ }),

/***/ "../node_modules/@theia/task/lib/browser/task-terminal-widget-manager.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/browser/task-terminal-widget-manager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskTerminalWidgetManager = exports.TaskTerminalWidgetOpenerOptions = exports.TaskTerminalWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const common_1 = __webpack_require__(/*! ../common */ "../node_modules/@theia/task/lib/common/index.js");
const task_protocol_1 = __webpack_require__(/*! ../common/process/task-protocol */ "../node_modules/@theia/task/lib/common/process/task-protocol.js");
const task_definition_registry_1 = __webpack_require__(/*! ./task-definition-registry */ "../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../node_modules/@theia/workspace/lib/browser/workspace-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
var TaskTerminalWidget;
(function (TaskTerminalWidget) {
    function is(widget) {
        return widget.kind === 'task';
    }
    TaskTerminalWidget.is = is;
})(TaskTerminalWidget || (exports.TaskTerminalWidget = TaskTerminalWidget = {}));
var TaskTerminalWidgetOpenerOptions;
(function (TaskTerminalWidgetOpenerOptions) {
    function isDedicatedTerminal(options) {
        const taskConfig = options.taskInfo ? options.taskInfo.config : options.taskConfig;
        return !!taskConfig && !!taskConfig.presentation && taskConfig.presentation.panel === common_1.PanelKind.Dedicated;
    }
    TaskTerminalWidgetOpenerOptions.isDedicatedTerminal = isDedicatedTerminal;
    function isNewTerminal(options) {
        const taskConfig = options.taskInfo ? options.taskInfo.config : options.taskConfig;
        return !!taskConfig && !!taskConfig.presentation && taskConfig.presentation.panel === common_1.PanelKind.New;
    }
    TaskTerminalWidgetOpenerOptions.isNewTerminal = isNewTerminal;
    function isSharedTerminal(options) {
        const taskConfig = options.taskInfo ? options.taskInfo.config : options.taskConfig;
        return !!taskConfig && (taskConfig.presentation === undefined || taskConfig.presentation.panel === undefined || taskConfig.presentation.panel === common_1.PanelKind.Shared);
    }
    TaskTerminalWidgetOpenerOptions.isSharedTerminal = isSharedTerminal;
    function echoExecutedCommand(options) {
        const taskConfig = options.taskInfo ? options.taskInfo.config : options.taskConfig;
        return !!taskConfig && (taskConfig.presentation === undefined || taskConfig.presentation.echo === undefined || taskConfig.presentation.echo);
    }
    TaskTerminalWidgetOpenerOptions.echoExecutedCommand = echoExecutedCommand;
})(TaskTerminalWidgetOpenerOptions || (exports.TaskTerminalWidgetOpenerOptions = TaskTerminalWidgetOpenerOptions = {}));
let TaskTerminalWidgetManager = class TaskTerminalWidgetManager {
    init() {
        this.taskWatcher.onTaskExit((event) => {
            const finishedTaskId = event.taskId;
            // find the terminal where the task ran, and mark it as "idle"
            for (const terminal of this.getTaskTerminalWidgets()) {
                if (terminal.taskId === finishedTaskId) {
                    const showReuseMessage = !!event.config && common_1.TaskOutputPresentation.shouldShowReuseMessage(event.config);
                    const closeOnFinish = !!event.config && common_1.TaskOutputPresentation.shouldCloseTerminalOnFinish(event.config);
                    this.updateTerminalOnTaskExit(terminal, showReuseMessage, closeOnFinish);
                    break;
                }
            }
        });
        this.terminalService.onDidCreateTerminal(async (widget) => {
            const terminal = TaskTerminalWidget.is(widget) && widget;
            if (terminal) {
                const didConnectListener = terminal.onDidOpen(async () => {
                    var _a, _b;
                    const context = (_b = (_a = this.workspaceService) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.resource.toString();
                    const tasksInfo = await this.taskServer.getTasks(context);
                    const taskInfo = tasksInfo.find(info => info.terminalId === widget.terminalId);
                    if (taskInfo) {
                        const taskConfig = taskInfo.config;
                        terminal.dedicated = !!taskConfig.presentation && !!taskConfig.presentation.panel && taskConfig.presentation.panel === common_1.PanelKind.Dedicated;
                        terminal.taskId = taskInfo.taskId;
                        terminal.taskConfig = taskConfig;
                        terminal.busy = true;
                    }
                    else {
                        this.updateTerminalOnTaskExit(terminal, true, false);
                    }
                });
                const didConnectFailureListener = terminal.onDidOpenFailure(async () => {
                    this.updateTerminalOnTaskExit(terminal, true, false);
                });
                terminal.onDidDispose(() => {
                    didConnectListener.dispose();
                    didConnectFailureListener.dispose();
                });
            }
        });
    }
    async newTaskTerminal(factoryOptions) {
        return this.terminalService.newTerminal({ ...factoryOptions, kind: 'task' });
    }
    async open(factoryOptions, openerOptions) {
        const taskInfo = openerOptions.taskInfo;
        const taskConfig = taskInfo ? taskInfo.config : openerOptions.taskConfig;
        const dedicated = TaskTerminalWidgetOpenerOptions.isDedicatedTerminal(openerOptions);
        if (dedicated && !taskConfig) {
            throw new Error('"taskConfig" must be included as part of the "option.taskInfo" if "isDedicated" is true');
        }
        const { isNew, widget } = await this.getWidgetToRunTask(factoryOptions, openerOptions);
        if (isNew) {
            this.shell.addWidget(widget, { area: openerOptions.widgetOptions ? openerOptions.widgetOptions.area : 'bottom' });
            widget.resetTerminal();
        }
        else {
            if (factoryOptions.title) {
                widget.setTitle(factoryOptions.title);
            }
            if (taskConfig && common_1.TaskOutputPresentation.shouldClearTerminalBeforeRun(taskConfig)) {
                widget.clearOutput();
            }
        }
        this.terminalService.open(widget, openerOptions);
        if (TaskTerminalWidgetOpenerOptions.echoExecutedCommand(openerOptions) &&
            taskInfo && task_protocol_1.ProcessTaskInfo.is(taskInfo) && taskInfo.command && taskInfo.command.length > 0) {
            widget.writeLine(`\x1b[1m> Executing task: ${taskInfo.command} <\x1b[0m\n`);
        }
        return widget;
    }
    async getWidgetToRunTask(factoryOptions, openerOptions) {
        var _a;
        let reusableTerminalWidget;
        const taskConfig = openerOptions.taskInfo ? openerOptions.taskInfo.config : openerOptions.taskConfig;
        if (TaskTerminalWidgetOpenerOptions.isDedicatedTerminal(openerOptions)) {
            for (const widget of this.getTaskTerminalWidgets()) {
                // to run a task whose `taskPresentation === 'dedicated'`, the terminal to be reused must be
                // 1) dedicated, 2) idle, 3) the one that ran the same task
                if (widget.dedicated &&
                    !widget.busy &&
                    widget.taskConfig && taskConfig &&
                    this.taskDefinitionRegistry.compareTasks(taskConfig, widget.taskConfig)) {
                    reusableTerminalWidget = widget;
                    break;
                }
            }
        }
        else if (TaskTerminalWidgetOpenerOptions.isSharedTerminal(openerOptions)) {
            const availableWidgets = [];
            for (const widget of this.getTaskTerminalWidgets()) {
                // to run a task whose `taskPresentation === 'shared'`, the terminal to be used must be
                // 1) not dedicated, and 2) idle
                if (!widget.dedicated && !widget.busy) {
                    availableWidgets.push(widget);
                }
            }
            const lastUsedWidget = availableWidgets.find(w => {
                const lastUsedTerminal = this.terminalService.lastUsedTerminal;
                return lastUsedTerminal && lastUsedTerminal.id === w.id;
            });
            reusableTerminalWidget = lastUsedWidget || availableWidgets[0];
        }
        // we are unable to find a terminal widget to run the task, or `taskPresentation === 'new'`
        const lastCwd = ((_a = taskConfig === null || taskConfig === void 0 ? void 0 : taskConfig.options) === null || _a === void 0 ? void 0 : _a.cwd) ? new uri_1.default(taskConfig.options.cwd) : new uri_1.default();
        if (!reusableTerminalWidget) {
            const widget = await this.newTaskTerminal(factoryOptions);
            widget.lastCwd = lastCwd;
            return { isNew: true, widget };
        }
        reusableTerminalWidget.lastCwd = lastCwd;
        return { isNew: false, widget: reusableTerminalWidget };
    }
    getTaskTerminalWidgets() {
        return this.terminalService.all.filter(TaskTerminalWidget.is);
    }
    updateTerminalOnTaskExit(terminal, showReuseMessage, closeOnFinish) {
        terminal.busy = false;
        if (closeOnFinish) {
            terminal.close();
        }
        else if (showReuseMessage) {
            terminal.scrollToBottom();
            terminal.writeLine('\x1b[1m\n\rTerminal will be reused by tasks. \x1b[0m\n');
        }
    }
};
exports.TaskTerminalWidgetManager = TaskTerminalWidgetManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], TaskTerminalWidgetManager.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], TaskTerminalWidgetManager.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], TaskTerminalWidgetManager.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.TaskWatcher),
    tslib_1.__metadata("design:type", common_1.TaskWatcher)
], TaskTerminalWidgetManager.prototype, "taskWatcher", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.TaskServer),
    tslib_1.__metadata("design:type", Object)
], TaskTerminalWidgetManager.prototype, "taskServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(workspace_service_1.WorkspaceService),
    tslib_1.__metadata("design:type", workspace_service_1.WorkspaceService)
], TaskTerminalWidgetManager.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TaskTerminalWidgetManager.prototype, "init", null);
exports.TaskTerminalWidgetManager = TaskTerminalWidgetManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskTerminalWidgetManager);


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./task-protocol */ "../node_modules/@theia/task/lib/common/task-protocol.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-watcher */ "../node_modules/@theia/task/lib/common/task-watcher.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./problem-matcher-protocol */ "../node_modules/@theia/task/lib/common/problem-matcher-protocol.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-util */ "../node_modules/@theia/task/lib/common/task-util.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/problem-matcher-protocol.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/problem-matcher-protocol.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProblemMatchData = exports.ProblemPattern = exports.ProblemMatcher = exports.ProblemLocationKind = exports.WatchingMatcher = exports.FileLocationKind = exports.ApplyToKind = void 0;
var ApplyToKind;
(function (ApplyToKind) {
    ApplyToKind[ApplyToKind["allDocuments"] = 0] = "allDocuments";
    ApplyToKind[ApplyToKind["openDocuments"] = 1] = "openDocuments";
    ApplyToKind[ApplyToKind["closedDocuments"] = 2] = "closedDocuments";
})(ApplyToKind || (exports.ApplyToKind = ApplyToKind = {}));
(function (ApplyToKind) {
    function fromString(value) {
        if (value) {
            value = value.toLowerCase();
            if (value === 'alldocuments') {
                return ApplyToKind.allDocuments;
            }
            else if (value === 'opendocuments') {
                return ApplyToKind.openDocuments;
            }
            else if (value === 'closeddocuments') {
                return ApplyToKind.closedDocuments;
            }
        }
        return undefined;
    }
    ApplyToKind.fromString = fromString;
})(ApplyToKind || (exports.ApplyToKind = ApplyToKind = {}));
var FileLocationKind;
(function (FileLocationKind) {
    FileLocationKind[FileLocationKind["Auto"] = 0] = "Auto";
    FileLocationKind[FileLocationKind["Relative"] = 1] = "Relative";
    FileLocationKind[FileLocationKind["Absolute"] = 2] = "Absolute";
})(FileLocationKind || (exports.FileLocationKind = FileLocationKind = {}));
(function (FileLocationKind) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'absolute') {
            return FileLocationKind.Absolute;
        }
        else if (value === 'relative') {
            return FileLocationKind.Relative;
        }
        else {
            return undefined;
        }
    }
    FileLocationKind.fromString = fromString;
})(FileLocationKind || (exports.FileLocationKind = FileLocationKind = {}));
var WatchingMatcher;
(function (WatchingMatcher) {
    function fromWatchingMatcherContribution(value) {
        if (!value) {
            return undefined;
        }
        return {
            activeOnStart: !!value.activeOnStart,
            beginsPattern: typeof value.beginsPattern === 'string' ? { regexp: value.beginsPattern } : value.beginsPattern,
            endsPattern: typeof value.endsPattern === 'string' ? { regexp: value.endsPattern } : value.endsPattern
        };
    }
    WatchingMatcher.fromWatchingMatcherContribution = fromWatchingMatcherContribution;
})(WatchingMatcher || (exports.WatchingMatcher = WatchingMatcher = {}));
var ProblemLocationKind;
(function (ProblemLocationKind) {
    ProblemLocationKind[ProblemLocationKind["File"] = 0] = "File";
    ProblemLocationKind[ProblemLocationKind["Location"] = 1] = "Location";
})(ProblemLocationKind || (exports.ProblemLocationKind = ProblemLocationKind = {}));
(function (ProblemLocationKind) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'file') {
            return ProblemLocationKind.File;
        }
        else if (value === 'location') {
            return ProblemLocationKind.Location;
        }
        else {
            return undefined;
        }
    }
    ProblemLocationKind.fromString = fromString;
})(ProblemLocationKind || (exports.ProblemLocationKind = ProblemLocationKind = {}));
var ProblemMatcher;
(function (ProblemMatcher) {
    function isWatchModeWatcher(matcher) {
        return !!matcher.watching;
    }
    ProblemMatcher.isWatchModeWatcher = isWatchModeWatcher;
})(ProblemMatcher || (exports.ProblemMatcher = ProblemMatcher = {}));
var ProblemPattern;
(function (ProblemPattern) {
    function fromProblemPatternContribution(value) {
        return {
            name: value.name,
            regexp: value.regexp,
            kind: value.kind ? ProblemLocationKind.fromString(value.kind) : undefined,
            file: value.file,
            message: value.message,
            location: value.location,
            line: value.line,
            character: value.column || value.character,
            endLine: value.endLine,
            endCharacter: value.endColumn || value.endCharacter,
            code: value.code,
            severity: value.severity,
            loop: value.loop
        };
    }
    ProblemPattern.fromProblemPatternContribution = fromProblemPatternContribution;
})(ProblemPattern || (exports.ProblemPattern = ProblemPattern = {}));
var ProblemMatchData;
(function (ProblemMatchData) {
    function is(data) {
        return 'marker' in data;
    }
    ProblemMatchData.is = is;
})(ProblemMatchData || (exports.ProblemMatchData = ProblemMatchData = {}));


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/process/task-protocol.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/process/task-protocol.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessTaskError = exports.ProcessTaskInfo = void 0;
const application_error_1 = __webpack_require__(/*! @theia/core/lib/common/application-error */ "../node_modules/@theia/core/lib/common/application-error.js");
var ProcessTaskInfo;
(function (ProcessTaskInfo) {
    function is(info) {
        return info['processId'] !== undefined;
    }
    ProcessTaskInfo.is = is;
})(ProcessTaskInfo || (exports.ProcessTaskInfo = ProcessTaskInfo = {}));
var ProcessTaskError;
(function (ProcessTaskError) {
    ProcessTaskError.CouldNotRun = application_error_1.ApplicationError.declare(1, (code) => ({
        message: `Error starting process (${code})`,
        data: { code }
    }));
})(ProcessTaskError || (exports.ProcessTaskError = ProcessTaskError = {}));


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/task-protocol.js":
/*!***************************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/task-protocol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskScope = exports.TaskCustomization = exports.TaskOutputPresentation = exports.PanelKind = exports.RevealKind = exports.DependsOrder = exports.TaskClient = exports.TaskServer = exports.taskPath = void 0;
exports.taskPath = '/services/task';
exports.TaskServer = Symbol('TaskServer');
exports.TaskClient = Symbol('TaskClient');
var DependsOrder;
(function (DependsOrder) {
    DependsOrder["Sequence"] = "sequence";
    DependsOrder["Parallel"] = "parallel";
})(DependsOrder || (exports.DependsOrder = DependsOrder = {}));
var RevealKind;
(function (RevealKind) {
    RevealKind["Always"] = "always";
    RevealKind["Silent"] = "silent";
    RevealKind["Never"] = "never";
})(RevealKind || (exports.RevealKind = RevealKind = {}));
var PanelKind;
(function (PanelKind) {
    PanelKind["Shared"] = "shared";
    PanelKind["Dedicated"] = "dedicated";
    PanelKind["New"] = "new";
})(PanelKind || (exports.PanelKind = PanelKind = {}));
var TaskOutputPresentation;
(function (TaskOutputPresentation) {
    function getDefault() {
        return {
            echo: true,
            reveal: RevealKind.Always,
            focus: false,
            panel: PanelKind.Shared,
            showReuseMessage: true,
            clear: false,
            close: false
        };
    }
    TaskOutputPresentation.getDefault = getDefault;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function fromJson(task) {
        let outputPresentation = getDefault();
        if (task && task.presentation) {
            if (task.presentation.reveal) {
                let reveal = RevealKind.Always;
                if (task.presentation.reveal === 'silent') {
                    reveal = RevealKind.Silent;
                }
                else if (task.presentation.reveal === 'never') {
                    reveal = RevealKind.Never;
                }
                outputPresentation = { ...outputPresentation, reveal };
            }
            if (task.presentation.panel) {
                let panel = PanelKind.Shared;
                if (task.presentation.panel === 'dedicated') {
                    panel = PanelKind.Dedicated;
                }
                else if (task.presentation.panel === 'new') {
                    panel = PanelKind.New;
                }
                outputPresentation = { ...outputPresentation, panel };
            }
            outputPresentation = {
                ...outputPresentation,
                echo: task.presentation.echo === undefined || task.presentation.echo,
                focus: shouldSetFocusToTerminal(task),
                showReuseMessage: shouldShowReuseMessage(task),
                clear: shouldClearTerminalBeforeRun(task),
                close: shouldCloseTerminalOnFinish(task)
            };
        }
        return outputPresentation;
    }
    TaskOutputPresentation.fromJson = fromJson;
    function shouldAlwaysRevealTerminal(task) {
        return !task.presentation || task.presentation.reveal === undefined || task.presentation.reveal === RevealKind.Always;
    }
    TaskOutputPresentation.shouldAlwaysRevealTerminal = shouldAlwaysRevealTerminal;
    function shouldSetFocusToTerminal(task) {
        return !!task.presentation && !!task.presentation.focus;
    }
    TaskOutputPresentation.shouldSetFocusToTerminal = shouldSetFocusToTerminal;
    function shouldClearTerminalBeforeRun(task) {
        return !!task.presentation && !!task.presentation.clear;
    }
    TaskOutputPresentation.shouldClearTerminalBeforeRun = shouldClearTerminalBeforeRun;
    function shouldCloseTerminalOnFinish(task) {
        return !!task.presentation && !!task.presentation.close;
    }
    TaskOutputPresentation.shouldCloseTerminalOnFinish = shouldCloseTerminalOnFinish;
    function shouldShowReuseMessage(task) {
        return !task.presentation || task.presentation.showReuseMessage === undefined || !!task.presentation.showReuseMessage;
    }
    TaskOutputPresentation.shouldShowReuseMessage = shouldShowReuseMessage;
})(TaskOutputPresentation || (exports.TaskOutputPresentation = TaskOutputPresentation = {}));
var TaskCustomization;
(function (TaskCustomization) {
    function isBuildTask(task) {
        return task.group === 'build' || typeof task.group === 'object' && task.group.kind === 'build';
    }
    TaskCustomization.isBuildTask = isBuildTask;
    function isDefaultBuildTask(task) {
        return isDefaultTask(task) && isBuildTask(task);
    }
    TaskCustomization.isDefaultBuildTask = isDefaultBuildTask;
    function isDefaultTask(task) {
        return typeof task.group === 'object' && task.group.isDefault;
    }
    TaskCustomization.isDefaultTask = isDefaultTask;
    function isTestTask(task) {
        return task.group === 'test' || typeof task.group === 'object' && task.group.kind === 'test';
    }
    TaskCustomization.isTestTask = isTestTask;
    function isDefaultTestTask(task) {
        return isDefaultTask(task) && isTestTask(task);
    }
    TaskCustomization.isDefaultTestTask = isDefaultTestTask;
})(TaskCustomization || (exports.TaskCustomization = TaskCustomization = {}));
var TaskScope;
(function (TaskScope) {
    TaskScope[TaskScope["Global"] = 1] = "Global";
    TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
})(TaskScope || (exports.TaskScope = TaskScope = {}));


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/task-util.js":
/*!***********************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/task-util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 EclipseSource and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromVariableName = exports.asVariableName = void 0;
/**
 * Converts the given standard name to a variable name starting with '$' if not already present.
 *
 * Variable names are used, for instance, to reference problem matchers, within task configurations.
 *
 * @param name standard name
 * @returns variable name with leading '$' if not already present.
 *
 * @see {@link fromVariableName} for the reverse conversion.
 */
function asVariableName(name) {
    return name.startsWith('$') ? name : `$${name}`;
}
exports.asVariableName = asVariableName;
/**
 * Converts a given variable name to a standard name, effectively removing a leading '$' if present.
 *
 * Standard names are used, for instance, in registries to store variable objects
 *
 * @param name variable name
 * @returns variable name without leading '$' if present.
 *
 * @see {@link asVariableName} for the reverse conversion.
 */
function fromVariableName(name) {
    return name.startsWith('$') ? name.slice(1) : name;
}
exports.fromVariableName = fromVariableName;


/***/ }),

/***/ "../node_modules/@theia/task/lib/common/task-watcher.js":
/*!**************************************************************!*\
  !*** ../node_modules/@theia/task/lib/common/task-watcher.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskWatcher = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
let TaskWatcher = class TaskWatcher {
    constructor() {
        this.onTaskCreatedEmitter = new event_1.Emitter();
        this.onTaskExitEmitter = new event_1.Emitter();
        this.onDidStartTaskProcessEmitter = new event_1.Emitter();
        this.onDidEndTaskProcessEmitter = new event_1.Emitter();
        this.onOutputProcessedEmitter = new event_1.Emitter();
        this.onBackgroundTaskEndedEmitter = new event_1.Emitter();
    }
    getTaskClient() {
        const newTaskEmitter = this.onTaskCreatedEmitter;
        const exitEmitter = this.onTaskExitEmitter;
        const taskProcessStartedEmitter = this.onDidStartTaskProcessEmitter;
        const taskProcessEndedEmitter = this.onDidEndTaskProcessEmitter;
        const outputProcessedEmitter = this.onOutputProcessedEmitter;
        const backgroundTaskEndedEmitter = this.onBackgroundTaskEndedEmitter;
        return {
            onTaskCreated(event) {
                newTaskEmitter.fire(event);
            },
            onTaskExit(event) {
                exitEmitter.fire(event);
            },
            onDidStartTaskProcess(event) {
                taskProcessStartedEmitter.fire(event);
            },
            onDidEndTaskProcess(event) {
                taskProcessEndedEmitter.fire(event);
            },
            onDidProcessTaskOutput(event) {
                outputProcessedEmitter.fire(event);
            },
            onBackgroundTaskEnded(event) {
                backgroundTaskEndedEmitter.fire(event);
            }
        };
    }
    get onTaskCreated() {
        return this.onTaskCreatedEmitter.event;
    }
    get onTaskExit() {
        return this.onTaskExitEmitter.event;
    }
    get onDidStartTaskProcess() {
        return this.onDidStartTaskProcessEmitter.event;
    }
    get onDidEndTaskProcess() {
        return this.onDidEndTaskProcessEmitter.event;
    }
    get onOutputProcessed() {
        return this.onOutputProcessedEmitter.event;
    }
    get onBackgroundTaskEnded() {
        return this.onBackgroundTaskEndedEmitter.event;
    }
};
exports.TaskWatcher = TaskWatcher;
exports.TaskWatcher = TaskWatcher = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TaskWatcher);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/test-execution-progress-service.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/test-execution-progress-service.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultTestExecutionProgressService = exports.TestExecutionProgressService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_result_view_contribution_1 = __webpack_require__(/*! ./view/test-result-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-result-view-contribution.js");
const test_view_contribution_1 = __webpack_require__(/*! ./view/test-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const test_preferences_1 = __webpack_require__(/*! ./test-preferences */ "../node_modules/@theia/test/lib/browser/test-preferences.js");
exports.TestExecutionProgressService = Symbol('TestExecutionProgressService');
let DefaultTestExecutionProgressService = class DefaultTestExecutionProgressService {
    async onTestRunRequested(preserveFocus) {
        if (!preserveFocus) {
            const openTesting = this.testPreferences['testing.openTesting'];
            if (openTesting === 'openOnTestStart') {
                this.openTestResultView();
            }
        }
    }
    async openTestResultView() {
        return this.testResultView.openView({ activate: true });
    }
};
exports.DefaultTestExecutionProgressService = DefaultTestExecutionProgressService;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_result_view_contribution_1.TestResultViewContribution),
    tslib_1.__metadata("design:type", test_result_view_contribution_1.TestResultViewContribution)
], DefaultTestExecutionProgressService.prototype, "testResultView", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_view_contribution_1.TestViewContribution),
    tslib_1.__metadata("design:type", test_view_contribution_1.TestViewContribution)
], DefaultTestExecutionProgressService.prototype, "testView", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_preferences_1.TestPreferences),
    tslib_1.__metadata("design:type", Object)
], DefaultTestExecutionProgressService.prototype, "testPreferences", void 0);
exports.DefaultTestExecutionProgressService = DefaultTestExecutionProgressService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DefaultTestExecutionProgressService);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/test-preferences.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/test-preferences.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindTestPreferences = exports.createTestPreferences = exports.TestPreferences = exports.TestPreferenceContribution = exports.TestConfigSchema = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
exports.TestConfigSchema = {
    type: 'object',
    properties: {
        'testing.openTesting': {
            type: 'string',
            enum: ['neverOpen', 'openOnTestStart'],
            enumDescriptions: [
                nls_1.nls.localizeByDefault('Never automatically open the testing views'),
                nls_1.nls.localizeByDefault('Open the test results view when tests start'),
            ],
            description: nls_1.nls.localizeByDefault('Controls when the testing view should open.'),
            default: 'neverOpen',
            scope: 'resource',
        }
    }
};
exports.TestPreferenceContribution = Symbol('TestPreferenceContribution');
exports.TestPreferences = Symbol('TestPreferences');
function createTestPreferences(preferences, schema = exports.TestConfigSchema) {
    return (0, browser_1.createPreferenceProxy)(preferences, schema);
}
exports.createTestPreferences = createTestPreferences;
const bindTestPreferences = (bind) => {
    bind(exports.TestPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(browser_1.PreferenceService);
        const contribution = ctx.container.get(exports.TestPreferenceContribution);
        return createTestPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.TestPreferenceContribution).toConstantValue({ schema: exports.TestConfigSchema });
    bind(browser_1.PreferenceContribution).toService(exports.TestPreferenceContribution);
};
exports.bindTestPreferences = bindTestPreferences;


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/test-service.js":
/*!***************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/test-service.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultTestService = exports.TestService = exports.TestContribution = exports.TestServices = exports.TestItem = exports.TestRun = exports.TestFailure = exports.TestMessage = exports.TestExecutionState = exports.TestRunProfileKind = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const collections_1 = __webpack_require__(/*! ../common/collections */ "../node_modules/@theia/test/lib/common/collections.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
var TestRunProfileKind;
(function (TestRunProfileKind) {
    TestRunProfileKind[TestRunProfileKind["Run"] = 1] = "Run";
    TestRunProfileKind[TestRunProfileKind["Debug"] = 2] = "Debug";
    TestRunProfileKind[TestRunProfileKind["Coverage"] = 3] = "Coverage";
})(TestRunProfileKind || (exports.TestRunProfileKind = TestRunProfileKind = {}));
var TestExecutionState;
(function (TestExecutionState) {
    TestExecutionState[TestExecutionState["Queued"] = 1] = "Queued";
    TestExecutionState[TestExecutionState["Running"] = 2] = "Running";
    TestExecutionState[TestExecutionState["Passed"] = 3] = "Passed";
    TestExecutionState[TestExecutionState["Failed"] = 4] = "Failed";
    TestExecutionState[TestExecutionState["Skipped"] = 5] = "Skipped";
    TestExecutionState[TestExecutionState["Errored"] = 6] = "Errored";
})(TestExecutionState || (exports.TestExecutionState = TestExecutionState = {}));
var TestMessage;
(function (TestMessage) {
    function is(obj) {
        return (0, common_1.isObject)(obj) && (markdown_rendering_1.MarkdownString.is(obj.message) || typeof obj.message === 'string');
    }
    TestMessage.is = is;
})(TestMessage || (exports.TestMessage = TestMessage = {}));
var TestFailure;
(function (TestFailure) {
    function is(obj) {
        return (0, common_1.isObject)(obj) && (obj.state === TestExecutionState.Failed || obj.state === TestExecutionState.Errored) && Array.isArray(obj.messages);
    }
    TestFailure.is = is;
})(TestFailure || (exports.TestFailure = TestFailure = {}));
var TestRun;
(function (TestRun) {
    function is(obj) {
        return (0, common_1.isObject)(obj)
            && typeof obj.cancel === 'function'
            && typeof obj.name === 'string'
            && typeof obj.isRunning === 'boolean'
            && typeof obj.controller === 'object'
            && typeof obj.onDidChangeProperty === 'function'
            && typeof obj.getTestState === 'function'
            && typeof obj.onDidChangeTestState === 'function'
            && typeof obj.onDidChangeTestState === 'function'
            && typeof obj.getOutput === 'function'
            && typeof obj.onDidChangeTestOutput === 'function'
            && Array.isArray(obj.items);
    }
    TestRun.is = is;
})(TestRun || (exports.TestRun = TestRun = {}));
var TestItem;
(function (TestItem) {
    function is(obj) {
        return (0, common_1.isObject)(obj)
            && obj.id !== undefined
            && obj.label !== undefined
            && Array.isArray(obj.tags)
            && Array.isArray(obj.tests)
            && obj.busy !== undefined
            && obj.canResolveChildren !== undefined
            && typeof obj.resolveChildren === 'function';
    }
    TestItem.is = is;
})(TestItem || (exports.TestItem = TestItem = {}));
var TestServices;
(function (TestServices) {
    function withTestRun(service, controllerId, runId) {
        const controller = service.getControllers().find(c => c.id === controllerId);
        if (!controller) {
            throw new Error(`No test controller with id '${controllerId}' found`);
        }
        const run = controller.testRuns.find(r => r.id === runId);
        if (!run) {
            throw new Error(`No test run with id '${runId}' found`);
        }
        return run;
    }
    TestServices.withTestRun = withTestRun;
})(TestServices || (exports.TestServices = TestServices = {}));
exports.TestContribution = Symbol('TestContribution');
exports.TestService = Symbol('TestService');
let DefaultTestService = class DefaultTestService {
    constructor() {
        this.testRunCounter = 0;
        this.onDidChangeIsRefreshingEmitter = new common_1.Emitter();
        this.onDidChangeIsRefreshing = this.onDidChangeIsRefreshingEmitter.event;
        this.controllers = new Map();
        this.refreshing = new Set();
        this.onControllersChangedEmitter = new common_1.Emitter();
        this.onControllersChanged = this.onControllersChangedEmitter.event;
    }
    registerContributions() {
        this.contributionProvider.getContributions().forEach(contribution => contribution.registerTestControllers(this));
    }
    registerTestController(controller) {
        if (this.controllers.has(controller.id)) {
            throw new Error('TestController already registered: ' + controller.id);
        }
        this.controllers.set(controller.id, controller);
        this.onControllersChangedEmitter.fire({ added: [controller] });
        return common_1.Disposable.create(() => {
            this.controllers.delete(controller.id);
            this.onControllersChangedEmitter.fire({ removed: [controller.id] });
        });
    }
    getControllers() {
        return Array.from(this.controllers.values());
    }
    refresh() {
        const cts = new vscode_languageserver_protocol_1.CancellationTokenSource();
        this.refreshing.add(cts);
        Promise.all(this.getControllers().map(controller => controller.refreshTests(cts.token))).then(() => {
            this.refreshing.delete(cts);
            if (this.refreshing.size === 0) {
                this.onDidChangeIsRefreshingEmitter.fire();
            }
        });
        if (this.refreshing.size === 1) {
            this.onDidChangeIsRefreshingEmitter.fire();
        }
    }
    cancelRefresh() {
        if (this.refreshing.size > 0) {
            this.refreshing.forEach(cts => cts.cancel());
            this.refreshing.clear();
            this.onDidChangeIsRefreshingEmitter.fire();
        }
    }
    get isRefreshing() {
        return this.refreshing.size > 0;
    }
    runAllTests(profileKind) {
        this.getControllers().forEach(controller => {
            this.runTestForController(controller, profileKind, controller.tests);
        });
    }
    async runTestForController(controller, profileKind, items) {
        const runProfiles = controller.testRunProfiles.filter(profile => profile.kind === profileKind);
        let activeProfile;
        if (runProfiles.length === 1) {
            activeProfile = runProfiles[0];
        }
        else if (runProfiles.length > 1) {
            const defaultProfile = runProfiles.find(p => p.isDefault);
            if (defaultProfile) {
                activeProfile = defaultProfile;
            }
            else {
                activeProfile = await this.pickProfile(runProfiles, common_1.nls.localizeByDefault('Pick a test profile to use'));
            }
        }
        if (activeProfile) {
            activeProfile.run(`Test run #${this.testRunCounter++}`, items, [], true);
        }
    }
    async pickProfile(runProfiles, title) {
        var _a;
        if (runProfiles.length === 0) {
            return undefined;
        }
        // eslint-disable-next-line arrow-body-style
        const picks = runProfiles.map(profile => {
            let iconClasses;
            if (profile.kind === TestRunProfileKind.Run) {
                iconClasses = (0, browser_1.codiconArray)('run');
            }
            else if (profile.kind === TestRunProfileKind.Debug) {
                iconClasses = (0, browser_1.codiconArray)('debug-alt');
            }
            return {
                iconClasses,
                label: `${profile.label}${profile.isDefault ? ' (default)' : ''}`,
                profile: profile
            };
        });
        return (_a = (await this.quickpickService.show(picks, { title: title }))) === null || _a === void 0 ? void 0 : _a.profile;
    }
    async pickProfileKind() {
        var _a;
        // eslint-disable-next-line arrow-body-style
        const picks = [{
                iconClasses: (0, browser_1.codiconArray)('run'),
                label: 'Run',
                kind: TestRunProfileKind.Run
            }, {
                iconClasses: (0, browser_1.codiconArray)('debug-alt'),
                label: 'Debug',
                kind: TestRunProfileKind.Debug
            }];
        return (_a = (await this.quickpickService.show(picks, { title: 'Select the kind of profiles' }))) === null || _a === void 0 ? void 0 : _a.kind;
    }
    runTests(profileKind, items) {
        (0, collections_1.groupBy)(items, item => item.controller).forEach((tests, controller) => {
            if (controller) {
                this.runTestForController(controller, profileKind, tests);
            }
        });
    }
    runTestsWithProfile(items) {
        (0, collections_1.groupBy)(items, item => item.controller).forEach((tests, controller) => {
            if (controller) {
                this.pickProfile(controller.testRunProfiles, common_1.nls.localizeByDefault('Pick a test profile to use')).then(activeProfile => {
                    if (activeProfile) {
                        activeProfile.run(`Test run #${this.testRunCounter++}`, items, [], true);
                    }
                });
            }
        });
    }
    selectDefaultProfile() {
        this.pickProfileKind().then(kind => {
            const profiles = this.getControllers().flatMap(c => c.testRunProfiles).filter(profile => profile.kind === kind);
            this.pickProfile(profiles, common_1.nls.localizeByDefault('Pick a test profile to use')).then(activeProfile => {
                if (activeProfile) {
                    // only change the default for the controller containing selected profile for default and its profiles with same kind
                    const controller = this.getControllers().find(c => c.testRunProfiles.includes(activeProfile));
                    controller === null || controller === void 0 ? void 0 : controller.testRunProfiles.filter(profile => profile.kind === activeProfile.kind).forEach(profile => {
                        profile.isDefault = profile === activeProfile;
                    });
                }
            });
        });
    }
    configureProfile() {
        const profiles = [];
        for (const controller of this.controllers.values()) {
            profiles.push(...controller.testRunProfiles);
        }
        ;
        this.pickProfile(profiles.filter(profile => profile.canConfigure), common_1.nls.localizeByDefault('Select a profile to update')).then(profile => {
            if (profile) {
                profile.configure();
            }
        });
    }
    clearResults() {
        for (const controller of this.controllers.values()) {
            controller.clearRuns();
        }
    }
};
exports.DefaultTestService = DefaultTestService;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.QuickPickService),
    tslib_1.__metadata("design:type", Object)
], DefaultTestService.prototype, "quickpickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.ContributionProvider),
    (0, inversify_1.named)(exports.TestContribution),
    tslib_1.__metadata("design:type", Object)
], DefaultTestService.prototype, "contributionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DefaultTestService.prototype, "registerContributions", null);
exports.DefaultTestService = DefaultTestService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DefaultTestService);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-context-key-service.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-context-key-service.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let TestContextKeyService = class TestContextKeyService {
    get contextValue() {
        return this._contextValue;
    }
    init() {
        this._contextValue = this.contextKeyService.createKey('testMessage', undefined);
    }
};
exports.TestContextKeyService = TestContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestContextKeyService.prototype, "init", null);
exports.TestContextKeyService = TestContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-execution-state-manager.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-execution-state-manager.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestExecutionStateManager = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
/**
 * This class manages the state of "internal" nodes in the test tree
 */
let TestExecutionStateManager = class TestExecutionStateManager {
    constructor() {
        this.executionStates = new Map();
    }
    init() {
        this.testService.getControllers().forEach(controller => this.addController(controller));
        this.testService.onControllersChanged(controllerDelta => {
            var _a;
            (_a = controllerDelta.added) === null || _a === void 0 ? void 0 : _a.forEach(controller => this.addController(controller));
        });
    }
    addController(controller) {
        controller.testRuns.forEach(run => this.addRun(run));
        controller.onRunsChanged(runDelta => {
            var _a, _b;
            (_a = runDelta.added) === null || _a === void 0 ? void 0 : _a.forEach(run => this.addRun(run));
            (_b = runDelta.removed) === null || _b === void 0 ? void 0 : _b.forEach(run => {
                this.executionStates.delete(run);
            });
        });
    }
    addRun(run) {
        this.executionStates.set(run, new TestExecutionStateMap);
        run.onDidChangeTestState(updates => {
            updates.forEach(update => {
                var _a, _b;
                this.updateState(run, update.test, (_a = update.oldState) === null || _a === void 0 ? void 0 : _a.state, (_b = update.newState) === null || _b === void 0 ? void 0 : _b.state);
            });
        });
    }
    updateState(run, item, oldState, newState) {
        const map = this.executionStates.get(run);
        map.reportState(item, oldState, newState);
    }
    getComputedState(run, item) {
        var _a;
        return (_a = this.executionStates.get(run)) === null || _a === void 0 ? void 0 : _a.getComputedState(item);
    }
};
exports.TestExecutionStateManager = TestExecutionStateManager;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestExecutionStateManager.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestExecutionStateManager.prototype, "init", null);
exports.TestExecutionStateManager = TestExecutionStateManager = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestExecutionStateManager);
class TestExecutionStateMap {
    constructor() {
        this.stateCounts = new Map();
    }
    reportState(item, oldState, newState) {
        if (oldState !== newState) {
            if (item.parent) {
                this.reportChildStateChanged(item.parent, oldState, newState);
            }
        }
    }
    reportChildStateChanged(parent, oldState, newState) {
        if (oldState !== newState) {
            const currentParentState = this.getComputedState(parent);
            let counts = this.stateCounts.get(parent);
            if (!counts) {
                counts = [];
                counts[test_service_1.TestExecutionState.Queued] = 0;
                counts[test_service_1.TestExecutionState.Running] = 0;
                counts[test_service_1.TestExecutionState.Passed] = 0;
                counts[test_service_1.TestExecutionState.Failed] = 0;
                counts[test_service_1.TestExecutionState.Skipped] = 0;
                counts[test_service_1.TestExecutionState.Errored] = 0;
                this.stateCounts.set(parent, counts);
            }
            if (oldState) {
                counts[oldState]--;
            }
            if (newState) {
                counts[newState]++;
            }
            const newParentState = this.getComputedState(parent);
            if (parent.parent && currentParentState !== newParentState) {
                this.reportChildStateChanged(parent.parent, currentParentState, newParentState);
            }
        }
    }
    updateState(item, oldState, newState) {
        let parent = item.parent;
        while (parent && 'parent' in parent) { // parent is a test item
            let counts = this.stateCounts.get(parent);
            if (!counts) {
                counts = [];
                counts[test_service_1.TestExecutionState.Queued] = 0;
                counts[test_service_1.TestExecutionState.Running] = 0;
                counts[test_service_1.TestExecutionState.Passed] = 0;
                counts[test_service_1.TestExecutionState.Failed] = 0;
                counts[test_service_1.TestExecutionState.Skipped] = 0;
                counts[test_service_1.TestExecutionState.Errored] = 0;
                this.stateCounts.set(parent, counts);
            }
            if (oldState) {
                counts[oldState]--;
            }
            counts[newState]++;
            parent = parent.parent;
        }
    }
    getComputedState(item) {
        const counts = this.stateCounts.get(item);
        if (counts) {
            if (counts[test_service_1.TestExecutionState.Errored] > 0) {
                return test_service_1.TestExecutionState.Errored;
            }
            else if (counts[test_service_1.TestExecutionState.Failed] > 0) {
                return test_service_1.TestExecutionState.Failed;
            }
            else if (counts[test_service_1.TestExecutionState.Running] > 0) {
                return test_service_1.TestExecutionState.Running;
            }
            else if (counts[test_service_1.TestExecutionState.Queued] > 0) {
                return test_service_1.TestExecutionState.Queued;
            }
            else if (counts[test_service_1.TestExecutionState.Passed] > 0) {
                return test_service_1.TestExecutionState.Passed;
            }
            else if (counts[test_service_1.TestExecutionState.Skipped] > 0) {
                return test_service_1.TestExecutionState.Skipped;
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
}


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-output-ui-model.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-output-ui-model.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestOutputUIModel = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const test_context_key_service_1 = __webpack_require__(/*! ./test-context-key-service */ "../node_modules/@theia/test/lib/browser/view/test-context-key-service.js");
let TestOutputUIModel = class TestOutputUIModel {
    constructor() {
        this.activeRuns = new Map();
        this.controllerListeners = new Map();
        this.onDidChangeActiveTestRunEmitter = new core_1.Emitter();
        this.onDidChangeActiveTestRun = this.onDidChangeActiveTestRunEmitter.event;
        this.onDidChangeActiveTestStateEmitter = new core_1.Emitter();
        this.onDidChangeActiveTestState = this.onDidChangeActiveTestStateEmitter.event;
        this.onDidChangeSelectedOutputSourceEmitter = new core_1.Emitter();
        this.onDidChangeSelectedOutputSource = this.onDidChangeSelectedOutputSourceEmitter.event;
        this.onDidChangeSelectedTestStateEmitter = new core_1.Emitter();
        this.onDidChangeSelectedTestState = this.onDidChangeSelectedTestStateEmitter.event;
    }
    init() {
        this.testService.getControllers().forEach(controller => this.addController(controller));
        this.testService.onControllersChanged(deltas => {
            var _a, _b;
            (_a = deltas.added) === null || _a === void 0 ? void 0 : _a.forEach(controller => this.addController(controller));
            (_b = deltas.removed) === null || _b === void 0 ? void 0 : _b.forEach(controller => this.removeController(controller));
        });
    }
    removeController(id) {
        var _a;
        (_a = this.controllerListeners.get(id)) === null || _a === void 0 ? void 0 : _a.dispose();
        if (this.activeRuns.has(id)) {
            this.activeRuns.delete(id);
        }
    }
    addController(controller) {
        this.controllerListeners.set(controller.id, controller.onRunsChanged(delta => {
            var _a;
            if (delta.added) {
                const currentRun = controller.testRuns[controller.testRuns.length - 1];
                if (currentRun) {
                    this.setActiveTestRun(currentRun);
                }
            }
            else {
                (_a = delta.removed) === null || _a === void 0 ? void 0 : _a.forEach(run => {
                    if (run === this.getActiveTestRun(controller)) {
                        const currentRun = controller.testRuns[controller.testRuns.length - 1];
                        this.doSetActiveRun(controller, currentRun);
                    }
                });
            }
        }));
    }
    getActiveTestRun(controller) {
        var _a;
        return (_a = this.activeRuns.get(controller.id)) === null || _a === void 0 ? void 0 : _a.run;
    }
    setActiveTestRun(run) {
        this.doSetActiveRun(run.controller, run);
    }
    doSetActiveRun(controller, run) {
        const old = this.activeRuns.get(controller.id);
        if (old !== run) {
            if (old) {
                old.toDispose.dispose();
            }
            if (run) {
                const toDispose = run.onDidChangeTestState(e => {
                    this.onDidChangeActiveTestStateEmitter.fire({
                        controller,
                        testRun: run,
                        statedDelta: e
                    });
                });
                this.activeRuns.set(controller.id, { run, toDispose });
            }
            else {
                this.activeRuns.delete(controller.id);
            }
            this.onDidChangeActiveTestRunEmitter.fire({ activeRun: run, controller: controller });
        }
    }
    get selectedOutputSource() {
        return this._selectedOutputSource;
    }
    set selectedOutputSource(element) {
        if (element !== this._selectedOutputSource) {
            this._selectedOutputSource = element;
            this.onDidChangeSelectedOutputSourceEmitter.fire(element);
        }
    }
    get selectedTestState() {
        return this._selectedTestState;
    }
    set selectedTestState(element) {
        if (element !== this._selectedTestState) {
            this._selectedTestState = element;
            if (this._selectedTestState && test_service_1.TestFailure.is(this._selectedTestState.state)) {
                const message = this._selectedTestState.state.messages[0];
                this.testContextKeys.contextValue.set(message.contextValue);
            }
            else {
                this.testContextKeys.contextValue.reset();
            }
            this.onDidChangeSelectedTestStateEmitter.fire(element);
        }
    }
};
exports.TestOutputUIModel = TestOutputUIModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_context_key_service_1.TestContextKeyService),
    tslib_1.__metadata("design:type", test_context_key_service_1.TestContextKeyService)
], TestOutputUIModel.prototype, "testContextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestOutputUIModel.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestOutputUIModel.prototype, "init", null);
exports.TestOutputUIModel = TestOutputUIModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestOutputUIModel);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-result-view-contribution.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-result-view-contribution.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestResultViewContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_result_widget_1 = __webpack_require__(/*! ./test-result-widget */ "../node_modules/@theia/test/lib/browser/view/test-result-widget.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
let TestResultViewContribution = class TestResultViewContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: test_result_widget_1.TestResultWidget.ID,
            widgetName: core_1.nls.localizeByDefault('Test Results'),
            defaultWidgetOptions: {
                area: 'bottom'
            }
        });
    }
};
exports.TestResultViewContribution = TestResultViewContribution;
exports.TestResultViewContribution = TestResultViewContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TestResultViewContribution);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-result-widget.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-result-widget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TestResultWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestResultWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_output_ui_model_1 = __webpack_require__(/*! ./test-output-ui-model */ "../node_modules/@theia/test/lib/browser/view/test-output-ui-model.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const markdown_renderer_1 = __webpack_require__(/*! @theia/core/lib/browser/markdown-rendering/markdown-renderer */ "../node_modules/@theia/core/lib/browser/markdown-rendering/markdown-renderer.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const navigation_location_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/navigation/navigation-location-service */ "../node_modules/@theia/editor/lib/browser/navigation/navigation-location-service.js");
const navigation_location_1 = __webpack_require__(/*! @theia/editor/lib/browser/navigation/navigation-location */ "../node_modules/@theia/editor/lib/browser/navigation/navigation-location.js");
let TestResultWidget = TestResultWidget_1 = class TestResultWidget extends browser_1.BaseWidget {
    constructor() {
        super();
        this.toDisposeOnRender = new core_1.DisposableCollection();
        this.input = [];
        this.addClass('theia-test-result-view');
        this.id = TestResultWidget_1.ID;
        this.title.label = core_1.nls.localizeByDefault('Test Results');
        this.title.caption = core_1.nls.localizeByDefault('Test Results');
        this.title.iconClass = (0, browser_1.codicon)('checklist');
        this.title.closable = true;
        this.scrollOptions = {
            minScrollbarLength: 35,
        };
    }
    init() {
        this.uiModel.onDidChangeSelectedTestState(e => {
            if (test_service_1.TestFailure.is(e)) {
                this.setInput(e.messages);
            }
        });
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.content = this.node.ownerDocument.createElement('div');
        this.node.append(this.content);
    }
    setInput(messages) {
        this.input = messages;
        this.update();
    }
    onUpdateRequest(msg) {
        this.render();
        super.onUpdateRequest(msg);
    }
    render() {
        this.toDisposeOnRender.dispose();
        this.toDisposeOnRender = new core_1.DisposableCollection();
        this.content.innerHTML = '';
        this.input.forEach(message => {
            if (markdown_rendering_1.MarkdownString.is(message.message)) {
                const line = this.markdownRenderer.render(message.message);
                this.content.append(line.element);
                this.toDisposeOnRender.push(line);
            }
            else {
                this.content.append(this.node.ownerDocument.createTextNode(message.message));
            }
            if (message.stackTrace) {
                const stackTraceElement = this.node.ownerDocument.createElement('div');
                message.stackTrace.map(frame => this.renderFrame(frame, stackTraceElement));
                this.content.append(stackTraceElement);
            }
        });
    }
    renderFrame(stackFrame, stackTraceElement) {
        const frameElement = stackTraceElement.ownerDocument.createElement('div');
        frameElement.classList.add('debug-frame');
        frameElement.append(`    ${core_1.nls.localize('theia/test/stackFrameAt', 'at')} ${stackFrame.label}`);
        // Add URI information as clickable links
        if (stackFrame.uri) {
            frameElement.append(' (');
            const uri = new uri_1.URI(stackFrame.uri);
            const link = this.node.ownerDocument.createElement('a');
            let content = `${this.labelProvider.getName(uri)}`;
            if (stackFrame.position) {
                // Display Position as a 1-based position, similar to Monaco ones.
                const monacoPosition = {
                    lineNumber: stackFrame.position.line + 1,
                    column: stackFrame.position.character + 1
                };
                content += `:${monacoPosition.lineNumber}:${monacoPosition.column}`;
            }
            link.textContent = content;
            link.href = `${uri}`;
            link.onclick = () => this.openUriInWorkspace(uri, stackFrame.position);
            frameElement.append(link);
            frameElement.append(')');
        }
        stackTraceElement.append(frameElement);
    }
    async openUriInWorkspace(uri, position) {
        this.fileService.resolve(uri).then(stat => {
            if (stat.isFile) {
                this.navigationService.reveal(navigation_location_1.NavigationLocation.create(uri, position !== null && position !== void 0 ? position : { line: 0, character: 0 }));
            }
        });
    }
    dispose() {
        this.toDisposeOnRender.dispose();
    }
};
exports.TestResultWidget = TestResultWidget;
TestResultWidget.ID = 'test-result-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(test_output_ui_model_1.TestOutputUIModel),
    tslib_1.__metadata("design:type", test_output_ui_model_1.TestOutputUIModel)
], TestResultWidget.prototype, "uiModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(markdown_renderer_1.MarkdownRenderer),
    tslib_1.__metadata("design:type", Object)
], TestResultWidget.prototype, "markdownRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], TestResultWidget.prototype, "openerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], TestResultWidget.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(navigation_location_service_1.NavigationLocationService),
    tslib_1.__metadata("design:type", navigation_location_service_1.NavigationLocationService)
], TestResultWidget.prototype, "navigationService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], TestResultWidget.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestResultWidget.prototype, "init", null);
exports.TestResultWidget = TestResultWidget = TestResultWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TestResultWidget);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-run-view-contribution.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-run-view-contribution.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestRunViewContribution = exports.TEST_RUNS_INLINE_MENU = exports.TEST_RUNS_CONTEXT_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const test_run_widget_1 = __webpack_require__(/*! ./test-run-widget */ "../node_modules/@theia/test/lib/browser/view/test-run-widget.js");
const test_view_contribution_1 = __webpack_require__(/*! ./test-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
exports.TEST_RUNS_CONTEXT_MENU = ['test-runs-context-menu'];
exports.TEST_RUNS_INLINE_MENU = [...exports.TEST_RUNS_CONTEXT_MENU, 'inline'];
let TestRunViewContribution = class TestRunViewContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            viewContainerId: test_view_contribution_1.TEST_VIEW_CONTAINER_ID,
            widgetId: test_run_widget_1.TestRunTreeWidget.ID,
            widgetName: core_1.nls.localize('theia/test/testRuns', 'Test Runs'),
            defaultWidgetOptions: {
                area: 'left',
                rank: 200,
            }
        });
    }
    registerToolbarItems(registry) {
        registry.registerItem({
            id: test_view_contribution_1.TestViewCommands.CLEAR_ALL_RESULTS.id,
            command: test_view_contribution_1.TestViewCommands.CLEAR_ALL_RESULTS.id,
            priority: 1
        });
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        menus.registerMenuAction(exports.TEST_RUNS_CONTEXT_MENU, {
            commandId: test_view_contribution_1.TestViewCommands.CANCEL_RUN.id
        });
    }
    registerCommands(commands) {
        super.registerCommands(commands);
        commands.registerCommand(test_view_contribution_1.TestViewCommands.CANCEL_RUN, {
            isEnabled: t => test_service_1.TestRun.is(t) && t.isRunning,
            isVisible: t => test_service_1.TestRun.is(t),
            execute: t => {
                if (test_service_1.TestRun.is(t)) {
                    t.cancel();
                }
            }
        });
        commands.registerCommand(test_view_contribution_1.TestViewCommands.CLEAR_ALL_RESULTS, {
            isEnabled: w => this.withWidget(w, () => true),
            isVisible: w => this.withWidget(w, () => true),
            execute: () => {
                this.testService.clearResults();
            }
        });
    }
    withWidget(widget = this.tryGetWidget(), cb) {
        if (widget instanceof test_run_widget_1.TestRunTreeWidget && widget.id === test_run_widget_1.TestRunTreeWidget.ID) {
            return cb(widget);
        }
        return false;
    }
};
exports.TestRunViewContribution = TestRunViewContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestRunViewContribution.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestRunViewContribution.prototype, "contextKeys", void 0);
exports.TestRunViewContribution = TestRunViewContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TestRunViewContribution);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-run-widget.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-run-widget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TestRunTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestRunTreeWidget = exports.TestRunTree = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "../node_modules/@theia/core/lib/browser/icon-theme-service.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const test_execution_state_manager_1 = __webpack_require__(/*! ./test-execution-state-manager */ "../node_modules/@theia/test/lib/browser/view/test-execution-state-manager.js");
const test_output_ui_model_1 = __webpack_require__(/*! ./test-output-ui-model */ "../node_modules/@theia/test/lib/browser/view/test-output-ui-model.js");
class TestRunNode {
    constructor(counter, id, run, parent) {
        this.counter = counter;
        this.id = id;
        this.run = run;
        this.parent = parent;
        this.selected = false;
        this.children = [];
    }
    get name() {
        return this.run.name || core_1.nls.localize('theia/test/testRunDefaultName', '{0} run {1}', this.run.controller.label, this.counter);
    }
    ;
}
class TestItemNode {
    constructor(id, item, parent) {
        this.id = id;
        this.item = item;
        this.parent = parent;
        this.selected = false;
    }
    get name() {
        return this.item.label;
    }
}
let TestRunTree = class TestRunTree extends tree_1.TreeImpl {
    constructor() {
        super(...arguments);
        this.ROOT = {
            id: 'TestResults',
            name: 'Test Results',
            parent: undefined,
            children: [],
            visible: false
        };
        this.controllerListeners = new Map();
        this.runs = new Map();
        this.nextId = 0;
    }
    init() {
        this.root = this.ROOT;
        this.testService.getControllers().forEach(controller => {
            this.addController(controller);
        });
        this.testService.onControllersChanged(controllerDelta => {
            var _a, _b;
            (_a = controllerDelta.removed) === null || _a === void 0 ? void 0 : _a.forEach(controller => {
                var _a;
                (_a = this.controllerListeners.get(controller)) === null || _a === void 0 ? void 0 : _a.dispose();
            });
            (_b = controllerDelta.added) === null || _b === void 0 ? void 0 : _b.forEach(controller => this.addController(controller));
        });
    }
    addController(controller) {
        controller.testRuns.forEach(run => this.addRun(run));
        const listeners = new core_1.DisposableCollection();
        this.controllerListeners.set(controller.id, listeners);
        listeners.push(controller.onRunsChanged(runDelta => {
            var _a, _b;
            (_a = runDelta.removed) === null || _a === void 0 ? void 0 : _a.forEach(run => {
                var _a;
                (_a = this.runs.get(run)) === null || _a === void 0 ? void 0 : _a.disposable.dispose();
                this.runs.delete(run);
                this.refresh(this.ROOT);
            });
            (_b = runDelta.added) === null || _b === void 0 ? void 0 : _b.forEach(run => {
                this.addRun(run);
                this.refresh(this.ROOT);
            });
        }));
    }
    addRun(run) {
        const newNode = this.createRunNode(run);
        const affected = [];
        const disposables = new core_1.DisposableCollection();
        disposables.push(run.onDidChangeTestState(deltas => {
            let needsRefresh = false;
            deltas.forEach(delta => {
                if (delta.newState) {
                    if (delta.newState.state > test_service_1.TestExecutionState.Queued) {
                        const testNode = info.tests.get(delta.test);
                        if (!testNode) {
                            if (info.tests.size === 0) {
                                newNode.expanded = true;
                            }
                            info.tests.set(delta.test, this.createTestItemNode(newNode, delta.test));
                            needsRefresh = true;
                        }
                        else {
                            affected.push(testNode);
                        }
                    }
                }
                else {
                    info.tests.delete(delta.test);
                    needsRefresh = true;
                }
            });
            if (needsRefresh) {
                this.refresh(newNode);
            }
            else {
                this.onDidUpdateEmitter.fire(affected);
            }
        }));
        disposables.push(run.onDidChangeProperty(() => this.onDidUpdateEmitter.fire([])));
        const info = {
            node: newNode,
            disposable: disposables,
            tests: new Map(run.items.filter(item => { var _a; return (((_a = run.getTestState(item)) === null || _a === void 0 ? void 0 : _a.state) || 0) > test_service_1.TestExecutionState.Queued; }).map(item => [item, this.createTestItemNode(newNode, item)]))
        };
        this.runs.set(run, info);
    }
    createRunNode(run) {
        return new TestRunNode(this.nextId, `id-${this.nextId++}`, run, this.ROOT);
    }
    createTestItemNode(parent, item) {
        return new TestItemNode(`testitem-${this.nextId++}`, item, parent);
    }
    async resolveChildren(parent) {
        if (parent === this.ROOT) {
            return Promise.resolve([...this.runs.values()].reverse().map(info => info.node));
        }
        else if (parent instanceof TestRunNode) {
            const runInfo = this.runs.get(parent.run);
            if (runInfo) {
                return Promise.resolve([...runInfo.tests.values()]);
            }
            else {
                return Promise.resolve([]);
            }
        }
        else {
            return Promise.resolve([]);
        }
    }
};
exports.TestRunTree = TestRunTree;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestRunTree.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestRunTree.prototype, "init", null);
exports.TestRunTree = TestRunTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestRunTree);
let TestRunTreeWidget = TestRunTreeWidget_1 = class TestRunTreeWidget extends tree_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this.id = TestRunTreeWidget_1.ID;
        this.title.label = core_1.nls.localize('theia/test/testRuns', 'Test Runs');
        this.title.caption = core_1.nls.localize('theia/test/testRuns', 'Test Runs');
        this.title.iconClass = (0, browser_1.codicon)('run');
        this.title.closable = true;
    }
    init() {
        super.init();
        this.addClass('theia-test-run-view');
        this.model.onSelectionChanged(() => {
            const node = this.model.selectedNodes[0];
            if (node instanceof TestRunNode) {
                this.uiModel.selectedOutputSource = {
                    get output() {
                        return node.run.getOutput();
                    },
                    onDidAddTestOutput: core_1.Event.map(node.run.onDidChangeTestOutput, evt => evt.map(item => item[1]))
                };
            }
            else if (node instanceof TestItemNode) {
                this.uiModel.selectedOutputSource = {
                    get output() {
                        return node.parent.run.getOutput(node.item);
                    },
                    onDidAddTestOutput: core_1.Event.map(node.parent.run.onDidChangeTestOutput, evt => evt.filter(item => item[0] === node.item).map(item => item[1]))
                };
                this.uiModel.selectedTestState = node.parent.run.getTestState(node.item);
            }
        });
    }
    renderTree(model) {
        if (tree_1.CompositeTreeNode.is(this.model.root) && this.model.root.children.length > 0) {
            return super.renderTree(model);
        }
        return React.createElement("div", { className: 'theia-widget-noInfo noMarkers' }, core_1.nls.localizeByDefault('No tests have been found in this workspace yet.'));
    }
    getTestStateClass(state) {
        switch (state) {
            case test_service_1.TestExecutionState.Queued: return `${(0, browser_1.codicon)('history')} queued`;
            case test_service_1.TestExecutionState.Running: return `${(0, browser_1.codicon)('sync')} codicon-modifier-spin running`;
            case test_service_1.TestExecutionState.Skipped: return `${(0, browser_1.codicon)('debug-step-over')} skipped`;
            case test_service_1.TestExecutionState.Failed: return `${(0, browser_1.codicon)('error')} failed`;
            case test_service_1.TestExecutionState.Errored: return `${(0, browser_1.codicon)('issues')} errored`;
            case test_service_1.TestExecutionState.Passed: return `${(0, browser_1.codicon)('pass')} passed`;
            default: return (0, browser_1.codicon)('circle');
        }
    }
    renderIcon(node, props) {
        var _a;
        if (node instanceof TestItemNode) {
            const state = (_a = node.parent.run.getTestState(node.item)) === null || _a === void 0 ? void 0 : _a.state;
            return React.createElement("div", { className: this.getTestStateClass(state) });
        }
        else if (node instanceof TestRunNode) {
            const icon = node.run.isRunning ? `${(0, browser_1.codicon)('sync')} codicon-modifier-spin running` : (0, browser_1.codicon)('circle');
            return React.createElement("div", { className: icon });
        }
        else {
            return super.renderIcon(node, props);
        }
    }
    toContextMenuArgs(node) {
        if (node instanceof TestRunNode) {
            return [node.run];
        }
        else if (node instanceof TestItemNode) {
            const item = node.item;
            const executionState = node.parent.run.getTestState(node.item);
            if (test_service_1.TestFailure.is(executionState)) {
                return [item, executionState.messages];
            }
            return [item];
        }
        return [];
    }
    storeState() {
        return {}; // don't store any state for now
    }
};
exports.TestRunTreeWidget = TestRunTreeWidget;
TestRunTreeWidget.ID = 'test-run-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], TestRunTreeWidget.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestRunTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], TestRunTreeWidget.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_execution_state_manager_1.TestExecutionStateManager),
    tslib_1.__metadata("design:type", test_execution_state_manager_1.TestExecutionStateManager)
], TestRunTreeWidget.prototype, "stateManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_output_ui_model_1.TestOutputUIModel),
    tslib_1.__metadata("design:type", test_output_ui_model_1.TestOutputUIModel)
], TestRunTreeWidget.prototype, "uiModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestRunTreeWidget.prototype, "init", null);
exports.TestRunTreeWidget = TestRunTreeWidget = TestRunTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(tree_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, browser_1.ContextMenuRenderer])
], TestRunTreeWidget);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-tree-widget.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-tree-widget.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TestTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestTreeWidget = exports.TestTree = exports.TestItemNode = exports.TestControllerNode = exports.TestRoot = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "../node_modules/@theia/core/lib/browser/icon-theme-service.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../node_modules/@theia/core/lib/browser/theming.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const tree_delta_1 = __webpack_require__(/*! ../../common/tree-delta */ "../node_modules/@theia/test/lib/common/tree-delta.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const test_execution_state_manager_1 = __webpack_require__(/*! ./test-execution-state-manager */ "../node_modules/@theia/test/lib/browser/view/test-execution-state-manager.js");
const test_output_ui_model_1 = __webpack_require__(/*! ./test-output-ui-model */ "../node_modules/@theia/test/lib/browser/view/test-output-ui-model.js");
const test_view_contribution_1 = __webpack_require__(/*! ./test-view-contribution */ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const ROOT_ID = 'TestTree';
var TestRoot;
(function (TestRoot) {
    function is(node) {
        return tree_1.CompositeTreeNode.is(node) && node.id === ROOT_ID;
    }
    TestRoot.is = is;
})(TestRoot || (exports.TestRoot = TestRoot = {}));
var TestControllerNode;
(function (TestControllerNode) {
    function is(node) {
        return tree_1.ExpandableTreeNode.is(node) && 'controller' in node;
    }
    TestControllerNode.is = is;
})(TestControllerNode || (exports.TestControllerNode = TestControllerNode = {}));
var TestItemNode;
(function (TestItemNode) {
    function is(node) {
        return tree_1.TreeNode.is(node) && 'testItem' in node;
    }
    TestItemNode.is = is;
})(TestItemNode || (exports.TestItemNode = TestItemNode = {}));
let TestTree = class TestTree extends tree_1.TreeImpl {
    constructor() {
        super(...arguments);
        this.controllerListeners = new Map();
    }
    init() {
        this.testService.getControllers().forEach(controller => this.addController(controller));
        this.testService.onControllersChanged(e => {
            var _a, _b;
            (_a = e.removed) === null || _a === void 0 ? void 0 : _a.forEach(controller => {
                var _a;
                (_a = this.controllerListeners.get(controller)) === null || _a === void 0 ? void 0 : _a.dispose();
            });
            (_b = e.added) === null || _b === void 0 ? void 0 : _b.forEach(controller => this.addController(controller));
            this.refresh(this.root);
        });
    }
    addController(controller) {
        const listeners = new core_1.DisposableCollection();
        this.controllerListeners.set(controller.id, listeners);
        listeners.push(controller.onItemsChanged(delta => {
            this.processDeltas(controller, controller, delta);
        }));
    }
    async resolveChildren(parent) {
        if (TestItemNode.is(parent)) {
            parent.testItem.resolveChildren();
            return Promise.resolve(parent.testItem.tests.map(test => this.createTestNode(parent.controller, parent, test)));
        }
        else if (TestControllerNode.is(parent)) {
            return Promise.resolve(parent.controller.tests.map(test => this.createTestNode(parent.controller, parent, test)));
        }
        else if (TestRoot.is(parent)) {
            return Promise.resolve(this.testService.getControllers().map(controller => this.createControllerNode(parent, controller)));
        }
        else {
            return Promise.resolve([]);
        }
    }
    createControllerNode(parent, controller) {
        const node = {
            id: controller.id,
            name: controller.label,
            controller: controller,
            expanded: false,
            children: [],
            parent: parent
        };
        return node;
    }
    processDeltas(controller, parent, deltas) {
        deltas.forEach(delta => this.processDelta(controller, parent, delta));
    }
    processDelta(controller, parent, delta) {
        if (delta.type === tree_delta_1.DeltaKind.ADDED || delta.type === tree_delta_1.DeltaKind.REMOVED) {
            let node;
            if (parent === controller && delta.path.length === 1) {
                node = this.getNode(this.computeId([controller.id]));
            }
            else {
                const item = this.findInParent(parent, delta.path.slice(0, delta.path.length - 1), 0);
                if (item) {
                    node = this.getNode(this.computeId(this.computePath(controller, item)));
                }
            }
            if (node) {
                this.refresh(node); // we only have composite tree nodes in this tree
            }
            else {
                console.warn('delta for unknown test item');
            }
        }
        else {
            const item = this.findInParent(parent, delta.path, 0);
            if (item) {
                if (delta.type === tree_delta_1.DeltaKind.CHANGED) {
                    this.fireChanged();
                }
                if (delta.childDeltas) {
                    this.processDeltas(controller, item, delta.childDeltas);
                }
            }
            else {
                console.warn('delta for unknown test item');
            }
        }
    }
    findInParent(root, path, startIndex) {
        if (startIndex >= path.length) {
            return root;
        }
        const child = root.tests.find(candidate => candidate.id === path[startIndex]);
        if (!child) {
            return undefined;
        }
        return this.findInParent(child, path, startIndex + 1);
    }
    computePath(controller, item) {
        const result = [controller.id];
        let current = item;
        while (current) {
            result.unshift(current.id);
            current = current.parent;
        }
        return result;
    }
    computeId(path) {
        return path.map(id => id.replace('/', '//')).join('/');
    }
    createTestNode(controller, parent, test) {
        const previous = this.getNode(test.id);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = {
            id: this.computeId(this.computePath(controller, test)),
            name: test.label,
            controller: controller,
            testItem: test,
            expanded: tree_1.ExpandableTreeNode.is(previous) ? previous.expanded : undefined,
            selected: false,
            children: [],
            parent: parent
        };
        result.children = test.tests.map(t => this.createTestNode(controller, result, t));
        if (result.children.length === 0 && !test.canResolveChildren) {
            delete result.expanded;
        }
        return result;
    }
};
exports.TestTree = TestTree;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestTree.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestTree.prototype, "init", null);
exports.TestTree = TestTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TestTree);
let TestTreeWidget = TestTreeWidget_1 = class TestTreeWidget extends tree_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this.id = TestTreeWidget_1.ID;
        this.title.label = core_1.nls.localizeByDefault('Test Explorer');
        this.title.caption = core_1.nls.localizeByDefault('Test Explorer');
        this.title.iconClass = (0, browser_1.codicon)('beaker');
        this.title.closable = true;
    }
    init() {
        super.init();
        this.addClass('theia-test-view');
        this.model.root = {
            id: ROOT_ID,
            parent: undefined,
            visible: false,
            children: []
        };
        this.uiModel.onDidChangeActiveTestRun(e => this.update());
        this.uiModel.onDidChangeActiveTestState(() => this.update());
        this.model.onSelectionChanged(() => {
            const that = this;
            const node = this.model.selectedNodes[0];
            if (TestItemNode.is(node)) {
                const run = that.uiModel.getActiveTestRun(node.controller);
                if (run) {
                    const output = run === null || run === void 0 ? void 0 : run.getOutput(node.testItem);
                    if (output) {
                        this.uiModel.selectedOutputSource = {
                            output: output,
                            onDidAddTestOutput: core_1.Event.map(run.onDidChangeTestOutput, evt => evt.filter(item => item[0] === node.testItem).map(item => item[1]))
                        };
                    }
                    this.uiModel.selectedTestState = run.getTestState(node.testItem);
                }
            }
        });
    }
    renderTree(model) {
        if (TestRoot.is(model.root) && model.root.children.length > 0) {
            return super.renderTree(model);
        }
        return React.createElement("div", { className: 'theia-widget-noInfo noMarkers' }, core_1.nls.localizeByDefault('No tests have been found in this workspace yet.'));
    }
    getTestStateClass(state) {
        switch (state) {
            case test_service_1.TestExecutionState.Queued: return `${(0, browser_1.codicon)('history')} queued`;
            case test_service_1.TestExecutionState.Running: return `${(0, browser_1.codicon)('sync')} codicon-modifier-spin running`;
            case test_service_1.TestExecutionState.Skipped: return `${(0, browser_1.codicon)('debug-step-over')} skipped`;
            case test_service_1.TestExecutionState.Failed: return `${(0, browser_1.codicon)('error')} failed`;
            case test_service_1.TestExecutionState.Errored: return `${(0, browser_1.codicon)('issues')} errored`;
            case test_service_1.TestExecutionState.Passed: return `${(0, browser_1.codicon)('pass')} passed`;
            case test_service_1.TestExecutionState.Running: return `${(0, browser_1.codicon)('sync-spin')} running`;
            default: return (0, browser_1.codicon)('circle');
        }
    }
    renderIcon(node, props) {
        var _a;
        if (TestItemNode.is(node)) {
            const currentRun = this.uiModel.getActiveTestRun(node.controller);
            let state;
            if (currentRun) {
                state = (_a = currentRun.getTestState(node.testItem)) === null || _a === void 0 ? void 0 : _a.state;
                if (!state) {
                    state = this.stateManager.getComputedState(currentRun, node.testItem);
                }
            }
            return React.createElement("div", { className: this.getTestStateClass(state) });
        }
        else {
            return super.renderIcon(node, props);
        }
    }
    renderTailDecorations(node, props) {
        if (TestItemNode.is(node)) {
            const testItem = node.testItem;
            return this.contextKeys.with({ view: this.id, controllerId: node.controller.id, testId: testItem.id, testItemHasUri: !!testItem.uri }, () => {
                const menu = this.menus.getMenu(test_view_contribution_1.TEST_VIEW_INLINE_MENU);
                const args = [node.testItem];
                const inlineCommands = menu.children.filter((item) => item instanceof core_1.ActionMenuNode);
                const tailDecorations = super.renderTailDecorations(node, props);
                return React.createElement(React.Fragment, null,
                    inlineCommands.length > 0 && React.createElement("div", { className: tree_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, inlineCommands.map((item, index) => this.renderInlineCommand(item, index, this.focusService.hasFocus(node), args))),
                    tailDecorations !== undefined && React.createElement("div", { className: tree_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, tailDecorations));
            });
        }
        else {
            return super.renderTailDecorations(node, props);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    renderInlineCommand(actionMenuNode, index, tabbable, args) {
        if (!actionMenuNode.icon || !this.commands.isVisible(actionMenuNode.command, ...args) || (actionMenuNode.when && !this.contextKeys.match(actionMenuNode.when))) {
            return false;
        }
        const className = [tree_1.TREE_NODE_SEGMENT_CLASS, tree_1.TREE_NODE_TAIL_CLASS, actionMenuNode.icon, browser_1.ACTION_ITEM, 'theia-test-tree-inline-action'].join(' ');
        const tabIndex = tabbable ? 0 : undefined;
        const titleString = actionMenuNode.label + this.resolveKeybindingForCommand(actionMenuNode.command);
        return React.createElement("div", { key: index, className: className, title: titleString, tabIndex: tabIndex, onClick: e => {
                e.stopPropagation();
                this.commands.executeCommand(actionMenuNode.command, ...args);
            } });
    }
    resolveKeybindingForCommand(command) {
        let result = '';
        if (command) {
            const bindings = this.keybindings.getKeybindingsForCommand(command);
            let found = false;
            if (bindings && bindings.length > 0) {
                bindings.forEach(binding => {
                    if (!found && this.keybindings.isEnabledInScope(binding, this.node)) {
                        found = true;
                        result = ` (${this.keybindings.acceleratorFor(binding, '+')})`;
                    }
                });
            }
        }
        return result;
    }
    toContextMenuArgs(node) {
        if (TestItemNode.is(node)) {
            return [node.testItem];
        }
        return [];
    }
    storeState() {
        return {}; // don't store any state for now
    }
};
exports.TestTreeWidget = TestTreeWidget;
TestTreeWidget.ID = 'test-tree-widget';
TestTreeWidget.TEST_CONTEXT_MENU = ['RESOURCE_CONTEXT_MENU'];
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], TestTreeWidget.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], TestTreeWidget.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_execution_state_manager_1.TestExecutionStateManager),
    tslib_1.__metadata("design:type", test_execution_state_manager_1.TestExecutionStateManager)
], TestTreeWidget.prototype, "stateManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(test_output_ui_model_1.TestOutputUIModel),
    tslib_1.__metadata("design:type", test_output_ui_model_1.TestOutputUIModel)
], TestTreeWidget.prototype, "uiModel", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", core_1.MenuModelRegistry)
], TestTreeWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], TestTreeWidget.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], TestTreeWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TestTreeWidget.prototype, "init", null);
exports.TestTreeWidget = TestTreeWidget = TestTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(tree_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, browser_1.ContextMenuRenderer])
], TestTreeWidget);


/***/ }),

/***/ "../node_modules/@theia/test/lib/browser/view/test-view-contribution.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/test/lib/browser/view/test-view-contribution.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestViewContribution = exports.TEST_VIEW_CONTAINER_TITLE_OPTIONS = exports.TEST_VIEW_CONTAINER_ID = exports.TEST_VIEW_INLINE_MENU = exports.TEST_VIEW_CONTEXT_MENU = exports.TestViewCommands = exports.PLUGIN_TEST_VIEW_TITLE_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const test_service_1 = __webpack_require__(/*! ../test-service */ "../node_modules/@theia/test/lib/browser/test-service.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const test_tree_widget_1 = __webpack_require__(/*! ./test-tree-widget */ "../node_modules/@theia/test/lib/browser/view/test-tree-widget.js");
const navigation_location_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/navigation/navigation-location-service */ "../node_modules/@theia/editor/lib/browser/navigation/navigation-location-service.js");
const navigation_location_1 = __webpack_require__(/*! @theia/editor/lib/browser/navigation/navigation-location */ "../node_modules/@theia/editor/lib/browser/navigation/navigation-location.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const file_navigator_commands_1 = __webpack_require__(/*! @theia/navigator/lib/browser/file-navigator-commands */ "../node_modules/@theia/navigator/lib/browser/file-navigator-commands.js");
exports.PLUGIN_TEST_VIEW_TITLE_MENU = ['plugin_test', 'title'];
var TestViewCommands;
(function (TestViewCommands) {
    /**
     * Command which refreshes all test.
     */
    TestViewCommands.REFRESH = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.refreshTests" /* TestCommandId.RefreshTestsAction */,
        label: 'Refresh Tests',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('refresh')
    });
    /**
     * Command which cancels the refresh
     */
    TestViewCommands.CANCEL_REFRESH = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.cancelTestRefresh" /* TestCommandId.CancelTestRefreshAction */,
        label: 'Cancel Test Refresh',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('stop')
    });
    TestViewCommands.RUN_ALL_TESTS = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.runAll" /* TestCommandId.RunAllAction */,
        label: 'Run All Tests',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('run-all')
    });
    TestViewCommands.DEBUG_ALL_TESTS = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.debugAll" /* TestCommandId.DebugAllAction */,
        label: 'Debug Tests',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('debug-all')
    });
    TestViewCommands.RUN_TEST = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.run" /* TestCommandId.RunAction */,
        label: 'Run Test',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('run')
    });
    TestViewCommands.RUN_TEST_WITH_PROFILE = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.runUsing" /* TestCommandId.RunUsingProfileAction */,
        category: 'Test',
        label: 'Execute using Profile...'
    });
    TestViewCommands.DEBUG_TEST = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.debug" /* TestCommandId.DebugAction */,
        label: 'Debug Test',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('debug-alt')
    });
    TestViewCommands.CANCEL_ALL_RUNS = core_1.Command.toLocalizedCommand({
        id: 'testing.cancelAllRuns',
        label: 'Cancel All Test Runs',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('debug-stop')
    }, 'theia/test/cancelAllTestRuns', core_1.nls.getDefaultKey('Test'));
    TestViewCommands.CANCEL_RUN = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.cancelRun" /* TestCommandId.CancelTestRunAction */,
        label: 'Cancel Test Run',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('debug-stop')
    });
    TestViewCommands.GOTO_TEST = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.editFocusedTest" /* TestCommandId.GoToTest */,
        label: 'Go to Test',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('go-to-file')
    });
    TestViewCommands.CONFIGURE_PROFILES = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.configureProfile" /* TestCommandId.ConfigureTestProfilesAction */,
        label: 'Configure Test Profiles',
        category: 'Test'
    });
    TestViewCommands.SELECT_DEFAULT_PROFILES = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.selectDefaultTestProfiles" /* TestCommandId.SelectDefaultTestProfiles */,
        label: 'Select Default Profile',
        category: 'Test'
    });
    TestViewCommands.CLEAR_ALL_RESULTS = core_1.Command.toDefaultLocalizedCommand({
        id: "testing.clearTestResults" /* TestCommandId.ClearTestResultsAction */,
        label: 'Clear All Results',
        category: 'Test',
        iconClass: (0, browser_1.codicon)('trash')
    });
})(TestViewCommands || (exports.TestViewCommands = TestViewCommands = {}));
exports.TEST_VIEW_CONTEXT_MENU = ['test-view-context-menu'];
exports.TEST_VIEW_INLINE_MENU = [...exports.TEST_VIEW_CONTEXT_MENU, 'inline'];
exports.TEST_VIEW_CONTAINER_ID = 'test-view-container';
exports.TEST_VIEW_CONTAINER_TITLE_OPTIONS = {
    label: core_1.nls.localizeByDefault('Testing'),
    iconClass: (0, browser_1.codicon)('beaker'),
    closeable: true
};
let TestViewContribution = class TestViewContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            viewContainerId: exports.TEST_VIEW_CONTAINER_ID,
            widgetId: test_tree_widget_1.TestTreeWidget.ID,
            widgetName: core_1.nls.localizeByDefault('Test Explorer'),
            defaultWidgetOptions: {
                area: 'left',
                rank: 600,
            }
        });
    }
    async initializeLayout() {
        await this.openView({ activate: false });
    }
    registerCommands(commands) {
        super.registerCommands(commands);
        commands.registerCommand(TestViewCommands.REFRESH, {
            isEnabled: w => this.withWidget(w, () => !this.testService.isRefreshing),
            isVisible: w => this.withWidget(w, () => !this.testService.isRefreshing),
            execute: () => this.testService.refresh()
        });
        commands.registerCommand(TestViewCommands.CANCEL_REFRESH, {
            isEnabled: w => this.withWidget(w, () => this.testService.isRefreshing),
            isVisible: w => this.withWidget(w, () => this.testService.isRefreshing),
            execute: () => this.testService.cancelRefresh()
        });
        commands.registerCommand(TestViewCommands.RUN_ALL_TESTS, {
            isEnabled: w => this.withWidget(w, () => true),
            isVisible: w => this.withWidget(w, () => true),
            execute: () => this.testService.runAllTests(test_service_1.TestRunProfileKind.Run)
        });
        commands.registerCommand(TestViewCommands.DEBUG_ALL_TESTS, {
            isEnabled: w => this.withWidget(w, () => true),
            isVisible: w => this.withWidget(w, () => true),
            execute: () => this.testService.runAllTests(test_service_1.TestRunProfileKind.Debug)
        });
        commands.registerCommand(TestViewCommands.RUN_TEST, {
            isEnabled: t => test_service_1.TestItem.is(t),
            isVisible: t => test_service_1.TestItem.is(t),
            execute: t => {
                this.testService.runTests(test_service_1.TestRunProfileKind.Run, [t]);
            }
        });
        commands.registerCommand(TestViewCommands.SELECT_DEFAULT_PROFILES, {
            isEnabled: t => test_service_1.TestItem.is(t),
            isVisible: t => test_service_1.TestItem.is(t),
            execute: () => {
                this.testService.selectDefaultProfile();
            }
        });
        commands.registerCommand(TestViewCommands.DEBUG_TEST, {
            isEnabled: t => test_service_1.TestItem.is(t),
            isVisible: t => test_service_1.TestItem.is(t),
            execute: t => {
                this.testService.runTests(test_service_1.TestRunProfileKind.Debug, [t]);
            }
        });
        commands.registerCommand(TestViewCommands.RUN_TEST_WITH_PROFILE, {
            isEnabled: t => test_service_1.TestItem.is(t),
            isVisible: t => test_service_1.TestItem.is(t),
            execute: t => {
                this.testService.runTestsWithProfile([t]);
            }
        });
        commands.registerCommand(TestViewCommands.CANCEL_ALL_RUNS, {
            isEnabled: w => this.withWidget(w, () => true),
            isVisible: w => this.withWidget(w, () => true),
            execute: () => this.cancelAllRuns()
        });
        commands.registerCommand(TestViewCommands.GOTO_TEST, {
            isEnabled: t => test_service_1.TestItem.is(t) && !!t.uri,
            isVisible: t => test_service_1.TestItem.is(t) && !!t.uri,
            execute: t => {
                if (test_service_1.TestItem.is(t)) {
                    this.fileSystem.resolve(t.uri).then(stat => {
                        if (stat.isFile) {
                            this.navigationService.reveal(navigation_location_1.NavigationLocation.create(t.uri, t.range ? t.range.start : { line: 0, character: 0 }));
                        }
                        else {
                            commands.executeCommand(file_navigator_commands_1.FileNavigatorCommands.REVEAL_IN_NAVIGATOR.id, t.uri);
                        }
                    });
                }
            }
        });
        commands.registerCommand(TestViewCommands.CONFIGURE_PROFILES, {
            execute: () => {
                this.testService.configureProfile();
            }
        });
    }
    cancelAllRuns() {
        this.testService.getControllers().forEach(controller => controller.testRuns.forEach(run => run.cancel()));
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        menus.registerMenuAction(exports.TEST_VIEW_INLINE_MENU, {
            commandId: TestViewCommands.RUN_TEST.id,
            order: 'a'
        });
        menus.registerMenuAction(exports.TEST_VIEW_INLINE_MENU, {
            commandId: TestViewCommands.DEBUG_TEST.id,
            order: 'aa'
        });
        menus.registerMenuAction(exports.TEST_VIEW_INLINE_MENU, {
            commandId: TestViewCommands.GOTO_TEST.id,
            order: 'aaa'
        });
        menus.registerMenuAction(exports.TEST_VIEW_CONTEXT_MENU, {
            commandId: TestViewCommands.RUN_TEST_WITH_PROFILE.id,
            order: 'aaaa'
        });
        menus.registerMenuAction(exports.TEST_VIEW_CONTEXT_MENU, {
            commandId: TestViewCommands.SELECT_DEFAULT_PROFILES.id,
            order: 'aaaaa'
        });
    }
    registerToolbarItems(toolbar) {
        toolbar.registerItem({
            id: TestViewCommands.REFRESH.id,
            command: TestViewCommands.REFRESH.id,
            priority: 0,
            onDidChange: this.testService.onDidChangeIsRefreshing
        });
        toolbar.registerItem({
            id: TestViewCommands.CANCEL_REFRESH.id,
            command: TestViewCommands.CANCEL_REFRESH.id,
            priority: 0,
            onDidChange: this.testService.onDidChangeIsRefreshing
        });
        toolbar.registerItem({
            id: TestViewCommands.RUN_ALL_TESTS.id,
            command: TestViewCommands.RUN_ALL_TESTS.id,
            menuPath: exports.PLUGIN_TEST_VIEW_TITLE_MENU,
            contextKeyOverlays: {
                'testing.profile.context.group': 'run'
            },
            priority: 1
        });
        toolbar.registerItem({
            id: TestViewCommands.DEBUG_ALL_TESTS.id,
            command: TestViewCommands.DEBUG_ALL_TESTS.id,
            menuPath: exports.PLUGIN_TEST_VIEW_TITLE_MENU,
            contextKeyOverlays: {
                'testing.profile.context.group': 'debug'
            },
            priority: 2
        });
        toolbar.registerItem({
            id: TestViewCommands.CANCEL_ALL_RUNS.id,
            command: TestViewCommands.CANCEL_ALL_RUNS.id,
            priority: 3
        });
    }
    withWidget(widget = this.tryGetWidget(), cb) {
        if (widget instanceof test_tree_widget_1.TestTreeWidget && widget.id === test_tree_widget_1.TestTreeWidget.ID) {
            return cb(widget);
        }
        return false;
    }
};
exports.TestViewContribution = TestViewContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(test_service_1.TestService),
    tslib_1.__metadata("design:type", Object)
], TestViewContribution.prototype, "testService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TestViewContribution.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(navigation_location_service_1.NavigationLocationService),
    tslib_1.__metadata("design:type", navigation_location_service_1.NavigationLocationService)
], TestViewContribution.prototype, "navigationService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], TestViewContribution.prototype, "fileSystem", void 0);
exports.TestViewContribution = TestViewContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TestViewContribution);


/***/ }),

/***/ "../node_modules/@theia/timeline/lib/browser/timeline-context-key-service.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/timeline/lib/browser/timeline-context-key-service.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let TimelineContextKeyService = class TimelineContextKeyService {
    get timelineItem() {
        return this._timelineItem;
    }
    init() {
        this._timelineItem = this.contextKeyService.createKey('timelineItem', undefined);
    }
};
exports.TimelineContextKeyService = TimelineContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TimelineContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TimelineContextKeyService.prototype, "init", null);
exports.TimelineContextKeyService = TimelineContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TimelineContextKeyService);


/***/ }),

/***/ "../node_modules/@theia/timeline/lib/browser/timeline-service.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/timeline/lib/browser/timeline-service.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineAggregate = exports.TimelineService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
let TimelineService = class TimelineService {
    constructor() {
        this.providers = new Map();
        this.onDidChangeProvidersEmitter = new common_1.Emitter();
        this.onDidChangeProviders = this.onDidChangeProvidersEmitter.event;
        this.onDidChangeTimelineEmitter = new common_1.Emitter();
        this.onDidChangeTimeline = this.onDidChangeTimelineEmitter.event;
    }
    registerTimelineProvider(provider) {
        const id = provider.id;
        this.providers.set(id, provider);
        if (provider.onDidChange) {
            provider.onDidChange(e => this.onDidChangeTimelineEmitter.fire(e));
        }
        this.onDidChangeProvidersEmitter.fire({ added: [id] });
        return common_1.Disposable.create(() => this.unregisterTimelineProvider(id));
    }
    unregisterTimelineProvider(id) {
        const provider = this.providers.get(id);
        if (provider) {
            provider.dispose();
            this.providers.delete(id);
            this.onDidChangeProvidersEmitter.fire({ removed: [id] });
        }
    }
    getSources() {
        return [...this.providers.values()].map(p => ({ id: p.id, label: p.label }));
    }
    getSchemas() {
        const result = [];
        Array.from(this.providers.values()).forEach(provider => {
            const scheme = provider.scheme;
            if (typeof scheme === 'string') {
                result.push(scheme);
            }
            else {
                scheme.forEach(s => result.push(s));
            }
        });
        return result;
    }
    getTimeline(id, uri, options, internalOptions) {
        const provider = this.providers.get(id);
        if (!provider) {
            return Promise.resolve(undefined);
        }
        if (typeof provider.scheme === 'string') {
            if (provider.scheme !== '*' && provider.scheme !== uri.scheme) {
                return Promise.resolve(undefined);
            }
        }
        return provider.provideTimeline(uri, options, internalOptions)
            .then(result => {
            if (!result) {
                return undefined;
            }
            result.items = result.items.map(item => ({ ...item, source: provider.id }));
            return result;
        });
    }
};
exports.TimelineService = TimelineService;
exports.TimelineService = TimelineService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TimelineService);
class TimelineAggregate {
    get cursor() {
        return this._cursor;
    }
    set cursor(cursor) {
        this._cursor = cursor;
    }
    constructor(timeline) {
        var _a;
        this.source = timeline.source;
        this.items = timeline.items;
        this._cursor = (_a = timeline.paging) === null || _a === void 0 ? void 0 : _a.cursor;
    }
    add(items) {
        this.items.push(...items);
        this.items.sort((a, b) => b.timestamp - a.timestamp);
    }
}
exports.TimelineAggregate = TimelineAggregate;


/***/ }),

/***/ "../node_modules/@theia/timeline/lib/browser/timeline-tree-model.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/timeline/lib/browser/timeline-tree-model.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineTreeModel = exports.LOAD_MORE_COMMAND = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
exports.LOAD_MORE_COMMAND = {
    id: 'timeline-load-more'
};
let TimelineTreeModel = class TimelineTreeModel extends tree_1.TreeModelImpl {
    updateTree(items, hasMoreItems) {
        const root = {
            id: 'timeline-tree-root',
            parent: undefined,
            visible: false,
            children: []
        };
        const children = items.map(item => ({
            timelineItem: item,
            id: item.id ? item.id : item.timestamp.toString(),
            parent: root,
            detail: item.detail,
            selected: false,
            visible: true
        }));
        let loadMore;
        if (hasMoreItems) {
            const loadMoreNode = { label: 'Load-more', timestamp: 0, handle: '', uri: '', source: '' };
            loadMoreNode.command = exports.LOAD_MORE_COMMAND;
            loadMore = {
                timelineItem: loadMoreNode,
                id: 'load-more',
                parent: root,
                selected: true
            };
            children.push(loadMore);
        }
        root.children = children;
        this.root = root;
        if (loadMore) {
            this.selectionService.addSelection(loadMore);
        }
    }
};
exports.TimelineTreeModel = TimelineTreeModel;
exports.TimelineTreeModel = TimelineTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TimelineTreeModel);


/***/ }),

/***/ "../node_modules/@theia/timeline/lib/browser/timeline-tree-widget.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@theia/timeline/lib/browser/timeline-tree-widget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TimelineTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineItemNode = exports.TimelineTreeWidget = exports.TIMELINE_ITEM_CONTEXT_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const timeline_tree_model_1 = __webpack_require__(/*! ./timeline-tree-model */ "../node_modules/@theia/timeline/lib/browser/timeline-tree-model.js");
const timeline_service_1 = __webpack_require__(/*! ./timeline-service */ "../node_modules/@theia/timeline/lib/browser/timeline-service.js");
const timeline_context_key_service_1 = __webpack_require__(/*! ./timeline-context-key-service */ "../node_modules/@theia/timeline/lib/browser/timeline-context-key-service.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
exports.TIMELINE_ITEM_CONTEXT_MENU = ['timeline-item-context-menu'];
let TimelineTreeWidget = TimelineTreeWidget_1 = class TimelineTreeWidget extends tree_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this.model = model;
        this.id = TimelineTreeWidget_1.ID;
        this.addClass('timeline-outer-container');
    }
    renderNode(node, props) {
        const attributes = this.createNodeAttributes(node, props);
        const content = React.createElement(TimelineItemNode, { timelineItem: node.timelineItem, commandRegistry: this.commandRegistry, contextKeys: this.contextKeys, contextMenuRenderer: this.contextMenuRenderer });
        return React.createElement('div', attributes, content);
    }
    handleEnter(event) {
        var _a;
        const node = this.model.getFocusedNode();
        const command = (_a = node === null || node === void 0 ? void 0 : node.timelineItem) === null || _a === void 0 ? void 0 : _a.command;
        if (command) {
            this.commandRegistry.executeCommand(command.id, ...(command.arguments ? command.arguments : []));
        }
    }
    async handleLeft(event) {
        this.model.selectPrevNode();
    }
};
exports.TimelineTreeWidget = TimelineTreeWidget;
TimelineTreeWidget.ID = 'timeline-tree-widget';
TimelineTreeWidget.PAGE_SIZE = 20;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", common_1.MenuModelRegistry)
], TimelineTreeWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(timeline_context_key_service_1.TimelineContextKeyService),
    tslib_1.__metadata("design:type", timeline_context_key_service_1.TimelineContextKeyService)
], TimelineTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(timeline_service_1.TimelineService),
    tslib_1.__metadata("design:type", timeline_service_1.TimelineService)
], TimelineTreeWidget.prototype, "timelineService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], TimelineTreeWidget.prototype, "commandRegistry", void 0);
exports.TimelineTreeWidget = TimelineTreeWidget = TimelineTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(timeline_tree_model_1.TimelineTreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, timeline_tree_model_1.TimelineTreeModel,
        browser_1.ContextMenuRenderer])
], TimelineTreeWidget);
class TimelineItemNode extends React.Component {
    constructor() {
        super(...arguments);
        this.open = () => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const command = this.props.timelineItem.command;
            if (command) {
                this.props.commandRegistry.executeCommand(command.id, ...command.arguments ? command.arguments : []);
            }
        };
        this.renderContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
            const { timelineItem, contextKeys, contextMenuRenderer } = this.props;
            const currentTimelineItem = contextKeys.timelineItem.get();
            contextKeys.timelineItem.set(timelineItem.contextValue);
            try {
                contextMenuRenderer.render({
                    menuPath: exports.TIMELINE_ITEM_CONTEXT_MENU,
                    anchor: event.nativeEvent,
                    args: [timelineItem],
                    context: event.currentTarget
                });
            }
            finally {
                contextKeys.timelineItem.set(currentTimelineItem);
            }
        };
    }
    render() {
        const { label, description, detail } = this.props.timelineItem;
        return React.createElement("div", { className: 'timeline-item', title: detail, onContextMenu: this.renderContextMenu, onClick: this.open },
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` },
                React.createElement("span", { className: 'name' }, label),
                React.createElement("span", { className: 'label' }, description)));
    }
}
exports.TimelineItemNode = TimelineItemNode;


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-contribution */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-frontend-module */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-frontend-module.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-service */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-container.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-container.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createHierarchyTreeWidget = void 0;
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
const typehierarchy_tree_1 = __webpack_require__(/*! ./typehierarchy-tree */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js");
const typehierarchy_tree_model_1 = __webpack_require__(/*! ./typehierarchy-tree-model */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-model.js");
const typehierarchy_tree_widget_1 = __webpack_require__(/*! ./typehierarchy-tree-widget */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-widget.js");
function createHierarchyTreeContainer(parent) {
    const child = (0, tree_1.createTreeContainer)(parent, {
        tree: typehierarchy_tree_1.TypeHierarchyTree,
        model: typehierarchy_tree_model_1.TypeHierarchyTreeModel,
        widget: typehierarchy_tree_widget_1.TypeHierarchyTreeWidget
    });
    return child;
}
function createHierarchyTreeWidget(parent) {
    return createHierarchyTreeContainer(parent).get(typehierarchy_tree_widget_1.TypeHierarchyTreeWidget);
}
exports.createHierarchyTreeWidget = createHierarchyTreeWidget;


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-model.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-model.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyTreeModel = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const tree_model_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-model */ "../node_modules/@theia/core/lib/browser/tree/tree-model.js");
const typehierarchy_provider_1 = __webpack_require__(/*! ../typehierarchy-provider */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-provider.js");
const typehierarchy_tree_1 = __webpack_require__(/*! ./typehierarchy-tree */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js");
let TypeHierarchyTreeModel = class TypeHierarchyTreeModel extends tree_model_1.TreeModelImpl {
    doOpenNode(node) {
        // do nothing (in particular do not expand the node)
    }
    /**
     * Initializes the tree by calculating and setting a new tree root node.
     */
    async initialize(options) {
        this.tree.root = undefined;
        this.tree.provider = undefined;
        const { location, languageId, direction } = options;
        if (languageId && location) {
            const provider = await this.registry.get(languageId);
            if (provider) {
                const params = {
                    textDocument: {
                        uri: location.uri
                    },
                    position: location.range.start,
                    direction,
                    resolve: 1
                };
                const symbol = await provider.get(params);
                if (symbol) {
                    const root = typehierarchy_tree_1.TypeHierarchyTree.RootNode.create(symbol, direction);
                    root.expanded = true;
                    this.tree.root = root;
                    this.tree.provider = provider;
                }
            }
        }
    }
    /**
     * If the tree root is set, it resets it with the inverse type hierarchy direction.
     */
    async flipDirection() {
        const { root } = this.tree;
        const service = this.tree.provider;
        if (typehierarchy_tree_1.TypeHierarchyTree.RootNode.is(root) && !!service) {
            const { direction, item } = root;
            const { uri, selectionRange } = item;
            const location = {
                uri,
                range: selectionRange
            };
            this.initialize({
                direction: direction === 0 /* TypeHierarchyDirection.Children */ ? 1 /* TypeHierarchyDirection.Parents */ : 0 /* TypeHierarchyDirection.Children */,
                location,
                languageId: service.languageId
            });
        }
    }
};
exports.TypeHierarchyTreeModel = TypeHierarchyTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(typehierarchy_provider_1.TypeHierarchyRegistry),
    tslib_1.__metadata("design:type", typehierarchy_provider_1.TypeHierarchyRegistry)
], TypeHierarchyTreeModel.prototype, "registry", void 0);
exports.TypeHierarchyTreeModel = TypeHierarchyTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TypeHierarchyTreeModel);


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-widget.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-widget.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TypeHierarchyTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyTreeWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const widgets_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/widgets */ "../node_modules/@theia/core/shared/@phosphor/widgets/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const editor_manager_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-manager */ "../node_modules/@theia/editor/lib/browser/editor-manager.js");
const context_menu_renderer_1 = __webpack_require__(/*! @theia/core/lib/browser/context-menu-renderer */ "../node_modules/@theia/core/lib/browser/context-menu-renderer.js");
const tree_widget_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-widget */ "../node_modules/@theia/core/lib/browser/tree/tree-widget.js");
const typehierarchy_tree_model_1 = __webpack_require__(/*! ./typehierarchy-tree-model */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-model.js");
const typehierarchy_tree_1 = __webpack_require__(/*! ./typehierarchy-tree */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../node_modules/@theia/core/lib/browser/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../node_modules/@theia/core/lib/common/nls.js");
let TypeHierarchyTreeWidget = TypeHierarchyTreeWidget_1 = class TypeHierarchyTreeWidget extends tree_widget_1.TreeWidget {
    constructor(props, model, contextMenuRenderer) {
        super(props, model, contextMenuRenderer);
        this.model = model;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.icons = new Map(Array.from(Object.keys(vscode_languageserver_protocol_1.SymbolKind)).map(key => [vscode_languageserver_protocol_1.SymbolKind[key], key.toLocaleLowerCase()]));
        this.id = TypeHierarchyTreeWidget_1.WIDGET_ID;
        this.title.label = TypeHierarchyTreeWidget_1.WIDGET_LABEL;
        this.title.caption = TypeHierarchyTreeWidget_1.WIDGET_LABEL;
        this.addClass(TypeHierarchyTreeWidget_1.Styles.TYPE_HIERARCHY_TREE_CLASS);
        this.title.closable = true;
        this.title.iconClass = (0, browser_1.codicon)('type-hierarchy');
        this.toDispose.push(this.model.onSelectionChanged(selection => {
            const node = selection[0];
            if (node) {
                this.openEditor(node, true);
            }
        }));
        this.toDispose.push(this.model.onOpenNode(node => this.openEditor(node)));
    }
    /**
     * Initializes the widget with the new input.
     */
    async initialize(options) {
        await this.model.initialize(options);
    }
    /**
     * See: `TreeWidget#renderIcon`.
     */
    renderIcon(node) {
        if (typehierarchy_tree_1.TypeHierarchyTree.Node.is(node)) {
            return React.createElement("div", { className: 'symbol-icon-center codicon codicon-symbol-' + this.icons.get(node.item.kind) || 0 });
        }
        return undefined;
    }
    /**
     * Opens up the node in the editor. On demand (`keepFocus`) it reveals the location in the editor.
     */
    async openEditor(node, keepFocus = false) {
        if (typehierarchy_tree_1.TypeHierarchyTree.Node.is(node)) {
            const { selectionRange, uri } = node.item;
            const editorWidget = await this.editorManager.open(new uri_1.default(uri), {
                mode: keepFocus ? 'reveal' : 'activate',
                selection: vscode_languageserver_protocol_1.Range.create(selectionRange.start, selectionRange.end)
            });
            if (editorWidget.parent instanceof widgets_1.DockPanel) {
                editorWidget.parent.selectWidget(editorWidget);
            }
        }
    }
};
exports.TypeHierarchyTreeWidget = TypeHierarchyTreeWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_manager_1.EditorManager),
    tslib_1.__metadata("design:type", editor_manager_1.EditorManager)
], TypeHierarchyTreeWidget.prototype, "editorManager", void 0);
exports.TypeHierarchyTreeWidget = TypeHierarchyTreeWidget = TypeHierarchyTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_widget_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(typehierarchy_tree_model_1.TypeHierarchyTreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(context_menu_renderer_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, typehierarchy_tree_model_1.TypeHierarchyTreeModel,
        context_menu_renderer_1.ContextMenuRenderer])
], TypeHierarchyTreeWidget);
(function (TypeHierarchyTreeWidget) {
    TypeHierarchyTreeWidget.WIDGET_ID = 'theia-typehierarchy';
    TypeHierarchyTreeWidget.WIDGET_LABEL = nls_1.nls.localizeByDefault('Type Hierarchy');
    /**
     * CSS styles for the `Type Hierarchy` widget.
     */
    let Styles;
    (function (Styles) {
        Styles.TYPE_HIERARCHY_TREE_CLASS = 'theia-type-hierarchy-tree';
    })(Styles = TypeHierarchyTreeWidget.Styles || (TypeHierarchyTreeWidget.Styles = {}));
})(TypeHierarchyTreeWidget || (exports.TypeHierarchyTreeWidget = TypeHierarchyTreeWidget = {}));


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var TypeHierarchyTree_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyTree = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../node_modules/@theia/core/lib/common/uuid.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const editor_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor */ "../node_modules/@theia/editor/lib/browser/editor.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "../node_modules/@theia/core/lib/browser/tree/index.js");
let TypeHierarchyTree = TypeHierarchyTree_1 = class TypeHierarchyTree extends tree_1.TreeImpl {
    async resolveChildren(parent) {
        if (TypeHierarchyTree_1.Node.is(parent)) {
            await this.ensureResolved(parent);
            if (parent.children.length === 0) {
                delete parent.children;
                delete parent.expanded;
                return [];
            }
            return parent.children.slice();
        }
        return [];
    }
    /**
     * Returns with the direction of the type hierarchy attached to the root node. `undefined` if the root is not set.
     */
    get direction() {
        if (TypeHierarchyTree_1.RootNode.is(this.root)) {
            return this.root.direction;
        }
        return undefined;
    }
    /**
     * Makes sure, the node and its children are resolved. Resolves it on demand.
     */
    async ensureResolved(node) {
        if (!node.resolved) {
            const { provider, direction } = this;
            if (provider && direction !== undefined) {
                const { item } = node;
                const param = {
                    item,
                    direction,
                    resolve: 1
                };
                const resolvedItem = await provider.resolve(param);
                if (resolvedItem) {
                    node.resolved = true;
                    const items = 0 /* TypeHierarchyDirection.Children */ === direction ? resolvedItem.children : resolvedItem.parents;
                    if (items) {
                        node.children = items.map(child => TypeHierarchyTree_1.Node.create(child, direction, false));
                    }
                    else {
                        node.children = [];
                    }
                }
            }
        }
    }
};
exports.TypeHierarchyTree = TypeHierarchyTree;
exports.TypeHierarchyTree = TypeHierarchyTree = TypeHierarchyTree_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TypeHierarchyTree);
(function (TypeHierarchyTree) {
    let RootNode;
    (function (RootNode) {
        function is(node) {
            if (Node.is(node) && 'direction' in node) {
                const { direction } = node;
                return direction === 0 /* TypeHierarchyDirection.Children */ || direction === 1 /* TypeHierarchyDirection.Parents */;
            }
            return false;
        }
        RootNode.is = is;
        function create(item, direction) {
            return {
                ...Node.create(item, direction, true),
                direction
            };
        }
        RootNode.create = create;
    })(RootNode = TypeHierarchyTree.RootNode || (TypeHierarchyTree.RootNode = {}));
    let Node;
    (function (Node) {
        function is(node) {
            if (!!node && 'resolved' in node && 'item' in node) {
                const { resolved, item } = node;
                return typeof resolved === 'boolean' && !!item;
            }
            return false;
        }
        Node.is = is;
        function create(item, direction, resolved = true) {
            const items = 0 /* TypeHierarchyDirection.Children */ === direction ? item.children : item.parents;
            if (items && items.length > 0) {
                // If the server sent more levels than requested, use them.
                resolved = true;
            }
            const node = {
                id: (0, uuid_1.generateUuid)(),
                name: item.name,
                description: item.detail,
                parent: undefined,
                location: editor_1.Location.create(item.uri, item.selectionRange),
                resolved,
                children: items ? items.map(child => create(child, direction, false)) : [],
                expanded: false,
                visible: true,
                selected: false,
                kind: item.kind,
                decorationData: decorationData(item, direction),
                item
            };
            // Trick: if the node is `resolved` and have zero `children`, make the node non-expandable.
            if (resolved && node.children.length === 0) {
                delete node.expanded;
            }
            return node;
        }
        Node.create = create;
        function decorationData(item, direction) {
            const captionSuffixes = [{
                    data: new uri_1.default(item.uri).displayName,
                    fontData: {
                        color: 'var(--theia-descriptionForeground)',
                    }
                }];
            if (item.detail) {
                captionSuffixes.unshift({
                    data: item.detail,
                    fontData: {
                        color: 'var(--theia-list-highlightForeground)',
                        style: 'italic'
                    }
                });
            }
            const data = `${0 /* TypeHierarchyDirection.Children */ === direction ? '▼' : '▲'}`;
            const color = `var(${0 /* TypeHierarchyDirection.Children */ === direction ? '--theia-errorForeground' : '--theia-successBackground'})`;
            return {
                captionSuffixes,
                captionPrefixes: [{
                        data,
                        fontData: {
                            color,
                            style: 'bold'
                        }
                    }]
            };
        }
    })(Node = TypeHierarchyTree.Node || (TypeHierarchyTree.Node = {}));
})(TypeHierarchyTree || (exports.TypeHierarchyTree = TypeHierarchyTree = {}));


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-contribution.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-contribution.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyCommands = exports.TypeHierarchyContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const shell_1 = __webpack_require__(/*! @theia/core/lib/browser/shell */ "../node_modules/@theia/core/lib/browser/shell/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../node_modules/@theia/core/lib/common/command.js");
const editor_menu_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-menu */ "../node_modules/@theia/editor/lib/browser/editor-menu.js");
const editor_manager_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-manager */ "../node_modules/@theia/editor/lib/browser/editor-manager.js");
const view_contribution_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/view-contribution */ "../node_modules/@theia/core/lib/browser/shell/view-contribution.js");
const typehierarchy_tree_1 = __webpack_require__(/*! ./tree/typehierarchy-tree */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree.js");
const typehierarchy_tree_widget_1 = __webpack_require__(/*! ./tree/typehierarchy-tree-widget */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-widget.js");
const typehierarchy_service_1 = __webpack_require__(/*! ./typehierarchy-service */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
let TypeHierarchyContribution = class TypeHierarchyContribution extends view_contribution_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: typehierarchy_tree_widget_1.TypeHierarchyTreeWidget.WIDGET_ID,
            widgetName: typehierarchy_tree_widget_1.TypeHierarchyTreeWidget.WIDGET_LABEL,
            defaultWidgetOptions: {
                area: 'bottom'
            },
            toggleCommandId: TypeHierarchyCommands.TOGGLE_VIEW.id,
            toggleKeybinding: 'ctrlcmd+shift+h'
        });
    }
    init() {
        this.editorHasTypeHierarchyProvider = this.contextKeyService.createKey('editorHasTypeHierarchyProvider', false);
        this.editorManager.onCurrentEditorChanged(() => this.editorHasTypeHierarchyProvider.set(this.isTypeHierarchyAvailable()));
        this.typeHierarchyServiceProvider.onDidChange(() => this.editorHasTypeHierarchyProvider.set(this.isTypeHierarchyAvailable()));
    }
    isTypeHierarchyAvailable() {
        const { selection, languageId } = this.editorAccess;
        return !!selection && !!languageId && !!this.typeHierarchyServiceProvider.get(languageId, new uri_1.default(selection.uri));
    }
    async openView(args) {
        const widget = await super.openView(args);
        const { selection, languageId } = this.editorAccess;
        const direction = this.getDirection(args);
        await widget.initialize({ location: selection, languageId, direction });
        return widget;
    }
    registerCommands(commands) {
        super.registerCommands(commands);
        commands.registerCommand(TypeHierarchyCommands.OPEN_SUBTYPE, {
            execute: () => this.openViewOrFlipHierarchyDirection(0 /* TypeHierarchyDirection.Children */),
            isEnabled: this.isEnabled.bind(this)
        });
        commands.registerCommand(TypeHierarchyCommands.OPEN_SUPERTYPE, {
            execute: () => this.openViewOrFlipHierarchyDirection(1 /* TypeHierarchyDirection.Parents */),
            isEnabled: this.isEnabled.bind(this)
        });
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        const menuPath = [...editor_menu_1.EDITOR_CONTEXT_MENU, 'type-hierarchy'];
        menus.registerMenuAction(menuPath, {
            commandId: TypeHierarchyCommands.OPEN_SUBTYPE.id
        });
        menus.registerMenuAction(menuPath, {
            commandId: TypeHierarchyCommands.OPEN_SUPERTYPE.id
        });
    }
    registerKeybindings(keybindings) {
        super.registerKeybindings(keybindings);
        keybindings.registerKeybinding({
            command: TypeHierarchyCommands.OPEN_SUBTYPE.id,
            keybinding: 'ctrlcmd+alt+h'
        });
    }
    /**
     * Flips the hierarchy direction in the `Type Hierarchy` view, if it is active and has a valid root.
     * Otherwise, calculates the type hierarchy based on the selection of the current editor.
     */
    async openViewOrFlipHierarchyDirection(direction) {
        if (this.isEnabled()) {
            const { activeWidget } = this.shell;
            if (activeWidget instanceof typehierarchy_tree_widget_1.TypeHierarchyTreeWidget && typehierarchy_tree_1.TypeHierarchyTree.RootNode.is(activeWidget.model.root)) {
                await activeWidget.model.flipDirection();
            }
            else {
                await this.openView({
                    toggle: false,
                    activate: true,
                    direction
                });
            }
        }
    }
    /**
     * Enabled if the `current` editor has the `languageId` or the `Type Hierarchy` widget is the active one.
     */
    isEnabled(languageId = this.editorAccess.languageId) {
        return !!languageId || this.shell.activeWidget instanceof typehierarchy_tree_widget_1.TypeHierarchyTreeWidget;
    }
    /**
     * Extracts the type hierarchy direction from the argument. If the direction cannot be extracted, returns with the `Children` as the default type.
     */
    getDirection(args) {
        return !!args && !!args.direction ? args.direction : 0 /* TypeHierarchyDirection.Children */;
    }
};
exports.TypeHierarchyContribution = TypeHierarchyContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(shell_1.ApplicationShell),
    tslib_1.__metadata("design:type", shell_1.ApplicationShell)
], TypeHierarchyContribution.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_manager_1.EditorAccess),
    (0, inversify_1.named)(editor_manager_1.EditorAccess.CURRENT),
    tslib_1.__metadata("design:type", editor_manager_1.EditorAccess)
], TypeHierarchyContribution.prototype, "editorAccess", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_manager_1.EditorManager),
    tslib_1.__metadata("design:type", editor_manager_1.EditorManager)
], TypeHierarchyContribution.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TypeHierarchyContribution.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(typehierarchy_service_1.TypeHierarchyServiceProvider),
    tslib_1.__metadata("design:type", typehierarchy_service_1.TypeHierarchyServiceProvider)
], TypeHierarchyContribution.prototype, "typeHierarchyServiceProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TypeHierarchyContribution.prototype, "init", null);
exports.TypeHierarchyContribution = TypeHierarchyContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TypeHierarchyContribution);
var TypeHierarchyCommands;
(function (TypeHierarchyCommands) {
    TypeHierarchyCommands.TOGGLE_VIEW = {
        id: 'typehierarchy:toggle'
    };
    TypeHierarchyCommands.OPEN_SUBTYPE = command_1.Command.toLocalizedCommand({
        id: 'typehierarchy:open-subtype',
        label: 'Subtype Hierarchy'
    }, 'theia/typehierarchy/subtypeHierarchy');
    TypeHierarchyCommands.OPEN_SUPERTYPE = command_1.Command.toLocalizedCommand({
        id: 'typehierarchy:open-supertype',
        label: 'Supertype Hierarchy'
    }, 'theia/typehierarchy/supertypeHierarchy');
})(TypeHierarchyCommands || (exports.TypeHierarchyCommands = TypeHierarchyCommands = {}));


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-frontend-module.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-frontend-module.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../node_modules/@theia/core/lib/browser/widget-manager.js");
const view_contribution_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/view-contribution */ "../node_modules/@theia/core/lib/browser/shell/view-contribution.js");
const typehierarchy_provider_1 = __webpack_require__(/*! ./typehierarchy-provider */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-provider.js");
const typehierarchy_contribution_1 = __webpack_require__(/*! ./typehierarchy-contribution */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-contribution.js");
const typehierarchy_tree_widget_1 = __webpack_require__(/*! ./tree/typehierarchy-tree-widget */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-widget.js");
const typehierarchy_service_1 = __webpack_require__(/*! ./typehierarchy-service */ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js");
const typehierarchy_tree_container_1 = __webpack_require__(/*! ./tree/typehierarchy-tree-container */ "../node_modules/@theia/typehierarchy/lib/browser/tree/typehierarchy-tree-container.js");
__webpack_require__(/*! ../../src/browser/style/index.css */ "../node_modules/@theia/typehierarchy/src/browser/style/index.css");
exports["default"] = new inversify_1.ContainerModule(bind => {
    (0, common_1.bindContributionProvider)(bind, typehierarchy_service_1.TypeHierarchyService);
    bind(typehierarchy_service_1.TypeHierarchyServiceProvider).to(typehierarchy_service_1.TypeHierarchyServiceProvider).inSingletonScope();
    bind(typehierarchy_provider_1.TypeHierarchyRegistry).toSelf().inSingletonScope();
    (0, view_contribution_1.bindViewContribution)(bind, typehierarchy_contribution_1.TypeHierarchyContribution);
    bind(widget_manager_1.WidgetFactory).toDynamicValue(context => ({
        id: typehierarchy_tree_widget_1.TypeHierarchyTreeWidget.WIDGET_ID,
        createWidget: () => (0, typehierarchy_tree_container_1.createHierarchyTreeWidget)(context.container)
    }));
});


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-provider.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-provider.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
let TypeHierarchyRegistry = class TypeHierarchyRegistry {
    constructor() {
        this.providers = new Map();
    }
    async get(languageId) {
        return languageId ? this.providers.get(languageId) : undefined;
    }
    register(provider) {
        const { languageId } = provider;
        if (this.providers.has(languageId)) {
            throw new Error(`type hierarchy provider for '${languageId}' language is already registered`);
        }
        this.providers.set(languageId, provider);
        return disposable_1.Disposable.create(() => this.providers.delete(languageId));
    }
};
exports.TypeHierarchyRegistry = TypeHierarchyRegistry;
exports.TypeHierarchyRegistry = TypeHierarchyRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TypeHierarchyRegistry);


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyServiceProvider = exports.TypeHierarchyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const language_selector_1 = __webpack_require__(/*! @theia/editor/lib/common/language-selector */ "../node_modules/@theia/editor/lib/common/language-selector.js");
exports.TypeHierarchyService = Symbol('TypeHierarchyService');
let TypeHierarchyServiceProvider = class TypeHierarchyServiceProvider {
    constructor() {
        this.onDidChangeEmitter = new common_1.Emitter();
        this.services = [];
    }
    get onDidChange() {
        return this.onDidChangeEmitter.event;
    }
    init() {
        this.services = this.services.concat(this.contributions.getContributions());
    }
    get(languageId, uri) {
        return this.services
            .filter(service => this.score(service, languageId, uri) > 0)
            .sort((left, right) => this.score(right, languageId, uri) - this.score(left, languageId, uri))[0];
    }
    score(service, languageId, uri) {
        return (0, language_selector_1.score)(service.selector, uri.scheme, uri.path.toString(), languageId, true);
    }
    add(service) {
        this.services.push(service);
        const that = this;
        this.onDidChangeEmitter.fire();
        return {
            dispose: () => {
                that.remove(service);
            }
        };
    }
    remove(service) {
        const length = this.services.length;
        this.services = this.services.filter(value => value !== service);
        const serviceWasRemoved = length !== this.services.length;
        if (serviceWasRemoved) {
            this.onDidChangeEmitter.fire();
        }
        return serviceWasRemoved;
    }
};
exports.TypeHierarchyServiceProvider = TypeHierarchyServiceProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.ContributionProvider),
    (0, inversify_1.named)(exports.TypeHierarchyService),
    tslib_1.__metadata("design:type", Object)
], TypeHierarchyServiceProvider.prototype, "contributions", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TypeHierarchyServiceProvider.prototype, "init", null);
exports.TypeHierarchyServiceProvider = TypeHierarchyServiceProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TypeHierarchyServiceProvider);


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../node_modules/@theia/typehierarchy/src/browser/style/index.css":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/typehierarchy/src/browser/style/index.css ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./index.css */ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/typehierarchy/src/browser/style/index.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "../node_modules/@theia/userstorage/lib/browser/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/@theia/userstorage/lib/browser/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./user-storage-uri */ "../node_modules/@theia/userstorage/lib/browser/user-storage-uri.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-storage-frontend-module */ "../node_modules/@theia/userstorage/lib/browser/user-storage-frontend-module.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/userstorage/lib/browser/user-storage-contribution.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/userstorage/lib/browser/user-storage-contribution.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserStorageContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../node_modules/@theia/core/lib/common/env-variables/index.js");
const delegating_file_system_provider_1 = __webpack_require__(/*! @theia/filesystem/lib/common/delegating-file-system-provider */ "../node_modules/@theia/filesystem/lib/common/delegating-file-system-provider.js");
const user_storage_uri_1 = __webpack_require__(/*! ./user-storage-uri */ "../node_modules/@theia/userstorage/lib/browser/user-storage-uri.js");
let UserStorageContribution = class UserStorageContribution {
    registerFileSystemProviders(service) {
        service.onWillActivateFileSystemProvider(event => {
            if (event.scheme === user_storage_uri_1.UserStorageUri.scheme) {
                event.waitUntil((async () => {
                    const provider = await this.createProvider(service);
                    service.registerProvider(user_storage_uri_1.UserStorageUri.scheme, provider);
                })());
            }
        });
    }
    getDelegate(service) {
        return service.activateProvider('file');
    }
    async getCongigDirUri() {
        return new uri_1.default(await this.environments.getConfigDirUri());
    }
    async createProvider(service) {
        const delegate = await this.getDelegate(service);
        const configDirUri = await this.getCongigDirUri();
        return new delegating_file_system_provider_1.DelegatingFileSystemProvider(delegate, {
            uriConverter: {
                to: resource => {
                    const relativePath = user_storage_uri_1.UserStorageUri.relative(resource);
                    if (relativePath) {
                        return configDirUri.resolve(relativePath).normalizePath();
                    }
                    return undefined;
                },
                from: resource => {
                    const relativePath = configDirUri.relative(resource);
                    if (relativePath) {
                        return user_storage_uri_1.UserStorageUri.resolve(relativePath);
                    }
                    return undefined;
                }
            }
        }, new disposable_1.DisposableCollection(delegate.watch(configDirUri, { excludes: [], recursive: true })));
    }
};
exports.UserStorageContribution = UserStorageContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    tslib_1.__metadata("design:type", Object)
], UserStorageContribution.prototype, "environments", void 0);
exports.UserStorageContribution = UserStorageContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], UserStorageContribution);


/***/ }),

/***/ "../node_modules/@theia/userstorage/lib/browser/user-storage-frontend-module.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@theia/userstorage/lib/browser/user-storage-frontend-module.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify/index.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
const user_storage_contribution_1 = __webpack_require__(/*! ./user-storage-contribution */ "../node_modules/@theia/userstorage/lib/browser/user-storage-contribution.js");
exports["default"] = new inversify_1.ContainerModule(bind => {
    bind(user_storage_contribution_1.UserStorageContribution).toSelf().inSingletonScope();
    bind(file_service_1.FileServiceContribution).toService(user_storage_contribution_1.UserStorageContribution);
});


/***/ }),

/***/ "../node_modules/@theia/userstorage/lib/browser/user-storage-uri.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/userstorage/lib/browser/user-storage-uri.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserStorageUri = void 0;
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
exports.UserStorageUri = new uri_1.default('user-storage:/user');


/***/ }),

/***/ "../node_modules/@theia/variable-resolver/lib/browser/variable-input-schema.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@theia/variable-resolver/lib/browser/variable-input-schema.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*
 * copied from
 * https://github.com/microsoft/vscode/blob/0a34756cae4fc67739e60c708b04637089f8bb0d/src/vs/workbench/services/configurationResolver/common/configurationResolverSchema.ts#L23
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inputsSchema = void 0;
const idDescription = "The input's id is used to associate an input with a variable of the form ${input:id}.";
const typeDescription = 'The type of user input prompt to use.';
const descriptionDescription = 'The description is shown when the user is prompted for input.';
const defaultDescription = 'The default value for the input.';
exports.inputsSchema = {
    definitions: {
        inputs: {
            type: 'array',
            description: 'User inputs. Used for defining user input prompts, such as free string input or a choice from several options.',
            items: {
                oneOf: [
                    {
                        type: 'object',
                        required: ['id', 'type', 'description'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['promptString'],
                                enumDescriptions: [
                                    "The 'promptString' type opens an input box to ask the user for input."
                                ]
                            },
                            description: {
                                type: 'string',
                                description: descriptionDescription
                            },
                            default: {
                                type: 'string',
                                description: defaultDescription
                            },
                        }
                    },
                    {
                        type: 'object',
                        required: ['id', 'type', 'description', 'options'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['pickString'],
                                enumDescriptions: [
                                    "The 'pickString' type shows a selection list.",
                                ]
                            },
                            description: {
                                type: 'string',
                                description: descriptionDescription
                            },
                            default: {
                                type: 'string',
                                description: defaultDescription
                            },
                            options: {
                                type: 'array',
                                description: 'An array of strings that defines the options for a quick pick.',
                                items: {
                                    type: 'string'
                                }
                            }
                        }
                    },
                    {
                        type: 'object',
                        required: ['id', 'type', 'command'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['command'],
                                enumDescriptions: [
                                    "The 'command' type executes a command.",
                                ]
                            },
                            command: {
                                type: 'string',
                                description: 'The command to execute for this input variable.'
                            },
                            args: {
                                type: 'object',
                                description: 'Optional arguments passed to the command.'
                            }
                        }
                    }
                ]
            }
        }
    }
};


/***/ }),

/***/ "../node_modules/@theia/vsx-registry/lib/common/ovsx-client-provider.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/vsx-registry/lib/common/ovsx-client-provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createOVSXClient = exports.OVSXClientProvider = exports.OVSXUrlResolver = void 0;
const ovsx_client_1 = __webpack_require__(/*! @theia/ovsx-client */ "../node_modules/@theia/ovsx-client/lib/index.js");
exports.OVSXUrlResolver = Symbol('OVSXUrlResolver');
exports.OVSXClientProvider = Symbol('OVSXClientProvider');
/**
 * @deprecated since 1.32.0
 */
async function createOVSXClient(vsxEnvironment, requestService) {
    const apiUrl = await vsxEnvironment.getRegistryApiUri();
    return new ovsx_client_1.OVSXHttpClient(apiUrl, requestService);
}
exports.createOVSXClient = createOVSXClient;


/***/ }),

/***/ "../node_modules/advanced-mark.js/dist/mark.js":
/*!*****************************************************!*\
  !*** ../node_modules/advanced-mark.js/dist/mark.js ***!
  \*****************************************************/
/***/ (function(module) {

/*!***************************************************
* advanced-mark.js v2.6.0
* https://github.com/angezid/advanced-mark.js
* MIT licensed
* Copyright (c) 2022–2024, angezid
* Based on 'mark.js', license https://git.io/vwTVl
*****************************************************/

(function (global, factory) {
   true ? module.exports = factory() :
  0;
})(this, (function () { 'use strict';

  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  var DOMIterator = /*#__PURE__*/function () {
    function DOMIterator(ctx, opt) {
      _classCallCheck(this, DOMIterator);
      this.ctx = ctx;
      this.opt = opt;
      this.map = [];
    }
    _createClass(DOMIterator, [{
      key: "getContexts",
      value: function getContexts() {
        var ctx = this.ctx,
          win = this.opt.window,
          sort = false;
        if (!ctx) return [];
        if (Array.isArray(ctx)) {
          sort = true;
        } else if (typeof ctx === 'string') {
          ctx = this.toArray(win.document.querySelectorAll(ctx));
        } else if (ctx.length >= 0) {
          ctx = this.toArray(ctx);
        } else {
          ctx = [ctx];
        }
        var array = [];
        ctx.forEach(function (elem) {
          if (array.indexOf(elem) === -1 && !array.some(function (node) {
            return node.contains(elem);
          })) {
            array.push(elem);
          }
        });
        if (sort) {
          array.sort(function (a, b) {
            return (a.compareDocumentPosition(b) & win.Node.DOCUMENT_POSITION_FOLLOWING) > 0 ? -1 : 1;
          });
        }
        return array;
      }
    }, {
      key: "toArray",
      value: function toArray(collection) {
        var array = [];
        for (var i = 0; i < collection.length; i++) {
          array.push(collection[i]);
        }
        return array;
      }
    }, {
      key: "getIframeContents",
      value: function getIframeContents(iframe, successFn, errorFn) {
        try {
          var doc = iframe.contentWindow.document;
          if (doc) {
            this.map.push([iframe, 'ready']);
            successFn({
              iframe: iframe,
              context: doc
            });
          }
        } catch (e) {
          errorFn({
            iframe: iframe,
            error: e
          });
        }
      }
    }, {
      key: "observeIframeLoad",
      value: function observeIframeLoad(ifr, successFn, errorFn) {
        var _this = this;
        if (this.map.some(function (arr) {
          return arr[0] === ifr;
        })) {
          return;
        }
        var id = null;
        var listener = function listener() {
          clearTimeout(id);
          ifr.removeEventListener('load', listener);
          _this.getIframeContents(ifr, successFn, errorFn);
        };
        ifr.addEventListener('load', listener);
        this.map.push([ifr, true]);
        id = setTimeout(listener, this.opt.iframesTimeout);
      }
    }, {
      key: "onIframeReady",
      value: function onIframeReady(ifr, successFn, errorFn) {
        try {
          var bl = 'about:blank',
            src = ifr.getAttribute('src'),
            win = ifr.contentWindow;
          if (win.document.readyState === 'complete') {
            if (src && src.trim() !== bl && win.location.href === bl) {
              this.observeIframeLoad(ifr, successFn, errorFn);
            } else {
              this.getIframeContents(ifr, successFn, errorFn);
            }
          } else {
            this.observeIframeLoad(ifr, successFn, errorFn);
          }
        } catch (e) {
          errorFn(e);
        }
      }
    }, {
      key: "waitForIframes",
      value: function waitForIframes(ctx, doneCb) {
        var _this2 = this;
        var shadow = this.opt.shadowDOM;
        var count = 0,
          iframes = 0,
          array,
          node;
        var collect = function collect(context) {
          var iterator = _this2.createIterator(context, _this2.opt.window.NodeFilter.SHOW_ELEMENT);
          while (node = iterator.nextNode()) {
            if (_this2.isIframe(node) && !_this2.map.some(function (arr) {
              return arr[0] === node;
            })) {
              array.push(node);
              iframes++;
            }
            if (shadow && node.shadowRoot && node.shadowRoot.mode === 'open') {
              collect(node.shadowRoot);
            }
          }
        };
        var loop = function loop(obj) {
          array = [];
          if (!obj.iframe || obj.context.location.href !== 'about:blank') {
            collect(obj.context);
            if (!obj.iframe && !array.length) {
              doneCb();
              return;
            }
          }
          if (array.length) {
            array.forEach(function (iframe) {
              _this2.onIframeReady(iframe, function (obj) {
                count++;
                loop(obj);
              }, function (obj) {
                if (_this2.opt.debug) {
                  console.log(obj.error || obj);
                }
                if (++count === iframes) doneCb();
              });
            });
          } else if (count === iframes) {
            doneCb();
          }
        };
        loop({
          context: ctx
        });
      }
    }, {
      key: "createIterator",
      value: function createIterator(ctx, whatToShow) {
        var win = this.opt.window;
        return win.document.createNodeIterator(ctx, whatToShow, function () {
          return win.NodeFilter.FILTER_ACCEPT;
        }, false);
      }
    }, {
      key: "addRemoveStyle",
      value: function addRemoveStyle(root, style, add) {
        if (add && !style) return;
        var elem = root.querySelector('style[data-markjs]');
        if (add) {
          if (!elem) {
            elem = this.opt.window.document.createElement('style');
            elem.setAttribute('data-markjs', 'true');
            root.appendChild(elem);
          }
          elem.textContent = style;
        } else if (elem) {
          root.removeChild(elem);
        }
      }
    }, {
      key: "isIframe",
      value: function isIframe(node) {
        return node.tagName === 'IFRAME' && !DOMIterator.matches(node, this.opt.exclude);
      }
    }, {
      key: "iterateThroughNodes",
      value: function iterateThroughNodes(ctx, whatToShow, filterCb, eachCb, doneCb) {
        var _this3 = this;
        var filter = this.opt.window.NodeFilter,
          shadow = this.opt.shadowDOM,
          iframe = this.opt.iframes;
        if (iframe || shadow) {
          var showElement = (whatToShow & filter.SHOW_ELEMENT) > 0,
            showText = (whatToShow & filter.SHOW_TEXT) > 0;
          var traverse = function traverse(node) {
            var iterator = _this3.createIterator(node, whatToShow | filter.SHOW_ELEMENT),
              root;
            while (node = iterator.nextNode()) {
              if (node.nodeType === 1) {
                if (showElement && filterCb(node)) {
                  eachCb(node);
                }
                if (iframe && _this3.isIframe(node) && _this3.map.some(function (arr) {
                  return arr[0] === node && arr[1] === 'ready';
                })) {
                  var doc = node.contentWindow.document;
                  if (doc) traverse(doc);
                }
                if (shadow && (root = node.shadowRoot) && root.mode === 'open') {
                  _this3.addRemoveStyle(root, shadow.style, showText);
                  traverse(root);
                }
              } else if (showText && node.nodeType === 3 && filterCb(node)) {
                eachCb(node);
              }
            }
          };
          traverse(ctx);
        } else {
          var iterator = this.createIterator(ctx, whatToShow);
          var node;
          while (node = iterator.nextNode()) {
            if (filterCb(node)) {
              eachCb(node);
            }
          }
        }
        doneCb();
      }
    }, {
      key: "forEachNode",
      value: function forEachNode(whatToShow, each, filter) {
        var _this4 = this;
        var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
        var contexts = this.getContexts();
        var open = contexts.length;
        if (!open) done();
        var ready = function ready() {
          contexts.forEach(function (ctx) {
            _this4.iterateThroughNodes(ctx, whatToShow, filter, each, function () {
              if (--open <= 0) done();
            });
          });
        };
        if (this.opt.iframes) {
          var count = open,
            fired = false;
          var id = setTimeout(function () {
            fired = true;
            ready();
          }, this.opt.iframesTimeout);
          var finish = function finish() {
            clearTimeout(id);
            if (!fired) ready();
          };
          contexts.forEach(function (ctx) {
            _this4.waitForIframes(ctx, function () {
              if (--count <= 0) finish();
            });
          });
        } else {
          ready();
        }
      }
    }], [{
      key: "matches",
      value: function matches(element, selector) {
        if (!selector || !selector.length) {
          return false;
        }
        var selectors = typeof selector === 'string' ? [selector] : selector;
        var fn = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;
        return fn && selectors.some(function (sel) {
          return fn.call(element, sel);
        });
      }
    }]);
    return DOMIterator;
  }();

  var RegExpCreator = /*#__PURE__*/function () {
    function RegExpCreator(options) {
      _classCallCheck(this, RegExpCreator);
      this.opt = _extends({}, {
        'diacritics': true,
        'synonyms': {},
        'accuracy': 'partially',
        'caseSensitive': false,
        'ignoreJoiners': false,
        'ignorePunctuation': [],
        'wildcards': 'disabled'
      }, options);
    }
    _createClass(RegExpCreator, [{
      key: "chars",
      get: function get() {
        var _this = this;
        if (!this._chars) {
          this._chars = [];
          ['aàáảãạăằắẳẵặâầấẩẫậäåāą', 'cçćč', 'dđď', 'eèéẻẽẹêềếểễệëěēę', 'iìíỉĩịîïī', 'lł', 'nñňń', 'oòóỏõọôồốổỗộơởỡớờợöøōő', 'rř', 'sšśșş', 'tťțţ', 'uùúủũụưừứửữựûüůūű', 'yýỳỷỹỵÿ', 'zžżź'].forEach(function (str) {
            _this._chars.push(str, str.toUpperCase());
          });
        }
        return this._chars;
      }
    }, {
      key: "create",
      value: function create(str, patterns) {
        var flags = 'g' + (this.opt.caseSensitive ? '' : 'i');
        str = this.checkWildcardsEscape(str);
        str = this.createSynonyms(str, flags);
        var joiners = this.getJoinersPunctuation();
        if (joiners) {
          str = this.setupIgnoreJoiners(str);
        }
        if (this.opt.diacritics) {
          str = this.createDiacritics(str);
        }
        str = str.replace(/\s+/g, '[\\s]+');
        if (joiners) {
          str = this.createJoiners(str, joiners);
        }
        if (this.opt.wildcards !== 'disabled') {
          str = this.createWildcards(str);
        }
        var obj = this.createAccuracy(str);
        return patterns ? obj : new RegExp("".concat(obj.lookbehind, "(").concat(obj.pattern, ")").concat(obj.lookahead), flags);
      }
    }, {
      key: "createCombinePattern",
      value: function createCombinePattern(array, capture) {
        var _this2 = this;
        if (!Array.isArray(array) || !array.length) {
          return null;
        }
        var group = capture ? '(' : '(?:',
          obj = this.create(array[0], true);
        obj.pattern = this.distinct(array.map(function (str) {
          return "".concat(group).concat(_this2.create(str, true).pattern, ")");
        })).join('|');
        return obj;
      }
    }, {
      key: "sortByLength",
      value: function sortByLength(arry) {
        return arry.sort(function (a, b) {
          return a.length === b.length ? a > b ? 1 : -1 : b.length - a.length;
        });
      }
    }, {
      key: "escape",
      value: function escape(str) {
        return str.replace(/[[\]/{}()*+?.\\^$|]/g, '\\$&');
      }
    }, {
      key: "preprocess",
      value: function preprocess(val) {
        if (val && val.length) {
          return this.distinct(typeof val === 'string' ? val.split('') : val).join('').replace(/[-^\]\\]/g, '\\$&');
        }
        return '';
      }
    }, {
      key: "distinct",
      value: function distinct(array) {
        var result = [];
        array.forEach(function (item) {
          if (item.trim() && result.indexOf(item) === -1) {
            result.push(item);
          }
        });
        return result;
      }
    }, {
      key: "createSynonyms",
      value: function createSynonyms(str, flags) {
        var _this3 = this;
        var syn = this.opt.synonyms;
        if (!Object.keys(syn).length) {
          return str;
        }
        for (var key in syn) {
          if (syn.hasOwnProperty(key)) {
            var array = Array.isArray(syn[key]) ? syn[key] : [syn[key]];
            array.unshift(key);
            array = this.sortByLength(this.distinct(array)).map(function (term) {
              return _this3.checkWildcardsEscape(term);
            });
            if (array.length > 1) {
              var pattern = array.map(function (k) {
                return _this3.escape(k);
              }).join('|');
              str = str.replace(new RegExp(pattern, flags), "(?:".concat(array.join('|'), ")"));
            }
          }
        }
        return str;
      }
    }, {
      key: "checkWildcardsEscape",
      value: function checkWildcardsEscape(str) {
        if (this.opt.wildcards !== 'disabled') {
          str = str.replace(/(\\.)+|[?*]/g, function (m, gr) {
            return gr ? m : m === '?' ? '\x01' : '\x02';
          }).replace(/\\+(?=[?*\x01\x02])/g, function (m) {
            return m.slice(1);
          });
        }
        return this.escape(str);
      }
    }, {
      key: "createWildcards",
      value: function createWildcards(str) {
        var spaces = this.opt.wildcards === 'withSpaces',
          boundary = this.opt.blockElementsBoundary,
          anyChar = "[^".concat(spaces && boundary ? '\x01' : '', "]*?");
        return str.replace(/\x01/g, spaces ? '[^]?' : '\\S?').replace(/\x02/g, spaces ? anyChar : '\\S*');
      }
    }, {
      key: "setupIgnoreJoiners",
      value: function setupIgnoreJoiners(str) {
        var reg = /((?:\\\\)+|\x02|\(\?:|\|)|\\?(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|.)(?=([|)\x02]|$)|.)/g;
        return str.replace(reg, function (m, gr1, gr2) {
          return gr1 || typeof gr2 !== 'undefined' ? m : m + '\x00';
        });
      }
    }, {
      key: "createJoiners",
      value: function createJoiners(str, joiners) {
        return str.split(/\x00+/).join("[".concat(joiners, "]*"));
      }
    }, {
      key: "getJoinersPunctuation",
      value: function getJoinersPunctuation() {
        var punct = this.preprocess(this.opt.ignorePunctuation),
          str = punct ? punct : '';
        if (this.opt.ignoreJoiners) {
          str += "\\u00ad\\u200b\\u200c\\u200d";
        }
        return str;
      }
    }, {
      key: "createDiacritics",
      value: function createDiacritics(str) {
        var _this4 = this;
        var array = this.chars;
        return str.split('').map(function (ch) {
          for (var i = 0; i < array.length; i += 2) {
            var lowerCase = array[i].indexOf(ch) !== -1;
            if (_this4.opt.caseSensitive) {
              if (lowerCase) {
                return '[' + array[i] + ']';
              } else if (array[i + 1].indexOf(ch) !== -1) {
                return '[' + array[i + 1] + ']';
              }
            } else if (lowerCase || array[i + 1].indexOf(ch) !== -1) {
              return '[' + array[i] + array[i + 1] + ']';
            }
          }
          return ch;
        }).join('');
      }
    }, {
      key: "createAccuracy",
      value: function createAccuracy(str) {
        var chars = '!-/:-@[-`{-~¡¿';
        var accuracy = this.opt.accuracy,
          lookbehind = '()',
          pattern = str,
          lookahead = '',
          limiters;
        if (typeof accuracy !== 'string') {
          limiters = this.preprocess(accuracy.limiters);
          accuracy = accuracy.value;
        }
        if (accuracy === 'exactly') {
          var charSet = limiters ? '[\\s' + limiters + ']' : '\\s';
          lookbehind = "(^|".concat(charSet, ")");
          lookahead = "(?=$|".concat(charSet, ")");
        } else {
          var chs = limiters || chars,
            _charSet = "[^\\s".concat(chs, "]*");
          if (accuracy === 'complementary') {
            pattern = _charSet + str + _charSet;
          } else if (accuracy === 'startsWith') {
            lookbehind = "(^|[\\s".concat(chs, "])");
            pattern = str.split(/\[\\s\]\+/).join(_charSet + '[\\s]+') + _charSet;
          }
        }
        return {
          lookbehind: lookbehind,
          pattern: pattern,
          lookahead: lookahead
        };
      }
    }]);
    return RegExpCreator;
  }();

  var Mark$1 = /*#__PURE__*/function () {
    function Mark(ctx) {
      _classCallCheck(this, Mark);
      this.ctx = ctx;
      this.nodeNames = ['script', 'style', 'title', 'head', 'html'];
    }
    _createClass(Mark, [{
      key: "opt",
      get: function get() {
        return this._opt;
      },
      set: function set(val) {
        if (!(val && val.window && val.window.document) && typeof window === 'undefined') {
          throw new Error('Mark.js: please provide a window object as an option.');
        }
        var win = val && val.window || window;
        this._opt = _extends({}, {
          'window': win,
          'element': '',
          'className': '',
          'exclude': [],
          'iframes': false,
          'iframesTimeout': 5000,
          'separateWordSearch': true,
          'acrossElements': false,
          'ignoreGroups': 0,
          'each': function each() {},
          'noMatch': function noMatch() {},
          'filter': function filter() {
            return true;
          },
          'done': function done() {},
          'debug': false,
          'log': win.console
        }, val);
        if (!this._opt.element) {
          this._opt.element = 'mark';
        }
        this.filter = win.NodeFilter;
        this.empty = win.document.createTextNode('');
      }
    }, {
      key: "iterator",
      get: function get() {
        return new DOMIterator(this.ctx, this.opt);
      }
    }, {
      key: "log",
      value: function log(msg) {
        var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'debug';
        if (this.opt.debug) {
          var log = this.opt.log;
          if (_typeof(log) === 'object' && typeof log[level] === 'function') {
            log[level]("mark.js: ".concat(msg));
          }
        }
      }
    }, {
      key: "report",
      value: function report(array) {
        var _this = this;
        array.forEach(function (item) {
          _this.log("".concat(item.text, " ").concat(JSON.stringify(item.obj)), item.level || 'debug');
          if (!item.skip) {
            _this.opt.noMatch(item.obj);
          }
        });
      }
    }, {
      key: "checkOption",
      value: function checkOption(opt, del) {
        this.opt = opt;
        var dict = this.cacheDict,
          clear = true;
        if (dict) {
          if (!del && this.opt.cacheTextNodes) {
            if (this.opt.acrossElements) {
              if (dict.across) {
                clear = false;
              }
            } else if (!dict.across) {
              clear = false;
            }
          }
          if (clear) {
            this.cacheDict = null;
          }
        }
      }
    }, {
      key: "getSeachTerms",
      value: function getSeachTerms(sv) {
        var search = typeof sv === 'string' ? [sv] : sv,
          separate = this.opt.separateWordSearch,
          array = [],
          termStats = {},
          split = function split(str) {
            str.split(/ +/).forEach(function (word) {
              return add(word);
            });
          },
          add = function add(str) {
            if (str.trim() && array.indexOf(str) === -1) {
              array.push(str);
              termStats[str] = 0;
            }
          };
        search.forEach(function (str) {
          if (separate) {
            if (separate === 'preserveTerms') {
              str.split(/"("*[^"]+"*)"/).forEach(function (term, i) {
                if (i % 2 > 0) add(term);else split(term);
              });
            } else {
              split(str);
            }
          } else {
            add(str);
          }
        });
        array.sort(function (a, b) {
          return b.length - a.length;
        });
        return {
          terms: array,
          termStats: termStats
        };
      }
    }, {
      key: "isNumeric",
      value: function isNumeric(value) {
        return Number(parseFloat(value)) == value;
      }
    }, {
      key: "checkRanges",
      value: function checkRanges(array, logs, min, max) {
        var _this2 = this;
        var level = 'error';
        var ranges = array.filter(function (range) {
          if (_this2.isNumeric(range.start) && _this2.isNumeric(range.length)) {
            range.start = parseInt(range.start);
            range.length = parseInt(range.length);
            if (range.start >= min && range.start < max && range.length > 0) {
              return true;
            }
          }
          logs.push({
            text: 'Invalid range: ',
            obj: range,
            level: level
          });
          return false;
        }).sort(function (a, b) {
          return a.start - b.start;
        });
        if (this.opt.wrapAllRanges) {
          return ranges;
        }
        var lastIndex = 0,
          index;
        return ranges.filter(function (range) {
          index = range.start + range.length;
          if (range.start >= lastIndex) {
            lastIndex = index;
            return true;
          }
          logs.push({
            text: (index < lastIndex ? 'Nest' : 'Overlapp') + 'ing range: ',
            obj: range,
            level: level
          });
          return false;
        });
      }
    }, {
      key: "setType",
      value: function setType(tags, boundary) {
        var custom = Array.isArray(boundary.tagNames) && boundary.tagNames.length;
        if (custom) {
          boundary.tagNames.forEach(function (name) {
            return tags[name.toLowerCase()] = 2;
          });
        }
        if (!custom || boundary.extend) {
          for (var key in tags) {
            tags[key] = 2;
          }
        }
        tags['br'] = 3;
      }
    }, {
      key: "getTextNodesAcross",
      value: function getTextNodesAcross(cb) {
        var _this3 = this;
        if (this.opt.cacheTextNodes && this.cacheDict) {
          this.cacheDict.lastIndex = 0;
          this.cacheDict.lastTextIndex = 0;
          cb(this.cacheDict);
          return;
        }
        var tags = {
          div: 1,
          p: 1,
          li: 1,
          td: 1,
          tr: 1,
          th: 1,
          ul: 1,
          ol: 1,
          dd: 1,
          dl: 1,
          dt: 1,
          h1: 1,
          h2: 1,
          h3: 1,
          h4: 1,
          h5: 1,
          h6: 1,
          hr: 1,
          blockquote: 1,
          figcaption: 1,
          figure: 1,
          pre: 1,
          table: 1,
          thead: 1,
          tbody: 1,
          tfoot: 1,
          input: 1,
          img: 1,
          nav: 1,
          details: 1,
          label: 1,
          form: 1,
          select: 1,
          menu: 1,
          br: 3,
          menuitem: 1,
          main: 1,
          section: 1,
          article: 1,
          aside: 1,
          picture: 1,
          output: 1,
          button: 1,
          header: 1,
          footer: 1,
          address: 1,
          area: 1,
          canvas: 1,
          map: 1,
          fieldset: 1,
          textarea: 1,
          track: 1,
          video: 1,
          audio: 1,
          body: 1,
          iframe: 1,
          meter: 1,
          object: 1,
          svg: 1
        };
        var nodes = [],
          boundary = this.opt.blockElementsBoundary,
          priorityType = boundary ? 2 : 1;
        var ch = '\x01',
          tempType,
          type,
          prevNode;
        if (boundary) {
          this.setType(tags, boundary);
          if (boundary["char"]) {
            ch = boundary["char"].charAt(0);
          }
        }
        var obj = {
          text: '',
          regex: /\s/,
          tags: tags,
          boundary: boundary,
          startOffset: 0,
          str: '',
          ch: ch
        };
        this.iterator.forEachNode(this.filter.SHOW_ELEMENT | this.filter.SHOW_TEXT, function (node) {
          if (prevNode) {
            nodes.push(_this3.getNodeInfo(prevNode, node, type, obj));
          }
          type = null;
          prevNode = node;
        }, function (node) {
          if (node.nodeType === 1) {
            tempType = tags[node.nodeName.toLowerCase()];
            if (tempType === 3) {
              obj.str += '\n';
            }
            if (!type || tempType === priorityType) {
              type = tempType;
            }
            return false;
          }
          return !_this3.excluded(node.parentNode);
        }, function () {
          if (prevNode) {
            nodes.push(_this3.getNodeInfo(prevNode, null, type, obj));
          }
          cb(_this3.createDict(obj.text, nodes, true));
        });
      }
    }, {
      key: "getNodeInfo",
      value: function getNodeInfo(prevNode, node, type, obj) {
        var start = obj.text.length,
          startOffset = obj.startOffset,
          ch = obj.ch;
        var offset = 0,
          str = obj.str,
          text = prevNode.textContent;
        if (node) {
          var startBySpace = obj.regex.test(node.textContent[0]),
            both = startBySpace && obj.regex.test(text[text.length - 1]);
          if (obj.boundary || !both) {
            var separate = type;
            if (!type) {
              var parent = prevNode.parentNode;
              while (parent) {
                type = obj.tags[parent.nodeName.toLowerCase()];
                if (type) {
                  separate = !(parent === node.parentNode || parent.contains(node));
                  break;
                }
                parent = parent.parentNode;
              }
            }
            if (separate) {
              if (!both) {
                str += type === 1 ? ' ' : type === 2 ? ' ' + ch + ' ' : '';
              } else if (type === 2) {
                str += both ? ch : startBySpace ? ' ' + ch : ch + ' ';
              }
            }
          }
        }
        if (str) {
          text += str;
          offset = str.length;
          obj.startOffset -= offset;
          obj.str = '';
        }
        obj.text += text;
        return this.createInfo(prevNode, start, obj.text.length - offset, offset, startOffset);
      }
    }, {
      key: "getTextNodes",
      value: function getTextNodes(cb) {
        var _this4 = this;
        if (this.opt.cacheTextNodes && this.cacheDict) {
          cb(this.cacheDict);
          return;
        }
        var nodes = [],
          regex = /\n/g,
          newLines = [0],
          lines = this.opt.markLines,
          show = this.filter.SHOW_TEXT | (lines ? this.filter.SHOW_ELEMENT : 0);
        var text = '',
          len = 0,
          rm;
        this.iterator.forEachNode(show, function (node) {
          if (lines) {
            while ((rm = regex.exec(node.textContent)) !== null) {
              newLines.push(len + rm.index);
            }
          }
          text += node.textContent;
          nodes.push({
            start: len,
            end: len = text.length,
            offset: 0,
            node: node
          });
        }, function (node) {
          if (lines && node.nodeType === 1) {
            if (node.tagName === 'BR') {
              newLines.push(len);
            }
            return false;
          }
          return !_this4.excluded(node.parentNode);
        }, function () {
          var dict = _this4.createDict(text, nodes, false);
          if (lines) {
            newLines.push(len);
            dict.newLines = newLines;
          }
          cb(dict);
        });
      }
    }, {
      key: "createDict",
      value: function createDict(text, nodes, across) {
        var dict = {
          text: text,
          nodes: nodes,
          lastIndex: 0,
          lastTextIndex: 0
        };
        if (this.opt.cacheTextNodes) {
          this.cacheDict = dict;
          this.cacheDict.across = across;
        }
        return dict;
      }
    }, {
      key: "excluded",
      value: function excluded(elem) {
        return this.nodeNames.indexOf(elem.nodeName.toLowerCase()) !== -1 || DOMIterator.matches(elem, this.opt.exclude);
      }
    }, {
      key: "wrapRangeInsert",
      value: function wrapRangeInsert(dict, n, s, e, start, index) {
        var ended = e === n.node.textContent.length,
          end = n.end;
        var type = 1,
          splitIndex = e,
          node = n.node;
        if (s !== 0) {
          node = node.splitText(s);
          splitIndex = e - s;
          type = ended ? 2 : 3;
        } else if (ended) {
          type = 0;
        }
        var retNode = ended ? this.empty : node.splitText(splitIndex),
          mark = this.wrapTextNode(node),
          markChild = mark.childNodes[0],
          nodeInfo = this.createInfo(retNode, type === 0 || type === 2 ? end : n.start + e, end, n.offset, n.startOffset);
        if (type === 0) {
          n.node = markChild;
          return {
            mark: mark,
            nodeInfo: nodeInfo,
            increment: 0
          };
        }
        var info = this.createInfo(markChild, type === 1 ? n.start : start, n.start + e, 0, n.startOffset);
        if (type === 1) {
          dict.nodes.splice(index, 1, info, nodeInfo);
        } else {
          if (type === 2) {
            dict.nodes.splice(index + 1, 0, info);
          } else {
            dict.nodes.splice(index + 1, 0, info, nodeInfo);
          }
          n.end = start;
          n.offset = 0;
        }
        return {
          mark: mark,
          nodeInfo: nodeInfo,
          increment: type < 3 ? 1 : 2
        };
      }
    }, {
      key: "createInfo",
      value: function createInfo(node, start, end, offset, startOffset) {
        return {
          node: node,
          start: start,
          end: end,
          offset: offset,
          startOffset: startOffset
        };
      }
    }, {
      key: "wrapRange",
      value: function wrapRange(node, start, end, eachCb) {
        var ended = end === node.textContent.length,
          index = end,
          retNode;
        if (start !== 0) {
          node = node.splitText(start);
          index = end - start;
        }
        retNode = ended ? this.empty : node.splitText(index);
        eachCb(this.wrapTextNode(node));
        return retNode;
      }
    }, {
      key: "wrapTextNode",
      value: function wrapTextNode(node) {
        var markNode = this.opt.window.document.createElement(this.opt.element);
        markNode.setAttribute('data-markjs', 'true');
        if (this.opt.className) {
          markNode.setAttribute('class', this.opt.className);
        }
        markNode.textContent = node.textContent;
        node.parentNode.replaceChild(markNode, node);
        return markNode;
      }
    }, {
      key: "wrapRangeAcross",
      value: function wrapRangeAcross(dict, start, end, filterCb, eachCb) {
        var i = dict.lastIndex,
          rangeStart = true;
        var wrapAllRanges = this.opt.wrapAllRanges || this.opt.cacheTextNodes;
        if (wrapAllRanges) {
          while (i > 0 && dict.nodes[i].start > start) {
            i--;
          }
        } else if (start < dict.lastTextIndex) {
          return;
        }
        for (i; i < dict.nodes.length; i++) {
          if (i + 1 === dict.nodes.length || dict.nodes[i + 1].start > start) {
            var n = dict.nodes[i];
            if (!filterCb(n)) break;
            var s = start - n.start,
              e = (end > n.end ? n.end : end) - n.start;
            if (s >= 0 && e > s) {
              if (wrapAllRanges) {
                var obj = this.wrapRangeInsert(dict, n, s, e, start, i);
                n = obj.nodeInfo;
                eachCb(obj.mark, rangeStart);
              } else {
                n.node = this.wrapRange(n.node, s, e, function (node) {
                  eachCb(node, rangeStart);
                });
                n.start += e;
                dict.lastTextIndex = n.start;
              }
              rangeStart = false;
            }
            if (end > n.end) {
              start = n.end + n.offset;
            } else {
              break;
            }
          }
        }
        dict.lastIndex = i;
      }
    }, {
      key: "wrapGroups",
      value: function wrapGroups(node, match, params, filterCb, eachCb) {
        var _this5 = this;
        var startIndex = match.index,
          isWrapped = false,
          group,
          start;
        params.groups.forEach(function (index) {
          group = match[index];
          if (group) {
            start = node.textContent.indexOf(group, startIndex);
            if (start !== -1) {
              if (filterCb(node, group, index)) {
                node = _this5.wrapRange(node, start, start + group.length, function (node) {
                  eachCb(node, index);
                });
                startIndex = 0;
                isWrapped = true;
              } else {
                startIndex = start + group.length;
              }
            }
          }
        });
        if (isWrapped) {
          params.regex.lastIndex = 0;
        }
        return node;
      }
    }, {
      key: "wrapGroupsAcross",
      value: function wrapGroupsAcross(dict, match, params, filterCb, eachCb) {
        var _this6 = this;
        var startIndex = 0,
          group,
          start,
          end;
        var s = match.index,
          text = match[0],
          wrap = function wrap(start, end, index) {
            _this6.wrapRangeAcross(dict, s + start, s + end, function (obj) {
              return filterCb(obj, text, index);
            }, function (node, groupStart) {
              eachCb(node, groupStart, index);
            });
          };
        if (this.opt.wrapAllRanges) {
          wrap(0, text.length, 0);
        }
        params.groups.forEach(function (index) {
          group = match[index];
          if (group) {
            start = text.indexOf(group, startIndex);
            if (start !== -1) {
              end = start + group.length;
              wrap(start, end, index);
              startIndex = end;
            }
          }
        });
      }
    }, {
      key: "wrapGroupsDFlag",
      value: function wrapGroupsDFlag(node, match, params, filterCb, eachCb) {
        var lastIndex = 0,
          offset = 0,
          i = 0,
          isWrapped = false,
          group,
          start,
          end = 0;
        while (++i < match.length) {
          group = match[i];
          if (group) {
            start = match.indices[i][0];
            if (start >= lastIndex) {
              end = match.indices[i][1];
              if (filterCb(node, group, i)) {
                node = this.wrapRange(node, start - offset, end - offset, function (node) {
                  eachCb(node, i);
                });
                if (end > lastIndex) {
                  lastIndex = end;
                }
                offset = end;
                isWrapped = true;
              }
            }
          }
        }
        if (isWrapped) {
          params.regex.lastIndex = 0;
        } else if (match[0].length === 0) {
          this.setLastIndex(params.regex, end);
        }
        return node;
      }
    }, {
      key: "wrapGroupsDFlagAcross",
      value: function wrapGroupsDFlagAcross(dict, match, params, filterCb, eachCb) {
        var lastIndex = 0,
          i = 0,
          group,
          start,
          end = 0,
          isWrapped;
        while (++i < match.length) {
          group = match[i];
          if (group) {
            start = match.indices[i][0];
            if (this.opt.wrapAllRanges || start >= lastIndex) {
              end = match.indices[i][1];
              isWrapped = false;
              this.wrapRangeAcross(dict, start, end, function (obj) {
                return filterCb(obj, group, i);
              }, function (node, groupStart) {
                isWrapped = true;
                eachCb(node, groupStart, i);
              });
              if (isWrapped && end > lastIndex) {
                lastIndex = end;
              }
            }
          }
        }
        if (match[0].length === 0) {
          this.setLastIndex(params.regex, end);
        }
      }
    }, {
      key: "setLastIndex",
      value: function setLastIndex(regex, end) {
        var index = regex.lastIndex;
        regex.lastIndex = end > index ? end : end > 0 ? index + 1 : Infinity;
      }
    }, {
      key: "collectGroupIndexes",
      value: function collectGroupIndexes(regex) {
        var groups = [],
          stack = [],
          index = 0,
          brackets = 0,
          str = regex.source,
          rm,
          reg = /(?:\\.)+|\[(?:[^\\\]]|(?:\\.))+\]|(\(\?<(?![=!])|\((?!\?))|(\()|(\))/g;
        while ((rm = reg.exec(str)) !== null) {
          if (rm[1]) {
            stack.push(1);
            index++;
            if (brackets++ === 0) {
              groups.push(index);
            }
          } else if (rm[2]) {
            stack.push(0);
          } else if (rm[3] && stack.pop()) {
            brackets--;
          }
        }
        return groups;
      }
    }, {
      key: "wrapSeparateGroups",
      value: function wrapSeparateGroups(regex, unused, filterCb, eachCb, endCb) {
        var _this7 = this;
        var hasIndices = regex.hasIndices,
          fn = hasIndices ? 'wrapGroupsDFlag' : 'wrapGroups',
          params = {
            regex: regex,
            groups: hasIndices ? {} : this.collectGroupIndexes(regex)
          },
          execution = {
            abort: false
          },
          info = {
            execution: execution
          };
        var node,
          match,
          filterStart,
          eachStart,
          count = 0;
        this.getTextNodes(function (dict) {
          dict.nodes.every(function (obj) {
            node = obj.node;
            info.offset = obj.start;
            while ((match = regex.exec(node.textContent)) !== null && (hasIndices || match[0] !== '')) {
              info.match = match;
              filterStart = eachStart = true;
              node = _this7[fn](node, match, params, function (node, group, grIndex) {
                info.matchStart = filterStart;
                info.groupIndex = grIndex;
                filterStart = false;
                return filterCb(node, group, info);
              }, function (node, grIndex) {
                if (eachStart) {
                  count++;
                }
                eachCb(node, {
                  match: match,
                  matchStart: eachStart,
                  count: count,
                  groupIndex: grIndex
                });
                eachStart = false;
              });
              if (execution.abort) break;
            }
            return !execution.abort;
          });
          endCb(count);
        });
      }
    }, {
      key: "wrapSeparateGroupsAcross",
      value: function wrapSeparateGroupsAcross(regex, unused, filterCb, eachCb, endCb) {
        var _this8 = this;
        var hasIndices = regex.hasIndices,
          fn = hasIndices ? 'wrapGroupsDFlagAcross' : 'wrapGroupsAcross',
          params = {
            regex: regex,
            groups: hasIndices ? {} : this.collectGroupIndexes(regex)
          },
          execution = {
            abort: false
          },
          info = {
            execution: execution
          };
        var match,
          filterStart,
          eachStart,
          count = 0;
        this.getTextNodesAcross(function (dict) {
          while ((match = regex.exec(dict.text)) !== null && (hasIndices || match[0] !== '')) {
            info.match = match;
            filterStart = eachStart = true;
            _this8[fn](dict, match, params, function (obj, group, grIndex) {
              info.matchStart = filterStart;
              info.groupIndex = grIndex;
              info.offset = obj.startOffset;
              filterStart = false;
              return filterCb(obj.node, group, info);
            }, function (node, groupStart, grIndex) {
              if (eachStart) {
                count++;
              }
              eachCb(node, {
                match: match,
                matchStart: eachStart,
                count: count,
                groupIndex: grIndex,
                groupStart: groupStart
              });
              eachStart = false;
            });
            if (execution.abort) break;
          }
          endCb(count);
        });
      }
    }, {
      key: "wrapMatches",
      value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {
        var _this9 = this;
        var index = ignoreGroups === 0 ? 0 : ignoreGroups + 1,
          execution = {
            abort: false
          },
          filterInfo = {
            execution: execution
          };
        var info,
          node,
          match,
          str,
          count = 0;
        this.getTextNodes(function (dict) {
          for (var k = 0; k < dict.nodes.length; k++) {
            info = dict.nodes[k];
            node = info.node;
            while ((match = regex.exec(node.textContent)) !== null && (str = match[index]) !== '') {
              filterInfo.match = match;
              filterInfo.offset = info.start;
              if (!filterCb(node, str, filterInfo)) {
                continue;
              }
              var i = 0,
                start = match.index;
              while (++i < index) {
                if (match[i]) {
                  start += match[i].length;
                }
              }
              var end = start + str.length;
              if (_this9.opt.cacheTextNodes) {
                var obj = _this9.wrapRangeInsert(dict, info, start, end, info.start + start, k);
                eachCb(obj.mark, {
                  match: match,
                  count: ++count
                });
                if (obj.increment === 0) break;
                k += obj.increment;
                info = obj.nodeInfo;
                node = info.node;
              } else {
                node = _this9.wrapRange(node, start, end, function (node) {
                  eachCb(node, {
                    match: match,
                    count: ++count
                  });
                });
              }
              regex.lastIndex = 0;
              if (execution.abort) break;
            }
            if (execution.abort) break;
          }
          endCb(count);
        });
      }
    }, {
      key: "wrapMatchesAcross",
      value: function wrapMatchesAcross(regex, ignoreGroups, filterCb, eachCb, endCb) {
        var _this10 = this;
        var index = ignoreGroups === 0 ? 0 : ignoreGroups + 1,
          execution = {
            abort: false
          },
          filterInfo = {
            execution: execution
          };
        var match,
          str,
          matchStart,
          count = 0;
        this.getTextNodesAcross(function (dict) {
          while ((match = regex.exec(dict.text)) !== null && (str = match[index]) !== '') {
            filterInfo.match = match;
            matchStart = true;
            var i = 0,
              start = match.index;
            while (++i < index) {
              if (match[i]) {
                start += match[i].length;
              }
            }
            _this10.wrapRangeAcross(dict, start, start + str.length, function (obj) {
              filterInfo.matchStart = matchStart;
              filterInfo.offset = obj.startOffset;
              matchStart = false;
              return filterCb(obj.node, str, filterInfo);
            }, function (node, mStart) {
              if (mStart) {
                count++;
              }
              eachCb(node, {
                match: match,
                matchStart: mStart,
                count: count
              });
            });
            if (execution.abort) break;
          }
          endCb(count);
        });
      }
    }, {
      key: "wrapRanges",
      value: function wrapRanges(ranges, filterCb, eachCb, endCb) {
        var _this11 = this;
        var lines = this.opt.markLines,
          logs = [],
          skipped = [],
          level = 'warn';
        var count = 0;
        this.getTextNodes(function (dict) {
          var max = lines ? dict.newLines.length : dict.text.length,
            array = _this11.checkRanges(ranges, logs, lines ? 1 : 0, max);
          array.forEach(function (range, index) {
            var start = range.start,
              end = start + range.length;
            if (end > max) {
              logs.push({
                text: "Range was limited to: ".concat(max),
                obj: range,
                skip: true,
                level: level
              });
              end = max;
            }
            if (lines) {
              start = dict.newLines[start - 1];
              if (dict.text[start] === '\n') {
                start++;
              }
              end = dict.newLines[end - 1];
            }
            var substr = dict.text.substring(start, end);
            if (substr.trim()) {
              _this11.wrapRangeAcross(dict, start, end, function (obj) {
                return filterCb(obj.node, range, substr, index);
              }, function (node, rangeStart) {
                if (rangeStart) {
                  count++;
                }
                eachCb(node, range, {
                  matchStart: rangeStart,
                  count: count
                });
              });
            } else {
              logs.push({
                text: 'Skipping whitespace only range: ',
                obj: range,
                level: level
              });
              skipped.push(range);
            }
          });
          _this11.log("Valid ranges: ".concat(JSON.stringify(array.filter(function (range) {
            return skipped.indexOf(range) === -1;
          }))));
          endCb(count, logs);
        });
      }
    }, {
      key: "unwrapMatches",
      value: function unwrapMatches(node) {
        var parent = node.parentNode,
          first = node.firstChild;
        if (node.childNodes.length === 1) {
          if (first.nodeType === 3) {
            var previous = node.previousSibling,
              next = node.nextSibling;
            if (previous && previous.nodeType === 3) {
              if (next && next.nodeType === 3) {
                previous.nodeValue += first.nodeValue + next.nodeValue;
                parent.removeChild(next);
              } else {
                previous.nodeValue += first.nodeValue;
              }
            } else if (next && next.nodeType === 3) {
              next.nodeValue = first.nodeValue + next.nodeValue;
            } else {
              parent.replaceChild(node.firstChild, node);
              return;
            }
            parent.removeChild(node);
          } else {
            parent.replaceChild(node.firstChild, node);
          }
        } else {
          if (!first) {
            parent.removeChild(node);
          } else {
            var docFrag = this.opt.window.document.createDocumentFragment();
            while (node.firstChild) {
              docFrag.appendChild(node.removeChild(node.firstChild));
            }
            parent.replaceChild(docFrag, node);
          }
          parent.normalize();
        }
      }
    }, {
      key: "markRegExp",
      value: function markRegExp(regexp, opt) {
        var _this12 = this;
        this.checkOption(opt);
        var totalMarks = 0,
          matchesSoFar = 0,
          fn = this.opt.separateGroups ? 'wrapSeparateGroups' : 'wrapMatches';
        if (this.opt.acrossElements) {
          fn += 'Across';
          if (!regexp.global && !regexp.sticky) {
            var splits = regexp.toString().split('/');
            regexp = new RegExp(regexp.source, 'g' + splits[splits.length - 1]);
            this.log('RegExp is recompiled - it must have a `g` flag');
          }
        }
        this.log("RegExp \"".concat(regexp, "\""));
        this[fn](regexp, this.opt.ignoreGroups, function (node, match, filterInfo) {
          return _this12.opt.filter(node, match, matchesSoFar, filterInfo);
        }, function (element, eachInfo) {
          matchesSoFar = eachInfo.count;
          totalMarks++;
          _this12.opt.each(element, eachInfo);
        }, function (totalMatches) {
          if (totalMatches === 0) {
            _this12.opt.noMatch(regexp);
          }
          _this12.opt.done(totalMarks, totalMatches);
        });
      }
    }, {
      key: "mark",
      value: function mark(sv, opt) {
        var _this13 = this;
        this.checkOption(opt);
        var _this$getSeachTerms = this.getSeachTerms(sv),
          terms = _this$getSeachTerms.terms,
          termStats = _this$getSeachTerms.termStats;
        if (!terms.length) {
          this.opt.done(0, 0, termStats);
          return;
        }
        if (this.opt.combinePatterns) {
          this.markCombinePatterns(terms, termStats);
          return;
        }
        var index = 0,
          totalMarks = 0,
          matches = 0,
          totalMatches = 0,
          termMatches;
        var regCreator = new RegExpCreator(this.opt),
          fn = this.opt.acrossElements ? 'wrapMatchesAcross' : 'wrapMatches';
        var loop = function loop(term) {
          termMatches = 0;
          var regex = regCreator.create(term);
          _this13.log("RegExp \"".concat(regex, "\""));
          _this13[fn](regex, 1, function (node, t, filterInfo) {
            matches = totalMatches + termMatches;
            return _this13.opt.filter(node, term, matches, termMatches, filterInfo);
          }, function (element, eachInfo) {
            termMatches = eachInfo.count;
            totalMarks++;
            _this13.opt.each(element, eachInfo);
          }, function (count) {
            totalMatches += count;
            if (count === 0) {
              _this13.opt.noMatch(term);
            }
            termStats[term] = count;
            if (++index < terms.length) {
              loop(terms[index]);
            } else {
              _this13.opt.done(totalMarks, totalMatches, termStats);
            }
          });
        };
        loop(terms[index]);
      }
    }, {
      key: "markCombinePatterns",
      value: function markCombinePatterns(terms, termStats) {
        var _this14 = this;
        var index = 0,
          totalMarks = 0,
          totalMatches = 0,
          term,
          termMatches;
        var across = this.opt.acrossElements,
          fn = across ? 'wrapMatchesAcross' : 'wrapMatches',
          flags = "g".concat(this.opt.caseSensitive ? '' : 'i'),
          patterns = this.getPatterns(terms);
        var loop = function loop(_ref) {
          var pattern = _ref.pattern,
            regTerms = _ref.regTerms;
          var regex = new RegExp(pattern, flags);
          _this14.log("RegExp \"".concat(regex, "\""));
          _this14[fn](regex, 1, function (node, t, filterInfo) {
            if (!across || filterInfo.matchStart) {
              term = _this14.getCurrentTerm(filterInfo.match, regTerms);
            }
            termMatches = termStats[term];
            return _this14.opt.filter(node, term, totalMatches + termMatches, termMatches, filterInfo);
          }, function (element, eachInfo) {
            totalMarks++;
            if (!across || eachInfo.matchStart) {
              termStats[term] += 1;
            }
            _this14.opt.each(element, eachInfo);
          }, function (count) {
            totalMatches += count;
            var array = regTerms.filter(function (term) {
              return termStats[term] === 0;
            });
            if (array.length) {
              _this14.opt.noMatch(array);
            }
            if (++index < patterns.length) {
              loop(patterns[index]);
            } else {
              _this14.opt.done(totalMarks, totalMatches, termStats);
            }
          });
        };
        loop(patterns[index]);
      }
    }, {
      key: "getCurrentTerm",
      value: function getCurrentTerm(match, terms) {
        var i = match.length;
        while (--i > 2) {
          if (match[i]) {
            return terms[i - 3];
          }
        }
        return ' ';
      }
    }, {
      key: "getPatterns",
      value: function getPatterns(terms) {
        var creator = new RegExpCreator(this.opt),
          option = this.opt.combinePatterns,
          array = [];
        var num = 10,
          value;
        if (option === Infinity) {
          num = Math.pow(2, 31);
        } else if (Number.isInteger(option) && (value = parseInt(option)) > 0) {
          num = value;
        }
        for (var i = 0; i < terms.length; i += num) {
          var chunk = terms.slice(i, Math.min(i + num, terms.length)),
            obj = creator.createCombinePattern(chunk, true);
          array.push({
            pattern: "".concat(obj.lookbehind, "(").concat(obj.pattern, ")").concat(obj.lookahead),
            regTerms: chunk
          });
        }
        return array;
      }
    }, {
      key: "markRanges",
      value: function markRanges(ranges, opt) {
        var _this15 = this;
        this.checkOption(opt, true);
        if (Array.isArray(ranges)) {
          var totalMarks = 0;
          this.wrapRanges(ranges, function (node, range, match, index) {
            return _this15.opt.filter(node, range, match, index);
          }, function (elem, range, rangeInfo) {
            totalMarks++;
            _this15.opt.each(elem, range, rangeInfo);
          }, function (totalRanges, logs) {
            _this15.report(logs);
            _this15.opt.done(totalMarks, totalRanges);
          });
        } else {
          this.report([{
            text: 'markRanges() accept an array of objects: ',
            obj: ranges,
            level: 'error'
          }]);
          this.opt.done(0, 0);
        }
      }
    }, {
      key: "unmark",
      value: function unmark(opt) {
        var _this16 = this;
        this.checkOption(opt, true);
        var selector = this.opt.element + '[data-markjs]';
        if (this.opt.className) {
          selector += ".".concat(this.opt.className);
        }
        this.log("Removal selector \"".concat(selector, "\""));
        this.iterator.forEachNode(this.filter.SHOW_ELEMENT, function (node) {
          _this16.unwrapMatches(node);
        }, function (node) {
          return DOMIterator.matches(node, selector) && !_this16.excluded(node);
        }, this.opt.done);
      }
    }]);
    return Mark;
  }();

  function Mark(ctx) {
    var _this = this;
    var instance = new Mark$1(ctx);
    this.mark = function (sv, opt) {
      instance.mark(sv, opt);
      return _this;
    };
    this.markRegExp = function (sv, opt) {
      instance.markRegExp(sv, opt);
      return _this;
    };
    this.markRanges = function (sv, opt) {
      instance.markRanges(sv, opt);
      return _this;
    };
    this.unmark = function (opt) {
      instance.unmark(opt);
      return _this;
    };
    this.getVersion = function () {
      return '2.6.0';
    };
    return this;
  }

  return Mark;

}));


/***/ }),

/***/ "../node_modules/anser/lib/index.js":
/*!******************************************!*\
  !*** ../node_modules/anser/lib/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
// https://datatracker.ietf.org/doc/html/rfc3986#appendix-A
var linkRegex = /(https?:\/\/(?:[A-Za-z0-9#;/?:@=+$',_.!~*()[\]-]|&amp;|%[A-Fa-f0-9]{2})+)/gm;

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. You should apply this after you have run `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>\"]/gm, function (str) {
                return str == "&" ? "&amp;" : str == '"' ? "&quot;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(linkRegex, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                isInverted: false,
                clearLine: options.clearLine,
                decoration: null,
                decorations: [],
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = null;
                    self.decorations = [];
                } else if (num === 1) {
                    self.decorations.push("bold");
                } else if (num === 2) {
                    self.decorations.push("dim");
                    // Enable code 2 to get string
                } else if (num === 3) {
                    self.decorations.push("italic");
                } else if (num === 4) {
                    self.decorations.push("underline");
                } else if (num === 5) {
                    self.decorations.push("blink");
                } else if (num === 7) {
                    self.decorations.push("reverse");
                } else if (num === 8) {
                    self.decorations.push("hidden");
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decorations.push("strikethrough");
                    /**
                     * Add several widely used style codes
                     * @see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
                     */
                } else if (num === 21) {
                    self.removeDecoration("bold");
                } else if (num === 22) {
                    self.removeDecoration("bold");
                    self.removeDecoration("dim");
                } else if (num === 23) {
                    self.removeDecoration("italic");
                } else if (num === 24) {
                    self.removeDecoration("underline");
                } else if (num === 25) {
                    self.removeDecoration("blink");
                } else if (num === 27) {
                    self.removeDecoration("reverse");
                } else if (num === 28) {
                    self.removeDecoration("hidden");
                } else if (num === 29) {
                    self.removeDecoration("strikethrough");
                } else if (num === 39) {
                    self.fg = null;
                } else if (num === 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decorations.length === 0) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decorations = self.decorations;
                result.decoration = self.decorations.slice(-1).pop() || null;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);
            var use_classes = options.use_classes;

            // "reverse" decoration reverses foreground and background colors
            jsonChunk.decorations = jsonChunk.decorations.filter(function (decoration) {
                if (decoration === "reverse") {
                    // when reversing, missing colors are defaulted to black (bg) and white (fg)
                    if (!jsonChunk.fg) {
                        jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
                    }
                    if (!jsonChunk.bg) {
                        jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
                    }
                    var tmpFg = jsonChunk.fg;
                    jsonChunk.fg = jsonChunk.bg;
                    jsonChunk.bg = tmpFg;
                    var tmpFgTrue = jsonChunk.fg_truecolor;
                    jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
                    jsonChunk.bg_truecolor = tmpFgTrue;
                    jsonChunk.isInverted = true;
                    return false;
                }
                return true;
            });

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var colors = [];
            var decorations = [];
            var textDecorations = [];
            var data = {};

            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.isInverted) {
                data["ansi-is-inverted"] = "true";
            }

            if (jsonChunk.fg) {
                if (use_classes) {
                    colors.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    colors.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    colors.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    colors.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            jsonChunk.decorations.forEach(function (decoration) {
                // use classes
                if (use_classes) {
                    decorations.push("ansi-" + decoration);
                    return;
                }
                // use styles
                if (decoration === "bold") {
                    decorations.push("font-weight:bold");
                } else if (decoration === "dim") {
                    decorations.push("opacity:0.5");
                } else if (decoration === "italic") {
                    decorations.push("font-style:italic");
                } else if (decoration === "hidden") {
                    decorations.push("visibility:hidden");
                } else if (decoration === "strikethrough") {
                    textDecorations.push("line-through");
                } else {
                    // underline and blink are treated here
                    textDecorations.push(decoration);
                }
            });

            if (textDecorations.length) {
                decorations.push("text-decoration:" + textDecorations.join(" "));
            }

            if (use_classes) {
                return "<span class=\"" + colors.concat(decorations).join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + colors.concat(decorations).join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
            var index = this.decorations.indexOf(decoration);

            if (index >= 0) {
                this.decorations.splice(index, 1);
            }
        }
    }]);

    return Anser;
}();

module.exports = Anser;

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/callhierarchy/src/browser/style/index.css":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/callhierarchy/src/browser/style/index.css ***!
  \***************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-CallHierarchyTree {
  font-size: var(--theia-ui-font-size1);
}

.theia-CallHierarchyTree .theia-TreeNode {
  width: 100%;
}

.theia-CallHierarchyTree .theia-ExpansionToggle {
  min-width: 9px;
  padding-right: 4px;
}

.theia-CallHierarchyTree .definitionNode {
  display: flex;
}

.theia-CallHierarchyTree .definitionNode {
  width: calc(100% - 32px);
}

.theia-CallHierarchyTree .definitionNode div {
  margin-right: 5px;
}

.theia-CallHierarchyTree .definitionNode .symbol {
  padding-right: 4px;
}

.theia-CallHierarchyTree .definitionNode .referenceCount {
  color: var(--theia-badge-background);
  padding-right: 4px;
}

.theia-CallHierarchyTree .definitionNode .container {
  color: var(--theia-descriptionForeground);
}

.theia-CallHierarchyTree .definitionNode-content {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.theia-CallHierarchyTree
  .definitionNode.deprecatedDefinition
  .definitionNode-content {
  text-decoration: line-through;
}
`, "",{"version":3,"sources":["webpack://./../node_modules/@theia/callhierarchy/src/browser/style/index.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,qCAAqC;AACvC;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,oCAAoC;EACpC,kBAAkB;AACpB;;AAEA;EACE,yCAAyC;AAC3C;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;;AAEA;;;EAGE,6BAA6B;AAC/B","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-CallHierarchyTree {\n  font-size: var(--theia-ui-font-size1);\n}\n\n.theia-CallHierarchyTree .theia-TreeNode {\n  width: 100%;\n}\n\n.theia-CallHierarchyTree .theia-ExpansionToggle {\n  min-width: 9px;\n  padding-right: 4px;\n}\n\n.theia-CallHierarchyTree .definitionNode {\n  display: flex;\n}\n\n.theia-CallHierarchyTree .definitionNode {\n  width: calc(100% - 32px);\n}\n\n.theia-CallHierarchyTree .definitionNode div {\n  margin-right: 5px;\n}\n\n.theia-CallHierarchyTree .definitionNode .symbol {\n  padding-right: 4px;\n}\n\n.theia-CallHierarchyTree .definitionNode .referenceCount {\n  color: var(--theia-badge-background);\n  padding-right: 4px;\n}\n\n.theia-CallHierarchyTree .definitionNode .container {\n  color: var(--theia-descriptionForeground);\n}\n\n.theia-CallHierarchyTree .definitionNode-content {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.theia-CallHierarchyTree\n  .definitionNode.deprecatedDefinition\n  .definitionNode-content {\n  text-decoration: line-through;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/output/src/browser/style/output.css":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/output/src/browser/style/output.css ***!
  \*********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-output .editor-container {
  height: 100%;
}

.theia-output .theia-output-error {
  color: var(--theia-errorForeground);
}

.theia-output .theia-output-warning {
  color: var(--theia-editorWarning-foreground);
}

#outputChannelList .theia-select-component {
  width: 170px;
}
`, "",{"version":3,"sources":["webpack://./../node_modules/@theia/output/src/browser/style/output.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,YAAY;AACd;;AAEA;EACE,mCAAmC;AACrC;;AAEA;EACE,4CAA4C;AAC9C;;AAEA;EACE,YAAY;AACd","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-output .editor-container {\n  height: 100%;\n}\n\n.theia-output .theia-output-error {\n  color: var(--theia-errorForeground);\n}\n\n.theia-output .theia-output-warning {\n  color: var(--theia-editorWarning-foreground);\n}\n\n#outputChannelList .theia-select-component {\n  width: 170px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css":
/*!**************************************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css ***!
  \**************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
.modal-Notification {
  pointer-events: all;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  -webkit-justify-content: center;
  justify-content: center;
  clear: both;
  box-sizing: border-box;
  position: relative;
  min-width: 200px;
  max-width: min(66vw, 800px);
  background-color: var(--theia-editorWidget-background);
  min-height: 35px;
  margin-bottom: 1px;
  color: var(--theia-editorWidget-foreground);
}

.modal-Notification .icon {
  display: inline-block;
  font-size: 20px;
  padding: 5px 0;
  width: 35px;
  order: 1;
}

.modal-Notification .icon .codicon {
  line-height: inherit;
  vertical-align: middle;
  font-size: calc(var(--theia-ui-padding) * 5);
  color: var(--theia-editorInfo-foreground);
}

.modal-Notification .icon .error {
  color: var(--theia-editorError-foreground);
}

.modal-Notification .icon .warning {
  color: var(--theia-editorWarning-foreground);
}

.modal-Notification .text {
  order: 2;
  display: inline-block;
  max-height: min(66vh, 600px);
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  align-self: center;
  flex: 1 100%;
  padding: 10px;
  overflow: auto;
  white-space: pre-wrap;
}

.modal-Notification .text > p {
  margin: 0;
  font-size: var(--theia-ui-font-size1);
  font-family: var(--theia-ui-font-family);
  vertical-align: middle;
}

.modal-Notification .buttons {
  display: flex;
  flex-direction: row;
  order: 3;
  white-space: nowrap;
  align-self: flex-end;
  height: 40px;
}

.modal-Notification .buttons > button {
  background-color: var(--theia-button-background);
  color: var(--theia-button-foreground);
  border: none;
  border-radius: 0;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  padding: 0 10px;
  margin: 0;
  font-size: var(--theia-ui-font-size1);
  outline: none;
  cursor: pointer;
}

.modal-Notification .buttons > button:hover {
  background-color: var(--theia-button-hoverBackground);
}

.modal-Notification .detail {
  align-self: center;
  order: 3;
  flex: 1 100%;
  color: var(--theia-descriptionForeground);
}

.modal-Notification .detail > p {
  margin: calc(var(--theia-ui-padding) * 2) 0px 0px 0px;
}

.modal-Notification .text {
  padding: calc(var(--theia-ui-padding) * 1.5);
}
`, "",{"version":3,"sources":["webpack://./../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;AACjF;EACE,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;EACjB,aAAa;EACb,mBAAmB;EACnB,+BAA+B;EAC/B,uBAAuB;EACvB,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,gBAAgB;EAChB,2BAA2B;EAC3B,sDAAsD;EACtD,gBAAgB;EAChB,kBAAkB;EAClB,2CAA2C;AAC7C;;AAEA;EACE,qBAAqB;EACrB,eAAe;EACf,cAAc;EACd,WAAW;EACX,QAAQ;AACV;;AAEA;EACE,oBAAoB;EACpB,sBAAsB;EACtB,4CAA4C;EAC5C,yCAAyC;AAC3C;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,4CAA4C;AAC9C;;AAEA;EACE,QAAQ;EACR,qBAAqB;EACrB,4BAA4B;EAC5B,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;EACjB,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,SAAS;EACT,qCAAqC;EACrC,wCAAwC;EACxC,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,QAAQ;EACR,mBAAmB;EACnB,oBAAoB;EACpB,YAAY;AACd;;AAEA;EACE,gDAAgD;EAChD,qCAAqC;EACrC,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,qBAAqB;EACrB,qBAAqB;EACrB,eAAe;EACf,SAAS;EACT,qCAAqC;EACrC,aAAa;EACb,eAAe;AACjB;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,YAAY;EACZ,yCAAyC;AAC3C;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,4CAA4C;AAC9C","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n.modal-Notification {\n  pointer-events: all;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  display: flex;\n  flex-direction: row;\n  -webkit-justify-content: center;\n  justify-content: center;\n  clear: both;\n  box-sizing: border-box;\n  position: relative;\n  min-width: 200px;\n  max-width: min(66vw, 800px);\n  background-color: var(--theia-editorWidget-background);\n  min-height: 35px;\n  margin-bottom: 1px;\n  color: var(--theia-editorWidget-foreground);\n}\n\n.modal-Notification .icon {\n  display: inline-block;\n  font-size: 20px;\n  padding: 5px 0;\n  width: 35px;\n  order: 1;\n}\n\n.modal-Notification .icon .codicon {\n  line-height: inherit;\n  vertical-align: middle;\n  font-size: calc(var(--theia-ui-padding) * 5);\n  color: var(--theia-editorInfo-foreground);\n}\n\n.modal-Notification .icon .error {\n  color: var(--theia-editorError-foreground);\n}\n\n.modal-Notification .icon .warning {\n  color: var(--theia-editorWarning-foreground);\n}\n\n.modal-Notification .text {\n  order: 2;\n  display: inline-block;\n  max-height: min(66vh, 600px);\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n  align-self: center;\n  flex: 1 100%;\n  padding: 10px;\n  overflow: auto;\n  white-space: pre-wrap;\n}\n\n.modal-Notification .text > p {\n  margin: 0;\n  font-size: var(--theia-ui-font-size1);\n  font-family: var(--theia-ui-font-family);\n  vertical-align: middle;\n}\n\n.modal-Notification .buttons {\n  display: flex;\n  flex-direction: row;\n  order: 3;\n  white-space: nowrap;\n  align-self: flex-end;\n  height: 40px;\n}\n\n.modal-Notification .buttons > button {\n  background-color: var(--theia-button-background);\n  color: var(--theia-button-foreground);\n  border: none;\n  border-radius: 0;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  padding: 0 10px;\n  margin: 0;\n  font-size: var(--theia-ui-font-size1);\n  outline: none;\n  cursor: pointer;\n}\n\n.modal-Notification .buttons > button:hover {\n  background-color: var(--theia-button-hoverBackground);\n}\n\n.modal-Notification .detail {\n  align-self: center;\n  order: 3;\n  flex: 1 100%;\n  color: var(--theia-descriptionForeground);\n}\n\n.modal-Notification .detail > p {\n  margin: calc(var(--theia-ui-padding) * 2) 0px 0px 0px;\n}\n\n.modal-Notification .text {\n  padding: calc(var(--theia-ui-padding) * 1.5);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/scm/src/browser/style/scm-amend-component.css":
/*!*******************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/scm/src/browser/style/scm-amend-component.css ***!
  \*******************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-scm-commit-container {
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--theia-sideBarSectionHeader-border);
  width: 100%;
  padding-top: 6px;
}

.theia-scm-amend-outer-container {
  display: flex;
  flex-direction: column;
  width: 100%;
  overflow: auto;
}

.theia-scm-commit-and-button {
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
}

.theia-scm-commit-avatar-and-text {
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  padding-top: 2px;
}

.theia-scm-commit-avatar-and-text img {
  width: 27px;
}

.theia-scm-commit-details {
  display: flex;
  flex-direction: column;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
}

.theia-scm-commit-message-avatar {
  margin-right: 5px;
}

.theia-scm-commit-message-summary {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.theia-scm-commit-message-time {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--theia-descriptionForeground);
  font-size: smaller;
}

.theia-scm-flex-container-center {
  display: flex;
  align-items: center;
}

.theia-scm-scrolling-container {
  position: relative;
  width: 100%;
  overflow: hidden;

  margin-top: 0;
  margin-bottom: 0;
  padding-top: 0;
  padding-bottom: 0;
  border-top: 0;
  border-bottom: 0;
}
`, "",{"version":3,"sources":["webpack://./../node_modules/@theia/scm/src/browser/style/scm-amend-component.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,aAAa;EACb,sBAAsB;EACtB,8DAA8D;EAC9D,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,WAAW;EACX,cAAc;AAChB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;AACb;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;EACvB,WAAW;AACb;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;EACvB,yCAAyC;EACzC,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,gBAAgB;;EAEhB,aAAa;EACb,gBAAgB;EAChB,cAAc;EACd,iBAAiB;EACjB,aAAa;EACb,gBAAgB;AAClB","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-scm-commit-container {\n  display: flex;\n  flex-direction: column;\n  border-top: 1px solid var(--theia-sideBarSectionHeader-border);\n  width: 100%;\n  padding-top: 6px;\n}\n\n.theia-scm-amend-outer-container {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  overflow: auto;\n}\n\n.theia-scm-commit-and-button {\n  display: flex;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n}\n\n.theia-scm-commit-avatar-and-text {\n  display: flex;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n  padding-top: 2px;\n}\n\n.theia-scm-commit-avatar-and-text img {\n  width: 27px;\n}\n\n.theia-scm-commit-details {\n  display: flex;\n  flex-direction: column;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  width: 100%;\n}\n\n.theia-scm-commit-message-avatar {\n  margin-right: 5px;\n}\n\n.theia-scm-commit-message-summary {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.theia-scm-commit-message-time {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  color: var(--theia-descriptionForeground);\n  font-size: smaller;\n}\n\n.theia-scm-flex-container-center {\n  display: flex;\n  align-items: center;\n}\n\n.theia-scm-scrolling-container {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n\n  margin-top: 0;\n  margin-bottom: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  border-top: 0;\n  border-bottom: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/typehierarchy/src/browser/style/index.css":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/@theia/typehierarchy/src/browser/style/index.css ***!
  \***************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2019 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-type-hierarchy-tree {
  font-size: var(--theia-ui-font-size0);
}

.theia-type-hierarchy-tree .theia-caption-suffix {
  padding-left: 10px !important;
}

.theia-type-hierarchy-tree .theia-caption-prefix {
  padding-right: 5px !important;
  padding-left: 1px !important;
}
`, "",{"version":3,"sources":["webpack://./../node_modules/@theia/typehierarchy/src/browser/style/index.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,qCAAqC;AACvC;;AAEA;EACE,6BAA6B;AAC/B;;AAEA;EACE,6BAA6B;EAC7B,4BAA4B;AAC9B","sourcesContent":["/********************************************************************************\n * Copyright (C) 2019 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-type-hierarchy-tree {\n  font-size: var(--theia-ui-font-size0);\n}\n\n.theia-type-hierarchy-tree .theia-caption-suffix {\n  padding-left: 10px !important;\n}\n\n.theia-type-hierarchy-tree .theia-caption-prefix {\n  padding-right: 5px !important;\n  padding-left: 1px !important;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/diff/lib/convert/dmp.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/convert/dmp.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToDMP = convertChangesToDMP;

/*istanbul ignore end*/
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}


/***/ }),

/***/ "../node_modules/diff/lib/convert/xml.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/convert/xml.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToXML = convertChangesToXML;

/*istanbul ignore end*/
function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/array.js":
/*!**********************************************!*\
  !*** ../node_modules/diff/lib/diff/array.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffArrays = diffArrays;
exports.arrayDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var arrayDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.arrayDiff = arrayDiff;

/*istanbul ignore end*/
arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/base.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/base.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var _options$timeout;

    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;

    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }

    var maxExecutionTime =
    /*istanbul ignore start*/
    (_options$timeout =
    /*istanbul ignore end*/
    options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: undefined
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Once we hit the right edge of the edit graph on some diagonal k, we can
    // definitely reach the end of the edit graph in no more than k edits, so
    // there's no point in considering any moves to diagonal k+1 any more (from
    // which we're guaranteed to need at least k+1 more edits).
    // Similarly, once we've reached the bottom of the edit graph, there's no
    // point considering moves to lower diagonals.
    // We record this fact by setting minDiagonalToConsider and
    // maxDiagonalToConsider to some finite value once we've hit the edge of
    // the edit graph.
    // This optimization is not faithful to the original algorithm presented in
    // Myers's paper, which instead pointlessly extends D-paths off the end of
    // the edit graph - see page 7 of Myers's paper which notes this point
    // explicitly and illustrates it with a diagram. This has major performance
    // implications for some common scenarios. For instance, to compute a diff
    // where the new text simply appends d characters on the end of the
    // original text of length n, the true Myers algorithm will take O(n+d^2)
    // time while this optimization needs only O(n+d) time.


    var minDiagonalToConsider = -Infinity,
        maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.

    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;
        var removePath = bestPath[diagonalPath - 1],
            addPath = bestPath[diagonalPath + 1];

        if (removePath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = false;

        if (addPath) {
          // what newPos will be after we do an insertion:
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }

        var canRemove = removePath && removePath.oldPos + 1 < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the old string is the farthest from the origin
        // and does not pass the bounds of the diff graph
        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm
        //       and prefer to order removals before insertions.


        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, undefined, 0);
        } else {
          basePath = self.addToPath(removePath, undefined, true, 1);
        }

        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          // If we have hit the end of both strings, then we are done
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;

          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }

          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced, or until the edit length exceeds options.maxEditLength (if given),
    // in which case it will return undefined.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last = path.lastComponent;

    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added: added,
          removed: removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added: added,
          removed: removed,
          previousComponent: last
        }
      };
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        oldPos = basePath.oldPos,
        newPos = oldPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }

    basePath.oldPos = oldPos;
    return newPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {
  // First we convert our linked list of components in reverse order to an
  // array in the right order:
  var components = [];
  var nextComponent;

  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }

  components.reverse();
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var finalComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }

  return components;
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/character.js":
/*!**************************************************!*\
  !*** ../node_modules/diff/lib/diff/character.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffChars = diffChars;
exports.characterDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.characterDiff = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/css.js":
/*!********************************************!*\
  !*** ../node_modules/diff/lib/diff/css.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffCss = diffCss;
exports.cssDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var cssDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.cssDiff = cssDiff;

/*istanbul ignore end*/
cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/json.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/json.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffJson = diffJson;
exports.canonicalize = canonicalize;
exports.jsonDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*istanbul ignore end*/
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

/*istanbul ignore start*/
exports.jsonDiff = jsonDiff;

/*istanbul ignore end*/
jsonDiff.useLongestToken = true;
jsonDiff.tokenize =
/*istanbul ignore start*/
_line
/*istanbul ignore end*/
.
/*istanbul ignore start*/
lineDiff
/*istanbul ignore end*/
.tokenize;

jsonDiff.castInput = function (value) {
  /*istanbul ignore start*/
  var _this$options =
  /*istanbul ignore end*/
  this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      typeof v === 'undefined' ? undefinedReplacement : v
    );
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return (
    /*istanbul ignore start*/
    _base
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  );
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer


function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (
  /*istanbul ignore start*/
  _typeof(
  /*istanbul ignore end*/
  obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/line.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/line.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffLines = diffLines;
exports.diffTrimmedLines = diffTrimmedLines;
exports.lineDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "../node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var lineDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.lineDiff = lineDiff;

/*istanbul ignore end*/
lineDiff.tokenize = function (value) {
  if (this.options.stripTrailingCr) {
    // remove one \r before \n to match GNU diff's --strip-trailing-cr behavior
    value = value.replace(/\r\n/g, '\n');
  }

  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}

function diffTrimmedLines(oldStr, newStr, callback) {
  var options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/sentence.js":
/*!*************************************************!*\
  !*** ../node_modules/diff/lib/diff/sentence.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffSentences = diffSentences;
exports.sentenceDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var sentenceDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.sentenceDiff = sentenceDiff;

/*istanbul ignore end*/
sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}


/***/ }),

/***/ "../node_modules/diff/lib/diff/word.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/word.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffWords = diffWords;
exports.diffWordsWithSpace = diffWordsWithSpace;
exports.wordDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "../node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.wordDiff = wordDiff;

/*istanbul ignore end*/
wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}

function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "../node_modules/diff/lib/index.js":
/*!*****************************************!*\
  !*** ../node_modules/diff/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Diff", ({
  enumerable: true,
  get: function get() {
    return _base["default"];
  }
}));
Object.defineProperty(exports, "diffChars", ({
  enumerable: true,
  get: function get() {
    return _character.diffChars;
  }
}));
Object.defineProperty(exports, "diffWords", ({
  enumerable: true,
  get: function get() {
    return _word.diffWords;
  }
}));
Object.defineProperty(exports, "diffWordsWithSpace", ({
  enumerable: true,
  get: function get() {
    return _word.diffWordsWithSpace;
  }
}));
Object.defineProperty(exports, "diffLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffLines;
  }
}));
Object.defineProperty(exports, "diffTrimmedLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffTrimmedLines;
  }
}));
Object.defineProperty(exports, "diffSentences", ({
  enumerable: true,
  get: function get() {
    return _sentence.diffSentences;
  }
}));
Object.defineProperty(exports, "diffCss", ({
  enumerable: true,
  get: function get() {
    return _css.diffCss;
  }
}));
Object.defineProperty(exports, "diffJson", ({
  enumerable: true,
  get: function get() {
    return _json.diffJson;
  }
}));
Object.defineProperty(exports, "canonicalize", ({
  enumerable: true,
  get: function get() {
    return _json.canonicalize;
  }
}));
Object.defineProperty(exports, "diffArrays", ({
  enumerable: true,
  get: function get() {
    return _array.diffArrays;
  }
}));
Object.defineProperty(exports, "applyPatch", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatch;
  }
}));
Object.defineProperty(exports, "applyPatches", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatches;
  }
}));
Object.defineProperty(exports, "parsePatch", ({
  enumerable: true,
  get: function get() {
    return _parse.parsePatch;
  }
}));
Object.defineProperty(exports, "merge", ({
  enumerable: true,
  get: function get() {
    return _merge.merge;
  }
}));
Object.defineProperty(exports, "reversePatch", ({
  enumerable: true,
  get: function get() {
    return _reverse.reversePatch;
  }
}));
Object.defineProperty(exports, "structuredPatch", ({
  enumerable: true,
  get: function get() {
    return _create.structuredPatch;
  }
}));
Object.defineProperty(exports, "createTwoFilesPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createTwoFilesPatch;
  }
}));
Object.defineProperty(exports, "createPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createPatch;
  }
}));
Object.defineProperty(exports, "formatPatch", ({
  enumerable: true,
  get: function get() {
    return _create.formatPatch;
  }
}));
Object.defineProperty(exports, "convertChangesToDMP", ({
  enumerable: true,
  get: function get() {
    return _dmp.convertChangesToDMP;
  }
}));
Object.defineProperty(exports, "convertChangesToXML", ({
  enumerable: true,
  get: function get() {
    return _xml.convertChangesToXML;
  }
}));

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./diff/base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_character = __webpack_require__(/*! ./diff/character */ "../node_modules/diff/lib/diff/character.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_word = __webpack_require__(/*! ./diff/word */ "../node_modules/diff/lib/diff/word.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./diff/line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_sentence = __webpack_require__(/*! ./diff/sentence */ "../node_modules/diff/lib/diff/sentence.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_css = __webpack_require__(/*! ./diff/css */ "../node_modules/diff/lib/diff/css.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_json = __webpack_require__(/*! ./diff/json */ "../node_modules/diff/lib/diff/json.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ./diff/array */ "../node_modules/diff/lib/diff/array.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_apply = __webpack_require__(/*! ./patch/apply */ "../node_modules/diff/lib/patch/apply.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./patch/parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_merge = __webpack_require__(/*! ./patch/merge */ "../node_modules/diff/lib/patch/merge.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_reverse = __webpack_require__(/*! ./patch/reverse */ "../node_modules/diff/lib/patch/reverse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./patch/create */ "../node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_dmp = __webpack_require__(/*! ./convert/dmp */ "../node_modules/diff/lib/convert/dmp.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_xml = __webpack_require__(/*! ./convert/xml */ "../node_modules/diff/lib/convert/xml.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/


/***/ }),

/***/ "../node_modules/diff/lib/patch/apply.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/apply.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyPatch = applyPatch;
exports.applyPatches = applyPatches;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_distanceIterator = _interopRequireDefault(__webpack_require__(/*! ../util/distance-iterator */ "../node_modules/diff/lib/util/distance-iterator.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
function applyPatch(source, uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _distanceIterator
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ])(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\n';

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.


function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}


/***/ }),

/***/ "../node_modules/diff/lib/patch/create.js":
/*!************************************************!*\
  !*** ../node_modules/diff/lib/patch/create.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.structuredPatch = structuredPatch;
exports.formatPatch = formatPatch;
exports.createTwoFilesPatch = createTwoFilesPatch;
exports.createPatch = createPatch;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ../diff/line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _line
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  diffLines)
  /*istanbul ignore end*/
  (oldStr, newStr, options);

  if (!diff) {
    return;
  }

  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  /*istanbul ignore start*/
  var _loop = function _loop(
  /*istanbul ignore end*/
  i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_curRange =
      /*istanbul ignore end*/
      curRange).push.apply(
      /*istanbul ignore start*/
      _curRange
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange2 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange2
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange3 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange3
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              // however, if the old file is empty, do not output the no-nl line
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    /*istanbul ignore start*/
    _loop(
    /*istanbul ignore end*/
    i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}

function formatPatch(diff) {
  if (Array.isArray(diff)) {
    return diff.map(formatPatch).join('\n');
  }

  var ret = [];

  if (diff.oldFileName == diff.newFileName) {
    ret.push('Index: ' + diff.oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }

    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}

function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}

function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}


/***/ }),

/***/ "../node_modules/diff/lib/patch/merge.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/merge.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calcLineCount = calcLineCount;
exports.merge = merge;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./create */ "../node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ../util/array */ "../node_modules/diff/lib/util/array.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function calcLineCount(hunk) {
  /*istanbul ignore start*/
  var _calcOldNewLineCount =
  /*istanbul ignore end*/
  calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}

function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return (
        /*istanbul ignore start*/
        (0,
        /*istanbul ignore end*/

        /*istanbul ignore start*/
        _parse
        /*istanbul ignore end*/
        .
        /*istanbul ignore start*/
        parsePatch)
        /*istanbul ignore end*/
        (param)[0]
      );
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return (
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/

      /*istanbul ignore start*/
      _create
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      structuredPatch)
      /*istanbul ignore end*/
      (undefined, undefined, base, param)
    );
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines;

      /*istanbul ignore end*/
      // Mine inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines2;

      /*istanbul ignore end*/
      // Theirs inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines2 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines2
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines3;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines3 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines3
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      myChanges));

      return;
    } else if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines4;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines4 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines4
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      theirChanges));

      return;
    }
  } else if (
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _array
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  arrayEqual)
  /*istanbul ignore end*/
  (myChanges, theirChanges)) {
    /*istanbul ignore start*/
    var _hunk$lines5;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines5 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines5
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    /*istanbul ignore start*/
    var _hunk$lines6;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines6 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines6
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}


/***/ }),

/***/ "../node_modules/diff/lib/patch/parse.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/parse.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parsePatch = parsePatch;

/*istanbul ignore end*/
function parsePatch(uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
      lines: [],
      linedelimiters: []
    }; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }

    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}


/***/ }),

/***/ "../node_modules/diff/lib/patch/reverse.js":
/*!*************************************************!*\
  !*** ../node_modules/diff/lib/patch/reverse.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reversePatch = reversePatch;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*istanbul ignore end*/
function reversePatch(structuredPatch) {
  if (Array.isArray(structuredPatch)) {
    return structuredPatch.map(reversePatch).reverse();
  }

  return (
    /*istanbul ignore start*/
    _objectSpread(_objectSpread({},
    /*istanbul ignore end*/
    structuredPatch), {}, {
      oldFileName: structuredPatch.newFileName,
      oldHeader: structuredPatch.newHeader,
      newFileName: structuredPatch.oldFileName,
      newHeader: structuredPatch.oldHeader,
      hunks: structuredPatch.hunks.map(function (hunk) {
        return {
          oldLines: hunk.newLines,
          oldStart: hunk.newStart,
          newLines: hunk.oldLines,
          newStart: hunk.oldStart,
          linedelimiters: hunk.linedelimiters,
          lines: hunk.lines.map(function (l) {
            if (l.startsWith('-')) {
              return (
                /*istanbul ignore start*/
                "+".concat(
                /*istanbul ignore end*/
                l.slice(1))
              );
            }

            if (l.startsWith('+')) {
              return (
                /*istanbul ignore start*/
                "-".concat(
                /*istanbul ignore end*/
                l.slice(1))
              );
            }

            return l;
          })
        };
      })
    })
  );
}


/***/ }),

/***/ "../node_modules/diff/lib/util/array.js":
/*!**********************************************!*\
  !*** ../node_modules/diff/lib/util/array.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayEqual = arrayEqual;
exports.arrayStartsWith = arrayStartsWith;

/*istanbul ignore end*/
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}

function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}


/***/ }),

/***/ "../node_modules/diff/lib/util/distance-iterator.js":
/*!**********************************************************!*\
  !*** ../node_modules/diff/lib/util/distance-iterator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;

/*istanbul ignore end*/
// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function
/*istanbul ignore start*/
_default
/*istanbul ignore end*/
(start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}


/***/ }),

/***/ "../node_modules/diff/lib/util/params.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/util/params.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateOptions = generateOptions;

/*istanbul ignore end*/
function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}


/***/ }),

/***/ "../node_modules/just-performance/dist/esm/browser.js":
/*!************************************************************!*\
  !*** ../node_modules/just-performance/dist/esm/browser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   performance: () => (/* binding */ performance)
/* harmony export */ });
const universal = typeof globalThis !== "undefined" ? globalThis : __webpack_require__.g;
const performance = universal.performance;



/***/ }),

/***/ "../node_modules/limiter/dist/cjs/RateLimiter.js":
/*!*******************************************************!*\
  !*** ../node_modules/limiter/dist/cjs/RateLimiter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RateLimiter = void 0;
const TokenBucket_1 = __webpack_require__(/*! ./TokenBucket */ "../node_modules/limiter/dist/cjs/TokenBucket.js");
const clock_1 = __webpack_require__(/*! ./clock */ "../node_modules/limiter/dist/cjs/clock.js");
/**
 * A generic rate limiter. Underneath the hood, this uses a token bucket plus
 * an additional check to limit how many tokens we can remove each interval.
 *
 * @param options
 * @param options.tokensPerInterval Maximum number of tokens that can be
 *  removed at any given moment and over the course of one interval.
 * @param options.interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param options.fireImmediately Whether or not the promise will resolve
 *  immediately when rate limiting is in effect (default is false).
 */
class RateLimiter {
    constructor({ tokensPerInterval, interval, fireImmediately }) {
        this.tokenBucket = new TokenBucket_1.TokenBucket({
            bucketSize: tokensPerInterval,
            tokensPerInterval,
            interval,
        });
        // Fill the token bucket to start
        this.tokenBucket.content = tokensPerInterval;
        this.curIntervalStart = clock_1.getMilliseconds();
        this.tokensThisInterval = 0;
        this.fireImmediately = fireImmediately !== null && fireImmediately !== void 0 ? fireImmediately : false;
    }
    /**
     * Remove the requested number of tokens. If the rate limiter contains enough
     * tokens and we haven't spent too many tokens in this interval already, this
     * will happen immediately. Otherwise, the removal will happen when enough
     * tokens become available.
     * @param count The number of tokens to remove.
     * @returns A promise for the remainingTokens count.
     */
    async removeTokens(count) {
        // Make sure the request isn't for more than we can handle
        if (count > this.tokenBucket.bucketSize) {
            throw new Error(`Requested tokens ${count} exceeds maximum tokens per interval ${this.tokenBucket.bucketSize}`);
        }
        const now = clock_1.getMilliseconds();
        // Advance the current interval and reset the current interval token count
        // if needed
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
            this.curIntervalStart = now;
            this.tokensThisInterval = 0;
        }
        // If we don't have enough tokens left in this interval, wait until the
        // next interval
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
            if (this.fireImmediately) {
                return -1;
            }
            else {
                const waitMs = Math.ceil(this.curIntervalStart + this.tokenBucket.interval - now);
                await clock_1.wait(waitMs);
                const remainingTokens = await this.tokenBucket.removeTokens(count);
                this.tokensThisInterval += count;
                return remainingTokens;
            }
        }
        // Remove the requested number of tokens from the token bucket
        const remainingTokens = await this.tokenBucket.removeTokens(count);
        this.tokensThisInterval += count;
        return remainingTokens;
    }
    /**
     * Attempt to remove the requested number of tokens and return immediately.
     * If the bucket (and any parent buckets) contains enough tokens and we
     * haven't spent too many tokens in this interval already, this will return
     * true. Otherwise, false is returned.
     * @param {Number} count The number of tokens to remove.
     * @param {Boolean} True if the tokens were successfully removed, otherwise
     *  false.
     */
    tryRemoveTokens(count) {
        // Make sure the request isn't for more than we can handle
        if (count > this.tokenBucket.bucketSize)
            return false;
        const now = clock_1.getMilliseconds();
        // Advance the current interval and reset the current interval token count
        // if needed
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
            this.curIntervalStart = now;
            this.tokensThisInterval = 0;
        }
        // If we don't have enough tokens left in this interval, return false
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
            return false;
        // Try to remove the requested number of tokens from the token bucket
        const removed = this.tokenBucket.tryRemoveTokens(count);
        if (removed) {
            this.tokensThisInterval += count;
        }
        return removed;
    }
    /**
     * Returns the number of tokens remaining in the TokenBucket.
     * @returns {Number} The number of tokens remaining.
     */
    getTokensRemaining() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
    }
}
exports.RateLimiter = RateLimiter;


/***/ }),

/***/ "../node_modules/limiter/dist/cjs/TokenBucket.js":
/*!*******************************************************!*\
  !*** ../node_modules/limiter/dist/cjs/TokenBucket.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenBucket = void 0;
const clock_1 = __webpack_require__(/*! ./clock */ "../node_modules/limiter/dist/cjs/clock.js");
/**
 * A hierarchical token bucket for rate limiting. See
 * http://en.wikipedia.org/wiki/Token_bucket for more information.
 *
 * @param options
 * @param options.bucketSize Maximum number of tokens to hold in the bucket.
 *  Also known as the burst rate.
 * @param options.tokensPerInterval Number of tokens to drip into the bucket
 *  over the course of one interval.
 * @param options.interval The interval length in milliseconds, or as
 *  one of the following strings: 'second', 'minute', 'hour', day'.
 * @param options.parentBucket Optional. A token bucket that will act as
 *  the parent of this bucket.
 */
class TokenBucket {
    constructor({ bucketSize, tokensPerInterval, interval, parentBucket }) {
        this.bucketSize = bucketSize;
        this.tokensPerInterval = tokensPerInterval;
        if (typeof interval === "string") {
            switch (interval) {
                case "sec":
                case "second":
                    this.interval = 1000;
                    break;
                case "min":
                case "minute":
                    this.interval = 1000 * 60;
                    break;
                case "hr":
                case "hour":
                    this.interval = 1000 * 60 * 60;
                    break;
                case "day":
                    this.interval = 1000 * 60 * 60 * 24;
                    break;
                default:
                    throw new Error("Invalid interval " + interval);
            }
        }
        else {
            this.interval = interval;
        }
        this.parentBucket = parentBucket;
        this.content = 0;
        this.lastDrip = clock_1.getMilliseconds();
    }
    /**
     * Remove the requested number of tokens. If the bucket (and any parent
     * buckets) contains enough tokens this will happen immediately. Otherwise,
     * the removal will happen when enough tokens become available.
     * @param count The number of tokens to remove.
     * @returns A promise for the remainingTokens count.
     */
    async removeTokens(count) {
        // Is this an infinite size bucket?
        if (this.bucketSize === 0) {
            return Number.POSITIVE_INFINITY;
        }
        // Make sure the bucket can hold the requested number of tokens
        if (count > this.bucketSize) {
            throw new Error(`Requested tokens ${count} exceeds bucket size ${this.bucketSize}`);
        }
        // Drip new tokens into this bucket
        this.drip();
        const comeBackLater = async () => {
            // How long do we need to wait to make up the difference in tokens?
            const waitMs = Math.ceil((count - this.content) * (this.interval / this.tokensPerInterval));
            await clock_1.wait(waitMs);
            return this.removeTokens(count);
        };
        // If we don't have enough tokens in this bucket, come back later
        if (count > this.content)
            return comeBackLater();
        if (this.parentBucket != undefined) {
            // Remove the requested from the parent bucket first
            const remainingTokens = await this.parentBucket.removeTokens(count);
            // Check that we still have enough tokens in this bucket
            if (count > this.content)
                return comeBackLater();
            // Tokens were removed from the parent bucket, now remove them from
            // this bucket. Note that we look at the current bucket and parent
            // bucket's remaining tokens and return the smaller of the two values
            this.content -= count;
            return Math.min(remainingTokens, this.content);
        }
        else {
            // Remove the requested tokens from this bucket
            this.content -= count;
            return this.content;
        }
    }
    /**
     * Attempt to remove the requested number of tokens and return immediately.
     * If the bucket (and any parent buckets) contains enough tokens this will
     * return true, otherwise false is returned.
     * @param {Number} count The number of tokens to remove.
     * @param {Boolean} True if the tokens were successfully removed, otherwise
     *  false.
     */
    tryRemoveTokens(count) {
        // Is this an infinite size bucket?
        if (!this.bucketSize)
            return true;
        // Make sure the bucket can hold the requested number of tokens
        if (count > this.bucketSize)
            return false;
        // Drip new tokens into this bucket
        this.drip();
        // If we don't have enough tokens in this bucket, return false
        if (count > this.content)
            return false;
        // Try to remove the requested tokens from the parent bucket
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
            return false;
        // Remove the requested tokens from this bucket and return
        this.content -= count;
        return true;
    }
    /**
     * Add any new tokens to the bucket since the last drip.
     * @returns {Boolean} True if new tokens were added, otherwise false.
     */
    drip() {
        if (this.tokensPerInterval === 0) {
            const prevContent = this.content;
            this.content = this.bucketSize;
            return this.content > prevContent;
        }
        const now = clock_1.getMilliseconds();
        const deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        const dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        const prevContent = this.content;
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
        return Math.floor(this.content) > Math.floor(prevContent);
    }
}
exports.TokenBucket = TokenBucket;


/***/ }),

/***/ "../node_modules/limiter/dist/cjs/clock.js":
/*!*************************************************!*\
  !*** ../node_modules/limiter/dist/cjs/clock.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wait = exports.getMilliseconds = void 0;
const just_performance_1 = __webpack_require__(/*! just-performance */ "../node_modules/just-performance/dist/esm/browser.js");
// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp) {
    const clocktime = just_performance_1.performance.now() * 1e-3;
    let seconds = Math.floor(clocktime);
    let nanoseconds = Math.floor((clocktime % 1) * 1e9);
    if (previousTimestamp != undefined) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds < 0) {
            seconds--;
            nanoseconds += 1e9;
        }
    }
    return [seconds, nanoseconds];
}
// The current timestamp in whole milliseconds
function getMilliseconds() {
    const [seconds, nanoseconds] = hrtime();
    return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
}
exports.getMilliseconds = getMilliseconds;
// Wait for a specified number of milliseconds before fulfilling the returned promise.
function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.wait = wait;


/***/ }),

/***/ "../node_modules/limiter/dist/cjs/index.js":
/*!*************************************************!*\
  !*** ../node_modules/limiter/dist/cjs/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./RateLimiter */ "../node_modules/limiter/dist/cjs/RateLimiter.js"), exports);
__exportStar(__webpack_require__(/*! ./TokenBucket */ "../node_modules/limiter/dist/cjs/TokenBucket.js"), exports);


/***/ }),

/***/ "../node_modules/lodash/_Symbol.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_Symbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "../node_modules/lodash/_baseGetTag.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseGetTag.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "../node_modules/lodash/_baseTrim.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_baseTrim.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "../node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "../node_modules/lodash/_freeGlobal.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_freeGlobal.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "../node_modules/lodash/_getRawTag.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getRawTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "../node_modules/lodash/_objectToString.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_objectToString.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "../node_modules/lodash/_root.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_root.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "../node_modules/lodash/_trimmedEndIndex.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_trimmedEndIndex.js ***!
  \**************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "../node_modules/lodash/debounce.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/debounce.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "../node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "../node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "../node_modules/lodash/isObject.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isObject.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "../node_modules/lodash/isObjectLike.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isObjectLike.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "../node_modules/lodash/isSymbol.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isSymbol.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "../node_modules/lodash/now.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/now.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "../node_modules/lodash/toNumber.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/toNumber.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "../node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "../node_modules/p-queue/dist/index.js":
/*!*********************************************!*\
  !*** ../node_modules/p-queue/dist/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PQueue)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "../node_modules/p-queue/node_modules/eventemitter3/index.mjs");
/* harmony import */ var p_timeout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p-timeout */ "../node_modules/p-timeout/index.js");
/* harmony import */ var _priority_queue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./priority-queue.js */ "../node_modules/p-queue/dist/priority-queue.js");



/**
Promise queue with concurrency control.
*/
class PQueue extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #carryoverConcurrencyCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #interval;
    #intervalEnd = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    #throwOnTimeout;
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    #idAssigner = 1n;
    /**
    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.

    Applies to each future operation.
    */
    timeout;
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options) {
        super();
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        options = {
            carryoverConcurrencyCount: false,
            intervalCap: Number.POSITIVE_INFINITY,
            interval: 0,
            concurrency: Number.POSITIVE_INFINITY,
            autoStart: true,
            queueClass: _priority_queue_js__WEBPACK_IMPORTED_MODULE_1__["default"],
            ...options,
        };
        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
            throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ''}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ''}\` (${typeof options.interval})`);
        }
        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
        this.#intervalCap = options.intervalCap;
        this.#interval = options.interval;
        this.#queue = new options.queueClass();
        this.#queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this.timeout = options.timeout;
        this.#throwOnTimeout = options.throwOnTimeout === true;
        this.#isPaused = options.autoStart === false;
    }
    get #doesIntervalAllowAnother() {
        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
        return this.#pending < this.#concurrency;
    }
    #next() {
        this.#pending--;
        this.#tryToStartAnother();
        this.emit('next');
    }
    #onResumeInterval() {
        this.#onInterval();
        this.#initializeIntervalIfNeeded();
        this.#timeoutId = undefined;
    }
    get #isIntervalPaused() {
        const now = Date.now();
        if (this.#intervalId === undefined) {
            const delay = this.#intervalEnd - now;
            if (delay < 0) {
                // Act as the interval was done
                // We don't need to resume it here because it will be resumed on line 160
                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;
            }
            else {
                // Act as the interval is pending
                if (this.#timeoutId === undefined) {
                    this.#timeoutId = setTimeout(() => {
                        this.#onResumeInterval();
                    }, delay);
                }
                return true;
            }
        }
        return false;
    }
    #tryToStartAnother() {
        if (this.#queue.size === 0) {
            // We can clear the interval ("pause")
            // Because we can redo it later ("resume")
            if (this.#intervalId) {
                clearInterval(this.#intervalId);
            }
            this.#intervalId = undefined;
            this.emit('empty');
            if (this.#pending === 0) {
                this.emit('idle');
            }
            return false;
        }
        if (!this.#isPaused) {
            const canInitializeInterval = !this.#isIntervalPaused;
            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
                const job = this.#queue.dequeue();
                if (!job) {
                    return false;
                }
                this.emit('active');
                job();
                if (canInitializeInterval) {
                    this.#initializeIntervalIfNeeded();
                }
                return true;
            }
        }
        return false;
    }
    #initializeIntervalIfNeeded() {
        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {
            return;
        }
        this.#intervalId = setInterval(() => {
            this.#onInterval();
        }, this.#interval);
        this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
            clearInterval(this.#intervalId);
            this.#intervalId = undefined;
        }
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
        this.#processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
        // eslint-disable-next-line no-empty
        while (this.#tryToStartAnother()) { }
    }
    get concurrency() {
        return this.#concurrency;
    }
    set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
            throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this.#concurrency = newConcurrency;
        this.#processQueue();
    }
    async #throwOnAbort(signal) {
        return new Promise((_resolve, reject) => {
            signal.addEventListener('abort', () => {
                reject(signal.reason);
            }, { once: true });
        });
    }
    /**
    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.

    For example, this can be used to prioritize a promise function to run earlier.

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 1});

    queue.add(async () => '🦄', {priority: 1});
    queue.add(async () => '🦀', {priority: 0, id: '🦀'});
    queue.add(async () => '🦄', {priority: 1});
    queue.add(async () => '🦄', {priority: 1});

    queue.setPriority('🦀', 2);
    ```

    In this case, the promise function with `id: '🦀'` runs second.

    You can also deprioritize a promise function to delay its execution:

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 1});

    queue.add(async () => '🦄', {priority: 1});
    queue.add(async () => '🦀', {priority: 1, id: '🦀'});
    queue.add(async () => '🦄');
    queue.add(async () => '🦄', {priority: 0});

    queue.setPriority('🦀', -1);
    ```
    Here, the promise function with `id: '🦀'` executes last.
    */
    setPriority(id, priority) {
        this.#queue.setPriority(id, priority);
    }
    async add(function_, options = {}) {
        // In case `id` is not defined.
        options.id ??= (this.#idAssigner++).toString();
        options = {
            timeout: this.timeout,
            throwOnTimeout: this.#throwOnTimeout,
            ...options,
        };
        return new Promise((resolve, reject) => {
            this.#queue.enqueue(async () => {
                this.#pending++;
                this.#intervalCount++;
                try {
                    options.signal?.throwIfAborted();
                    let operation = function_({ signal: options.signal });
                    if (options.timeout) {
                        operation = (0,p_timeout__WEBPACK_IMPORTED_MODULE_2__["default"])(Promise.resolve(operation), { milliseconds: options.timeout });
                    }
                    if (options.signal) {
                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
                    }
                    const result = await operation;
                    resolve(result);
                    this.emit('completed', result);
                }
                catch (error) {
                    if (error instanceof p_timeout__WEBPACK_IMPORTED_MODULE_2__.TimeoutError && !options.throwOnTimeout) {
                        resolve();
                        return;
                    }
                    reject(error);
                    this.emit('error', error);
                }
                finally {
                    this.#next();
                }
            }, options);
            this.emit('add');
            this.#tryToStartAnother();
        });
    }
    async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
        if (!this.#isPaused) {
            return this;
        }
        this.#isPaused = false;
        this.#processQueue();
        return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
        this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
        this.#queue = new this.#queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */
    async onEmpty() {
        // Instantly resolve if the queue is empty
        if (this.#queue.size === 0) {
            return;
        }
        await this.#onEvent('empty');
    }
    /**
    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.

    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.

    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
    */
    async onSizeLessThan(limit) {
        // Instantly resolve if the queue is empty.
        if (this.#queue.size < limit) {
            return;
        }
        await this.#onEvent('next', () => this.#queue.size < limit);
    }
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    async onIdle() {
        // Instantly resolve if none pending and if nothing else is queued
        if (this.#pending === 0 && this.#queue.size === 0) {
            return;
        }
        await this.#onEvent('idle');
    }
    async #onEvent(event, filter) {
        return new Promise(resolve => {
            const listener = () => {
                if (filter && !filter()) {
                    return;
                }
                this.off(event, listener);
                resolve();
            };
            this.on(event, listener);
        });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
        return this.#queue.size;
    }
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
    sizeBy(options) {
        // eslint-disable-next-line unicorn/no-array-callback-reference
        return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
        return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
        return this.#isPaused;
    }
}


/***/ }),

/***/ "../node_modules/p-queue/dist/lower-bound.js":
/*!***************************************************!*\
  !*** ../node_modules/p-queue/dist/lower-bound.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lowerBound)
/* harmony export */ });
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
        const step = Math.trunc(count / 2);
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        }
        else {
            count = step;
        }
    }
    return first;
}


/***/ }),

/***/ "../node_modules/p-queue/dist/priority-queue.js":
/*!******************************************************!*\
  !*** ../node_modules/p-queue/dist/priority-queue.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PriorityQueue)
/* harmony export */ });
/* harmony import */ var _lower_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-bound.js */ "../node_modules/p-queue/dist/lower-bound.js");

class PriorityQueue {
    #queue = [];
    enqueue(run, options) {
        options = {
            priority: 0,
            ...options,
        };
        const element = {
            priority: options.priority,
            id: options.id,
            run,
        };
        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
            this.#queue.push(element);
            return;
        }
        const index = (0,_lower_bound_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.#queue, element, (a, b) => b.priority - a.priority);
        this.#queue.splice(index, 0, element);
    }
    setPriority(id, priority) {
        const index = this.#queue.findIndex((element) => element.id === id);
        if (index === -1) {
            throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
        }
        const [item] = this.#queue.splice(index, 1);
        this.enqueue(item.run, { priority, id });
    }
    dequeue() {
        const item = this.#queue.shift();
        return item?.run;
    }
    filter(options) {
        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
        return this.#queue.length;
    }
}


/***/ }),

/***/ "../node_modules/p-queue/node_modules/eventemitter3/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/p-queue/node_modules/eventemitter3/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../node_modules/p-queue/node_modules/eventemitter3/index.mjs":
/*!********************************************************************!*\
  !*** ../node_modules/p-queue/node_modules/eventemitter3/index.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../node_modules/p-queue/node_modules/eventemitter3/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "../node_modules/p-timeout/index.js":
/*!******************************************!*\
  !*** ../node_modules/p-timeout/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError),
/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),
/* harmony export */   "default": () => (/* binding */ pTimeout)
/* harmony export */ });
class TimeoutError extends Error {
	constructor(message) {
		super(message);
		this.name = 'TimeoutError';
	}
}

/**
An error to be thrown when the request is aborted by AbortController.
DOMException is thrown instead of this Error when DOMException is available.
*/
class AbortError extends Error {
	constructor(message) {
		super();
		this.name = 'AbortError';
		this.message = message;
	}
}

/**
TODO: Remove AbortError and just throw DOMException when targeting Node 18.
*/
const getDOMException = errorMessage => globalThis.DOMException === undefined
	? new AbortError(errorMessage)
	: new DOMException(errorMessage);

/**
TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.
*/
const getAbortedReason = signal => {
	const reason = signal.reason === undefined
		? getDOMException('This operation was aborted.')
		: signal.reason;

	return reason instanceof Error ? reason : getDOMException(reason);
};

function pTimeout(promise, options) {
	const {
		milliseconds,
		fallback,
		message,
		customTimers = {setTimeout, clearTimeout},
	} = options;

	let timer;
	let abortHandler;

	const wrappedPromise = new Promise((resolve, reject) => {
		if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {
			throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
		}

		if (options.signal) {
			const {signal} = options;
			if (signal.aborted) {
				reject(getAbortedReason(signal));
			}

			abortHandler = () => {
				reject(getAbortedReason(signal));
			};

			signal.addEventListener('abort', abortHandler, {once: true});
		}

		if (milliseconds === Number.POSITIVE_INFINITY) {
			promise.then(resolve, reject);
			return;
		}

		// We create the error outside of `setTimeout` to preserve the stack trace.
		const timeoutError = new TimeoutError();

		timer = customTimers.setTimeout.call(undefined, () => {
			if (fallback) {
				try {
					resolve(fallback());
				} catch (error) {
					reject(error);
				}

				return;
			}

			if (typeof promise.cancel === 'function') {
				promise.cancel();
			}

			if (message === false) {
				resolve();
			} else if (message instanceof Error) {
				reject(message);
			} else {
				timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
				reject(timeoutError);
			}
		}, milliseconds);

		(async () => {
			try {
				resolve(await promise);
			} catch (error) {
				reject(error);
			}
		})();
	});

	const cancelablePromise = wrappedPromise.finally(() => {
		cancelablePromise.clear();
		if (abortHandler && options.signal) {
			options.signal.removeEventListener('abort', abortHandler);
		}
	});

	cancelablePromise.clear = () => {
		customTimers.clearTimeout.call(undefined, timer);
		timer = undefined;
	};

	return cancelablePromise;
}


/***/ }),

/***/ "../node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var use_latest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-latest */ "../node_modules/use-latest/dist/use-latest.esm.js");
/* harmony import */ var use_composed_ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-composed-ref */ "../node_modules/use-composed-ref/dist/use-composed-ref.esm.js");






var HIDDEN_TEXTAREA_STYLE = {
  'min-height': '0',
  'max-height': 'none',
  height: '0',
  visibility: 'hidden',
  overflow: 'hidden',
  position: 'absolute',
  'z-index': '-1000',
  top: '0',
  right: '0',
  display: 'block'
};
var forceHiddenStyles = function forceHiddenStyles(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;

var hiddenTextarea = null;
var getHeight = function getHeight(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    return height + sizingData.borderSize;
  }

  // remove padding, since height = content
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tabindex', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize,
    borderSize = sizingData.borderSize,
    sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function (_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  // Double set and calc due to Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1795904
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);

  // measure height of a textarea with a single row
  hiddenTextarea.value = 'x';
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === 'border-box') {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === 'border-box') {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}

var noop = function noop() {};
var pick = function pick(props, obj) {
  return props.reduce(function (acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};

var SIZING_STYLE = ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'boxSizing', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'lineHeight', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop',
// non-standard
'tabSize', 'textIndent',
// non-standard
'textRendering', 'textTransform', 'width', 'wordBreak', 'wordSpacing', 'scrollbarGutter'];
var isIE = !!document.documentElement.currentStyle ;
var getSizingData = function getSizingData(node) {
  var style = window.getComputedStyle(node);
  if (style === null) {
    return null;
  }
  var sizingStyle = pick(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing;

  // probably node is detached from DOM, can't read computed dimensions
  if (boxSizing === '') {
    return null;
  }

  // IE (Edge has already correct behaviour) returns content width as computed width
  // so we need to add manually padding and border widths
  if (isIE && boxSizing === 'border-box') {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + 'px';
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize
  };
};
var getSizingData$1 = getSizingData;

function useListener(target, type, listener) {
  var latestListener = (0,use_latest__WEBPACK_IMPORTED_MODULE_3__["default"])(listener);
  react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect(function () {
    var handler = function handler(ev) {
      return latestListener.current(ev);
    };
    // might happen if document.fonts is not defined, for instance
    if (!target) {
      return;
    }
    target.addEventListener(type, handler);
    return function () {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useFormResetListener = function useFormResetListener(libRef, listener) {
  useListener(document.body, 'reset', function (ev) {
    if (libRef.current.form === ev.target) {
      listener(ev);
    }
  });
};
var useWindowResizeListener = function useWindowResizeListener(listener) {
  useListener(window, 'resize', listener);
};
var useFontsLoadedListener = function useFontsLoadedListener(listener) {
  useListener(document.fonts, 'loadingdone', listener);
};

var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements,
    maxRows = _ref.maxRows,
    minRows = _ref.minRows,
    _ref$onChange = _ref.onChange,
    onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
    _ref$onHeightChange = _ref.onHeightChange,
    onHeightChange = _ref$onHeightChange === void 0 ? noop : _ref$onHeightChange,
    props = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, _excluded);
  if (props.style) {
    if ('maxHeight' in props.style) {
      throw new Error('Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.');
    }
    if ('minHeight' in props.style) {
      throw new Error('Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.');
    }
  }
  var isControlled = props.value !== undefined;
  var libRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  var ref = (0,use_composed_ref__WEBPACK_IMPORTED_MODULE_4__["default"])(libRef, userRef);
  var heightRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(0);
  var measurementsCacheRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  var resizeTextarea = function resizeTextarea() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', minRows, maxRows),
      height = _calculateNodeHeight[0],
      rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty('height', height + "px", 'important');
      onHeightChange(height, {
        rowHeight: rowHeight
      });
    }
  };
  var handleChange = function handleChange(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect(resizeTextarea);
    useFormResetListener(libRef, function () {
      if (!isControlled) {
        var currentValue = libRef.current.value;
        requestAnimationFrame(function () {
          var node = libRef.current;
          if (node && currentValue !== node.value) {
            resizeTextarea();
          }
        });
      }
    });
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement("textarea", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
      onChange: handleChange,
      ref: ref
    }));
  }
};
var index = /* #__PURE__ */react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(TextareaAutosize);




/***/ }),

/***/ "../node_modules/semver/classes/comparator.js":
/*!****************************************************!*\
  !*** ../node_modules/semver/classes/comparator.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "../node_modules/semver/internal/parse-options.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "../node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "../node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "../node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "../node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "../node_modules/semver/classes/range.js")


/***/ }),

/***/ "../node_modules/semver/classes/range.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/classes/range.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SPACE_CHARACTERS = /\s+/g

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.formatted = undefined
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.formatted = undefined
  }

  get range () {
    if (this.formatted === undefined) {
      this.formatted = ''
      for (let i = 0; i < this.set.length; i++) {
        if (i > 0) {
          this.formatted += '||'
        }
        const comps = this.set[i]
        for (let k = 0; k < comps.length; k++) {
          if (k > 0) {
            this.formatted += ' '
          }
          this.formatted += comps[k].toString().trim()
        }
      }
    }
    return this.formatted
  }

  format () {
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = __webpack_require__(/*! ../internal/lrucache */ "../node_modules/semver/internal/lrucache.js")
const cache = new LRU()

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "../node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "../node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "../node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "../node_modules/semver/classes/semver.js")
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(/*! ../internal/re */ "../node_modules/semver/internal/re.js")
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ "../node_modules/semver/internal/constants.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "../node_modules/semver/classes/semver.js":
/*!************************************************!*\
  !*** ../node_modules/semver/classes/semver.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "../node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "../node_modules/semver/internal/constants.js")
const { safeRe: re, safeSrc: src, t } = __webpack_require__(/*! ../internal/re */ "../node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "../node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "../node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
        version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('build compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    if (release.startsWith('pre')) {
      if (!identifier && identifierBase === false) {
        throw new Error('invalid increment argument: identifier is empty')
      }
      // Avoid an invalid semver results
      if (identifier) {
        const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`)
        const match = `-${identifier}`.match(r)
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`)
        }
      }
    }

    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break
      case 'release':
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`)
        }
        this.prerelease.length = 0
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "../node_modules/semver/functions/clean.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/clean.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "../node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "../node_modules/semver/functions/cmp.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/functions/cmp.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "../node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "../node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "../node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "../node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "../node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "../node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "../node_modules/semver/functions/coerce.js":
/*!**************************************************!*\
  !*** ../node_modules/semver/functions/coerce.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "../node_modules/semver/functions/parse.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "../node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]
    let next
    while ((next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1
  }

  if (match === null) {
    return null
  }

  const major = match[2]
  const minor = match[3] || '0'
  const patch = match[4] || '0'
  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''

  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
}
module.exports = coerce


/***/ }),

/***/ "../node_modules/semver/functions/compare-build.js":
/*!*********************************************************!*\
  !*** ../node_modules/semver/functions/compare-build.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "../node_modules/semver/functions/compare-loose.js":
/*!*********************************************************!*\
  !*** ../node_modules/semver/functions/compare-loose.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "../node_modules/semver/functions/compare.js":
/*!***************************************************!*\
  !*** ../node_modules/semver/functions/compare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "../node_modules/semver/functions/diff.js":
/*!************************************************!*\
  !*** ../node_modules/semver/functions/diff.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse.js */ "../node_modules/semver/functions/parse.js")

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length
  const lowHasPre = !!lowVersion.prerelease.length

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // If the main part has no difference
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return 'minor'
      }
      return 'patch'
    }
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
}

module.exports = diff


/***/ }),

/***/ "../node_modules/semver/functions/eq.js":
/*!**********************************************!*\
  !*** ../node_modules/semver/functions/eq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "../node_modules/semver/functions/gt.js":
/*!**********************************************!*\
  !*** ../node_modules/semver/functions/gt.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "../node_modules/semver/functions/gte.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/functions/gte.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "../node_modules/semver/functions/inc.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/functions/inc.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "../node_modules/semver/functions/lt.js":
/*!**********************************************!*\
  !*** ../node_modules/semver/functions/lt.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "../node_modules/semver/functions/lte.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/functions/lte.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "../node_modules/semver/functions/major.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/major.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "../node_modules/semver/functions/minor.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/minor.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "../node_modules/semver/functions/neq.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/functions/neq.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "../node_modules/semver/functions/parse.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/parse.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse


/***/ }),

/***/ "../node_modules/semver/functions/patch.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/patch.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "../node_modules/semver/functions/prerelease.js":
/*!******************************************************!*\
  !*** ../node_modules/semver/functions/prerelease.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "../node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "../node_modules/semver/functions/rcompare.js":
/*!****************************************************!*\
  !*** ../node_modules/semver/functions/rcompare.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "../node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "../node_modules/semver/functions/rsort.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/rsort.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "../node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "../node_modules/semver/functions/satisfies.js":
/*!*****************************************************!*\
  !*** ../node_modules/semver/functions/satisfies.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "../node_modules/semver/functions/sort.js":
/*!************************************************!*\
  !*** ../node_modules/semver/functions/sort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "../node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "../node_modules/semver/functions/valid.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/functions/valid.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "../node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "../node_modules/semver/index.js":
/*!***************************************!*\
  !*** ../node_modules/semver/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "../node_modules/semver/internal/re.js")
const constants = __webpack_require__(/*! ./internal/constants */ "../node_modules/semver/internal/constants.js")
const SemVer = __webpack_require__(/*! ./classes/semver */ "../node_modules/semver/classes/semver.js")
const identifiers = __webpack_require__(/*! ./internal/identifiers */ "../node_modules/semver/internal/identifiers.js")
const parse = __webpack_require__(/*! ./functions/parse */ "../node_modules/semver/functions/parse.js")
const valid = __webpack_require__(/*! ./functions/valid */ "../node_modules/semver/functions/valid.js")
const clean = __webpack_require__(/*! ./functions/clean */ "../node_modules/semver/functions/clean.js")
const inc = __webpack_require__(/*! ./functions/inc */ "../node_modules/semver/functions/inc.js")
const diff = __webpack_require__(/*! ./functions/diff */ "../node_modules/semver/functions/diff.js")
const major = __webpack_require__(/*! ./functions/major */ "../node_modules/semver/functions/major.js")
const minor = __webpack_require__(/*! ./functions/minor */ "../node_modules/semver/functions/minor.js")
const patch = __webpack_require__(/*! ./functions/patch */ "../node_modules/semver/functions/patch.js")
const prerelease = __webpack_require__(/*! ./functions/prerelease */ "../node_modules/semver/functions/prerelease.js")
const compare = __webpack_require__(/*! ./functions/compare */ "../node_modules/semver/functions/compare.js")
const rcompare = __webpack_require__(/*! ./functions/rcompare */ "../node_modules/semver/functions/rcompare.js")
const compareLoose = __webpack_require__(/*! ./functions/compare-loose */ "../node_modules/semver/functions/compare-loose.js")
const compareBuild = __webpack_require__(/*! ./functions/compare-build */ "../node_modules/semver/functions/compare-build.js")
const sort = __webpack_require__(/*! ./functions/sort */ "../node_modules/semver/functions/sort.js")
const rsort = __webpack_require__(/*! ./functions/rsort */ "../node_modules/semver/functions/rsort.js")
const gt = __webpack_require__(/*! ./functions/gt */ "../node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ./functions/lt */ "../node_modules/semver/functions/lt.js")
const eq = __webpack_require__(/*! ./functions/eq */ "../node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./functions/neq */ "../node_modules/semver/functions/neq.js")
const gte = __webpack_require__(/*! ./functions/gte */ "../node_modules/semver/functions/gte.js")
const lte = __webpack_require__(/*! ./functions/lte */ "../node_modules/semver/functions/lte.js")
const cmp = __webpack_require__(/*! ./functions/cmp */ "../node_modules/semver/functions/cmp.js")
const coerce = __webpack_require__(/*! ./functions/coerce */ "../node_modules/semver/functions/coerce.js")
const Comparator = __webpack_require__(/*! ./classes/comparator */ "../node_modules/semver/classes/comparator.js")
const Range = __webpack_require__(/*! ./classes/range */ "../node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ./functions/satisfies */ "../node_modules/semver/functions/satisfies.js")
const toComparators = __webpack_require__(/*! ./ranges/to-comparators */ "../node_modules/semver/ranges/to-comparators.js")
const maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ "../node_modules/semver/ranges/max-satisfying.js")
const minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ "../node_modules/semver/ranges/min-satisfying.js")
const minVersion = __webpack_require__(/*! ./ranges/min-version */ "../node_modules/semver/ranges/min-version.js")
const validRange = __webpack_require__(/*! ./ranges/valid */ "../node_modules/semver/ranges/valid.js")
const outside = __webpack_require__(/*! ./ranges/outside */ "../node_modules/semver/ranges/outside.js")
const gtr = __webpack_require__(/*! ./ranges/gtr */ "../node_modules/semver/ranges/gtr.js")
const ltr = __webpack_require__(/*! ./ranges/ltr */ "../node_modules/semver/ranges/ltr.js")
const intersects = __webpack_require__(/*! ./ranges/intersects */ "../node_modules/semver/ranges/intersects.js")
const simplifyRange = __webpack_require__(/*! ./ranges/simplify */ "../node_modules/semver/ranges/simplify.js")
const subset = __webpack_require__(/*! ./ranges/subset */ "../node_modules/semver/ranges/subset.js")
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ "../node_modules/semver/internal/constants.js":
/*!****************************************************!*\
  !*** ../node_modules/semver/internal/constants.js ***!
  \****************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}


/***/ }),

/***/ "../node_modules/semver/internal/debug.js":
/*!************************************************!*\
  !*** ../node_modules/semver/internal/debug.js ***!
  \************************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "../node_modules/semver/internal/identifiers.js":
/*!******************************************************!*\
  !*** ../node_modules/semver/internal/identifiers.js ***!
  \******************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "../node_modules/semver/internal/lrucache.js":
/*!***************************************************!*\
  !*** ../node_modules/semver/internal/lrucache.js ***!
  \***************************************************/
/***/ ((module) => {

class LRUCache {
  constructor () {
    this.max = 1000
    this.map = new Map()
  }

  get (key) {
    const value = this.map.get(key)
    if (value === undefined) {
      return undefined
    } else {
      // Remove the key from the map and add it to the end
      this.map.delete(key)
      this.map.set(key, value)
      return value
    }
  }

  delete (key) {
    return this.map.delete(key)
  }

  set (key, value) {
    const deleted = this.delete(key)

    if (!deleted && value !== undefined) {
      // If cache is full, delete the least recently used item
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value
        this.delete(firstKey)
      }

      this.map.set(key, value)
    }

    return this
  }
}

module.exports = LRUCache


/***/ }),

/***/ "../node_modules/semver/internal/parse-options.js":
/*!********************************************************!*\
  !*** ../node_modules/semver/internal/parse-options.js ***!
  \********************************************************/
/***/ ((module) => {

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions


/***/ }),

/***/ "../node_modules/semver/internal/re.js":
/*!*********************************************!*\
  !*** ../node_modules/semver/internal/re.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = __webpack_require__(/*! ./constants */ "../node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "../node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const safeSrc = exports.safeSrc = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  safeSrc[index] = safe
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
createToken('COERCEFULL', src[t.COERCEPLAIN] +
              `(?:${src[t.PRERELEASE]})?` +
              `(?:${src[t.BUILD]})?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)
createToken('COERCERTLFULL', src[t.COERCEFULL], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "../node_modules/semver/ranges/gtr.js":
/*!********************************************!*\
  !*** ../node_modules/semver/ranges/gtr.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "../node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "../node_modules/semver/ranges/intersects.js":
/*!***************************************************!*\
  !*** ../node_modules/semver/ranges/intersects.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects


/***/ }),

/***/ "../node_modules/semver/ranges/ltr.js":
/*!********************************************!*\
  !*** ../node_modules/semver/ranges/ltr.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "../node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "../node_modules/semver/ranges/max-satisfying.js":
/*!*******************************************************!*\
  !*** ../node_modules/semver/ranges/max-satisfying.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "../node_modules/semver/ranges/min-satisfying.js":
/*!*******************************************************!*\
  !*** ../node_modules/semver/ranges/min-satisfying.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "../node_modules/semver/ranges/min-version.js":
/*!****************************************************!*\
  !*** ../node_modules/semver/ranges/min-version.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "../node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "../node_modules/semver/ranges/outside.js":
/*!************************************************!*\
  !*** ../node_modules/semver/ranges/outside.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "../node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "../node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "../node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "../node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "../node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "../node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "../node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "../node_modules/semver/ranges/simplify.js":
/*!*************************************************!*\
  !*** ../node_modules/semver/ranges/simplify.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "../node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "../node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "../node_modules/semver/ranges/subset.js":
/*!***********************************************!*\
  !*** ../node_modules/semver/ranges/subset.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "../node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "../node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "../node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "../node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "../node_modules/semver/ranges/to-comparators.js":
/*!*******************************************************!*\
  !*** ../node_modules/semver/ranges/to-comparators.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "../node_modules/semver/ranges/valid.js":
/*!**********************************************!*\
  !*** ../node_modules/semver/ranges/valid.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "../node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "../node_modules/use-composed-ref/dist/use-composed-ref.esm.js":
/*!*********************************************************************!*\
  !*** ../node_modules/use-composed-ref/dist/use-composed-ref.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useComposedRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


// basically Exclude<React.ClassAttributes<T>["ref"], string>

var updateRef = function updateRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function useComposedRef(libRef, userRef) {
  var prevUserRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();
  return react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};




/***/ }),

/***/ "../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var index = react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect ;




/***/ }),

/***/ "../node_modules/use-latest/dist/use-latest.esm.js":
/*!*********************************************************!*\
  !*** ../node_modules/use-latest/dist/use-latest.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useLatest)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-isomorphic-layout-effect */ "../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js");



var useLatest = function useLatest(value) {
  var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(value);
  (0,use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
    ref.current = value;
  });
  return ref;
};




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_theia_plugin-ext_lib_hosted_browser_hosted-plugin_js-node_modules_theia_-c4dfd2.js.map